//  -*- Mode: C++ -*-

// walk.hh

/*
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2014      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
*/


namespace stella {

// Class definitions:
class TranslationUnit : public StandardObject {
public:
  Module* tuHomeModule;
  Object* theObject;
  Symbol* category;
  char* annotation;
  boolean auxiliaryP;
  Object* codeRegister;
  Object* translation;
  List* referencedGlobals;
public:
  virtual void printObject(std::ostream* stream);
  virtual Surrogate* primaryType();
  virtual Module* homeModule();
};


// Global declarations:
extern List* oAVAILABLE_STELLA_FEATURESo;
extern DECLARE_STELLA_SPECIAL(oCURRENT_STELLA_FEATURESo, List* );
extern List* oDEFAULT_STELLA_FEATURESo;
extern List* oTRACED_KEYWORDSo;
extern DECLARE_STELLA_SPECIAL(oSAFETYo, int );
extern DECLARE_STELLA_SPECIAL(oDEBUGLEVELo, int );
extern DECLARE_STELLA_SPECIAL(oOPTIMIZESPEEDLEVELo, int );
extern DECLARE_STELLA_SPECIAL(oOPTIMIZESPACELEVELo, int );
extern DECLARE_STELLA_SPECIAL(oTRANSLATIONUNITSo, List* );
extern DECLARE_STELLA_SPECIAL(oCURRENTTRANSLATIONUNITo, TranslationUnit* );
extern DECLARE_STELLA_SPECIAL(oTRANSLATIONPHASEo, Keyword* );
extern DECLARE_STELLA_SPECIAL(oTRANSLATIONVERBOSITYLEVELo, int );
extern DECLARE_STELLA_SPECIAL(oUSEHARDCODEDSYMBOLSpo, boolean );
extern DECLARE_STELLA_SPECIAL(oTRANSLATOROUTPUTLANGUAGEo, Keyword* );
extern DECLARE_STELLA_SPECIAL(oLOCALVARIABLETYPETABLEo, KeyValueList* );
extern DECLARE_STELLA_SPECIAL(oMETHODBEINGWALKEDo, MethodSlot* );
extern DECLARE_STELLA_SPECIAL(oFOUNDRETURNpo, boolean );
extern DECLARE_STELLA_SPECIAL(oTARGETTYPEo, StandardObject* );
extern DECLARE_STELLA_SPECIAL(oLOCALGENSYMTABLEo, KeyValueList* );
extern DECLARE_STELLA_SPECIAL(oTRANSLATIONERRORSo, int );
extern DECLARE_STELLA_SPECIAL(oTRANSLATIONWARNINGSo, int );
extern DECLARE_STELLA_SPECIAL(oTRANSLATIONNOTESo, int );
extern OutputStream* oFUNCTION_CALL_LOG_STREAMo;
extern boolean oLOG_FUNCTION_CALLSpo;
extern int oLOG_BREAK_POINT_COUNTERo;
extern Cons* oWRAPPED_TYPE_TABLEo;
extern Cons* oCOERSION_TABLEo;
extern HashTable* oSYMBOL_REGISTRYo;
extern List* oSYMBOL_SETo;
extern DECLARE_STELLA_SPECIAL(oCURRENTFILEo, char* );
extern DECLARE_STELLA_SPECIAL(oSPECIALVARIABLESTACKo, KeyValueList* );
extern DECLARE_STELLA_SPECIAL(oSPECIALSENABLEDpo, boolean );
extern DECLARE_STELLA_SPECIAL(oNOFSPECIALSATLOOPENTRYo, int );
extern Cons* oTYPE_PREDICATE_TABLEo;
extern List* oNUMERIC_TYPE_HIERARCHYo;
extern DECLARE_STELLA_SPECIAL(oINLININGMETHODCALLpo, boolean );
extern Keyword* oMIXIN_IMPLEMENTATION_STYLEo;
extern int oMAX_NUMBER_OF_STARTUP_UNITSo;
extern HashTable* oNATIVE_NAME_TABLEo;
extern DECLARE_STELLA_SPECIAL(oEVALUATIONTREEo, Object* );
extern DECLARE_STELLA_SPECIAL(oEVALUATIONPARENTTREEo, Object* );

// Function signatures:
void printStellaFeatures();
void setStellaFeature(Cons* features);
void setStellaFeatureEvaluatorWrapper(Cons* arguments);
void unsetStellaFeature(Cons* features);
void unsetStellaFeatureEvaluatorWrapper(Cons* arguments);
void resetStellaFeatures();
boolean enabledStellaFeatureP(Keyword* feature);
boolean disabledStellaFeatureP(Keyword* feature);
Object* traceIf(Object* keyword, Cons* body);
boolean traceKeywordP(Object* keyword);
List* addTrace(Cons* keywords);
List* addTraceEvaluatorWrapper(Cons* arguments);
List* dropTrace(Cons* keywords);
List* dropTraceEvaluatorWrapper(Cons* arguments);
void clearTrace();
void setOptimizationLevels(int safety, int debug, int speed, int space);
boolean preserveTailMergeOptimizabilityP();
boolean methodCallInliningEnabledP();
boolean optimizeBooleanTestsP();
boolean checkForIllegalReturnP();
boolean supportUnexecP();
char* nameQuotedTree(Cons* tree);
Cons* getQuotedTree(char* treeName, char* modulename);
TranslationUnit* newTranslationUnit();
Object* accessTranslationUnitSlotValue(TranslationUnit* self, Symbol* slotname, Object* value, boolean setvalueP);
void clearTranslationUnit(TranslationUnit* self);
void printTranslationUnit(TranslationUnit* self, std::ostream* stream);
boolean useHardcodedSymbolsP();
Keyword* translatorOutputLanguage();
char* translatorOutputLanguageName();
Keyword* setTranslatorOutputLanguage(Keyword* newLanguage);
boolean translateToCommonLispP();
boolean translateToCppP();
boolean translateToJavaP();
boolean translateToSingleInheritanceLanguageP();
Keyword* toggleOutputLanguage();
boolean useBootstrapTranslatorP();
Keyword* toggleTranslators();
boolean declarationOperatorP(Symbol* operatoR);
boolean declarationTreeP(Cons* tree);
char* createAnnotation(Cons* topLevelTree);
void walkTopLevelTree(Cons* tree, boolean createannotationP);
Object* walkTopLevelExpression(Object* tree);
void walkPhaseOneUnit(TranslationUnit* unit);
void walkAuxiliaryTree(Cons* tree);
TranslationUnit* helpWalkAuxiliaryTree(Cons* tree, boolean finalizeP);
void walkAllPhaseOneUnits();
void translateAllUnits();
boolean unitIncludedInOtherUnitsP(TranslationUnit* unit);
Cons* combineTranslatedTrees();
Object* translateWalkedTree(Object* codetree);
Object* incrementallyTranslate(Object* tree);
void resetTranslationErrors();
void signalTranslationError();
void signalTranslationWarning();
void signalTranslationNote();
boolean ignoreTranslationErrorsP();
boolean translationErrorsP();
void summarizeTranslationErrors();
void printErrorContext(char* prefix, OutputStream* stream);
boolean logFunctionCallP(MethodSlot* method);
Cons* wrapBodyWithLogFunctionCallTree(MethodSlot* method, Cons* body);
void logFunctionCall(char* name);
void startFunctionCallLogging(char* filename);
void startFunctionCallLoggingEvaluatorWrapper(Cons* arguments);
void stopFunctionCallLogging();
void setCallLogBreakPoint(int count);
void setCallLogBreakPointEvaluatorWrapper(Cons* arguments);
void breakProgram(char* message);
void terminateProgram();
void po(Object* thing);
boolean variableEqlP(Symbol* var1, Symbol* var2);
Object* lookupVariableTable(KeyValueList* self, Symbol* variable);
void insertAtVariableTable(KeyValueList* self, Symbol* variable, Object* value);
void pushVariableBinding(Symbol* variable, StandardObject* type);
void popVariableBinding();
StandardObject* lookupVariableType(Symbol* variablename);
void setLocalVariableInfo(Symbol* variable, Keyword* key, Object* info);
Object* getLocalVariableInfo(Symbol* variable, Keyword* key);
void registerReferenceToGlobalVariable(Symbol* variablename);
Symbol* localGensym(char* prefix);
Symbol* methodGensym(char* prefix);
Symbol* yieldLocalVariableAlias(Symbol* variable, int level);
boolean renameShadowingLocalVariablesP();
void maybeRenameLocalVariable(Symbol* variable);
Symbol* trueVariableName(Symbol* variable);
boolean suppressWarningsP();
boolean badArgumentRangeP(Cons* tree, int minarity, int maxarity);
boolean badArgumentCountP(Cons* tree, int arity);
Cons* yieldIllegalStatementTree();
Object* yieldIllegalExpressionTree();
Cons* walkDontCallMeTree(Object* tree, StandardObject* returntype, StandardObject*& _Return1);
boolean illegalTreeP(Object* tree);
boolean nativeClassMethodInliningP();
Object* prognify(Cons* trees);
Object* optimizeProgn(Cons* prognTree);
Cons* treeToTrees(Object* tree);
Surrogate* wrappedTypeToType(Surrogate* self);
Surrogate* wrapperValueType(Wrapper* self);
Object* lookupCoersionMethod(Surrogate* sourcetype, Surrogate* targettype, Object* expression);
Object* applyCoercionMethod(Object* expression, Surrogate* sourcetype, Surrogate* targettype, Object* coercionmethod, StandardObject*& _Return1);
boolean translatingCodeP();
Surrogate* verifyType(Surrogate* self);
boolean safeSubtypeOfP(Surrogate* subtype, Surrogate* supertype);
void warnAboutUnknownSourceType(Object* tree);
Object* coerceATree(Object* tree, StandardObject* sourcetype, StandardObject* targettype, StandardObject*& _Return1);
Object* helpCoerceATree(Object* tree, StandardObject* sourcetype, StandardObject* targettype, boolean testonlyP, StandardObject*& _Return1, boolean& _Return2);
boolean coercibleP(Object* tree, StandardObject* sourcetype, StandardObject* targettype);
boolean walkingExpressionP();
Object* walkExpressionTree(Object* exptree, StandardObject* targettype, Symbol* operatorname, boolean vrletisokP, StandardObject*& _Return1);
StandardObject* computeExpressionType(Object* expression, boolean wrapP);
Object* walkWithoutTypeTree(Object* tree);
Cons* walkListOfTrees(Cons* trees);
Cons* walkListOfStatements(Cons* trees);
Object* walkStatement(Object* tree, boolean warnonatomP);
Cons* eliminateVrletStatement(Cons* tree);
Cons* sysTree(Object* tree, StandardObject* typespec, StandardObject*& _Return1);
StandardObject* walkedExpressionType(Object* tree);
Object* walkedExpressionExpression(Object* tree);
boolean needIdenticalMethodSignaturesP();
StandardObject* computeMostGeneralReturnType(MethodSlot* method, StandardObject* returntype);
StandardObject* computeRealSlotType(StorageSlot* slot, StandardObject* firstargtype, StandardObject* returntype);
Object* sysTreeIfNeeded(Slot* slot, Object* tree, StandardObject* firstargtype, StandardObject* returntype, StandardObject*& _Return1);
Surrogate* targetLanguageType(Object* tree);
Cons* setTargetLanguageType(Cons* systree, Surrogate* type, StandardObject*& _Return1);
Object* walkATree(Object* tree, StandardObject*& _Return1);
Object* helpWalkATree(Object* tree, StandardObject*& _Return1);
Cons* walkAConsTree(Cons* tree, StandardObject*& _Return1);
boolean incrementalTranslationP();
char* constructSymbolConstantName(GeneralizedSymbol* symbol);
Symbol* yieldSymbolConstantName(GeneralizedSymbol* symbol);
Symbol* createStartupSymbol(GeneralizedSymbol* symbol);
GeneralizedSymbol* registerSymbol(GeneralizedSymbol* symbol);
void clearSymbolRegistry();
Cons* yieldHardcodedInternRegisteredSymbolsTree();
Surrogate* lookupConstantSymbol(Symbol* self);
boolean constantSymbolP(Symbol* symbol);
Symbol* walkConstantSymbol(Symbol* self, Surrogate*& _Return1);
boolean atomicExpressionP(Object* tree);
boolean variableExpressionP(Object* tree);
boolean vrletExpressionP(Object* tree);
boolean proceduralExpressionP(Object* tree);
boolean substituteOnce(Object* expression, Object* newtree, Object* oldtree);
Cons* transformVrletExpression(Cons* statement, Cons* vrexpression, StandardObject*& _Return1);
Cons* helpTransformBooleanProceduralExpression(Object* expression, Symbol* testvariable);
Cons* transformBooleanProceduralExpression(Cons* statement, Cons* vrexpression, StandardObject*& _Return1);
Cons* percolateOutBooleanVrletExpressions(Cons* booleanexpression);
Cons* transformProceduralExpression(Cons* statement, Cons* vrexpression, StandardObject* type, StandardObject*& _Return1);
Cons* percolateOutVrletExpression(Cons* statement, Cons* vrexpression, StandardObject* type, StandardObject*& _Return1);
Cons* walkSetqTree(Cons* tree, StandardObject*& _Return1);
Cons* yieldFixedSlotValueSetterTree(Slot* slot, Object* objectref, Object* valuetree);
Cons* walkSetfTree(Cons* tree, StandardObject*& _Return1);
Cons* yieldDynamicSlotValueTree(StorageSlot* slot, Object* objectref, StandardObject* returntype);
Cons* yieldDynamicSlotValueSetterTree(StorageSlot* slot, Object* objectref, Object* valueref, StandardObject* returntype);
Cons* yieldNativeSlotValueTree(StorageSlot* slot, Object* objectref, StandardObject* objecttype);
Cons* yieldContextSensitiveSlotValueTree(StorageSlot* slot, Object* objectref, StandardObject* returntype, Cons* csoptions, StandardObject*& _Return1);
Cons* yieldSlotValueTree(StorageSlot* slot, Object* objectref, StandardObject* objecttype, StandardObject* returntype, Cons* csoptions, StandardObject*& _Return1);
Cons* walkSlotValueTree(Cons* tree, StandardObject*& _Return1);
Cons* yieldNativeSlotValueSetterTree(StorageSlot* slot, Object* objectref, StandardObject* objecttype, Object* valueref);
Cons* yieldContextSensitiveSlotValueSetterTree(StorageSlot* slot, Object* objectref, Object* valueref, StandardObject* returntype, Cons* csoptions, StandardObject*& _Return1);
Cons* yieldSlotValueSetterTree(StorageSlot* slot, Object* objectref, StandardObject* objecttype, Object* valueref, StandardObject* returntype, Cons* csoptions, StandardObject*& _Return1);
Cons* walkSlotValueSetterTree(Cons* tree, StandardObject*& _Return1);
Cons* walkArefTree(Cons* tree, StandardObject*& _Return1);
StandardObject* safeYieldTypeSpecifier(Object* typetree);
Cons* walkADeclaration(Symbol* variable, Object* typetree, Object* value, boolean inputparameterP);
Cons* walkVariableDeclarations(Cons* declarations);
Cons* transformLetWithProceduralExpression(Cons* tree);
void popLocalVariableBindings(Cons* declarations);
Cons* walkLetTree(Cons* tree, StandardObject*& _Return1);
Keyword* specialImplementationStyle();
void pushSpecial(Symbol* variable, Symbol* oldvaluevariable);
void popSpecial();
Symbol* lookupOldValueVariable(Symbol* variable);
boolean needToUnbindSpecialsP();
Cons* yieldSpecialUnbindTree(int nofbindings);
Cons* yieldReturnSpecialUnbindTree();
Cons* yieldLoopExitSpecialUnbindTree();
Cons* walkSpecialTree(Cons* tree, StandardObject*& _Return1);
Cons* walkClSpecialTree(Cons* tree, StandardObject*& _Return1);
Cons* walkUnwindProtectSpecialTree(Cons* tree, StandardObject*& _Return1);
Cons* walkCastTree(Cons* tree, StandardObject*& _Return1);
boolean valuesTreeP(Object* tree);
Cons* walkValuesTree(Cons* tree, StandardObject*& _Return1);
Object* walkMvExpressionTree(Object* tree, List* targettypes, Symbol* operatoR, Cons*& _Return1, List*& _Return2);
List* listifyTypeSpec(StandardObject* typespec);
Slot* slotFromExpressionTree(Cons* tree);
Object* walkMvTree(Object* tree, Cons*& _Return1, List*& _Return2);
Cons* walkMvValuesTree(Cons* tree, Cons*& _Return1, List*& _Return2);
Object* coerceMvTree(Object* tree, Symbol* operatoR, List* sourcetypes, List* targettypes, Cons*& _Return1, List*& _Return2);
Cons* walkReturnAndUnbindSpecials(Cons* tree, StandardObject*& _Return1);
Cons* walkReturnTree(Cons* tree, StandardObject*& _Return1);
Cons* walkMvSetqTree(Cons* tree, StandardObject*& _Return1);
Cons* walkMvBindTree(Cons* tree, StandardObject*& _Return1);
Cons* walkLoopTree(Cons* tree, StandardObject*& _Return1);
Cons* walkLoopExitTree(Cons* tree, StandardObject*& _Return1);
Cons* walkWhileTree(Cons* tree, StandardObject*& _Return1);
Cons* walkConditionalTree(Cons* tree, StandardObject*& _Return1);
Cons* walkChooseTree(Cons* tree, StandardObject*& _Return1);
Object* walkBooleanTree(Cons* tree, StandardObject*& _Return1);
boolean andOrNotTreeP(Object* tree);
Object* helpWalkBooleanTree(Cons* tree);
Cons* walkCondTree(Cons* tree, StandardObject*& _Return1);
Cons* condTreeToIfTree(Cons* tree);
Object* yieldHardcodedCaseSymbolIdOrIds(Object* casetest);
Cons* walkHardcodedSymbolCaseTree(Cons* tree, StandardObject*& _Return1);
Cons* yieldIsaPCaseTest(Surrogate* casekey, Object* testexpression);
Cons* yieldSubtypeOfPCaseTest(Surrogate* casekey, Object* testexpression);
Cons* yieldCondTest(Object* casetest, Object* testvariable, Symbol* equalitytest);
Object* yieldCondTestOrTests(Object* casetest, Object* testvariable, Symbol* equalitytest);
int countCaseTestClauses(Cons* tree, boolean& _Return1);
Cons* attachUnhandledCaseErrorClause(Cons* casetree, Object* testtree);
Cons* walkNonBuiltInCaseTree(Cons* tree, Symbol* equalitytest, StandardObject*& _Return1);
Cons* walkCaseTree(Cons* tree, StandardObject*& _Return1);
Cons* walkTypecaseTree(Cons* tree, StandardObject*& _Return1);
Cons* yieldCastedTypecaseClauseTrees(Symbol* testvariable, StandardObject* clausetype, Cons* clausetrees);
void verifyTypecaseClauseType(Surrogate* testtype, Surrogate* clausetype, List* precedingclausetypes, Cons* clause);
Cons* walkWithProcessLockTree(Cons* tree, StandardObject*& _Return1);
Cons* finishWalkingEqlTree(Cons* tree, Surrogate* type1, Surrogate* type2, StandardObject*& _Return1);
Cons* finishWalkingEqualTree(Cons* tree, Surrogate* type1, Surrogate* type2, StandardObject*& _Return1);
Object* walkEqualityTree(Cons* tree, StandardObject*& _Return1);
Surrogate* moreGeneralNumericType(Surrogate* type1, Surrogate* type2);
Cons* yieldArithmeticOperatorCallTree(Symbol* operatoR, Cons* operands);
Cons* yieldNestedArithmeticOperatorCallTree(Symbol* operatoR, Cons* operands);
Object* walkArithmeticTree(Cons* tree, Surrogate*& _Return1);
Object* walkQuotedTree(Cons* tree, StandardObject*& _Return1);
Object* walkBquoteTree(Cons* tree, StandardObject*& _Return1);
Object* expandMacro(Cons* tree);
Object* walkMacroTree(Cons* tree, StandardObject*& _Return1);
Cons* walkPrintStreamTree(Cons* tree, StandardObject*& _Return1);
boolean warnAboutUndefinedMethodsP();
boolean warnAboutMissingMethodsP();
boolean walkTypeSpecIsNativeTypeP(StandardObject* thetype);
Cons* walkUndefinedSlotTree(Cons* tree, StandardObject* firstargtype, boolean warnP, Surrogate*& _Return1);
Cons* walkSlotOnAbstractTypeTree(Cons* tree, Surrogate* abstracttype, StandardObject*& _Return1);
MethodSlot* findPrototypeMethod(Symbol* methodname, Surrogate* abstracttype);
int compatibleRealMethods(MethodSlot* prototypemethod, Surrogate* abstracttype, int& _Return1, boolean& _Return2);
boolean stringConcatenateMethodP(MethodSlot* method);
boolean passVariableArgumentsAsListP(MethodSlot* method);
StandardObject* variableArgumentsType(MethodSlot* method);
Symbol* variableArgumentsName(MethodSlot* method);
StandardObject* yieldListifiedVariableArgumentsType(MethodSlot* method);
Cons* yieldListifiedVariableArguments(Cons* walkedargs, StandardObject* targettype, boolean wrapargsP);
Object* finishWalkingArgumentListTree(Slot* self, Cons* tree, StandardObject* firstargtype, StandardObject*& _Return1);
Cons* walkVariableArguments(Cons* arguments, MethodSlot* method, StandardObject* firstargtype);
Cons* quoteArguments(MethodSlot* method, Cons* arguments);
StandardObject* walkFirstArgumentToFunction(MethodSlot* fnslot, Cons* tree);
Object* walkCallSlotTree(Cons* tree, StandardObject*& _Return1);
boolean inlineMethodCallP(MethodSlot* method);
boolean methodInlinableP(MethodSlot* method);
boolean mostSpecificMethodP(MethodSlot* method);
boolean helpMostSpecificMethodP(Class* clasS, MethodSlot* method);
Object* inlinableMethodBody(MethodSlot* method);
Object* walkInlineMethodCall(MethodSlot* method, Cons* walkedargs, StandardObject* firstargtype);
Cons* yieldVerbatimInlineCallTree(MethodSlot* method, Cons* walkedargs);
boolean inlineVariableReferenceP(Symbol* self);
Cons* walkInlineVariableReference(Symbol* self, StandardObject*& _Return1);
boolean sideEffectFreeExpressionP(Object* tree);
int estimatedEvaluationCost(Object* tree);
Cons* yieldSynthesizedMethodBody(TranslationUnit* unit);
Cons* walkMethodObject(TranslationUnit* unit);
void walkDefmethodTree(Cons* tree);
void walkMethodUnit(TranslationUnit* unit);
void printUndefinedMethods(Module* module, boolean localP);
Cons* walkSysCallTree(Cons* tree, StandardObject*& _Return1);
void walkDefclassTree(Cons* tree);
Cons* yieldInitializeHardwiredSlots(Class* clasS);
Object* yieldInitialValueExpression(StorageSlot* slot);
Cons* yieldConstructorAttachment(Class* clasS, Symbol* classref);
void cleanupAuxiliaryMethods(Class* clasS);
void registerAuxiliaryMethod(MethodSlot* method, Slot* reason);
boolean mixinTypeVariablesAllowedP();
boolean createNativeMixinSlotAccessorsP();
void createAccessorUnitsForSlot(StorageSlot* slot, Class* clasS, boolean mixinaccessorsP, boolean signaturesonlyP);
void createAccessorUnitsForMixinSlot(StorageSlot* slot, Class* clasS);
void createSlotAccessorUnits(Class* clasS);
void createInlineMethodUnits(Class* clasS);
Cons* yieldMixinMethodTree(MethodSlot* method, Class* clasS);
void createMixinMethodUnits(Class* clasS);
void createDefprintUnit(Class* clasS);
void walkClassUnit(TranslationUnit* unit);
void createFinalizationUnits();
void walkDefslotTree(Cons* tree);
void walkSlotUnit(TranslationUnit* unit);
MethodSlot* lookupMacro(Symbol* name);
void walkDefmacroTree(Cons* tree);
void walkDefglobalTree(Cons* tree);
void walkGlobalUnit(TranslationUnit* unit);
void walkDeftypeTree(Cons* tree);
void walkTypeUnit(TranslationUnit* unit);
void walkStartupTimePrognTree(Cons* tree);
Keyword* extractStartupTimePhase(Cons* tree);
void walkStartupTimePrognUnit(TranslationUnit* unit);
boolean earlierStartupUnitP(TranslationUnit* unit1, TranslationUnit* unit2);
Cons* combineStartupFunctionUnits(Symbol* startupfnname);
void extractStartupFunctionUnits(List* startupunits, Symbol* startupfnname);
Symbol* yieldStartupFunctionName(char* file);
char* yieldStartupFunctionClassname(Symbol* functionName);
void createStartupFunctionUnits();
boolean dontGenerateStartupCodeP();
void removeAllStartupTimePrognUnits();
Cons* walkSignalExceptionTree(Cons* tree, StandardObject*& _Return1);
Cons* walkExceptionCaseTree(Cons* tree, StandardObject*& _Return1);
Cons* walkExceptionHandlerTrees(Cons* tree);
Cons* walkUnwindProtectTree(Cons* tree, Surrogate*& _Return1);
void walkVerbatimDefinitionTree(Cons* tree);
void walkVerbatimUnit(TranslationUnit* unit);
Object* walkVerbatimTree(Cons* tree, StandardObject*& _Return1);
Object* lookupVerbatimTree(Cons* tree, Keyword* language);
boolean verbatimTreeP(Object* tree);
void walkDefmoduleTree(Cons* tree);
void walkModuleUnit(TranslationUnit* unit);
Cons* extractRequiredArgumentValues(StandardObject* classtype, PropertyList* slotsandvalues);
void preprocessArrayArguments(ParametricTypeSpecifier* arraytype, PropertyList* slotsandvalues);
void evaluateArrayArgumentValue(ParametricTypeSpecifier* arraytype, List* requiredvalues, Slot* slot, Object* valueref);
Cons* yieldNewArgumentsTree(Cons* keywordsandvalues, StandardObject* classtype, Symbol* selfvariable, Cons*& _Return1);
Surrogate* getCurrentSelfType();
Cons* walkNewTree(Cons* tree, StandardObject*& _Return1);
Cons* walkMakeTree(Cons* tree, StandardObject*& _Return1);
Cons* walkFuncallTree(Cons* tree, StandardObject*& _Return1);
Cons* walkTheCodeTree(Cons* tree, StandardObject*& _Return1);
Cons* deUglifyArguments(Cons* uglyarguments);
Object* deUglifyParseTree(Object* tree);
void registerNativeName(Symbol* name, Keyword* language, Keyword* category);
boolean nativeNameP(Symbol* name, Keyword* language, Keyword* category);
Symbol* yieldRenamedNameIfNative(Symbol* name, Keyword* language, Keyword* category);
boolean methodNeedsLispMacroP(MethodSlot* method);
Cons* yieldLispMacroTrees(Symbol* name, MethodSlot* method, Cons*& _Return1);
void createLispMacroUnits(Symbol* name, MethodSlot* method);
boolean commandP(MethodSlot* method);
MethodSlot* lookupCommand(Symbol* name);
MethodSlot* lookupCommandLikeFunction(Symbol* name);
boolean methodMustBeEvaluableP(MethodSlot* method);
boolean methodCallableViaApplyP(MethodSlot* method);
boolean methodNeedsEvaluatorWrapperP(MethodSlot* method);
Symbol* yieldEvaluatorWrapperName(Symbol* methodname);
Object* yieldArgumentAccessTree(Symbol* argumentsvariable, int index, boolean restargumentP);
Cons* yieldEvaluatorWrapperTree(MethodSlot* method);
MethodSlot* createEvaluatorWrapperUnit(MethodSlot* method);
Object* evaluate(Object* expression);
Object* evaluateString(char* expression);
Object* tryToEvaluate(Object* tree);
Object* evaluateConsTree(Cons* tree, StandardObject*& _Return1);
Object* evaluateArgumentTree(Object* tree, boolean evaluateP, StandardObject*& _Return1);
Object* evaluateAtomicTree(Object* tree, StandardObject*& _Return1);
Object* makeEvaluatableBquoteTree(Object* tree);
Object* evaluateBquoteTree(Cons* tree, StandardObject*& _Return1);
Object* coerceEvaluatedTree(Object* tree, Object* sourcetree, StandardObject* sourcetype, StandardObject* targettype, boolean evaluateP, StandardObject*& _Return1);
void helpStartupWalk1();
void helpStartupWalk2();
void helpStartupWalk3();
void helpStartupWalk4();
void helpStartupWalk5();
void helpStartupWalk6();
void helpStartupWalk7();
void helpStartupWalk8();
void helpStartupWalk9();
void helpStartupWalk10();
void helpStartupWalk11();
void helpStartupWalk12();
void helpStartupWalk13();
void helpStartupWalk14();
void startupWalk();

// Auxiliary global declarations:
extern Keyword* KWD_WALK_WARN_ABOUT_UNDEFINED_METHODS;
extern Keyword* KWD_WALK_WARN_ABOUT_MISSING_METHODS;
extern Keyword* KWD_WALK_SUPPRESS_WARNINGS;
extern Keyword* KWD_WALK_USE_HARDCODED_SYMBOLS;
extern Keyword* KWD_WALK_USE_COMMON_LISP_STRUCTS;
extern Keyword* KWD_WALK_USE_COMMON_LISP_CONSES;
extern Keyword* KWD_WALK_USE_CPP_GARBAGE_COLLECTOR;
extern Keyword* KWD_WALK_MINIMIZE_JAVA_PREFIXES;
extern Keyword* KWD_WALK_TRANSLATE_WITH_COPYRIGHT_HEADER;
extern Keyword* KWD_WALK_SUPPORT_UNEXEC;
extern Keyword* KWD_WALK_USE_COMMON_LISP_VECTOR_STRUCTS;
extern Surrogate* SGT_WALK_STELLA_CONS;
extern Symbol* SYM_WALK_STELLA_MEMBp;
extern Symbol* SYM_WALK_STELLA_oTRACED_KEYWORDSo;
extern Surrogate* SGT_WALK_STELLA_VOID;
extern Symbol* SYM_WALK_STELLA_OR;
extern Symbol* SYM_WALK_STELLA_WHEN;
extern Symbol* SYM_WALK_STELLA_AND;
extern Symbol* SYM_WALK_STELLA_DEFINEDp;
extern Symbol* SYM_WALK_STELLA_PRINT;
extern Symbol* SYM_WALK_STELLA_EOL;
extern Keyword* KWD_WALK_COMMON_LISP;
extern Symbol* SYM_WALK_STELLA_FLUSH_OUTPUT;
extern Symbol* SYM_WALK_STELLA_STANDARD_OUTPUT;
extern Keyword* KWD_WALK_JAVA;
extern Surrogate* SGT_WALK_STELLA_F_GET_QUOTED_TREE_MEMO_TABLE_000;
extern Surrogate* SGT_WALK_STELLA_TRANSLATION_UNIT;
extern Symbol* SYM_WALK_STELLA_TU_HOME_MODULE;
extern Symbol* SYM_WALK_STELLA_THE_OBJECT;
extern Symbol* SYM_WALK_STELLA_CATEGORY;
extern Symbol* SYM_WALK_STELLA_ANNOTATION;
extern Symbol* SYM_WALK_STELLA_AUXILIARYp;
extern Symbol* SYM_WALK_STELLA_CODE_REGISTER;
extern Symbol* SYM_WALK_STELLA_TRANSLATION;
extern Symbol* SYM_WALK_STELLA_REFERENCED_GLOBALS;
extern Symbol* SYM_WALK_STELLA_CLASS;
extern Symbol* SYM_WALK_STELLA_METHOD;
extern Symbol* SYM_WALK_STELLA_GLOBAL_VARIABLE;
extern Keyword* KWD_WALK_CPP;
extern Keyword* KWD_WALK_CPP_STANDALONE;
extern Keyword* KWD_WALK_IDL;
extern Symbol* SYM_WALK_STELLA_PROGN;
extern Symbol* SYM_WALK_STELLA_DEFCLASS;
extern Symbol* SYM_WALK_STELLA_DEFSLOT;
extern Symbol* SYM_WALK_STELLA_DEFMETHOD;
extern Symbol* SYM_WALK_STELLA_DEFUN;
extern Symbol* SYM_WALK_STELLA_DEFOPERATOR;
extern Symbol* SYM_WALK_STELLA_DEFGLOBAL;
extern Symbol* SYM_WALK_STELLA_DEFSPECIAL;
extern Symbol* SYM_WALK_STELLA_DEFCONSTANT;
extern Symbol* SYM_WALK_STELLA_DEFTYPE;
extern Symbol* SYM_WALK_STELLA_DEFMODULE;
extern Symbol* SYM_WALK_STELLA_DEFMACRO;
extern Symbol* SYM_WALK_STELLA_STARTUP_TIME_PROGN;
extern Symbol* SYM_WALK_STELLA_VERBATIM;
extern Symbol* SYM_WALK_STELLA_MODULE;
extern Symbol* SYM_WALK_STELLA_TYPE;
extern Symbol* SYM_WALK_STELLA_PRINT_METHOD;
extern Symbol* SYM_WALK_STELLA_SLOT;
extern Keyword* KWD_WALK_JAVA_STANDALONE;
extern Symbol* SYM_WALK_STELLA_METHOD_CONSTRUCTORp;
extern Keyword* KWD_WALK_DEFINE;
extern Keyword* KWD_WALK_FINALIZE;
extern Keyword* KWD_WALK_WALK;
extern Keyword* KWD_WALK_TRANSLATE;
extern Symbol* SYM_WALK_STELLA_METHOD_MACROp;
extern Surrogate* SGT_WALK_STELLA_GLOBAL_VARIABLE;
extern Surrogate* SGT_WALK_STELLA_TYPE_SPEC;
extern Surrogate* SGT_WALK_STELLA_MODULE;
extern Symbol* SYM_WALK_STELLA_SLOT_AUXILIARYp;
extern Symbol* SYM_WALK_STELLA_METHOD_GLOBALLY_INLINEp;
extern Symbol* SYM_WALK_STELLA_LOG_FUNCTION_CALL;
extern Symbol* SYM_WALK_STELLA_START_FUNCTION_CALL_LOGGING;
extern Symbol* SYM_WALK_STELLA_STOP_FUNCTION_CALL_LOGGING;
extern Symbol* SYM_WALK_STELLA_SET_CALL_LOG_BREAK_POINT;
extern Symbol* SYM_WALK_STELLA_BREAK_PROGRAM;
extern Symbol* SYM_WALK_STELLA_TERMINATE_PROGRAM;
extern Symbol* SYM_WALK_STELLA_PO;
extern Symbol* SYM_WALK_STELLA_NULLp;
extern Symbol* SYM_WALK_STELLA_EQp;
extern Symbol* SYM_WALK_STELLA_EQLp;
extern Symbol* SYM_WALK_STELLA_l;
extern Symbol* SYM_WALK_STELLA_le;
extern Symbol* SYM_WALK_STELLA_g;
extern Symbol* SYM_WALK_STELLA_ge;
extern Symbol* SYM_WALK_STELLA_CAST;
extern Surrogate* SGT_WALK_STELLA_UNKNOWN;
extern Surrogate* SGT_WALK_STELLA_LISP_CODE;
extern Surrogate* SGT_WALK_STELLA_OUTPUT_STREAM;
extern Surrogate* SGT_WALK_STELLA_NATIVE_OUTPUT_STREAM;
extern Symbol* SYM_WALK_STELLA_INLINE;
extern Surrogate* SGT_WALK_STELLA_UNINITIALIZED;
extern Keyword* KWD_WALK_SECOND_CLASS;
extern Surrogate* SGT_WALK_STELLA_KEY_VALUE_LIST;
extern Symbol* SYM_WALK_STELLA_NULL;
extern Keyword* KWD_WALK_TYPE;
extern Keyword* KWD_WALK_ALIAS;
extern Symbol* SYM_WALK_STELLA_ERROR;
extern Symbol* SYM_WALK_STELLA_ILLEGAL_EXPRESSION_FLAGGED_BY_THE_TRANSLATOR;
extern Symbol* SYM_WALK_STELLA_BAD_SYS;
extern Surrogate* SGT_WALK_STELLA_INTEGER_WRAPPER;
extern Surrogate* SGT_WALK_STELLA_INTEGER;
extern Surrogate* SGT_WALK_STELLA_LONG_INTEGER_WRAPPER;
extern Surrogate* SGT_WALK_STELLA_LONG_INTEGER;
extern Surrogate* SGT_WALK_STELLA_FLOAT_WRAPPER;
extern Surrogate* SGT_WALK_STELLA_FLOAT;
extern Surrogate* SGT_WALK_STELLA_NUMBER_WRAPPER;
extern Surrogate* SGT_WALK_STELLA_NUMBER;
extern Surrogate* SGT_WALK_STELLA_STRING_WRAPPER;
extern Surrogate* SGT_WALK_STELLA_STRING;
extern Surrogate* SGT_WALK_STELLA_MUTABLE_STRING_WRAPPER;
extern Surrogate* SGT_WALK_STELLA_MUTABLE_STRING;
extern Surrogate* SGT_WALK_STELLA_CHARACTER_WRAPPER;
extern Surrogate* SGT_WALK_STELLA_CHARACTER;
extern Surrogate* SGT_WALK_STELLA_BOOLEAN_WRAPPER;
extern Surrogate* SGT_WALK_STELLA_BOOLEAN;
extern Surrogate* SGT_WALK_STELLA_FUNCTION_CODE_WRAPPER;
extern Surrogate* SGT_WALK_STELLA_FUNCTION_CODE;
extern Surrogate* SGT_WALK_STELLA_METHOD_CODE_WRAPPER;
extern Surrogate* SGT_WALK_STELLA_METHOD_CODE;
extern Surrogate* SGT_WALK_STELLA_OBJECT;
extern Symbol* SYM_WALK_STELLA_INLINE_WRAP_BOOLEAN;
extern Symbol* SYM_WALK_STELLA_WRAP_LITERAL;
extern Symbol* SYM_WALK_STELLA_INTEGER_TO_BOOLEAN_WRAPPER;
extern Symbol* SYM_WALK_STELLA_INTEGER_TO_BOOLEAN;
extern Symbol* SYM_WALK_STELLA_MUTABLE_STRING_TO_STRING;
extern Symbol* SYM_WALK_STELLA_STRING_TO_MUTABLE_STRING;
extern Surrogate* SGT_WALK_STELLA_SYMBOL;
extern Symbol* SYM_WALK_STELLA_INTERN_SYMBOL;
extern Symbol* SYM_WALK_STELLA_CHARACTER_TO_STRING;
extern Symbol* SYM_WALK_STELLA_SYMBOL_NAME;
extern Symbol* SYM_WALK_STELLA_INLINE_UNWRAP_BOOLEAN;
extern Symbol* SYM_WALK_STELLA_WRAPPER_VALUE;
extern Symbol* SYM_WALK_STELLA_NUMBER_WRAPPER_TO_FLOAT;
extern Surrogate* SGT_WALK_STELLA_SURROGATE;
extern Surrogate* SGT_WALK_STELLA_CLASS;
extern Symbol* SYM_WALK_STELLA_SURROGATE_VALUE;
extern Surrogate* SGT_WALK_STELLA_INPUT_STREAM;
extern Surrogate* SGT_WALK_STELLA_NATIVE_INPUT_STREAM;
extern Symbol* SYM_WALK_STELLA_NATIVE_STREAM;
extern Symbol* SYM_WALK_STELLA_lXg;
extern Surrogate* SGT_WALK_STELLA_SINGLE_FLOAT;
extern Symbol* SYM_WALK_STELLA_IDENTITY;
extern Surrogate* SGT_WALK_STELLA_DOUBLE_FLOAT;
extern Surrogate* SGT_WALK_STELLA_SHORT_INTEGER;
extern Surrogate* SGT_WALK_STELLA_UNSIGNED_SHORT_INTEGER;
extern Surrogate* SGT_WALK_STELLA_UNSIGNED_LONG_INTEGER;
extern Symbol* SYM_WALK_STELLA_VRLET;
extern Symbol* SYM_WALK_STELLA_SYS_CALL_METHOD;
extern Symbol* SYM_WALK_STELLA_SYS_CALL_FUNCTION;
extern Symbol* SYM_WALK_STELLA_TYPED_SYS;
extern Symbol* SYM_WALK_STELLA_SYS_INLINE_CALL;
extern Symbol* SYM_WALK_STELLA_SAFE_CAST;
extern Surrogate* SGT_WALK_STELLA_NON_OBJECT;
extern Surrogate* SGT_WALK_STELLA_WRAPPER;
extern Symbol* SYM_WALK_STELLA_LET;
extern Symbol* SYM_WALK_STELLA_X;
extern Surrogate* SGT_WALK_STELLA_LITERAL;
extern Symbol* SYM_WALK_STELLA_VOID_SYS;
extern Symbol* SYM_WALK_STELLA_SLOT_TYPE_SPECIFIER;
extern Symbol* SYM_WALK_STELLA_SYS_FOREACH;
extern Symbol* SYM_WALK_STELLA_SETQ;
extern Symbol* SYM_WALK_STELLA_SYS_SET_DEFAULT;
extern Symbol* SYM_WALK_STELLA_SETF;
extern Symbol* SYM_WALK_STELLA_SLOT_VALUE;
extern Symbol* SYM_WALK_STELLA_SLOT_VALUE_SETTER;
extern Symbol* SYM_WALK_STELLA_AREF;
extern Symbol* SYM_WALK_STELLA_AREF_SETTER;
extern Symbol* SYM_WALK_STELLA_WITH_PROCESS_LOCK;
extern Symbol* SYM_WALK_STELLA_LOOP;
extern Symbol* SYM_WALK_STELLA_VALUES;
extern Symbol* SYM_WALK_STELLA_SPECIAL;
extern Symbol* SYM_WALK_STELLA_SYS_SPECIAL;
extern Symbol* SYM_WALK_STELLA_RETURN;
extern Symbol* SYM_WALK_STELLA_MV_SETQ;
extern Symbol* SYM_WALK_STELLA_MV_BIND;
extern Symbol* SYM_WALK_STELLA_BREAK;
extern Symbol* SYM_WALK_STELLA_CONTINUE;
extern Symbol* SYM_WALK_STELLA_WHILE;
extern Symbol* SYM_WALK_STELLA_FOREACH;
extern Symbol* SYM_WALK_STELLA_EXISTS;
extern Symbol* SYM_WALK_STELLA_FORALL;
extern Symbol* SYM_WALK_STELLA_SOME;
extern Symbol* SYM_WALK_STELLA_SETOF;
extern Symbol* SYM_WALK_STELLA_SET_OF;
extern Symbol* SYM_WALK_STELLA_SELECT;
extern Symbol* SYM_WALK_STELLA_IF;
extern Symbol* SYM_WALK_STELLA_UNLESS;
extern Symbol* SYM_WALK_STELLA_CHOOSE;
extern Symbol* SYM_WALK_STELLA_NOT;
extern Symbol* SYM_WALK_STELLA_COND;
extern Symbol* SYM_WALK_STELLA_CASE;
extern Symbol* SYM_WALK_STELLA_TYPECASE;
extern Symbol* SYM_WALK_STELLA_e;
extern Symbol* SYM_WALK_STELLA_i;
extern Symbol* SYM_WALK_STELLA__;
extern Symbol* SYM_WALK_STELLA_o;
extern Symbol* SYM_WALK_STELLA_s;
extern Symbol* SYM_WALK_STELLA_QUOTE;
extern Symbol* SYM_WALK_STELLA_BQUOTE;
extern Symbol* SYM_WALK_STELLA_PRINT_STREAM;
extern Symbol* SYM_WALK_STELLA_PRINT_NATIVE_STREAM;
extern Symbol* SYM_WALK_STELLA_NEW;
extern Symbol* SYM_WALK_STELLA_ALLOCATE;
extern Symbol* SYM_WALK_STELLA_LOCAL_NEW;
extern Symbol* SYM_WALK_STELLA_MAKE;
extern Symbol* SYM_WALK_STELLA_FUNCALL;
extern Symbol* SYM_WALK_STELLA_SYS_CALL_FUNCTION_CODE;
extern Symbol* SYM_WALK_STELLA_SYS_CALL_METHOD_CODE;
extern Symbol* SYM_WALK_STELLA_THE_CODE;
extern Symbol* SYM_WALK_STELLA_SIGNAL_EXCEPTION;
extern Symbol* SYM_WALK_STELLA_EXCEPTION_CASE;
extern Symbol* SYM_WALK_STELLA_UNWIND_PROTECT;
extern Symbol* SYM_WALK_STELLA_SYS_UNWIND_PROTECT;
extern Symbol* SYM_WALK_STELLA_SYS_SLOT_VALUE;
extern Symbol* SYM_WALK_STELLA_SYS_SLOT_VALUE_SETTER;
extern Symbol* SYM_WALK_STELLA_SYS_CALL_METHOD_SETTER;
extern Symbol* SYM_WALK_STELLA_SYS_NEW;
extern Keyword* KWD_WALK_PUBLICp;
extern Symbol* SYM_WALK_STELLA_TRUE;
extern Keyword* KWD_WALK_SYMBOLS;
extern Symbol* SYM_WALK_STELLA_INTERN_RIGID_SYMBOL_WRT_MODULE;
extern Symbol* SYM_WALK_STELLA_GET_STELLA_MODULE;
extern Symbol* SYM_WALK_STELLA_INTERN_SYMBOL_AT;
extern Symbol* SYM_WALK_STELLA_INTERN_SURROGATE_AT;
extern Symbol* SYM_WALK_STELLA_INTERN_KEYWORD_AT;
extern Symbol* SYM_WALK_STELLA_FALSE;
extern Keyword* KWD_WALK_INLINE_ARGUMENT;
extern Surrogate* SGT_WALK_STELLA_KEYWORD;
extern Keyword* KWD_WALK_PLACE_WHERE_VRLET_WAS;
extern Keyword* KWD_WALK_PLACE_WHERE_LAST_EXPRESSION_WAS;
extern Keyword* KWD_WALK_DYNAMIC;
extern Symbol* SYM_WALK_STELLA_IT;
extern Symbol* SYM_WALK_STELLA_ON;
extern Symbol* SYM_WALK_STELLA_DYNAMIC_SLOTS;
extern Symbol* SYM_WALK_STELLA_WHERE;
extern Symbol* SYM_WALK_STELLA_KEY;
extern Symbol* SYM_WALK_STELLA_DO;
extern Symbol* SYM_WALK_STELLA_WRAPPEDVALUE;
extern Symbol* SYM_WALK_STELLA_VALUE;
extern Keyword* KWD_WALK_BIT;
extern Symbol* SYM_WALK_STELLA_DYNAMICSLOTS;
extern Symbol* SYM_WALK_STELLA_NEWVALUE;
extern Symbol* SYM_WALK_STELLA_FOUNDMATCHINGENTRYp;
extern Symbol* SYM_WALK_STELLA_THE_KV_LIST;
extern Symbol* SYM_WALK_STELLA_KV_CONS;
extern Symbol* SYM_WALK_STELLA_OLDVALUE;
extern Keyword* KWD_WALK_CONTEXT_SENSITIVEp;
extern Keyword* KWD_WALK_DONT_INHERITp;
extern Symbol* SYM_WALK_STELLA_ACCESS_IN_CONTEXT;
extern Symbol* SYM_WALK_STELLA_HOME_CONTEXT;
extern Keyword* KWD_WALK_COPY_TO_CHILDRENp;
extern Symbol* SYM_WALK_STELLA_UPDATE_IN_CONTEXT;
extern Symbol* SYM_WALK_STELLA_CS_VALUEp;
extern Surrogate* SGT_WALK_STELLA_ARRAY;
extern Symbol* SYM_WALK_STELLA_ANY_VALUE;
extern Symbol* SYM_WALK_STELLA_VARIABLE_DECLARATION;
extern Symbol* SYM_WALK_STELLA_ILLEGAL_VARIABLE;
extern Keyword* KWD_WALK_UNBIND_WITH_DESTRUCTORS;
extern Keyword* KWD_WALK_UNWIND_PROTECT;
extern Surrogate* SGT_WALK_STELLA_METHOD_SLOT;
extern Symbol* SYM_WALK_STELLA_OTHERWISE;
extern Symbol* SYM_WALK_STELLA_SYMBOL_ID;
extern Symbol* SYM_WALK_STELLA_GENERALIZED_SYMBOL;
extern Symbol* SYM_WALK_STELLA_BOOLEANp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_BOOLEANp;
extern Symbol* SYM_WALK_STELLA_INTEGERp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_INTEGERp;
extern Symbol* SYM_WALK_STELLA_LONG_INTEGERp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_LONG_INTEGERp;
extern Symbol* SYM_WALK_STELLA_FLOATp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_FLOATp;
extern Symbol* SYM_WALK_STELLA_STRINGp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_STRINGp;
extern Symbol* SYM_WALK_STELLA_CHARACTERp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_CHARACTERp;
extern Symbol* SYM_WALK_STELLA_WRAPPERp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_WRAPPERp;
extern Surrogate* SGT_WALK_STELLA_VERBATIM_STRING_WRAPPER;
extern Symbol* SYM_WALK_STELLA_VERBATIM_STRINGp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_VERBATIM_STRINGp;
extern Symbol* SYM_WALK_STELLA_SURROGATEp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_SURROGATEp;
extern Surrogate* SGT_WALK_STELLA_TYPE;
extern Symbol* SYM_WALK_STELLA_TYPEp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_TYPEp;
extern Symbol* SYM_WALK_STELLA_SYMBOLp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_SYMBOLp;
extern Surrogate* SGT_WALK_STELLA_TRANSIENT_SYMBOL;
extern Symbol* SYM_WALK_STELLA_TRANSIENT_SYMBOLp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_TRANSIENT_SYMBOLp;
extern Symbol* SYM_WALK_STELLA_KEYWORDp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_KEYWORDp;
extern Symbol* SYM_WALK_STELLA_CONSp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_CONSp;
extern Symbol* SYM_WALK_STELLA_STELLA_CLASSp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_CLASSp;
extern Surrogate* SGT_WALK_STELLA_STORAGE_SLOT;
extern Symbol* SYM_WALK_STELLA_STORAGE_SLOTp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_STORAGE_SLOTp;
extern Symbol* SYM_WALK_STELLA_METHOD_SLOTp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_METHOD_SLOTp;
extern Surrogate* SGT_WALK_STELLA_ANCHORED_TYPE_SPECIFIER;
extern Symbol* SYM_WALK_STELLA_ANCHORED_TYPE_SPECIFIERp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_ANCHORED_TYPE_SPECIFIERp;
extern Surrogate* SGT_WALK_STELLA_PARAMETRIC_TYPE_SPECIFIER;
extern Symbol* SYM_WALK_STELLA_PARAMETRIC_TYPE_SPECIFIERp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OF_PARAMETRIC_TYPE_SPECIFIERp;
extern Symbol* SYM_WALK_STELLA_ISAp;
extern Symbol* SYM_WALK_STELLA_SUBTYPE_OFp;
extern Surrogate* SGT_WALK_STELLA_GENERALIZED_SYMBOL;
extern Symbol* SYM_WALK_STELLA_STRING_EQLp;
extern Symbol* SYM_WALK_STELLA_SAFE_PRIMARY_TYPE;
extern Surrogate* SGT_WALK_STELLA_PROCESS_LOCK_OBJECT;
extern Surrogate* SGT_WALK_STELLA_STANDARD_OBJECT;
extern Symbol* SYM_WALK_STELLA_EQL_TO_BOOLEANp;
extern Symbol* SYM_WALK_STELLA_EQL_TO_INTEGERp;
extern Symbol* SYM_WALK_STELLA_EQL_TO_LONG_INTEGERp;
extern Symbol* SYM_WALK_STELLA_EQL_TO_FLOATp;
extern Symbol* SYM_WALK_STELLA_EQL_TO_STRINGp;
extern Symbol* SYM_WALK_STELLA_GET_QUOTED_TREE;
extern Symbol* SYM_WALK_STELLA_METHOD_BODY_ARGUMENTp;
extern Keyword* KWD_WALK_WARN;
extern Keyword* KWD_WALK_ERROR;
extern Keyword* KWD_WALK_CONTINUABLE_ERROR;
extern Symbol* SYM_WALK_STELLA_CLASS_CL_NATIVE_TYPE;
extern Symbol* SYM_WALK_STELLA_CLASS_CPP_NATIVE_TYPE;
extern Symbol* SYM_WALK_STELLA_CLASS_JAVA_NATIVE_TYPE;
extern Symbol* SYM_WALK_STELLA_CONCATENATE;
extern Symbol* SYM_WALK_STELLA_NIL;
extern Symbol* SYM_WALK_STELLA_WRAP_BOOLEAN;
extern Symbol* SYM_WALK_STELLA_CONS;
extern Symbol* SYM_WALK_STELLA_CONS_LIST;
extern Symbol* SYM_WALK_STELLA_ALLOCATE_ITERATOR;
extern Surrogate* SGT_WALK_STELLA_ARGUMENT_LIST_ITERATOR;
extern Symbol* SYM_WALK_STELLA_LENGTH;
extern Symbol* SYM_WALK_STELLA_METHOD_VARIABLE_ARGUMENTSp;
extern Symbol* SYM_WALK_STELLA_COPY_CONS_TREE;
extern Symbol* SYM_WALK_STELLA_GET_SYM;
extern Symbol* SYM_WALK_STELLA_GET_SGT;
extern Symbol* SYM_WALK_STELLA_GET_KWD;
extern Surrogate* SGT_WALK_STELLA_ARGUMENT_LIST;
extern Symbol* SYM_WALK_STELLA_CACHED_INLINABLE_METHOD_BODY;
extern Keyword* KWD_WALK_INLINE_REFERENCES;
extern Symbol* SYM_WALK_STELLA_INLINE_CALL;
extern Symbol* SYM_WALK_STELLA_METHOD_INHERITS_THROUGH;
extern Keyword* KWD_WALK_FUNCTION;
extern Keyword* KWD_WALK_METHODS;
extern Symbol* SYM_WALK_STELLA_FORWARD_DECLARATIONp;
extern Symbol* SYM_WALK_STELLA_METHOD_NATIVEp;
extern Symbol* SYM_WALK_STELLA_METHOD_COMMANDp;
extern Symbol* SYM_WALK_STELLA_MAIN;
extern Keyword* KWD_WALK_CLASS;
extern Keyword* KWD_WALK_EMBEDDED;
extern Symbol* SYM_WALK_STELLA_CLASS_CONSTRUCTOR_CODE;
extern Symbol* SYM_WALK_STELLA_CLASS_AUXILIARY_METHODS;
extern Symbol* SYM_WALK_STELLA_AUXILIARY_METHOD_REASON;
extern Keyword* KWD_WALK_FIRST_CLASS_WITH_TYPECASE;
extern Keyword* KWD_WALK_AUXILIARYp;
extern Symbol* SYM_WALK_STELLA_PRINT_FORM;
extern Symbol* SYM_WALK_STELLA_PRINT_OBJECT;
extern Symbol* SYM_WALK_STELLA_SELF;
extern Symbol* SYM_WALK_STELLA_STREAM;
extern Symbol* SYM_WALK_STELLA_NATIVE_OUTPUT_STREAM;
extern Keyword* KWD_WALK_CLASSES;
extern Keyword* KWD_WALK_FINALIZE_CLASSES;
extern Symbol* SYM_WALK_STELLA_FINALIZE_CLASSES;
extern Keyword* KWD_WALK_FINALIZE_METHODS;
extern Symbol* SYM_WALK_STELLA_FINALIZE_SLOTS;
extern Symbol* SYM_WALK_STELLA_CLEANUP_UNFINALIZED_CLASSES;
extern Symbol* SYM_WALK_STELLA_DEFINE_EXTERNAL_SLOT_FROM_STRINGIFIED_SOURCE;
extern Keyword* KWD_WALK_MACROp;
extern Symbol* SYM_WALK_STELLA_OBJECT;
extern Keyword* KWD_WALK_UNBOUND_SPECIAL_VARIABLE;
extern Keyword* KWD_WALK_GLOBALS;
extern Symbol* SYM_WALK_STELLA_DEFINE_STELLA_GLOBAL_VARIABLE_FROM_STRINGIFIED_SOURCE;
extern Symbol* SYM_WALK_STELLA_DEFINE_STELLA_TYPE_FROM_STRINGIFIED_SOURCE;
extern Keyword* KWD_WALK_FINAL;
extern Symbol* SYM_WALK_STELLA_CURRENT_STARTUP_TIME_PHASEp;
extern Keyword* KWD_WALK_MODULES;
extern Symbol* SYM_WALK_STELLA_WITHIN_MODULE;
extern Symbol* SYM_WALK_STELLA_oSTELLA_MODULEo;
extern Symbol* SYM_WALK_STELLA_oSTARTUP_TIME_PHASEo;
extern Symbol* SYM_WALK_STELLA_METHOD_STARTUP_CLASSNAME;
extern Symbol* SYM_WALK_STELLA_FUNCTION;
extern Symbol* SYM_WALK_STELLA_LOOKUP_FUNCTION;
extern Symbol* SYM_WALK_STELLA_oBOOTSTRAP_LOCKo;
extern Surrogate* SGT_WALK_STELLA_STELLA_ROOT_EXCEPTION;
extern Symbol* SYM_WALK_STELLA_SYS_SIGNAL;
extern Symbol* SYM_WALK_STELLA_SYS_HANDLER_CASE;
extern Surrogate* SGT_WALK_STELLA_NATIVE_EXCEPTION;
extern Symbol* SYM_WALK_STELLA_SYS_HANDLE_EXCEPTION;
extern Keyword* KWD_WALK_OTHERWISE;
extern Symbol* SYM_WALK_STELLA_INITIAL_ELEMENT;
extern Symbol* SYM_WALK_STELLA_SIZE;
extern Symbol* SYM_WALK_STELLA_STORAGE_SLOT;
extern Surrogate* SGT_WALK_STELLA_CODE;
extern Keyword* KWD_WALK_METHOD;
extern Symbol* SYM_WALK_STELLA_METHOD_CODE;
extern Surrogate* SGT_WALK_STELLA_COMPOUND_TYPE_SPECIFIER;
extern Symbol* SYM_WALK_STELLA_METHOD_LISP_MACROp;
extern Symbol* SYM_WALK_STELLA_DOCUMENTATION;
extern Symbol* SYM_WALK_STELLA_EXPRESSION;
extern Symbol* SYM_WALK_STELLA_IGNORE;
extern Symbol* SYM_WALK_STELLA_oIGNORETRANSLATIONERRORSpo;
extern Symbol* SYM_WALK_STELLA_CL_INCREMENTALLY_TRANSLATE;
extern Symbol* SYM_WALK_STELLA_REGISTER_NATIVE_NAME;
extern Symbol* SYM_WALK_STELLA_REST;
extern Symbol* SYM_WALK_STELLA_NTH_REST;
extern Symbol* SYM_WALK_STELLA_NTH;
extern Symbol* SYM_WALK_STELLA_ARGUMENTS;
extern Symbol* SYM_WALK_STELLA_RESULT;
extern Symbol* SYM_WALK_STELLA_METHOD_EVALUATE_ARGUMENTSp;
extern Symbol* SYM_WALK_STELLA_APPEND;
extern Symbol* SYM_WALK_STELLA_EVALUATOR_WRAPPER_CODE;
extern Symbol* SYM_WALK_STELLA_LISTo;
extern Symbol* SYM_WALK_STELLA_STARTUP_WALK;


} // end of namespace stella
