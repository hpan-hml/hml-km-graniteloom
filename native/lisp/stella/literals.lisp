;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; literals.lisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2014      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-LITERALS-STELLA-BOOLEAN NULL)
(CL:DEFVAR KWD-LITERALS-NULL-WRAPPER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-FALSE-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-INTEGER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-LONG-INTEGER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-LONG-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-FLOAT NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-FLOAT-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-STRING NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-MUTABLE-STRING NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-MUTABLE-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-CHARACTER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-CHARACTER-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-FUNCTION-CODE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-METHOD-CODE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL-METHOD-CODE-WRAPPER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-TRUE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-TRUE-WRAPPER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-FALSE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-BOOLEAN NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN NULL)
(CL:DEFVAR KWD-LITERALS-WRAP-FUNCTION NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-INTEGER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-LONG-INTEGER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-FLOAT NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-STRING NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-CHARACTER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-FUNCTION-CODE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-METHOD-CODE NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-LONG-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-FLOAT-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-VERBATIM-STRING-WRAPPER NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-CHARACTER-WRAPPER NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NULL NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-NIL NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-CONS NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-WRAP-LITERAL NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-GET-KWD NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-TYPED-SYS NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-SYMBOL NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-GET-SGT NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-INTERN-COMMON-LISP-SYMBOL NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-GET-SYM NULL)
(CL:DEFVAR SGT-LITERALS-STELLA-CONS NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-LIST* NULL)
(CL:DEFVAR |SYM-LITERALS-STELLA-&| NULL)
(CL:DEFVAR |SYM-LITERALS-STELLA-&&| NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-CONCATENATE NULL)
(CL:DEFVAR KWD-LITERALS-OTHER NULL)
(CL:DEFVAR KWD-LITERALS-DIGIT NULL)
(CL:DEFVAR KWD-LITERALS-LETTER NULL)
(CL:DEFVAR KWD-LITERALS-SYMBOL-CONSTITUENT NULL)
(CL:DEFVAR KWD-LITERALS-SYMBOL-QUALIFIER NULL)
(CL:DEFVAR KWD-LITERALS-ESCAPE NULL)
(CL:DEFVAR KWD-LITERALS-DELIMITER NULL)
(CL:DEFVAR KWD-LITERALS-WHITE-SPACE NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-STARTUP-LITERALS NULL)
(CL:DEFVAR SYM-LITERALS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* SYMBOL-SYM STANDARD-ERROR
  *CLASS-HIERARCHY-BOOTED?* NIL EOL NULL-CHARACTER NULL-FLOAT
  MOST-POSITIVE-INTEGER NULL-LONG-INTEGER NULL-INTEGER))

;;; (DEFGLOBAL ZERO-WRAPPER ...)

(CL:DEFVAR ZERO-WRAPPER NULL)

;;; (DEFGLOBAL ONE-WRAPPER ...)

(CL:DEFVAR ONE-WRAPPER NULL)

;;; (DEFGLOBAL TRUE-WRAPPER ...)

(CL:DEFVAR TRUE-WRAPPER NULL)

;;; (DEFGLOBAL FALSE-WRAPPER ...)

(CL:DEFVAR FALSE-WRAPPER NULL)

;;; (DEFGLOBAL NULL-INTEGER-WRAPPER ...)

(CL:DEFVAR NULL-INTEGER-WRAPPER NULL)

;;; (DEFGLOBAL NULL-LONG-INTEGER-WRAPPER ...)

(CL:DEFVAR NULL-LONG-INTEGER-WRAPPER NULL)

;;; (DEFGLOBAL NULL-FLOAT-WRAPPER ...)

(CL:DEFVAR NULL-FLOAT-WRAPPER NULL)

;;; (DEFGLOBAL NULL-STRING-WRAPPER ...)

(CL:DEFVAR NULL-STRING-WRAPPER NULL)

;;; (DEFGLOBAL NULL-MUTABLE-STRING-WRAPPER ...)

(CL:DEFVAR NULL-MUTABLE-STRING-WRAPPER NULL)

;;; (DEFGLOBAL NULL-CHARACTER-WRAPPER ...)

(CL:DEFVAR NULL-CHARACTER-WRAPPER NULL)

;;; (DEFGLOBAL NULL-FUNCTION-CODE-WRAPPER ...)

(CL:DEFVAR NULL-FUNCTION-CODE-WRAPPER NULL)

;;; (DEFGLOBAL NULL-METHOD-CODE-WRAPPER ...)

(CL:DEFVAR NULL-METHOD-CODE-WRAPPER NULL)

;;; (DEFMETHOD (TERMINATE-WRAPPER? BOOLEAN) ...)

(CL:DEFMETHOD TERMINATE-WRAPPER? ((SELF WRAPPER))
  (CL:IF
   (CL:OR (CL:EQ SELF NULL-LONG-INTEGER-WRAPPER)
    (CL:EQ SELF NULL-FLOAT-WRAPPER) (CL:EQ SELF NULL-STRING-WRAPPER)
    (CL:EQ SELF NULL-MUTABLE-STRING-WRAPPER)
    (CL:EQ SELF NULL-CHARACTER-WRAPPER)
    (CL:EQ SELF NULL-FUNCTION-CODE-WRAPPER)
    (CL:EQ SELF NULL-METHOD-CODE-WRAPPER))
   (CL:RETURN-FROM TERMINATE-WRAPPER? CL:NIL)
   (CL:RETURN-FROM TERMINATE-WRAPPER? CL:T)))

;;; (DEFMETHOD (TERMINATE-WRAPPER? BOOLEAN) ...)

(CL:DEFMETHOD TERMINATE-WRAPPER? ((SELF INTEGER-WRAPPER))
  (CL:IF
   (CL:OR (CL:EQ SELF ZERO-WRAPPER) (CL:EQ SELF ONE-WRAPPER)
    (CL:EQ SELF NULL-INTEGER-WRAPPER))
   (CL:RETURN-FROM TERMINATE-WRAPPER? CL:NIL)
   (CL:RETURN-FROM TERMINATE-WRAPPER? CL:T)))

;;; (DEFGLOBAL *LITERAL-TYPE-INFO-TABLE* ...)

(CL:DEFVAR *LITERAL-TYPE-INFO-TABLE* NULL
  "Table that holds a variety of information about literal
types, e.g., the name of their null-wrapper, wrap-function, etc.")

;;; (DEFGLOBAL *LITERAL-TYPES* ...)

(CL:DEFVAR *LITERAL-TYPES* NULL
  "List of literal types stored in '*literal-type-info-table*'.
Maintained for iteration purposes.")

;;; (DEFUN (LOOKUP-LITERAL-TYPE-INFO OBJECT) ...)

(CL:DEFUN LOOKUP-LITERAL-TYPE-INFO (TYPE KEY)
  (CL:LET* ((ENTRY (LOOKUP *LITERAL-TYPE-INFO-TABLE* TYPE)))
   (CL:IF (CL:NOT (CL:EQ ENTRY NULL))
    (CL:RETURN-FROM LOOKUP-LITERAL-TYPE-INFO (LOOKUP ENTRY KEY))
    (CL:RETURN-FROM LOOKUP-LITERAL-TYPE-INFO NULL))))

;;; (DEFUN SET-LITERAL-TYPE-INFO ...)

(CL:DEFUN SET-LITERAL-TYPE-INFO (TYPE KEY VALUE)
  (CL:LET* ((ENTRY (LOOKUP *LITERAL-TYPE-INFO-TABLE* TYPE)))
   (CL:WHEN (CL:EQ ENTRY NULL) (CL:SETQ ENTRY (NEW-KEY-VALUE-LIST))
    (INSERT-AT *LITERAL-TYPE-INFO-TABLE* TYPE ENTRY)
    (INSERT-LAST *LITERAL-TYPES* TYPE))
   (INSERT-AT ENTRY KEY VALUE))
  :VOID)

;;; (DEFUN (WRAP-INTEGER INTEGER-WRAPPER) ...)

(CL:DEFUN WRAP-INTEGER (VALUE)
  "Return a literal object whose value is the INTEGER 'value'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:FIXNUM)
  (CL:IF (CL:= VALUE NULL-INTEGER)
   (CL:RETURN-FROM WRAP-INTEGER NULL-INTEGER-WRAPPER)
   (CL:CASE VALUE (0 (CL:RETURN-FROM WRAP-INTEGER ZERO-WRAPPER))
    (1 (CL:RETURN-FROM WRAP-INTEGER ONE-WRAPPER))
    (CL:OTHERWISE
     (CL:RETURN-FROM WRAP-INTEGER (NEW-INTEGER-WRAPPER VALUE))))))

;;; (DEFUN (UNWRAP-INTEGER INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) UNWRAP-INTEGER))
(CL:DEFUN UNWRAP-INTEGER (WRAPPER)
  "Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL."
  (CL:IF (CL:EQ WRAPPER NULL)
   (CL:RETURN-FROM UNWRAP-INTEGER NULL-INTEGER)
   (CL:RETURN-FROM UNWRAP-INTEGER (%WRAPPER-VALUE WRAPPER))))

;;; (DEFUN (WRAP-LONG-INTEGER LONG-INTEGER-WRAPPER) ...)

(CL:DEFUN WRAP-LONG-INTEGER (VALUE)
  "Return a literal object whose value is the LONG-INTEGER 'value'."
  (CL:IF (CL:= VALUE NULL-LONG-INTEGER)
   (CL:RETURN-FROM WRAP-LONG-INTEGER NULL-LONG-INTEGER-WRAPPER)
   (CL:RETURN-FROM WRAP-LONG-INTEGER (NEW-LONG-INTEGER-WRAPPER VALUE))))

;;; (DEFUN (UNWRAP-LONG-INTEGER LONG-INTEGER) ...)

(CL:DEFUN UNWRAP-LONG-INTEGER (WRAPPER)
  "Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL."
  (CL:IF (CL:EQ WRAPPER NULL)
   (CL:RETURN-FROM UNWRAP-LONG-INTEGER NULL-LONG-INTEGER)
   (CL:RETURN-FROM UNWRAP-LONG-INTEGER (%WRAPPER-VALUE WRAPPER))))

;;; (DEFUN (WRAP-INTEGER-VALUE NUMBER-WRAPPER) ...)

(CL:DEFUN WRAP-INTEGER-VALUE (VALUE)
  "Return a literal object whose value is 'value'.  Choose a regular integer
wrapper unless `value' is too large and needs to be stored in a long wrapper."
  (CL:IF
   (CL:AND (CL:>= VALUE NULL-INTEGER)
    (CL:<= VALUE MOST-POSITIVE-INTEGER))
   (CL:LET*
    ((INTWRAPPER (CL:MAKE-INSTANCE (CL:QUOTE INTEGER-WRAPPER))))
    (CL:SETF (%WRAPPER-VALUE INTWRAPPER) (CL:TRUNCATE VALUE))
    (CL:RETURN-FROM WRAP-INTEGER-VALUE INTWRAPPER))
   (CL:LET*
    ((LONGWRAPPER (CL:MAKE-INSTANCE (CL:QUOTE LONG-INTEGER-WRAPPER))))
    (CL:SETF (%WRAPPER-VALUE LONGWRAPPER) VALUE)
    (CL:RETURN-FROM WRAP-INTEGER-VALUE LONGWRAPPER))))

;;; (DEFUN (WRAP-FLOAT FLOAT-WRAPPER) ...)

(CL:DEFUN WRAP-FLOAT (VALUE)
  "Return a literal object whose value is the FLOAT 'value'."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:DOUBLE-FLOAT)
  (CL:IF (CL:= VALUE NULL-FLOAT)
   (CL:RETURN-FROM WRAP-FLOAT NULL-FLOAT-WRAPPER)
   (CL:RETURN-FROM WRAP-FLOAT (NEW-FLOAT-WRAPPER VALUE))))

;;; (DEFUN (UNWRAP-FLOAT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT) UNWRAP-FLOAT))
(CL:DEFUN UNWRAP-FLOAT (WRAPPER)
  "Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL."
  (CL:IF (CL:EQ WRAPPER NULL) (CL:RETURN-FROM UNWRAP-FLOAT NULL-FLOAT)
   (CL:RETURN-FROM UNWRAP-FLOAT (%WRAPPER-VALUE WRAPPER))))

;;; (DEFUN (WRAP-STRING STRING-WRAPPER) ...)

(CL:DEFUN WRAP-STRING (VALUE)
  "Return a literal object whose value is the STRING 'value'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:SIMPLE-STRING)
  (CL:IF (CL:EQ VALUE STELLA::NULL-STRING)
   (CL:RETURN-FROM WRAP-STRING NULL-STRING-WRAPPER)
   (CL:RETURN-FROM WRAP-STRING (NEW-STRING-WRAPPER VALUE))))

;;; (DEFUN (UNWRAP-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) UNWRAP-STRING))
(CL:DEFUN UNWRAP-STRING (WRAPPER)
  "Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL."
  (CL:IF (CL:EQ WRAPPER NULL)
   (CL:RETURN-FROM UNWRAP-STRING STELLA::NULL-STRING)
   (CL:RETURN-FROM UNWRAP-STRING (%WRAPPER-VALUE WRAPPER))))

;;; (DEFUN (WRAP-MUTABLE-STRING MUTABLE-STRING-WRAPPER) ...)

(CL:DEFUN WRAP-MUTABLE-STRING (VALUE)
  "Return a literal object whose value is the MUTABLE-STRING 'value'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:SIMPLE-STRING)
  (CL:IF (NULL? VALUE)
   (CL:RETURN-FROM WRAP-MUTABLE-STRING NULL-MUTABLE-STRING-WRAPPER)
   (CL:RETURN-FROM WRAP-MUTABLE-STRING
    (NEW-MUTABLE-STRING-WRAPPER VALUE))))

;;; (DEFUN (UNWRAP-MUTABLE-STRING MUTABLE-STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) UNWRAP-MUTABLE-STRING))
(CL:DEFUN UNWRAP-MUTABLE-STRING (WRAPPER)
  "Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL."
  (CL:IF (CL:EQ WRAPPER NULL)
   (CL:RETURN-FROM UNWRAP-MUTABLE-STRING STELLA::NULL-STRING)
   (CL:RETURN-FROM UNWRAP-MUTABLE-STRING (%WRAPPER-VALUE WRAPPER))))

;;; (DEFUN (WRAP-CHARACTER CHARACTER-WRAPPER) ...)

(CL:DEFUN WRAP-CHARACTER (VALUE)
  "Return a literal object whose value is the CHARACTER 'value'."
  (CL:IF (NULL? VALUE)
   (CL:RETURN-FROM WRAP-CHARACTER NULL-CHARACTER-WRAPPER)
   (CL:RETURN-FROM WRAP-CHARACTER (NEW-CHARACTER-WRAPPER VALUE))))

;;; (DEFUN (UNWRAP-CHARACTER CHARACTER) ...)

(CL:DEFUN UNWRAP-CHARACTER (WRAPPER)
  "Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL."
  (CL:IF (CL:EQ WRAPPER NULL)
   (CL:RETURN-FROM UNWRAP-CHARACTER NULL-CHARACTER)
   (CL:RETURN-FROM UNWRAP-CHARACTER (%WRAPPER-VALUE WRAPPER))))

;;; (DEFUN (WRAP-FUNCTION-CODE FUNCTION-CODE-WRAPPER) ...)

(CL:DEFUN WRAP-FUNCTION-CODE (VALUE)
  "Return a literal object whose value is the FUNCTION-CODE 'value'."
  (CL:IF (CL:EQ VALUE NULL)
   (CL:RETURN-FROM WRAP-FUNCTION-CODE NULL-FUNCTION-CODE-WRAPPER)
   (CL:RETURN-FROM WRAP-FUNCTION-CODE
    (NEW-FUNCTION-CODE-WRAPPER VALUE))))

;;; (DEFUN (UNWRAP-FUNCTION-CODE FUNCTION-CODE) ...)

(CL:DEFUN UNWRAP-FUNCTION-CODE (WRAPPER)
  "Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL."
  (CL:IF (CL:EQ WRAPPER NULL)
   (CL:RETURN-FROM UNWRAP-FUNCTION-CODE NULL)
   (CL:RETURN-FROM UNWRAP-FUNCTION-CODE (%WRAPPER-VALUE WRAPPER))))

;;; (DEFUN (WRAP-METHOD-CODE METHOD-CODE-WRAPPER) ...)

(CL:DEFUN WRAP-METHOD-CODE (VALUE)
  "Return a literal object whose value is the METHOD-CODE 'value'."
  (CL:IF (CL:EQ VALUE NULL)
   (CL:RETURN-FROM WRAP-METHOD-CODE NULL-METHOD-CODE-WRAPPER)
   (CL:RETURN-FROM WRAP-METHOD-CODE (NEW-METHOD-CODE-WRAPPER VALUE))))

;;; (DEFUN (UNWRAP-METHOD-CODE METHOD-CODE) ...)

(CL:DEFUN UNWRAP-METHOD-CODE (WRAPPER)
  "Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL."
  (CL:IF (CL:EQ WRAPPER NULL) (CL:RETURN-FROM UNWRAP-METHOD-CODE NULL)
   (CL:RETURN-FROM UNWRAP-METHOD-CODE (%WRAPPER-VALUE WRAPPER))))

;;; (DEFUN (WRAP-BOOLEAN BOOLEAN-WRAPPER) ...)

(CL:DEFUN WRAP-BOOLEAN (VALUE)
  "Return a literal object whose value is the BOOLEAN 'value'."
  (CL:RETURN-FROM WRAP-BOOLEAN (CL:IF VALUE TRUE-WRAPPER FALSE-WRAPPER)))

;;; (DEFUN (UNWRAP-BOOLEAN BOOLEAN) ...)

(CL:DEFUN UNWRAP-BOOLEAN (WRAPPER)
  "Unwrap `wrapper' and return its values as a regular BOOLEAN.
Map NULL onto FALSE."
  (CL:RETURN-FROM UNWRAP-BOOLEAN (CL:EQ WRAPPER TRUE-WRAPPER)))

;;; (DEFUN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN BOOLEAN) ...)

(CL:DEFUN COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (WRAPPER)
  (CL:WHEN (CL:EQ WRAPPER NULL)
   (CL:WARN
    "Coercing an undefined BOOLEAN-WRAPPER to FALSE.  Explicitly guard~% with `defined?' or use `unwrap-boolean' to avoid this warning."))
  (CL:RETURN-FROM COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
   (CL:EQ WRAPPER TRUE-WRAPPER)))

;;; (DEFMACRO INLINE-WRAP-BOOLEAN ...)

(CL:DEFUN INLINE-WRAP-BOOLEAN (EXPRESSION)
  (CL:LET* ((WALKEDEXP (WALKED-EXPRESSION-EXPRESSION EXPRESSION)))
   (CL:COND
    ((CL:EQ WALKEDEXP SYM-LITERALS-STELLA-TRUE)
     (CL:RETURN-FROM INLINE-WRAP-BOOLEAN
      SYM-LITERALS-STELLA-TRUE-WRAPPER))
    ((CL:EQ WALKEDEXP SYM-LITERALS-STELLA-FALSE)
     (CL:RETURN-FROM INLINE-WRAP-BOOLEAN
      SYM-LITERALS-STELLA-FALSE-WRAPPER))
    (CL:T
     (CL:RETURN-FROM INLINE-WRAP-BOOLEAN
      (LIST* SYM-LITERALS-STELLA-WRAP-BOOLEAN EXPRESSION NIL))))))

;;; (DEFMACRO INLINE-UNWRAP-BOOLEAN ...)

(CL:DEFUN INLINE-UNWRAP-BOOLEAN (EXPRESSION)
  (CL:LET* ((WALKEDEXP (WALKED-EXPRESSION-EXPRESSION EXPRESSION)))
   (CL:COND
    ((CL:EQ WALKEDEXP SYM-LITERALS-STELLA-TRUE-WRAPPER)
     (CL:RETURN-FROM INLINE-UNWRAP-BOOLEAN SYM-LITERALS-STELLA-TRUE))
    ((CL:EQ WALKEDEXP SYM-LITERALS-STELLA-FALSE-WRAPPER)
     (CL:RETURN-FROM INLINE-UNWRAP-BOOLEAN SYM-LITERALS-STELLA-FALSE))
    (CL:T
     (CL:RETURN-FROM INLINE-UNWRAP-BOOLEAN
      (LIST* SYM-LITERALS-STELLA-COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
       EXPRESSION NIL))))))

;;; (DEFMETHOD (WRAP-LITERAL INTEGER-WRAPPER) ...)

(%%DEFINTEGERMETHOD WRAP-LITERAL ((VALUE CL:FIXNUM))
  (CL:DECLARE (CL:TYPE CL:FIXNUM VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:FIXNUM)
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-INTEGER VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL LONG-INTEGER-WRAPPER) ...)

(%%DEFINTEGERMETHOD WRAP-LITERAL ((VALUE CL:INTEGER))
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-LONG-INTEGER VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL FLOAT-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:FLOAT))
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:DOUBLE-FLOAT)
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-FLOAT VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL MUTABLE-STRING-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:STRING))
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:SIMPLE-STRING)
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-MUTABLE-STRING VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL STRING-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:STRING))
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:SIMPLE-STRING)
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-STRING VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL CHARACTER-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:CHARACTER))
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-CHARACTER VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL FUNCTION-CODE-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:FUNCTION))
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-FUNCTION-CODE VALUE)))

;;; (DEFMETHOD (WRAP-LITERAL METHOD-CODE-WRAPPER) ...)

(CL:DEFMETHOD WRAP-LITERAL ((VALUE CL:STANDARD-GENERIC-FUNCTION))
  (CL:RETURN-FROM WRAP-LITERAL (WRAP-METHOD-CODE VALUE)))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(%%DEFCONSMETHOD COPY-WRAPPED-LITERAL ((SELF STANDARD-OBJECT))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL SELF))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF LITERAL-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL SELF))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF INTEGER-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL
   (WRAP-INTEGER (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF LONG-INTEGER-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL
   (WRAP-LONG-INTEGER (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF FLOAT-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL
   (WRAP-FLOAT (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF STRING-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL
   (WRAP-STRING (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF MUTABLE-STRING-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL
   (WRAP-MUTABLE-STRING (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF CHARACTER-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL
   (WRAP-CHARACTER (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF FUNCTION-CODE-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL
   (WRAP-FUNCTION-CODE (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ...)

(CL:DEFMETHOD COPY-WRAPPED-LITERAL ((SELF METHOD-CODE-WRAPPER))
  (CL:RETURN-FROM COPY-WRAPPED-LITERAL
   (WRAP-METHOD-CODE (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X OBJECT) Y)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
    "object-eql?: Don't know how to compare `" X "' with `" Y "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(%%DEFCONSMETHOD OBJECT-EQL? ((X STANDARD-OBJECT) Y)
  (CL:RETURN-FROM OBJECT-EQL? (CL:EQ X Y)))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X INTEGER-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL?
   (CL:AND (CL:NOT (CL:EQ Y NULL))
    (CL:OR (CL:EQ (PRIMARY-TYPE Y) SGT-LITERALS-STELLA-INTEGER-WRAPPER)
     (ISA? Y SGT-LITERALS-STELLA-INTEGER-WRAPPER))
    (CL:= (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X LONG-INTEGER-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL?
   (CL:AND (CL:NOT (CL:EQ Y NULL))
    (CL:OR
     (CL:EQ (PRIMARY-TYPE Y) SGT-LITERALS-STELLA-LONG-INTEGER-WRAPPER)
     (ISA? Y SGT-LITERALS-STELLA-LONG-INTEGER-WRAPPER))
    (CL:= (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X FLOAT-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL?
   (CL:AND (CL:NOT (CL:EQ Y NULL))
    (CL:OR (CL:EQ (PRIMARY-TYPE Y) SGT-LITERALS-STELLA-FLOAT-WRAPPER)
     (ISA? Y SGT-LITERALS-STELLA-FLOAT-WRAPPER))
    (CL:= (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X BOOLEAN-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL?
   (CL:OR (CL:EQ X Y)
    (CL:AND (CL:NOT (CL:EQ Y NULL))
     (CL:OR
      (CL:EQ (PRIMARY-TYPE Y) SGT-LITERALS-STELLA-BOOLEAN-WRAPPER)
      (ISA? Y SGT-LITERALS-STELLA-BOOLEAN-WRAPPER))
     (CL:EQ (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y))))))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X STRING-WRAPPER) Y)
  (CL:WHEN (CL:NOT (CL:EQ Y NULL))
   (CL:LET* ((YTYPE (PRIMARY-TYPE Y)))
    (CL:WHEN
     (CL:OR (CL:EQ YTYPE SGT-LITERALS-STELLA-STRING-WRAPPER)
      (CL:EQ YTYPE SGT-LITERALS-STELLA-VERBATIM-STRING-WRAPPER)
      (CL:AND (CL:NOT *CLASS-HIERARCHY-BOOTED?*)
       (CL:OR (CL:EQ YTYPE NULL)
        (CL:EQ SGT-LITERALS-STELLA-STRING-WRAPPER NULL)
        (CL:EQ SGT-LITERALS-STELLA-VERBATIM-STRING-WRAPPER NULL)))
      (ISA? Y SGT-LITERALS-STELLA-STRING-WRAPPER))
     (CL:RETURN-FROM OBJECT-EQL?
      (STRING-EQL? (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y))))))
  (CL:RETURN-FROM OBJECT-EQL? CL:NIL))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X MUTABLE-STRING-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL? (CL:EQ X Y)))

;;; (DEFMETHOD (OBJECT-EQL? BOOLEAN) ...)

(CL:DEFMETHOD OBJECT-EQL? ((X CHARACTER-WRAPPER) Y)
  (CL:RETURN-FROM OBJECT-EQL?
   (CL:AND (CL:NOT (CL:EQ Y NULL))
    (CL:OR
     (CL:EQ (PRIMARY-TYPE Y) SGT-LITERALS-STELLA-CHARACTER-WRAPPER)
     (ISA? Y SGT-LITERALS-STELLA-CHARACTER-WRAPPER))
    (CL:EQL (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))

;;; (DEFUN (EQL-TO-BOOLEAN? BOOLEAN) ...)

(CL:DEFUN EQL-TO-BOOLEAN? (Y X)
  (CL:RETURN-FROM EQL-TO-BOOLEAN?
   (CL:AND (BOOLEAN? Y) (CL:EQ (%WRAPPER-VALUE Y) X))))

;;; (DEFUN (EQL-TO-INTEGER? BOOLEAN) ...)

(CL:DEFUN EQL-TO-INTEGER? (Y X)
  (CL:DECLARE (CL:TYPE CL:FIXNUM X))
  #+MCL
  (CL:CHECK-TYPE X CL:FIXNUM)
  (CL:RETURN-FROM EQL-TO-INTEGER?
   (CL:AND (INTEGER? Y) (CL:= (%WRAPPER-VALUE Y) X))))

;;; (DEFUN (EQL-TO-LONG-INTEGER? BOOLEAN) ...)

(CL:DEFUN EQL-TO-LONG-INTEGER? (Y X)
  (CL:RETURN-FROM EQL-TO-LONG-INTEGER?
   (CL:AND (LONG-INTEGER? Y) (CL:= (%WRAPPER-VALUE Y) X))))

;;; (DEFUN (EQL-TO-FLOAT? BOOLEAN) ...)

(CL:DEFUN EQL-TO-FLOAT? (Y X)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT X))
  #+MCL
  (CL:CHECK-TYPE X CL:DOUBLE-FLOAT)
  (CL:RETURN-FROM EQL-TO-FLOAT?
   (CL:AND (FLOAT? Y) (CL:= (%WRAPPER-VALUE Y) X))))

;;; (DEFUN (EQL-TO-STRING? BOOLEAN) ...)

(CL:DEFUN EQL-TO-STRING? (Y X)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING X))
  #+MCL
  (CL:CHECK-TYPE X CL:SIMPLE-STRING)
  (CL:RETURN-FROM EQL-TO-STRING?
   (CL:AND (STRING? Y) (STRING-EQL? (%WRAPPER-VALUE Y) X))))

;;; (DEFUN (EQL-TO-CHARACTER? BOOLEAN) ...)

(CL:DEFUN EQL-TO-CHARACTER? (Y X)
  (CL:RETURN-FROM EQL-TO-CHARACTER?
   (CL:AND (CHARACTER? Y) (CL:EQL (%WRAPPER-VALUE Y) X))))

;;; (DEFUN (HELP-BQUOTIFY OBJECT) ...)

(CL:DEFUN HELP-BQUOTIFY (TREE)
  (CL:WHEN (CL:EQ TREE NULL)
   (CL:RETURN-FROM HELP-BQUOTIFY SYM-LITERALS-STELLA-NULL))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-LITERALS-STELLA-CONS)
     (CL:PROGN
      (CL:IF (CL:EQ TREE NIL)
       (CL:RETURN-FROM HELP-BQUOTIFY SYM-LITERALS-STELLA-NIL)
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-CONS
         (HELP-BQUOTIFY (%%VALUE TREE))
         (HELP-BQUOTIFY (%%REST TREE)))))))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM HELP-BQUOTIFY
       (CONS-LIST SYM-LITERALS-STELLA-WRAP-LITERAL TREE))))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM HELP-BQUOTIFY
       (CONS-LIST SYM-LITERALS-STELLA-WRAP-LITERAL TREE))))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM HELP-BQUOTIFY
       (CONS-LIST SYM-LITERALS-STELLA-WRAP-LITERAL TREE))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM HELP-BQUOTIFY
       (CONS-LIST SYM-LITERALS-STELLA-WRAP-LITERAL TREE))))
    ((SUBTYPE-OF-CHARACTER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM HELP-BQUOTIFY
       (CONS-LIST SYM-LITERALS-STELLA-WRAP-LITERAL TREE))))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (USE-HARDCODED-SYMBOLS?)
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-GET-KWD
         (WRAP-INTEGER (%SYMBOL-ID TREE))))
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-TYPED-SYS (REGISTER-SYMBOL TREE)
         SGT-LITERALS-STELLA-SYMBOL)))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (USE-HARDCODED-SYMBOLS?)
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-GET-SGT
         (WRAP-INTEGER (%SYMBOL-ID TREE))))
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-TYPED-SYS (REGISTER-SYMBOL TREE)
         SGT-LITERALS-STELLA-SYMBOL)))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (SYMBOL-COMMON-LISP? TREE)
       (CL:RETURN-FROM HELP-BQUOTIFY
        (CONS-LIST SYM-LITERALS-STELLA-INTERN-COMMON-LISP-SYMBOL
         (WRAP-STRING (%SYMBOL-NAME TREE))))
       (CL:IF (USE-HARDCODED-SYMBOLS?)
        (CL:RETURN-FROM HELP-BQUOTIFY
         (CONS-LIST SYM-LITERALS-STELLA-GET-SYM
          (WRAP-INTEGER (%SYMBOL-ID (PERMANENTIFY TREE)))))
        (CL:RETURN-FROM HELP-BQUOTIFY
         (CONS-LIST SYM-LITERALS-STELLA-TYPED-SYS
          (REGISTER-SYMBOL TREE) SGT-LITERALS-STELLA-SYMBOL))))))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
        " Illegal argument to quote: `" (DE-UGLIFY-PARSE-TREE TREE)
        "'." EOL)))
     (CL:RETURN-FROM HELP-BQUOTIFY NULL)))))

;;; (DEFUN (BQUOTIFY OBJECT) ...)

(CL:DEFUN BQUOTIFY (TREE)
  (CL:RETURN-FROM BQUOTIFY (HELP-BQUOTIFY TREE)))

;;; (DEFUN (EXPAND-BQUOTE-TREE OBJECT) ...)

(CL:DEFUN EXPAND-BQUOTE-TREE (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-LITERALS-STELLA-CONS)
    (CL:PROGN
     (CL:LET*
      ((EXPANDEDTREE (CONS SYM-LITERALS-STELLA-LIST* NIL))
       (CURSOR TREE) (TERM (%%VALUE CURSOR)))
      (CL:LOOP WHILE
       (CL:AND (CL:NOT (CL:EQ CURSOR NIL))
        (CL:NOT
         (CL:OR (CL:EQ TERM |SYM-LITERALS-STELLA-&|)
          (CL:EQ TERM |SYM-LITERALS-STELLA-&&|))))
       DO
       (CL:SETQ EXPANDEDTREE
        (CONS (EXPAND-BQUOTE-TREE TERM) EXPANDEDTREE))
       (CL:SETQ CURSOR (%%REST CURSOR))
       (CL:SETQ TERM (%%VALUE CURSOR)))
      (CL:COND
       ((CL:EQ CURSOR NIL)
        (CL:RETURN-FROM EXPAND-BQUOTE-TREE
         (REVERSE (CONS SYM-LITERALS-STELLA-NIL EXPANDEDTREE))))
       ((CL:EQ TERM |SYM-LITERALS-STELLA-&|)
        (CL:SETQ CURSOR (%%REST CURSOR))
        (CL:WHEN (CL:EQ CURSOR NIL)
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
            " Illegal bquote tree -- missing term after '&'.." EOL))))
        (CL:RETURN-FROM EXPAND-BQUOTE-TREE
         (REVERSE
          (CONS (EXPAND-BQUOTE-TREE (%%REST CURSOR))
           (CONS (%%VALUE CURSOR) EXPANDEDTREE)))))
       (CL:T (CL:SETQ CURSOR (%%REST CURSOR))
        (CL:WHEN (CL:EQ CURSOR NIL)
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
            " Illegal bquote tree -- missing term after '&&'." EOL))))
        (CL:RETURN-FROM EXPAND-BQUOTE-TREE
         (REVERSE
          (CONS
           (CONS-LIST SYM-LITERALS-STELLA-CONCATENATE (%%VALUE CURSOR)
            (EXPAND-BQUOTE-TREE (%%REST CURSOR)))
           EXPANDEDTREE))))))))
   (CL:T (CL:RETURN-FROM EXPAND-BQUOTE-TREE (BQUOTIFY TREE)))))

;;; (DEFUN (SIMPLIFY-BQUOTE-TREE OBJECT) ...)

(CL:DEFUN SIMPLIFY-BQUOTE-TREE (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-LITERALS-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((CURSOR (%%REST TREE)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
       (CL:SETF (%%VALUE CURSOR)
        (SIMPLIFY-BQUOTE-TREE (%%VALUE CURSOR)))
       (CL:SETQ CURSOR (%%REST CURSOR)))
      (CL:WHEN
       (CL:NOT (CL:EQ (%%VALUE TREE) SYM-LITERALS-STELLA-LIST*))
       (CL:RETURN-FROM SIMPLIFY-BQUOTE-TREE TREE))
      (CL:CASE (LENGTH (%%REST TREE))
       (1
        (CL:RETURN-FROM SIMPLIFY-BQUOTE-TREE (%%VALUE (%%REST TREE))))
       (2 (CL:SETF (%%VALUE TREE) SYM-LITERALS-STELLA-CONS)
        (CL:RETURN-FROM SIMPLIFY-BQUOTE-TREE TREE))
       (CL:OTHERWISE (CL:RETURN-FROM SIMPLIFY-BQUOTE-TREE TREE))))))
   (CL:T (CL:RETURN-FROM SIMPLIFY-BQUOTE-TREE TREE))))

;;; (DEFMETHOD (PERMANENTIFY OBJECT) ...)

(%%DEFCONSMETHOD PERMANENTIFY ((SELF OBJECT))
  (CL:RETURN-FROM PERMANENTIFY SELF))

;;; (DEFMETHOD (PERMANENTIFY SYMBOL) ...)

(CL:DEFMETHOD PERMANENTIFY ((SELF SYMBOL))
  (CL:RETURN-FROM PERMANENTIFY SELF))

;;; (DEFMETHOD (PERMANENTIFY SYMBOL) ...)

(CL:DEFMETHOD PERMANENTIFY ((SELF TRANSIENT-SYMBOL))
  (CL:RETURN-FROM PERMANENTIFY
   (INTERN-PERMANENT-SYMBOL (%SYMBOL-NAME SELF))))

;;; (DEFMETHOD (PERMANENTIFY LITERAL-WRAPPER) ...)

(CL:DEFMETHOD PERMANENTIFY ((SELF LITERAL-WRAPPER))
  (CL:RETURN-FROM PERMANENTIFY (COPY-WRAPPED-LITERAL SELF)))

;;; (DEFUN (PERMANENT-COPY OBJECT) ...)

(CL:DEFUN PERMANENT-COPY (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-LITERALS-STELLA-CONS)
    (CL:PROGN
     (CL:IF (CL:EQ TREE NIL) (CL:RETURN-FROM PERMANENT-COPY TREE)
      (CL:RETURN-FROM PERMANENT-COPY
       (CONS (PERMANENT-COPY (%%VALUE TREE))
        (PERMANENT-COPY (%%REST TREE)))))))
   (CL:T (CL:RETURN-FROM PERMANENT-COPY (PERMANENTIFY TREE)))))

;;; (DEFMETHOD (SOFT-PERMANENTIFY SYMBOL) ...)

(CL:DEFMETHOD SOFT-PERMANENTIFY ((SYMBOL SYMBOL))
  (CL:RETURN-FROM SOFT-PERMANENTIFY SYMBOL))

;;; (DEFMETHOD (SOFT-PERMANENTIFY SYMBOL) ...)

(CL:DEFMETHOD SOFT-PERMANENTIFY ((SYMBOL TRANSIENT-SYMBOL))
  (CL:LET*
   ((PERMANENTSYMBOL
     (LOOKUP-RIGID-SYMBOL-WRT-MODULE (%SYMBOL-NAME SYMBOL)
      (CL:IF (CL:NOT (CL:EQ (%HOME-CONTEXT SYMBOL) NULL))
       (%HOME-CONTEXT SYMBOL) *MODULE*)
      SYMBOL-SYM)))
   (CL:IF (CL:NOT (CL:EQ PERMANENTSYMBOL NULL))
    (CL:RETURN-FROM SOFT-PERMANENTIFY PERMANENTSYMBOL)
    (CL:RETURN-FROM SOFT-PERMANENTIFY SYMBOL))))

;;; (DEFUN PRINT-CHARACTER ...)

(CL:DEFUN PRINT-CHARACTER (CHAR STREAM)
  (%%PRINT-STREAM STREAM "#\\")
  (CL:CASE CHAR (#\Linefeed (%%PRINT-STREAM STREAM "Linefeed"))
   (#\Backspace (%%PRINT-STREAM STREAM "Backspace"))
   (#\Tab (%%PRINT-STREAM STREAM "Tab"))
   (#\Return (%%PRINT-STREAM STREAM "Return"))
   (#\Page (%%PRINT-STREAM STREAM "Page"))
   (CL:OTHERWISE (%%PRINT-STREAM STREAM CHAR)))
  :VOID)

;;; (DEFUN (CREATE-CHARACTER-TYPE-TABLE (ARRAY (256) OF KEYWORD)) ...)

(CL:DEFUN CREATE-CHARACTER-TYPE-TABLE ()
  (CL:LET* ((TABLE (CL:MAKE-ARRAY 256)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR TABLE))
   (CL:LET* ((CODE NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 255))
    (CL:DECLARE (CL:TYPE CL:FIXNUM CODE ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ CODE ITER-000)
     (CL:SETF (CL:AREF TABLE CODE) KWD-LITERALS-OTHER)
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((CODE NULL-INTEGER)
     (ITER-001 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\0)))
     (UPPER-BOUND-001 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\9)))
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-001 NULL-INTEGER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM CODE ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-001)) DO
     (CL:SETQ CODE ITER-001)
     (CL:SETF (CL:AREF TABLE CODE) KWD-LITERALS-DIGIT)
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:LET*
    ((CODE NULL-INTEGER)
     (ITER-002 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A)))
     (UPPER-BOUND-002 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Z)))
     (UNBOUNDED?-001 (CL:= UPPER-BOUND-002 NULL-INTEGER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM CODE ITER-002 UPPER-BOUND-002))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-001 (CL:<= ITER-002 UPPER-BOUND-002)) DO
     (CL:SETQ CODE ITER-002)
     (CL:SETF (CL:AREF TABLE CODE) KWD-LITERALS-LETTER)
     (CL:SETQ ITER-002 (CL:1+ ITER-002))))
   (CL:LET*
    ((CODE NULL-INTEGER)
     (ITER-003 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\a)))
     (UPPER-BOUND-003 (CL:THE CL:FIXNUM (CL:CHAR-CODE #\z)))
     (UNBOUNDED?-002 (CL:= UPPER-BOUND-003 NULL-INTEGER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM CODE ITER-003 UPPER-BOUND-003))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-002 (CL:<= ITER-003 UPPER-BOUND-003)) DO
     (CL:SETQ CODE ITER-003)
     (CL:SETF (CL:AREF TABLE CODE) KWD-LITERALS-LETTER)
     (CL:SETQ ITER-003 (CL:1+ ITER-003))))
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\!)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\$)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\%)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\<)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\>)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\=)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\?)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\[)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\])))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\^)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\_)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\{)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\})))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\~)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\*)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\.)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\+)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\-)))
    KWD-LITERALS-SYMBOL-CONSTITUENT)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\:)))
    KWD-LITERALS-SYMBOL-QUALIFIER)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\/)))
    KWD-LITERALS-SYMBOL-QUALIFIER)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\@)))
    KWD-LITERALS-SYMBOL-QUALIFIER)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\\)))
    KWD-LITERALS-ESCAPE)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\()))
    KWD-LITERALS-DELIMITER)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\))))
    KWD-LITERALS-DELIMITER)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\")))
    KWD-LITERALS-DELIMITER)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\|)))
    KWD-LITERALS-DELIMITER)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\')))
    KWD-LITERALS-DELIMITER)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\`)))
    KWD-LITERALS-DELIMITER)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\,)))
    KWD-LITERALS-DELIMITER)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\ )))
    KWD-LITERALS-WHITE-SPACE)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Tab)))
    KWD-LITERALS-WHITE-SPACE)
   (CL:SETF
    (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Linefeed)))
    KWD-LITERALS-WHITE-SPACE)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Return)))
    KWD-LITERALS-WHITE-SPACE)
   (CL:SETF
    (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Linefeed)))
    KWD-LITERALS-WHITE-SPACE)
   (CL:SETF (CL:AREF TABLE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Page)))
    KWD-LITERALS-WHITE-SPACE)
   (CL:RETURN-FROM CREATE-CHARACTER-TYPE-TABLE TABLE)))

;;; (DEFGLOBAL *CHARACTER-TYPE-TABLE* ...)

(CL:DEFVAR *CHARACTER-TYPE-TABLE* STELLA::NULL-1D-ARRAY
  "Table of character types.  Entry 'i' represents the type
of the character whose 'char-code' equals 'i'.  Each character is classified 
by one of the following keywords: :DIGIT, :LETTER, :SYMBOL-CONSTITUENT, 
:SYMBOL-QUALIFIER, :ESCAPE, :DELIMITER, :WHITE-SPACE, or :OTHER.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-VECTOR *CHARACTER-TYPE-TABLE*))

;;; (DEFUN (DIGIT-CHARACTER? BOOLEAN) ...)

(CL:DEFUN DIGIT-CHARACTER? (CH)
  "Return TRUE if `ch' represents a digit."
  (CL:RETURN-FROM DIGIT-CHARACTER?
   (CL:EQ
    (CL:AREF *CHARACTER-TYPE-TABLE*
     (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
    KWD-LITERALS-DIGIT)))

;;; (DEFUN (LETTER-CHARACTER? BOOLEAN) ...)

(CL:DEFUN LETTER-CHARACTER? (CH)
  "Return TRUE if `ch' represents a letter."
  (CL:RETURN-FROM LETTER-CHARACTER?
   (CL:EQ
    (CL:AREF *CHARACTER-TYPE-TABLE*
     (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
    KWD-LITERALS-LETTER)))

;;; (DEFUN (UPPER-CASE-CHARACTER? BOOLEAN) ...)

(CL:DEFUN UPPER-CASE-CHARACTER? (CH)
  "Return TRUE if `ch' represents an upper-case character."
  (CL:LET* ((CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CHARCODE))
   (CL:RETURN-FROM UPPER-CASE-CHARACTER?
    (CL:AND (CL:>= CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A)))
     (CL:<= CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Z)))))))

;;; (DEFUN (LOWER-CASE-CHARACTER? BOOLEAN) ...)

(CL:DEFUN LOWER-CASE-CHARACTER? (CH)
  "Return TRUE if `ch' represents a lower-case character."
  (CL:LET* ((CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CHARCODE))
   (CL:RETURN-FROM LOWER-CASE-CHARACTER?
    (CL:AND (CL:>= CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\a)))
     (CL:<= CHARCODE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\z)))))))

;;; (DEFUN (WHITE-SPACE-CHARACTER? BOOLEAN) ...)

(CL:DEFUN WHITE-SPACE-CHARACTER? (CH)
  "Return TRUE if `ch' is a white space character."
  (CL:RETURN-FROM WHITE-SPACE-CHARACTER?
   (CL:EQ
    (CL:AREF *CHARACTER-TYPE-TABLE*
     (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
    KWD-LITERALS-WHITE-SPACE)))

;;; (DEFUN (ALL-UPPER-CASE-STRING? BOOLEAN) ...)

(CL:DEFUN ALL-UPPER-CASE-STRING? (S)
  "Return TRUE if all letters in `s' are upper case."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
  #+MCL
  (CL:CHECK-TYPE S CL:SIMPLE-STRING)
  (CL:LET*
   ((CODE 0) (CODEA (CL:THE CL:FIXNUM (CL:CHAR-CODE #\a)))
    (CODEZ (CL:THE CL:FIXNUM (CL:CHAR-CODE #\z))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CODE CODEA CODEZ))
   (CL:LET*
    ((CH NULL-CHARACTER) (VECTOR-000 S) (INDEX-000 0)
     (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ CH
      (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))))
     (CL:SETQ CODE (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
     (CL:WHEN (CL:AND (CL:>= CODE CODEA) (CL:<= CODE CODEZ))
      (CL:RETURN-FROM ALL-UPPER-CASE-STRING? CL:NIL))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:RETURN-FROM ALL-UPPER-CASE-STRING? CL:T)))

;;; (DEFUN (ALL-LOWER-CASE-STRING? BOOLEAN) ...)

(CL:DEFUN ALL-LOWER-CASE-STRING? (S)
  "Return TRUE if all letters in `s' are lower case."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
  #+MCL
  (CL:CHECK-TYPE S CL:SIMPLE-STRING)
  (CL:LET*
   ((CODE 0) (CODEA (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A)))
    (CODEZ (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Z))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CODE CODEA CODEZ))
   (CL:LET*
    ((CH NULL-CHARACTER) (VECTOR-000 S) (INDEX-000 0)
     (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ CH
      (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))))
     (CL:SETQ CODE (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
     (CL:WHEN (CL:AND (CL:<= CODE CODEZ) (CL:>= CODE CODEA))
      (CL:RETURN-FROM ALL-LOWER-CASE-STRING? CL:NIL))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:RETURN-FROM ALL-LOWER-CASE-STRING? CL:T)))

;;; (DEFGLOBAL *CHARACTER-UPCASE-TABLE* ...)

(CL:DEFVAR *CHARACTER-UPCASE-TABLE* STELLA::NULL-STRING)
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *CHARACTER-UPCASE-TABLE*))

;;; (DEFUN (INITIALIZE-CHARACTER-UPCASE-TABLE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:SIMPLE-STRING)
  INITIALIZE-CHARACTER-UPCASE-TABLE))
(CL:DEFUN INITIALIZE-CHARACTER-UPCASE-TABLE ()
  (CL:LET*
   ((BUFFER
     (CL:THE CL:SIMPLE-STRING
      (CL:MAKE-STRING 256 :INITIAL-ELEMENT NULL-CHARACTER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BUFFER))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 255))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET ((SELF BUFFER) (CH (CL:CODE-CHAR I)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:WHEN
      (CL:AND (CL:>= I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\a)))
       (CL:<= I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\z))))
      (CL:LET
       ((SELF BUFFER)
        (CH
         (CL:CODE-CHAR
          (CL:THE CL:FIXNUM
           (CL:+ (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A))
            (CL:- I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\a)))))))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (SETF
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:RETURN-FROM INITIALIZE-CHARACTER-UPCASE-TABLE
    (CL:LET ((S BUFFER)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S)))))

;;; (DEFGLOBAL *CHARACTER-DOWNCASE-TABLE* ...)

(CL:DEFVAR *CHARACTER-DOWNCASE-TABLE* STELLA::NULL-STRING)
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *CHARACTER-DOWNCASE-TABLE*))

;;; (DEFUN (INITIALIZE-CHARACTER-DOWNCASE-TABLE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:SIMPLE-STRING)
  INITIALIZE-CHARACTER-DOWNCASE-TABLE))
(CL:DEFUN INITIALIZE-CHARACTER-DOWNCASE-TABLE ()
  (CL:LET*
   ((BUFFER
     (CL:THE CL:SIMPLE-STRING
      (CL:MAKE-STRING 256 :INITIAL-ELEMENT NULL-CHARACTER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BUFFER))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 255))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET ((SELF BUFFER) (CH (CL:CODE-CHAR I)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:WHEN
      (CL:AND (CL:>= I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A)))
       (CL:<= I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\Z))))
      (CL:LET
       ((SELF BUFFER)
        (CH
         (CL:CODE-CHAR
          (CL:THE CL:FIXNUM
           (CL:+ (CL:THE CL:FIXNUM (CL:CHAR-CODE #\a))
            (CL:- I (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A)))))))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (SETF
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:RETURN-FROM INITIALIZE-CHARACTER-DOWNCASE-TABLE
    (CL:LET ((S BUFFER)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S)))))

;;; (DEFUN (UPCASE-CHARACTER CHARACTER) ...)

(CL:DEFUN UPCASE-CHARACTER (CHAR)
  "If `char' is lowercase, return its uppercase version,
otherwise, return 'char' unmodified."
  (CL:RETURN-FROM UPCASE-CHARACTER
   (CL:LET
    ((SELF *CHARACTER-UPCASE-TABLE*)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE CHAR))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
     (CL:THE CL:FIXNUM POSITION)))))

;;; (DEFUN (DOWNCASE-CHARACTER CHARACTER) ...)

(CL:DEFUN DOWNCASE-CHARACTER (CHAR)
  "If `char' is uppercase, return its lowercase version,
otherwise, return 'char' unmodified."
  (CL:RETURN-FROM DOWNCASE-CHARACTER
   (CL:LET
    ((SELF *CHARACTER-DOWNCASE-TABLE*)
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE CHAR))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
     (CL:THE CL:FIXNUM POSITION)))))

;;; (DEFUN PRINT-STRING-READABLY ...)

(CL:DEFUN PRINT-STRING-READABLY (STRING STREAM)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:PRIN1 STRING STREAM)
  :VOID)

;;; (DEFUN (STRING-TO-MUTABLE-STRING MUTABLE-STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  STRING-TO-MUTABLE-STRING))
(CL:DEFUN STRING-TO-MUTABLE-STRING (S)
  "Copy `s' into a mutable string with the same content.
In Lisp and C++ this simply copies `s'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
  #+MCL
  (CL:CHECK-TYPE S CL:SIMPLE-STRING)
  (CL:RETURN-FROM STRING-TO-MUTABLE-STRING (CL:COPY-SEQ S)))

;;; (DEFUN (MUTABLE-STRING-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  MUTABLE-STRING-TO-STRING))
(CL:DEFUN MUTABLE-STRING-TO-STRING (S)
  "Convert `s' into a regular string with the same content.
In Lisp and C++ this is a no-op."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
  #+MCL
  (CL:CHECK-TYPE S CL:SIMPLE-STRING)
  (CL:RETURN-FROM MUTABLE-STRING-TO-STRING S))

;;; (DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ...)

(%%DEFCONSMETHOD NUMBER-WRAPPER-TO-FLOAT ((SELF OBJECT))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SELF
    "' is not a number wrapper")
   (CL:ERROR
    (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ...)

(CL:DEFMETHOD NUMBER-WRAPPER-TO-FLOAT ((SELF INTEGER-WRAPPER))
  (CL:RETURN-FROM NUMBER-WRAPPER-TO-FLOAT
   (CL:FLOAT (%WRAPPER-VALUE SELF) 0.0d0)))

;;; (DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ...)

(CL:DEFMETHOD NUMBER-WRAPPER-TO-FLOAT ((SELF LONG-INTEGER-WRAPPER))
  (CL:RETURN-FROM NUMBER-WRAPPER-TO-FLOAT
   (CL:FLOAT (%WRAPPER-VALUE SELF) 0.0d0)))

;;; (DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ...)

(CL:DEFMETHOD NUMBER-WRAPPER-TO-FLOAT ((SELF FLOAT-WRAPPER))
  (CL:RETURN-FROM NUMBER-WRAPPER-TO-FLOAT (%WRAPPER-VALUE SELF)))

(CL:DEFUN HELP-STARTUP-LITERALS1 ()
  (CL:PROGN
   (CL:SETQ SGT-LITERALS-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ KWD-LITERALS-NULL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-WRAPPER" NULL 2))
   (CL:SETQ SYM-LITERALS-STELLA-FALSE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-INTEGER-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-LONG-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LONG-INTEGER" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-LONG-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-LONG-INTEGER-WRAPPER" NULL
     0))
   (CL:SETQ SGT-LITERALS-STELLA-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-FLOAT-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-FLOAT-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-STRING-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-MUTABLE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-MUTABLE-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-MUTABLE-STRING-WRAPPER" NULL
     0))
   (CL:SETQ SGT-LITERALS-STELLA-CHARACTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-CHARACTER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-CHARACTER-WRAPPER" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-FUNCTION-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-FUNCTION-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-FUNCTION-CODE-WRAPPER" NULL
     0))
   (CL:SETQ SGT-LITERALS-STELLA-METHOD-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL-METHOD-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-METHOD-CODE-WRAPPER" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-TRUE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE-WRAPPER" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-BOOLEAN" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN"
     NULL 0))
   (CL:SETQ KWD-LITERALS-WRAP-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-FUNCTION" NULL 2))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-INTEGER" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-LONG-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-LONG-INTEGER" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-FLOAT" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-STRING" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-CHARACTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-CHARACTER" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-FUNCTION-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-FUNCTION-CODE" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-METHOD-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-METHOD-CODE" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER" NULL 1))
   (CL:SETQ SGT-LITERALS-STELLA-LONG-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LONG-INTEGER-WRAPPER" NULL 1))
   (CL:SETQ SGT-LITERALS-STELLA-FLOAT-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-WRAPPER" NULL 1))
   (CL:SETQ SGT-LITERALS-STELLA-BOOLEAN-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-WRAPPER" NULL 1))
   (CL:SETQ SGT-LITERALS-STELLA-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER" NULL 1))
   (CL:SETQ SGT-LITERALS-STELLA-VERBATIM-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM-STRING-WRAPPER" NULL 1))
   (CL:SETQ SGT-LITERALS-STELLA-CHARACTER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER-WRAPPER" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-NIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-WRAP-LITERAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAP-LITERAL" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-GET-KWD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-KWD" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-TYPED-SYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPED-SYS" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-GET-SGT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SGT" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-INTERN-COMMON-LISP-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERN-COMMON-LISP-SYMBOL" NULL
     0))
   (CL:SETQ SYM-LITERALS-STELLA-GET-SYM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SYM" NULL 0))
   (CL:SETQ SGT-LITERALS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SYM-LITERALS-STELLA-LIST*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST*" NULL 0))
   (CL:SETQ |SYM-LITERALS-STELLA-&|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "&" NULL 0))
   (CL:SETQ |SYM-LITERALS-STELLA-&&|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "&&" NULL 0))
   (CL:SETQ SYM-LITERALS-STELLA-CONCATENATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCATENATE" NULL 0))
   (CL:SETQ KWD-LITERALS-OTHER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHER" NULL 2))
   (CL:SETQ KWD-LITERALS-DIGIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIGIT" NULL 2))
   (CL:SETQ KWD-LITERALS-LETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LETTER" NULL 2))
   (CL:SETQ KWD-LITERALS-SYMBOL-CONSTITUENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-CONSTITUENT" NULL 2))
   (CL:SETQ KWD-LITERALS-SYMBOL-QUALIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-QUALIFIER" NULL 2))
   (CL:SETQ KWD-LITERALS-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPE" NULL 2)))
  :VOID)

(CL:DEFUN HELP-STARTUP-LITERALS2 ()
  (CL:PROGN (CL:SETQ *LITERAL-TYPE-INFO-TABLE* (NEW-HASH-TABLE))
   (CL:SETQ *LITERAL-TYPES* (NEW-LIST))
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-BOOLEAN
    KWD-LITERALS-NULL-WRAPPER SYM-LITERALS-STELLA-FALSE-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-INTEGER
    KWD-LITERALS-NULL-WRAPPER SYM-LITERALS-STELLA-NULL-INTEGER-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-LONG-INTEGER
    KWD-LITERALS-NULL-WRAPPER
    SYM-LITERALS-STELLA-NULL-LONG-INTEGER-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-FLOAT
    KWD-LITERALS-NULL-WRAPPER SYM-LITERALS-STELLA-NULL-FLOAT-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-STRING
    KWD-LITERALS-NULL-WRAPPER SYM-LITERALS-STELLA-NULL-STRING-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-MUTABLE-STRING
    KWD-LITERALS-NULL-WRAPPER
    SYM-LITERALS-STELLA-NULL-MUTABLE-STRING-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-CHARACTER
    KWD-LITERALS-NULL-WRAPPER
    SYM-LITERALS-STELLA-NULL-CHARACTER-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-FUNCTION-CODE
    KWD-LITERALS-NULL-WRAPPER
    SYM-LITERALS-STELLA-NULL-FUNCTION-CODE-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-METHOD-CODE
    KWD-LITERALS-NULL-WRAPPER
    SYM-LITERALS-STELLA-NULL-METHOD-CODE-WRAPPER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-BOOLEAN
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-BOOLEAN)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-INTEGER
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-INTEGER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-LONG-INTEGER
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-LONG-INTEGER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-FLOAT
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-FLOAT)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-STRING
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-STRING)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-CHARACTER
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-CHARACTER)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-FUNCTION-CODE
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-FUNCTION-CODE)
   (SET-LITERAL-TYPE-INFO SGT-LITERALS-STELLA-METHOD-CODE
    KWD-LITERALS-WRAP-FUNCTION SYM-LITERALS-STELLA-WRAP-METHOD-CODE)
   (CL:SETQ *CHARACTER-TYPE-TABLE* (CREATE-CHARACTER-TYPE-TABLE))
   (CL:SETQ *CHARACTER-UPCASE-TABLE*
    (INITIALIZE-CHARACTER-UPCASE-TABLE))
   (CL:SETQ *CHARACTER-DOWNCASE-TABLE*
    (INITIALIZE-CHARACTER-DOWNCASE-TABLE)))
  :VOID)

(CL:DEFUN HELP-STARTUP-LITERALS3 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (TERMINATE-WRAPPER? BOOLEAN) ((SELF WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION TERMINATE-WRAPPER?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (TERMINATE-WRAPPER? BOOLEAN) ((SELF INTEGER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION TERMINATE-WRAPPER?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-LITERAL-TYPE-INFO"
    "(DEFUN (LOOKUP-LITERAL-TYPE-INFO OBJECT) ((TYPE TYPE) (KEY KEYWORD)))"
    (CL:FUNCTION LOOKUP-LITERAL-TYPE-INFO) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-LITERAL-TYPE-INFO"
    "(DEFUN SET-LITERAL-TYPE-INFO ((TYPE TYPE) (KEY KEYWORD) (VALUE OBJECT)))"
    (CL:FUNCTION SET-LITERAL-TYPE-INFO) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-INTEGER"
    "(DEFUN (WRAP-INTEGER INTEGER-WRAPPER) ((VALUE INTEGER)) :DOCUMENTATION \"Return a literal object whose value is the INTEGER 'value'.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION WRAP-INTEGER) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-INTEGER"
    "(DEFUN (UNWRAP-INTEGER INTEGER) ((WRAPPER INTEGER-WRAPPER)) :DOCUMENTATION \"Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNWRAP-INTEGER) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-LONG-INTEGER"
    "(DEFUN (WRAP-LONG-INTEGER LONG-INTEGER-WRAPPER) ((VALUE LONG-INTEGER)) :DOCUMENTATION \"Return a literal object whose value is the LONG-INTEGER 'value'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION WRAP-LONG-INTEGER) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-LONG-INTEGER"
    "(DEFUN (UNWRAP-LONG-INTEGER LONG-INTEGER) ((WRAPPER LONG-INTEGER-WRAPPER)) :DOCUMENTATION \"Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNWRAP-LONG-INTEGER) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-INTEGER-VALUE"
    "(DEFUN (WRAP-INTEGER-VALUE NUMBER-WRAPPER) ((VALUE LONG-INTEGER)) :DOCUMENTATION \"Return a literal object whose value is 'value'.  Choose a regular integer
wrapper unless `value' is too large and needs to be stored in a long wrapper.\" :PUBLIC? TRUE)"
    (CL:FUNCTION WRAP-INTEGER-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-FLOAT"
    "(DEFUN (WRAP-FLOAT FLOAT-WRAPPER) ((VALUE FLOAT)) :DOCUMENTATION \"Return a literal object whose value is the FLOAT 'value'.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION WRAP-FLOAT) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-FLOAT"
    "(DEFUN (UNWRAP-FLOAT FLOAT) ((WRAPPER FLOAT-WRAPPER)) :DOCUMENTATION \"Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNWRAP-FLOAT) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-STRING"
    "(DEFUN (WRAP-STRING STRING-WRAPPER) ((VALUE STRING)) :DOCUMENTATION \"Return a literal object whose value is the STRING 'value'.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION WRAP-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-STRING"
    "(DEFUN (UNWRAP-STRING STRING) ((WRAPPER STRING-WRAPPER)) :DOCUMENTATION \"Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNWRAP-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-MUTABLE-STRING"
    "(DEFUN (WRAP-MUTABLE-STRING MUTABLE-STRING-WRAPPER) ((VALUE MUTABLE-STRING)) :DOCUMENTATION \"Return a literal object whose value is the MUTABLE-STRING 'value'.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION WRAP-MUTABLE-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-MUTABLE-STRING"
    "(DEFUN (UNWRAP-MUTABLE-STRING MUTABLE-STRING) ((WRAPPER MUTABLE-STRING-WRAPPER)) :DOCUMENTATION \"Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNWRAP-MUTABLE-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-CHARACTER"
    "(DEFUN (WRAP-CHARACTER CHARACTER-WRAPPER) ((VALUE CHARACTER)) :DOCUMENTATION \"Return a literal object whose value is the CHARACTER 'value'.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION WRAP-CHARACTER) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-CHARACTER"
    "(DEFUN (UNWRAP-CHARACTER CHARACTER) ((WRAPPER CHARACTER-WRAPPER)) :DOCUMENTATION \"Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNWRAP-CHARACTER) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-FUNCTION-CODE"
    "(DEFUN (WRAP-FUNCTION-CODE FUNCTION-CODE-WRAPPER) ((VALUE FUNCTION-CODE)) :DOCUMENTATION \"Return a literal object whose value is the FUNCTION-CODE 'value'.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION WRAP-FUNCTION-CODE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-FUNCTION-CODE"
    "(DEFUN (UNWRAP-FUNCTION-CODE FUNCTION-CODE) ((WRAPPER FUNCTION-CODE-WRAPPER)) :DOCUMENTATION \"Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNWRAP-FUNCTION-CODE) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-METHOD-CODE"
    "(DEFUN (WRAP-METHOD-CODE METHOD-CODE-WRAPPER) ((VALUE METHOD-CODE)) :DOCUMENTATION \"Return a literal object whose value is the METHOD-CODE 'value'.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION WRAP-METHOD-CODE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-METHOD-CODE"
    "(DEFUN (UNWRAP-METHOD-CODE METHOD-CODE) ((WRAPPER METHOD-CODE-WRAPPER)) :DOCUMENTATION \"Unwrap `wrapper' and return the result.
Return NULL if `wrapper' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNWRAP-METHOD-CODE) NULL)
   (DEFINE-FUNCTION-OBJECT "WRAP-BOOLEAN"
    "(DEFUN (WRAP-BOOLEAN BOOLEAN-WRAPPER) ((VALUE BOOLEAN)) :DOCUMENTATION \"Return a literal object whose value is the BOOLEAN 'value'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :CONSTRUCTOR? TRUE (RETURN (CHOOSE VALUE TRUE-WRAPPER FALSE-WRAPPER)))"
    (CL:FUNCTION WRAP-BOOLEAN) NULL)
   (DEFINE-FUNCTION-OBJECT "UNWRAP-BOOLEAN"
    "(DEFUN (UNWRAP-BOOLEAN BOOLEAN) ((WRAPPER BOOLEAN-WRAPPER)) :DOCUMENTATION \"Unwrap `wrapper' and return its values as a regular BOOLEAN.
Map NULL onto FALSE.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQ? WRAPPER TRUE-WRAPPER)))"
    (CL:FUNCTION UNWRAP-BOOLEAN) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN"
    "(DEFUN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN BOOLEAN) ((WRAPPER BOOLEAN-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN) NULL)
   (DEFINE-FUNCTION-OBJECT "INLINE-WRAP-BOOLEAN"
    "(DEFUN INLINE-WRAP-BOOLEAN ((EXPRESSION OBJECT)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION INLINE-WRAP-BOOLEAN) NULL)
   (DEFINE-FUNCTION-OBJECT "INLINE-UNWRAP-BOOLEAN"
    "(DEFUN INLINE-UNWRAP-BOOLEAN ((EXPRESSION OBJECT)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION INLINE-UNWRAP-BOOLEAN) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL INTEGER-WRAPPER) ((VALUE INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-INTEGER VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL LONG-INTEGER-WRAPPER) ((VALUE LONG-INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-LONG-INTEGER VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL FLOAT-WRAPPER) ((VALUE FLOAT)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-FLOAT VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL MUTABLE-STRING-WRAPPER) ((VALUE MUTABLE-STRING)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-MUTABLE-STRING VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL STRING-WRAPPER) ((VALUE STRING)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-STRING VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL CHARACTER-WRAPPER) ((VALUE CHARACTER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-CHARACTER VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL FUNCTION-CODE-WRAPPER) ((VALUE FUNCTION-CODE)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-FUNCTION-CODE VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (WRAP-LITERAL METHOD-CODE-WRAPPER) ((VALUE METHOD-CODE)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (WRAP-METHOD-CODE VALUE)))"
    (CL:FUNCTION WRAP-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF STANDARD-OBJECT)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF LITERAL-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF INTEGER-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF LONG-INTEGER-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF FLOAT-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF STRING-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF MUTABLE-STRING-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF CHARACTER-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF FUNCTION-CODE-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY-WRAPPED-LITERAL OBJECT) ((SELF METHOD-CODE-WRAPPER)))"
    (CL:FUNCTION COPY-WRAPPED-LITERAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X OBJECT) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X STANDARD-OBJECT) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X INTEGER-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X LONG-INTEGER-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X FLOAT-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X BOOLEAN-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X STRING-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X MUTABLE-STRING-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (OBJECT-EQL? BOOLEAN) ((X CHARACTER-WRAPPER) (Y OBJECT)))"
    (CL:FUNCTION OBJECT-EQL?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL-TO-BOOLEAN?"
    "(DEFUN (EQL-TO-BOOLEAN? BOOLEAN) ((Y OBJECT) (X BOOLEAN)))"
    (CL:FUNCTION EQL-TO-BOOLEAN?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL-TO-INTEGER?"
    "(DEFUN (EQL-TO-INTEGER? BOOLEAN) ((Y OBJECT) (X INTEGER)))"
    (CL:FUNCTION EQL-TO-INTEGER?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL-TO-LONG-INTEGER?"
    "(DEFUN (EQL-TO-LONG-INTEGER? BOOLEAN) ((Y OBJECT) (X LONG-INTEGER)))"
    (CL:FUNCTION EQL-TO-LONG-INTEGER?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL-TO-FLOAT?"
    "(DEFUN (EQL-TO-FLOAT? BOOLEAN) ((Y OBJECT) (X FLOAT)))"
    (CL:FUNCTION EQL-TO-FLOAT?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL-TO-STRING?"
    "(DEFUN (EQL-TO-STRING? BOOLEAN) ((Y OBJECT) (X STRING)))"
    (CL:FUNCTION EQL-TO-STRING?) NULL)
   (DEFINE-FUNCTION-OBJECT "EQL-TO-CHARACTER?"
    "(DEFUN (EQL-TO-CHARACTER? BOOLEAN) ((Y OBJECT) (X CHARACTER)))"
    (CL:FUNCTION EQL-TO-CHARACTER?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-BQUOTIFY"
    "(DEFUN (HELP-BQUOTIFY OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION HELP-BQUOTIFY) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-LITERALS4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "BQUOTIFY"
    "(DEFUN (BQUOTIFY OBJECT) ((TREE OBJECT)))" (CL:FUNCTION BQUOTIFY)
    NULL)
   (DEFINE-FUNCTION-OBJECT "EXPAND-BQUOTE-TREE"
    "(DEFUN (EXPAND-BQUOTE-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION EXPAND-BQUOTE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "SIMPLIFY-BQUOTE-TREE"
    "(DEFUN (SIMPLIFY-BQUOTE-TREE OBJECT) ((TREE OBJECT)))"
    (CL:FUNCTION SIMPLIFY-BQUOTE-TREE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PERMANENTIFY OBJECT) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION PERMANENTIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PERMANENTIFY SYMBOL) ((SELF SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION PERMANENTIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PERMANENTIFY SYMBOL) ((SELF TRANSIENT-SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION PERMANENTIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PERMANENTIFY LITERAL-WRAPPER) ((SELF LITERAL-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION PERMANENTIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "PERMANENT-COPY"
    "(DEFUN (PERMANENT-COPY OBJECT) ((TREE OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION PERMANENT-COPY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SOFT-PERMANENTIFY SYMBOL) ((SYMBOL SYMBOL)))"
    (CL:FUNCTION SOFT-PERMANENTIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SOFT-PERMANENTIFY SYMBOL) ((SYMBOL TRANSIENT-SYMBOL)))"
    (CL:FUNCTION SOFT-PERMANENTIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-CHARACTER"
    "(DEFUN PRINT-CHARACTER ((CHAR CHARACTER) (STREAM NATIVE-OUTPUT-STREAM)) :PUBLIC? TRUE)"
    (CL:FUNCTION PRINT-CHARACTER) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-CHARACTER-TYPE-TABLE"
    "(DEFUN (CREATE-CHARACTER-TYPE-TABLE (ARRAY (256) OF KEYWORD)) ())"
    (CL:FUNCTION CREATE-CHARACTER-TYPE-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "DIGIT-CHARACTER?"
    "(DEFUN (DIGIT-CHARACTER? BOOLEAN) ((CH CHARACTER)) :DOCUMENTATION \"Return TRUE if `ch' represents a digit.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? (AREF *CHARACTER-TYPE-TABLE* (CHARACTER-CODE CH)) :DIGIT)))"
    (CL:FUNCTION DIGIT-CHARACTER?) NULL)
   (DEFINE-FUNCTION-OBJECT "LETTER-CHARACTER?"
    "(DEFUN (LETTER-CHARACTER? BOOLEAN) ((CH CHARACTER)) :DOCUMENTATION \"Return TRUE if `ch' represents a letter.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? (AREF *CHARACTER-TYPE-TABLE* (CHARACTER-CODE CH)) :LETTER)))"
    (CL:FUNCTION LETTER-CHARACTER?) NULL)
   (DEFINE-FUNCTION-OBJECT "UPPER-CASE-CHARACTER?"
    "(DEFUN (UPPER-CASE-CHARACTER? BOOLEAN) ((CH CHARACTER)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if `ch' represents an upper-case character.\")"
    (CL:FUNCTION UPPER-CASE-CHARACTER?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOWER-CASE-CHARACTER?"
    "(DEFUN (LOWER-CASE-CHARACTER? BOOLEAN) ((CH CHARACTER)) :PUBLIC? TRUE :DOCUMENTATION \"Return TRUE if `ch' represents a lower-case character.\")"
    (CL:FUNCTION LOWER-CASE-CHARACTER?) NULL)
   (DEFINE-FUNCTION-OBJECT "WHITE-SPACE-CHARACTER?"
    "(DEFUN (WHITE-SPACE-CHARACTER? BOOLEAN) ((CH CHARACTER)) :DOCUMENTATION \"Return TRUE if `ch' is a white space character.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (EQL? (AREF *CHARACTER-TYPE-TABLE* (CHARACTER-CODE CH)) :WHITE-SPACE)))"
    (CL:FUNCTION WHITE-SPACE-CHARACTER?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-UPPER-CASE-STRING?"
    "(DEFUN (ALL-UPPER-CASE-STRING? BOOLEAN) ((S STRING)) :DOCUMENTATION \"Return TRUE if all letters in `s' are upper case.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-UPPER-CASE-STRING?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-LOWER-CASE-STRING?"
    "(DEFUN (ALL-LOWER-CASE-STRING? BOOLEAN) ((S STRING)) :DOCUMENTATION \"Return TRUE if all letters in `s' are lower case.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-LOWER-CASE-STRING?) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-CHARACTER-UPCASE-TABLE"
    "(DEFUN (INITIALIZE-CHARACTER-UPCASE-TABLE STRING) ())"
    (CL:FUNCTION INITIALIZE-CHARACTER-UPCASE-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-CHARACTER-DOWNCASE-TABLE"
    "(DEFUN (INITIALIZE-CHARACTER-DOWNCASE-TABLE STRING) ())"
    (CL:FUNCTION INITIALIZE-CHARACTER-DOWNCASE-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCASE-CHARACTER"
    "(DEFUN (UPCASE-CHARACTER CHARACTER) ((CHAR CHARACTER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"If `char' is lowercase, return its uppercase version,
otherwise, return 'char' unmodified.\" (RETURN (NTH *CHARACTER-UPCASE-TABLE* (CHARACTER-CODE CHAR))))"
    (CL:FUNCTION UPCASE-CHARACTER) NULL)
   (DEFINE-FUNCTION-OBJECT "DOWNCASE-CHARACTER"
    "(DEFUN (DOWNCASE-CHARACTER CHARACTER) ((CHAR CHARACTER)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"If `char' is uppercase, return its lowercase version,
otherwise, return 'char' unmodified.\" (RETURN (NTH *CHARACTER-DOWNCASE-TABLE* (CHARACTER-CODE CHAR))))"
    (CL:FUNCTION DOWNCASE-CHARACTER) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-STRING-READABLY"
    "(DEFUN PRINT-STRING-READABLY ((STRING STRING) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-STRING-READABLY) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-MUTABLE-STRING"
    "(DEFUN (STRING-TO-MUTABLE-STRING MUTABLE-STRING) ((S STRING)) :DOCUMENTATION \"Copy `s' into a mutable string with the same content.
In Lisp and C++ this simply copies `s'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:COPY-SEQ S) :CPP \"strcpy(new (GC) char[strlen(s)+1], s)\" :JAVA \"new StringBuffer(s)\")))"
    (CL:FUNCTION STRING-TO-MUTABLE-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "MUTABLE-STRING-TO-STRING"
    "(DEFUN (MUTABLE-STRING-TO-STRING STRING) ((S MUTABLE-STRING)) :DOCUMENTATION \"Convert `s' into a regular string with the same content.
In Lisp and C++ this is a no-op.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VERBATIM :COMMON-LISP S :CPP \"s\" :JAVA \"s.toString()\")))"
    (CL:FUNCTION MUTABLE-STRING-TO-STRING) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION NUMBER-WRAPPER-TO-FLOAT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ((SELF INTEGER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION NUMBER-WRAPPER-TO-FLOAT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ((SELF LONG-INTEGER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION NUMBER-WRAPPER-TO-FLOAT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NUMBER-WRAPPER-TO-FLOAT FLOAT) ((SELF FLOAT-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION NUMBER-WRAPPER-TO-FLOAT) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-LITERALS"
    "(DEFUN STARTUP-LITERALS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-LITERALS) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-LITERALS-STELLA-STARTUP-LITERALS)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
     SYM-LITERALS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupLiterals") NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFUN STARTUP-LITERALS ()
  (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 0)
   (CL:SETQ ZERO-WRAPPER (NEW-INTEGER-WRAPPER 0))
   (CL:SETQ ONE-WRAPPER (NEW-INTEGER-WRAPPER 1))
   (CL:SETQ FALSE-WRAPPER (NEW-BOOLEAN-WRAPPER CL:NIL))
   (CL:SETQ TRUE-WRAPPER (NEW-BOOLEAN-WRAPPER CL:T))
   (CL:SETQ NULL-INTEGER-WRAPPER (NEW-INTEGER-WRAPPER NULL-INTEGER))
   (CL:SETQ NULL-LONG-INTEGER-WRAPPER
    (NEW-LONG-INTEGER-WRAPPER NULL-LONG-INTEGER))
   (CL:SETQ NULL-FLOAT-WRAPPER (NEW-FLOAT-WRAPPER NULL-FLOAT))
   (CL:SETQ NULL-STRING-WRAPPER
    (NEW-STRING-WRAPPER STELLA::NULL-STRING))
   (CL:SETQ NULL-MUTABLE-STRING-WRAPPER
    (NEW-MUTABLE-STRING-WRAPPER STELLA::NULL-STRING))
   (CL:SETQ NULL-CHARACTER-WRAPPER
    (NEW-CHARACTER-WRAPPER NULL-CHARACTER))
   (CL:SETQ NULL-FUNCTION-CODE-WRAPPER
    (NEW-FUNCTION-CODE-WRAPPER NULL))
   (CL:SETQ NULL-METHOD-CODE-WRAPPER (NEW-METHOD-CODE-WRAPPER NULL)))
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-LITERALS1)
    (CL:SETQ KWD-LITERALS-DELIMITER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DELIMITER" NULL 2))
    (CL:SETQ KWD-LITERALS-WHITE-SPACE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WHITE-SPACE" NULL 2))
    (CL:SETQ SYM-LITERALS-STELLA-STARTUP-LITERALS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-LITERALS" NULL 0))
    (CL:SETQ SYM-LITERALS-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL
      0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-LITERALS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-LITERALS3)
    (HELP-STARTUP-LITERALS4))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL ZERO-WRAPPER INTEGER-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL ONE-WRAPPER INTEGER-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL TRUE-WRAPPER BOOLEAN-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL FALSE-WRAPPER BOOLEAN-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-INTEGER-WRAPPER INTEGER-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-LONG-INTEGER-WRAPPER LONG-INTEGER-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-FLOAT-WRAPPER FLOAT-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-STRING-WRAPPER STRING-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-MUTABLE-STRING-WRAPPER MUTABLE-STRING-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-CHARACTER-WRAPPER CHARACTER-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-FUNCTION-CODE-WRAPPER FUNCTION-CODE-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL NULL-METHOD-CODE-WRAPPER METHOD-CODE-WRAPPER NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LITERAL-TYPE-INFO-TABLE* (HASH-TABLE OF TYPE (KEY-VALUE-LIST OF KEYWORD OBJECT)) (NEW HASH-TABLE) :DOCUMENTATION \"Table that holds a variety of information about literal
types, e.g., the name of their null-wrapper, wrap-function, etc.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LITERAL-TYPES* (LIST OF TYPE) (NEW LIST) :DOCUMENTATION \"List of literal types stored in '*literal-type-info-table*'.
Maintained for iteration purposes.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CHARACTER-TYPE-TABLE* (ARRAY (256) OF KEYWORD) (CREATE-CHARACTER-TYPE-TABLE) :DOCUMENTATION \"Table of character types.  Entry 'i' represents the type
of the character whose 'char-code' equals 'i'.  Each character is classified 
by one of the following keywords: :DIGIT, :LETTER, :SYMBOL-CONSTITUENT, 
:SYMBOL-QUALIFIER, :ESCAPE, :DELIMITER, :WHITE-SPACE, or :OTHER.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CHARACTER-UPCASE-TABLE* STRING (INITIALIZE-CHARACTER-UPCASE-TABLE))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CHARACTER-DOWNCASE-TABLE* STRING (INITIALIZE-CHARACTER-DOWNCASE-TABLE))")))
  :VOID)
