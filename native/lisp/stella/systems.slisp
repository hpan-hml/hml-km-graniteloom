;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; systems.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2010      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-SYSTEMS-STELLA-SET-LOAD-PATH NULL)
(CL:DEFVAR KWD-SYSTEMS-COMMON-LISP NULL)
(CL:DEFVAR KWD-SYSTEMS-FUNCTION NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-PUSH-LOAD-PATH NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-ADD-LOAD-PATH NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DROP-LOAD-PATH NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-TRUE NULL)
(CL:DEFVAR KWD-SYSTEMS-TRUE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-FALSE NULL)
(CL:DEFVAR KWD-SYSTEMS-FALSE NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-UNKNOWN NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-INTEGER NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-FLOAT NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-NUMBER NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-STRING NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-KEYWORD NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-SYMBOL NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-BOOLEAN NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-MODULE NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-PROPERTY-LIST NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-CONS NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-LIST NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-IDENTITY NULL)
(CL:DEFVAR KWD-SYSTEMS-DEFINE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-IN-MODULE NULL)
(CL:DEFVAR KWD-SYSTEMS-FINALIZE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFMODULE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFSYSTEM NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFCLASS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFSLOT NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFUN NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFMETHOD NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-LOAD-FILE NULL)
(CL:DEFVAR KWD-SYSTEMS-DIRECTORY NULL)
(CL:DEFVAR KWD-SYSTEMS-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-REQUIRED-SYSTEMS NULL)
(CL:DEFVAR KWD-SYSTEMS-LOAD-SYSTEM NULL)
(CL:DEFVAR KWD-SYSTEMS-ACTION NULL)
(CL:DEFVAR KWD-SYSTEMS-LANGUAGE NULL)
(CL:DEFVAR KWD-SYSTEMS-MAKE-SYSTEM NULL)
(CL:DEFVAR KWD-SYSTEMS-LISP-ONLY-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-CPP-ONLY-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-JAVA-ONLY-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-DATA-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-PREPROCESSED-FILES NULL)
(CL:DEFVAR KWD-SYSTEMS-CARDINAL-MODULE NULL)
(CL:DEFVAR KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY NULL)
(CL:DEFVAR KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY NULL)
(CL:DEFVAR KWD-SYSTEMS-ROOT-BINARY-DIRECTORY NULL)
(CL:DEFVAR KWD-SYSTEMS-BANNER NULL)
(CL:DEFVAR KWD-SYSTEMS-COPYRIGHT-HEADER NULL)
(CL:DEFVAR KWD-SYSTEMS-PRODUCTION-SETTINGS NULL)
(CL:DEFVAR KWD-SYSTEMS-DEVELOPMENT-SETTINGS NULL)
(CL:DEFVAR KWD-SYSTEMS-FINALIZATION-FUNCTION NULL)
(CL:DEFVAR KWD-SYSTEMS-JAVA NULL)
(CL:DEFVAR KWD-SYSTEMS-LISP NULL)
(CL:DEFVAR KWD-SYSTEMS-CPP NULL)
(CL:DEFVAR KWD-SYSTEMS-LISP-BINARY NULL)
(CL:DEFVAR KWD-SYSTEMS-DEVELOPMENT-SETTINGS? NULL)
(CL:DEFVAR KWD-SYSTEMS-PRODUCTION-SETTINGS? NULL)
(CL:DEFVAR KWD-SYSTEMS-FORCE-TRANSLATION? NULL)
(CL:DEFVAR KWD-SYSTEMS-FORCE-RECOMPILATION? NULL)
(CL:DEFVAR KWD-SYSTEMS-TWO-PASS? NULL)
(CL:DEFVAR KWD-SYSTEMS-LOAD-SYSTEM? NULL)
(CL:DEFVAR KWD-SYSTEMS-STARTUP? NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-MAKE-SYSTEM NULL)
(CL:DEFVAR KWD-SYSTEMS-USE-COMMON-LISP-STRUCTS NULL)
(CL:DEFVAR KWD-SYSTEMS-STELLA NULL)
(CL:DEFVAR KWD-SYSTEMS-WARN-ABOUT-UNDEFINED-METHODS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-LOAD-SYSTEM NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-UNLESS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-SYSTEM-STARTED-UP? NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN NULL)
(CL:DEFVAR KWD-SYSTEMS-EARLY-INITS NULL)
(CL:DEFVAR KWD-SYSTEMS-MODULES NULL)
(CL:DEFVAR KWD-SYSTEMS-PUBLIC? NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-STARTUP NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-FOREACH NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-PHASE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-IN NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-INTERVAL NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-PHASE-TO-INTEGER NULL)
(CL:DEFVAR KWD-SYSTEMS-FINAL NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DO NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-SETQ NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-*STARTUP-TIME-PHASE* NULL)
(CL:DEFVAR KWD-SYSTEMS-SET NULL)
(CL:DEFVAR KWD-SYSTEMS-WHITE-SPACE NULL)
(CL:DEFVAR KWD-SYSTEMS-ADD NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-CONFIGURATION-TABLE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-LOAD-CONFIGURATION-FILE NULL)
(CL:DEFVAR KWD-SYSTEMS-ROOT-DIRECTORY NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-GET-PROPERTY NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-SET-PROPERTY NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-ADD-PROPERTY-VALUE NULL)
(CL:DEFVAR KWD-SYSTEMS-ERROR NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-CMD-LINE-OPTION NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-KEYS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-VALUE-TYPE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-MULTI-VALUED? NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-N-ARGUMENTS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFAULT-VALUE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-CONFIGURATION-PROPERTY NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-ERROR-ACTION NULL)
(CL:DEFVAR KWD-SYSTEMS-DOCUMENTATION NULL)
(CL:DEFVAR KWD-SYSTEMS-KEY NULL)
(CL:DEFVAR KWD-SYSTEMS-KEY2 NULL)
(CL:DEFVAR KWD-SYSTEMS-KEY3 NULL)
(CL:DEFVAR KWD-SYSTEMS-KEYS NULL)
(CL:DEFVAR KWD-SYSTEMS-VALUE-TYPE NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-TYPE NULL)
(CL:DEFVAR KWD-SYSTEMS-MULTI-VALUED? NULL)
(CL:DEFVAR KWD-SYSTEMS-N-ARGUMENTS NULL)
(CL:DEFVAR KWD-SYSTEMS-DEFAULT-VALUE NULL)
(CL:DEFVAR SGT-SYSTEMS-STELLA-OBJECT NULL)
(CL:DEFVAR KWD-SYSTEMS-PROPERTY NULL)
(CL:DEFVAR KWD-SYSTEMS-HANDLER NULL)
(CL:DEFVAR KWD-SYSTEMS-ERROR-ACTION NULL)
(CL:DEFVAR KWD-SYSTEMS-WARN NULL)
(CL:DEFVAR KWD-SYSTEMS-IGNORE NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-EVAL-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-EVAL-IN-MODULE-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-LOAD-PATH-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-CONFIG-FILE-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-LOAD-FILE-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-DEFINE-PROPERTY-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-HELP-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-STARTUP-SYSTEMS NULL)
(CL:DEFVAR SYM-SYSTEMS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL NULL-STRING-WRAPPER *CHARACTER-TYPE-TABLE* *STELLA-MODULE*
  *FUNCTION-LOOKUP-TABLE* *CURRENT-STELLA-FEATURES*
  *TRANSLATOROUTPUTLANGUAGE* NIL-LIST STANDARD-ERROR
  *CURRENT-SYSTEM-ACTION* *CURRENTFILE* *MODULE* *TRANSLATIONUNITS*
  *EVALUATIONTREE* *EVALUATIONPARENTTREE* *TRANSLATIONPHASE*
  *CURRENTSYSTEMDEFINITION* STANDARD-OUTPUT EOL MOST-POSITIVE-INTEGER
  NULL-FLOAT TRUE-WRAPPER FALSE-WRAPPER NIL NULL-INTEGER))

;;; (DEFGLOBAL *FILE-LOAD-PATH* ...)

(CL:DEFVAR *FILE-LOAD-PATH* NULL)

;;; (DEFUN (PARSE-DIRECTORY-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN PARSE-DIRECTORY-PATH (PATH)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATH))
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  (CL:LET*
   ((SEPARATOR #\|) (LENGTH (CL:THE CL:FIXNUM (CL:LENGTH PATH)))
    (START 0) (END 0) (PARSEDPATH NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH START END))
   (CL:LOOP (CL:SETQ END (POSITION PATH SEPARATOR START))
    (CL:SETQ PARSEDPATH
     (CONS
      (WRAP-STRING
       (FILE-NAME-AS-DIRECTORY (SUBSEQUENCE PATH START END)))
      PARSEDPATH))
    (CL:IF
     (CL:AND (CL:NOT (CL:= END NULL-INTEGER))
      (CL:< END (CL:1- LENGTH)))
     (CL:SETQ START (CL:1+ END)) (CL:RETURN)))
   (CL:RETURN-FROM PARSE-DIRECTORY-PATH (REVERSE PARSEDPATH))))

;;; (DEFUN (SET-LOAD-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN %SET-LOAD-PATH (PATH)
  "Set the STELLA load path to the |-separated
directories listed in `path'.  Return the resulting load path."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATH))
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  (CL:SETQ *FILE-LOAD-PATH* (PARSE-DIRECTORY-PATH PATH))
  (CL:RETURN-FROM %SET-LOAD-PATH *FILE-LOAD-PATH*))

(CL:DEFUN SET-LOAD-PATH-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM SET-LOAD-PATH-EVALUATOR-WRAPPER
   (%SET-LOAD-PATH (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))

(CL:DEFMACRO SET-LOAD-PATH (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set the STELLA load path to the |-separated
directories listed in `path'.  Return the resulting load path."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/SET-LOAD-PATH|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-LOAD-PATH)))

;;; (DEFUN (GET-LOAD-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN GET-LOAD-PATH ()
  "Return the current STELLA load path."
  (CL:RETURN-FROM GET-LOAD-PATH *FILE-LOAD-PATH*))

;;; (DEFUN (PUSH-LOAD-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN %PUSH-LOAD-PATH (PATH)
  "Add the directories listed in the |-separated
`path' to the front of the STELLA load path.  Return the
resulting load path."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATH))
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  (CL:SETQ *FILE-LOAD-PATH*
   (CONCATENATE (PARSE-DIRECTORY-PATH PATH) *FILE-LOAD-PATH*))
  (CL:RETURN-FROM %PUSH-LOAD-PATH *FILE-LOAD-PATH*))

(CL:DEFUN PUSH-LOAD-PATH-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM PUSH-LOAD-PATH-EVALUATOR-WRAPPER
   (%PUSH-LOAD-PATH
    (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))

(CL:DEFMACRO PUSH-LOAD-PATH (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Add the directories listed in the |-separated
`path' to the front of the STELLA load path.  Return the
resulting load path."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/PUSH-LOAD-PATH|)) (CL:MACRO-FUNCTION (CL:QUOTE PUSH-LOAD-PATH)))

;;; (DEFUN (POP-LOAD-PATH STRING) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION () CL:SIMPLE-STRING) POP-LOAD-PATH))
(CL:DEFUN POP-LOAD-PATH ()
  "Remove the first element from the STELLA load path
and return the removed element."
  (CL:LET* ((HEAD-000 (%%VALUE *FILE-LOAD-PATH*)))
   (CL:SETQ *FILE-LOAD-PATH* (%%REST *FILE-LOAD-PATH*))
   (CL:LET* ((VALUE-000 HEAD-000))
    (CL:RETURN-FROM POP-LOAD-PATH
     (%STRING-WRAPPER.WRAPPER-VALUE VALUE-000)))))

(CL:DEFUN POP-LOAD-PATH-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:SETQ ARGUMENTS ARGUMENTS)
  (CL:LET* ((RESULT (POP-LOAD-PATH)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:IF (CL:NOT (CL:EQ RESULT STELLA::NULL-STRING))
    (CL:RETURN-FROM POP-LOAD-PATH-EVALUATOR-WRAPPER
     (WRAP-STRING RESULT))
    (CL:RETURN-FROM POP-LOAD-PATH-EVALUATOR-WRAPPER NULL))))

;;; (DEFUN (ADD-LOAD-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN %ADD-LOAD-PATH (PATH)
  "Append the directories listed in the |-separated
`path' to the end of the STELLA load path.  Return the resulting
load path."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATH))
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  (CL:SETQ *FILE-LOAD-PATH*
   (CONCATENATE *FILE-LOAD-PATH* (PARSE-DIRECTORY-PATH PATH)))
  (CL:RETURN-FROM %ADD-LOAD-PATH *FILE-LOAD-PATH*))

(CL:DEFUN ADD-LOAD-PATH-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM ADD-LOAD-PATH-EVALUATOR-WRAPPER
   (%ADD-LOAD-PATH (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))

(CL:DEFMACRO ADD-LOAD-PATH (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Append the directories listed in the |-separated
`path' to the end of the STELLA load path.  Return the resulting
load path."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/ADD-LOAD-PATH|)) (CL:MACRO-FUNCTION (CL:QUOTE ADD-LOAD-PATH)))

;;; (DEFUN (DROP-LOAD-PATH (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN %DROP-LOAD-PATH (PATH)
  "Remove the directories listed in the |-separated
`path' from the PowerLoom load path."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATH))
  #+MCL
  (CL:CHECK-TYPE PATH CL:SIMPLE-STRING)
  (CL:LET* ((DIR NULL) (ITER-000 (PARSE-DIRECTORY-PATH PATH)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ DIR (%%VALUE ITER-000))
    (CL:SETQ *FILE-LOAD-PATH* (REMOVE *FILE-LOAD-PATH* DIR))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM %DROP-LOAD-PATH *FILE-LOAD-PATH*))

(CL:DEFUN DROP-LOAD-PATH-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM DROP-LOAD-PATH-EVALUATOR-WRAPPER
   (%DROP-LOAD-PATH
    (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))

(CL:DEFMACRO DROP-LOAD-PATH (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Remove the directories listed in the |-separated
`path' from the PowerLoom load path."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/DROP-LOAD-PATH|)) (CL:MACRO-FUNCTION (CL:QUOTE DROP-LOAD-PATH)))

;;; (DEFGLOBAL *STELLA-FILE-EXTENSIONS* ...)

(CL:DEFVAR *STELLA-FILE-EXTENSIONS* NULL
  "File extensions to append by default when a
file is looked up by `find-file-in-load-path'.")

;;; (DEFUN (FIND-FILE-IN-LOAD-PATH STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING CL:T) CL:SIMPLE-STRING)
  FIND-FILE-IN-LOAD-PATH))
(CL:DEFUN FIND-FILE-IN-LOAD-PATH (FILE EXTENSIONS)
  "Try to find `file' in the current load path and, if found,
return its full name.  If `file' can't be found literally, try to find it
with any of the listed `extensions' added.  If `extensions' is NULL it defaults
to `*stella-file-extensions*', therefore, to not default to any extensions
the value has to be supplied as NIL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  #+MCL
  (CL:CHECK-TYPE FILE CL:SIMPLE-STRING)
  (CL:LET* ((EXPANDEDFILE FILE))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING EXPANDEDFILE))
   (CL:WHEN (CL:EQ EXTENSIONS NULL)
    (CL:SETQ EXTENSIONS *STELLA-FILE-EXTENSIONS*))
   (CL:LET*
    ((DIR NULL) (ITER-000 (CONS (WRAP-STRING "") *FILE-LOAD-PATH*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DIR (%%VALUE ITER-000))
     (CL:HANDLER-CASE
      (CL:PROGN
       (CL:SETQ EXPANDEDFILE (CONCATENATE (UNWRAP-STRING DIR) FILE))
       (CL:WHEN (PROBE-FILE? EXPANDEDFILE)
        (CL:RETURN-FROM FIND-FILE-IN-LOAD-PATH EXPANDEDFILE))
       (CL:LET* ((EXT NULL) (ITER-001 EXTENSIONS))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ EXT (%%VALUE ITER-001))
         (CL:SETQ EXPANDEDFILE
          (CONCATENATE (UNWRAP-STRING DIR) FILE
           (%STRING-WRAPPER.WRAPPER-VALUE EXT)))
         (CL:WHEN (PROBE-FILE? EXPANDEDFILE)
          (CL:RETURN-FROM FIND-FILE-IN-LOAD-PATH EXPANDEDFILE))
         (CL:SETQ ITER-001 (%%REST ITER-001)))))
      (CL:CONDITION (E) (CL:SETQ E E)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM FIND-FILE-IN-LOAD-PATH STELLA::NULL-STRING)))

;;; (DEFUN (COERCE-VALUE-TO-BOOLEAN BOOLEAN-WRAPPER) ...)

(CL:DEFUN COERCE-VALUE-TO-BOOLEAN (VALUE ERROR?)
  "Return the boolean object represented by `value'.  Return NULL
if coercion is not possible or raise an error if `error?' is TRUE."
  (CL:COND
   ((CL:OR (CL:EQ VALUE SYM-SYSTEMS-STELLA-TRUE)
     (CL:EQ VALUE KWD-SYSTEMS-TRUE))
    (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN TRUE-WRAPPER))
   ((CL:OR (CL:EQ VALUE SYM-SYSTEMS-STELLA-FALSE)
     (CL:EQ VALUE KWD-SYSTEMS-FALSE))
    (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN FALSE-WRAPPER)))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:COND
       ((STRING-EQUAL? (%SYMBOL.SYMBOL-NAME VALUE) "TRUE")
        (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN TRUE-WRAPPER))
       ((STRING-EQUAL? (%SYMBOL.SYMBOL-NAME VALUE) "FALSE")
        (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN FALSE-WRAPPER)))))
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (CL:COND
       ((STRING-EQUAL? (%KEYWORD.SYMBOL-NAME VALUE) "TRUE")
        (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN TRUE-WRAPPER))
       ((STRING-EQUAL? (%KEYWORD.SYMBOL-NAME VALUE) "FALSE")
        (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN FALSE-WRAPPER)))))
    ((SUBTYPE-OF-BOOLEAN? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN VALUE)))
    (CL:T)))
  (CL:IF ERROR?
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "coerce-value-to-boolean: can't coerce `" VALUE "' of type `"
     (CL:IF (CL:NOT (CL:EQ VALUE NULL)) (PRIMARY-TYPE VALUE)
      SGT-SYSTEMS-STELLA-UNKNOWN)
     "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
   (CL:RETURN-FROM COERCE-VALUE-TO-BOOLEAN NULL)))

;;; (DEFUN (COERCE-TO-BOOLEAN BOOLEAN-WRAPPER) ...)

(CL:DEFUN COERCE-TO-BOOLEAN (OBJECT)
  "Return the boolean object represented by `object'.
Return NULL if coercion is not possible."
  (CL:RETURN-FROM COERCE-TO-BOOLEAN
   (COERCE-VALUE-TO-BOOLEAN OBJECT CL:NIL)))

;;; (DEFUN (COERCE-VALUE-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:SIMPLE-STRING)
  COERCE-VALUE-TO-STRING))
(CL:DEFUN COERCE-VALUE-TO-STRING (VALUE ERROR?)
  "Coerce `value' into a string if possible, return NULL
otherwise or raise an error if `error?' is true."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-STRING
       (%STRING-WRAPPER.WRAPPER-VALUE VALUE))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SYSTEMS-STELLA-GENERALIZED-SYMBOL)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-STRING
       (%GENERALIZED-SYMBOL.SYMBOL-NAME VALUE))))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-STRING
       (INTEGER-TO-STRING
        (CL:TRUNCATE (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))))))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-STRING
       (INTEGER-TO-STRING
        (%LONG-INTEGER-WRAPPER.WRAPPER-VALUE VALUE)))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-STRING
       (FLOAT-TO-STRING (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE)))))
    (CL:T)))
  (CL:IF ERROR?
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "coerce-value-to-string: don't know how to coerce `" VALUE "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
   (CL:RETURN-FROM COERCE-VALUE-TO-STRING STELLA::NULL-STRING)))

;;; (DEFUN (COERCE-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) COERCE-TO-STRING))
(CL:DEFUN COERCE-TO-STRING (OBJECT)
  "Coerce `object' into a string.  If no standard coercion
is possible, simply stringify `object'."
  (CL:LET* ((STRING (COERCE-VALUE-TO-STRING OBJECT CL:NIL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
   (CL:WHEN (CL:EQ STRING STELLA::NULL-STRING)
    (CL:SETQ STRING (STRINGIFY OBJECT)))
   (CL:RETURN-FROM COERCE-TO-STRING STRING)))

;;; (DEFUN (COERCE-VALUE-TO-FLOAT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:DOUBLE-FLOAT)
  COERCE-VALUE-TO-FLOAT))
(CL:DEFUN COERCE-VALUE-TO-FLOAT (VALUE ERROR?)
  "Coerce `value' to a float value if possible, return
NULL otherwise or raise an error if `error?' is true."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-FLOAT
       (CL:* (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE) 1.0d0))))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-FLOAT
       (CL:* (%LONG-INTEGER-WRAPPER.WRAPPER-VALUE VALUE) 1.0d0))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-VALUE-TO-FLOAT
       (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))))
    (CL:T)))
  (CL:IF ERROR?
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "coerce-value-to-float: don't know how to coerce `" VALUE "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
   (CL:RETURN-FROM COERCE-VALUE-TO-FLOAT NULL-FLOAT)))

;;; (DEFUN (COERCE-TO-FLOAT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT) COERCE-TO-FLOAT))
(CL:DEFUN COERCE-TO-FLOAT (OBJECT)
  "Coerce `number' to a float value or NULL if not possible."
  (CL:RETURN-FROM COERCE-TO-FLOAT (COERCE-VALUE-TO-FLOAT OBJECT CL:NIL)))

;;; (DEFUN (COERCE-VALUE-TO-TYPE OBJECT) ...)

(CL:DEFUN COERCE-VALUE-TO-TYPE (VALUE TYPE ERROR?)
  "Coerce `value' to `type'.  Return NULL if not possible
or raise an error if `error?' is TRUE."
  (CL:COND
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-INTEGER)
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
     (CL:COND
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
       (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))
      ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
         (WRAP-INTEGER (FLOOR (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))))))
      ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
       (CL:PROGN
        (CL:WHEN
         (CL:AND
          (CL:>= (%LONG-INTEGER-WRAPPER.WRAPPER-VALUE VALUE)
           NULL-INTEGER)
          (CL:<= (%LONG-INTEGER-WRAPPER.WRAPPER-VALUE VALUE)
           MOST-POSITIVE-INTEGER))
         (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE))))
      (CL:T))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-FLOAT)
    (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
     (WRAP-FLOAT (COERCE-VALUE-TO-FLOAT VALUE ERROR?))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-NUMBER)
    (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE VALUE)))
     (CL:COND
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
       (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))
      ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-001)
       (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))
      ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
       (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))
      (CL:T))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-STRING)
    (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
     (WRAP-STRING (COERCE-VALUE-TO-STRING VALUE ERROR?))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-KEYWORD)
    (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE VALUE)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-002
        SGT-SYSTEMS-STELLA-GENERALIZED-SYMBOL)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE (KEYWORDIFY VALUE))))
      ((SUBTYPE-OF-STRING? TEST-VALUE-002)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE (KEYWORDIFY VALUE))))
      (CL:T))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-SYMBOL)
    (CL:LET* ((TEST-VALUE-003 (SAFE-PRIMARY-TYPE VALUE)))
     (CL:COND
      ((SUBTYPE-OF-KEYWORD? TEST-VALUE-003)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
         (INTERN-SYMBOL (%KEYWORD.SYMBOL-NAME VALUE)))))
      ((SUBTYPE-OF-SURROGATE? TEST-VALUE-003)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
         (INTERN-DERIVED-SYMBOL VALUE
          (%SURROGATE.SYMBOL-NAME VALUE)))))
      ((SUBTYPE-OF-SYMBOL? TEST-VALUE-003)
       (CL:PROGN (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))
      ((SUBTYPE-OF-STRING? TEST-VALUE-003)
       (CL:PROGN
        (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
         (INTERN-SYMBOL (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))))
      (CL:T))))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-BOOLEAN)
    (CL:RETURN-FROM COERCE-VALUE-TO-TYPE
     (COERCE-VALUE-TO-BOOLEAN VALUE ERROR?)))
   ((CL:EQ TYPE SGT-SYSTEMS-STELLA-MODULE)
    (CL:LET* ((MODULE (COERCE-TO-MODULE VALUE CL:NIL)))
     (CL:WHEN (CL:NOT (CL:EQ MODULE NULL))
      (CL:RETURN-FROM COERCE-VALUE-TO-TYPE MODULE))))
   (CL:T
    (CL:COND
     ((CL:EQ TYPE NULL) (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE))
     ((ISA? VALUE TYPE) (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE))
     ((ISA? VALUE (TYPE-TO-WRAPPED-TYPE TYPE))
      (CL:RETURN-FROM COERCE-VALUE-TO-TYPE VALUE)))))
  (CL:IF ERROR?
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "coerce-value-to-type: don't know how to coerce `" VALUE
     "' to type `" TYPE "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
   (CL:RETURN-FROM COERCE-VALUE-TO-TYPE NULL)))

;;; (DEFUN (COERCE-OPTION-VALUE OBJECT) ...)

(CL:DEFUN COERCE-OPTION-VALUE (VALUE TYPE)
  "Coerce `value' to `type'.  Return NULL if not possible."
  (CL:RETURN-FROM COERCE-OPTION-VALUE
   (COERCE-VALUE-TO-TYPE VALUE TYPE CL:NIL)))

;;; (DEFUN (VET-OPTIONS PROPERTY-LIST) ...)

(CL:DEFUN VET-OPTIONS (PLIST LEGALOPTIONS)
  (CL:LET* ((PROPERTYLIST NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE PLIST)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-SYSTEMS-STELLA-PROPERTY-LIST)
      (CL:PROGN (CL:SETQ PROPERTYLIST PLIST)))
     ((CL:EQ TEST-VALUE-000 SGT-SYSTEMS-STELLA-CONS)
      (CL:PROGN
       (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
        (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000) PLIST)
        (CL:SETQ PROPERTYLIST SELF-000))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-SYSTEMS-STELLA-LIST)
      (CL:PROGN
       (CL:LET* ((SELF-001 (NEW-PROPERTY-LIST)))
        (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-001)
         (%LIST.THE-CONS-LIST PLIST))
        (CL:SETQ PROPERTYLIST SELF-001))))
     (CL:T (CL:WARN "Illegal argument passed to 'vet-options'")
      (CL:RETURN-FROM VET-OPTIONS (NEW-PROPERTY-LIST)))))
   (CL:LET*
    ((KEY NULL) (VALUE NULL)
     (ITER-000 (%PROPERTY-LIST.THE-PLIST PROPERTYLIST)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ KEY (%%VALUE ITER-000))
     (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
     (CL:WHEN
      (CL:OR (CL:NOT (STELLA-OBJECT? KEY)) (CL:NOT (KEYWORD? KEY))
       (CL:AND (CL:NOT (CL:EQ LEGALOPTIONS NULL))
        (CL:NOT (MEMBER? LEGALOPTIONS KEY))))
      (CL:SETQ VALUE VALUE)
      (CL:WHEN (CL:NOT (STELLA-OBJECT? KEY))
       (CL:LET* ((NEWPLIST (NEW-PROPERTY-LIST)))
        (CL:LET*
         ((KEY NULL) (VALUE NULL)
          (ITER-001 (%PROPERTY-LIST.THE-PLIST PROPERTYLIST)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ KEY (%%VALUE ITER-001))
          (CL:SETQ VALUE (%%VALUE (%%REST ITER-001)))
          (INSERT-AT NEWPLIST (STELLIFY KEY) (STELLIFY VALUE))
          (CL:SETQ ITER-001 (%%REST (%%REST ITER-001)))))
        (CL:SETF (%PROPERTY-LIST.THE-PLIST PROPERTYLIST)
         (%PROPERTY-LIST.THE-PLIST NEWPLIST)))
       (VET-OPTIONS PROPERTYLIST LEGALOPTIONS)
       (CL:RETURN-FROM VET-OPTIONS PROPERTYLIST))
      (REMOVE-AT PROPERTYLIST KEY)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Skipping illegal option: `" KEY "'" EOL EOL)
      (CL:IF (KEYWORD? KEY)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "   Legal options are: `" LEGALOPTIONS "'" EOL EOL)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "   Option must be a keyword." EOL))
      (VET-OPTIONS PROPERTYLIST LEGALOPTIONS)
      (CL:RETURN-FROM VET-OPTIONS PROPERTYLIST))
     (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
   (CL:RETURN-FROM VET-OPTIONS PROPERTYLIST)))

;;; (DEFUN (PARSE-OPTIONS PROPERTY-LIST) ...)

(CL:DEFUN PARSE-OPTIONS (OPTIONS |LEGALOPTIONS&TYPES| COERCIONERROR? ALLOWOTHERKEYS?)
  "Parse `options', check their validity according to
`legalOptions&Types' and return the result as a PROPERTY-LIST.
`legalOptions&Types' has to either be NULL or a flat list of legal
<keyword> <coercionType> pairs.  A type specifcation of @IDENTITY
means don't perform any coercion.
If `coercionError?' is TRUE, raise an error if a coercion failed.
If `allowOtherKeys?' is TRUE options other than those specified in
`legalOptions&Types' are allowed but won't be coerced since we don't
know their type."
  (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
   (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000) |LEGALOPTIONS&TYPES|)
   (CL:LET*
    ((LEGALOPTIONS SELF-000) (PARSEDOPTIONS NULL) (TYPE NULL)
     (COERCEDVALUE NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OPTIONS)))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 SGT-SYSTEMS-STELLA-CONS)
       (CL:PROGN
        (CL:WHEN (CL:LOGBITP 0 (CL:THE CL:FIXNUM (LENGTH OPTIONS)))
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
           "Odd-length options list: `" OPTIONS "'")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
        (CL:LET* ((SELF-003 (NEW-PROPERTY-LIST)))
         (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-003) OPTIONS)
         (CL:SETQ PARSEDOPTIONS SELF-003))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-SYSTEMS-STELLA-PROPERTY-LIST)
       (CL:PROGN (CL:SETQ PARSEDOPTIONS OPTIONS)))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
         "Illegal options specification: `" OPTIONS "'")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
    (CL:WHEN (CL:NOT (CL:EQ LEGALOPTIONS NULL))
     (CL:LET*
      ((KEY NULL) (VALUE NULL)
       (ITER-000 (%PROPERTY-LIST.THE-PLIST PARSEDOPTIONS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ KEY (%%VALUE ITER-000))
       (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
       (CL:SETQ TYPE (LOOKUP LEGALOPTIONS KEY))
       (CL:WHEN (CL:AND (CL:EQ TYPE NULL) (CL:NOT ALLOWOTHERKEYS?))
        (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
          "Illegal option: `" KEY "'")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))
       (CL:WHEN
        (CL:NOT
         (CL:OR (CL:EQ TYPE SGT-SYSTEMS-STELLA-IDENTITY)
          (CL:EQ VALUE NULL)))
        (CL:SETQ COERCEDVALUE
         (COERCE-VALUE-TO-TYPE VALUE TYPE COERCIONERROR?))
        (INSERT-AT PARSEDOPTIONS KEY COERCEDVALUE))
       (CL:SETQ ITER-000 (%%REST (%%REST ITER-000))))))
    (CL:RETURN-FROM PARSE-OPTIONS PARSEDOPTIONS))))

;;; (DEFUN (EVALUATE-COMMAND OBJECT) ...)

(CL:DEFUN EVALUATE-COMMAND (COMMAND FINALIZE?)
  (CL:LET*
   ((*TRANSLATIONERRORS* 0) (*TRANSLATIONWARNINGS* 0)
    (*TRANSLATIONNOTES* 0) (*IGNORETRANSLATIONERRORS?* CL:NIL)
    (*TRANSLATIONUNITS* NULL) (*TRANSLATIONPHASE* KWD-SYSTEMS-DEFINE)
    (*EVALUATIONTREE* NULL))
   (CL:DECLARE
    (CL:SPECIAL *TRANSLATIONERRORS* *TRANSLATIONWARNINGS*
     *TRANSLATIONNOTES* *IGNORETRANSLATIONERRORS?* *TRANSLATIONUNITS*
     *TRANSLATIONPHASE* *EVALUATIONTREE*))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM *TRANSLATIONERRORS* *TRANSLATIONWARNINGS*
     *TRANSLATIONNOTES*))
   (CL:LET* ((OPERATOR NULL) (RESULT NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE COMMAND)))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 SGT-SYSTEMS-STELLA-CONS)
       (CL:PROGN (CL:SETQ OPERATOR (%%VALUE COMMAND))
        (CL:COND
         ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE OPERATOR))
          (CL:PROGN
           (CL:COND
            ((CL:EQ OPERATOR SYM-SYSTEMS-STELLA-IN-MODULE)
             (HANDLE-IN-MODULE-TREE COMMAND CL:NIL CL:NIL))
            (CL:T
             (CL:COND
              ((DECLARATION-TREE? COMMAND)
               (CL:SETQ *TRANSLATIONUNITS* (LIST))
               (WALK-TOP-LEVEL-TREE COMMAND CL:NIL)
               (CL:CASE (LENGTH (REVERSE *TRANSLATIONUNITS*))
                (0
                 (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
                  (%%PRINT-STREAM
                   (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
                   "While evaluating '" *EVALUATIONTREE*)
                  (CL:WHEN (CL:NOT (CL:EQ *EVALUATIONPARENTTREE* NULL))
                   (%%PRINT-STREAM
                    (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
                    EOL "' inside '" *EVALUATIONPARENTTREE*))
                  (%%PRINT-STREAM
                   (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
                   "':" EOL)
                  (%%PRINT-STREAM
                   (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
                   "Couldn't translate `" COMMAND "'")
                  (CL:ERROR
                   (NEW-EVALUATION-EXCEPTION
                    (THE-STRING-READER STREAM-000)))))
                (1
                 (CL:SETQ RESULT
                  (%TRANSLATION-UNIT.THE-OBJECT
                   (FIRST *TRANSLATIONUNITS*))))
                (CL:OTHERWISE
                 (CL:LET* ((RESULTS NIL))
                  (CL:LET*
                   ((UNIT NULL)
                    (ITER-000 (%LIST.THE-CONS-LIST *TRANSLATIONUNITS*))
                    (COLLECT-000 NULL))
                   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
                    (CL:SETQ UNIT (%%VALUE ITER-000))
                    (CL:IF (CL:EQ COLLECT-000 NULL)
                     (CL:PROGN
                      (CL:SETQ COLLECT-000
                       (CONS (%TRANSLATION-UNIT.THE-OBJECT UNIT) NIL))
                      (CL:IF (CL:EQ RESULTS NIL)
                       (CL:SETQ RESULTS COLLECT-000)
                       (ADD-CONS-TO-END-OF-CONS-LIST RESULTS
                        COLLECT-000)))
                     (CL:PROGN
                      (CL:SETF (%%REST COLLECT-000)
                       (CONS (%TRANSLATION-UNIT.THE-OBJECT UNIT) NIL))
                      (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
                    (CL:SETQ ITER-000 (%%REST ITER-000))))
                  (CL:SETQ RESULT RESULTS)))))
              ((STRING-EQUAL? (%SYMBOL.SYMBOL-NAME OPERATOR)
                "in-package"))
              (CL:T (%EVALUATE COMMAND)))))))
         (CL:T (%EVALUATE COMMAND)))))
      ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ RESULT COMMAND)))
      ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ RESULT COMMAND)))
      (CL:T (%EVALUATE COMMAND))))
    (CL:WHEN (CL:AND (CL:NOT (TRANSLATION-ERRORS?)) FINALIZE?)
     (CL:SETQ *TRANSLATIONPHASE* KWD-SYSTEMS-FINALIZE)
     (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
      (RUN-SYSTEM-FINALIZATION *CURRENTSYSTEMDEFINITION*)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Can't run finalization because *currentSystemDefinition* is not set."
       EOL)))
    (CL:RETURN-FROM EVALUATE-COMMAND RESULT))))

;;; (DEFUN LOAD-FILE ...)

(CL:DEFUN %LOAD-FILE (FILE)
  "Read STELLA commands from `file' and evaluate them.
The file should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  #+MCL
  (CL:CHECK-TYPE FILE CL:SIMPLE-STRING)
  (CL:LET* ((TEMP-000 (FIND-FILE-IN-LOAD-PATH FILE NULL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-000))
   (CL:SETQ FILE
    (CL:IF (CL:NOT (CL:EQ TEMP-000 STELLA::NULL-STRING)) TEMP-000
     FILE)))
  (ENSURE-FILE-EXISTS FILE "load-file")
  (CL:LET*
   ((TOPLEVELINVOCATION? (CL:EQ *CURRENTFILE* STELLA::NULL-STRING))
    (SKIPCOMMAND? CL:NIL) (SEENINMODULE? CL:NIL) (COMMANDS NIL)
    (INPUTSTREAM NULL))
   (CL:UNWIND-PROTECT
    (CL:LET* ((*CURRENTFILE* (FILE-BASE-NAME FILE)))
     (CL:DECLARE (CL:SPECIAL *CURRENTFILE*))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING *CURRENTFILE*))
     (CL:SETQ INPUTSTREAM (NEW-INPUT-FILE-STREAM FILE))
     (CL:LET* ((*MODULE* *MODULE*) (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:LET* ((TREE NULL) (ITER-000 (S-EXPRESSIONS INPUTSTREAM)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ TREE (%S-EXPRESSION-ITERATOR.VALUE ITER-000))
        (CL:TAGBODY
         (CL:COND
          ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-SYSTEMS-STELLA-CONS)
           (CL:PROGN
            (CL:MULTIPLE-VALUE-SETQ (SKIPCOMMAND? SEENINMODULE?)
             (HANDLE-IN-MODULE-TREE TREE SEENINMODULE? CL:T))
            (CL:WHEN SKIPCOMMAND? (CL:GO :CONTINUE))
            (CL:LET* ((OPERATOR (%%VALUE TREE)))
             (CL:COND
              ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE OPERATOR))
               (CL:PROGN
                (CL:COND
                 ((CL:OR (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFMODULE)
                   (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFSYSTEM)
                   (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFCLASS)
                   (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFSLOT)
                   (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFUN)
                   (CL:EQ OPERATOR SYM-SYSTEMS-STELLA-DEFMETHOD))
                  (EVALUATE-COMMAND TREE CL:NIL))
                 (CL:T
                  (CL:IF
                   (CL:NOT (CL:EQ (LOOKUP-COMMAND OPERATOR) NULL))
                   (CL:SETQ COMMANDS (CONS TREE COMMANDS))
                   (EVALUATE-COMMAND TREE CL:NIL))))))
              (CL:T (EVALUATE-COMMAND TREE CL:NIL))))))
          (CL:T (EVALUATE-COMMAND TREE CL:NIL)))
         :CONTINUE)))
      (CL:LET* ((*TRANSLATIONPHASE* KWD-SYSTEMS-FINALIZE))
       (CL:DECLARE (CL:SPECIAL *TRANSLATIONPHASE*))
       (RUN-SYSTEM-FINALIZATION *CURRENTSYSTEMDEFINITION*))
      (CL:LET*
       ((FINALIZE? (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))))
       (CL:LET* ((TREE NULL) (ITER-001 (REVERSE COMMANDS)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ TREE (%%VALUE ITER-001))
         (EVALUATE-COMMAND TREE FINALIZE?)
         (CL:SETQ ITER-001 (%%REST ITER-001)))))))
    (CL:WHEN TOPLEVELINVOCATION? (SWEEP-TRANSIENTS))
    (CL:WHEN (CL:NOT (CL:EQ INPUTSTREAM NULL)) (FREE INPUTSTREAM))))
  :VOID)

(CL:DEFUN LOAD-FILE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%LOAD-FILE (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))
  :VOID)

(CL:DEFMACRO LOAD-FILE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Read STELLA commands from `file' and evaluate them.
The file should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/LOAD-FILE|)) (CL:MACRO-FUNCTION (CL:QUOTE LOAD-FILE)))

;;; (DEFGLOBAL *SYSTEMDEFINITIONS* ...)

(CL:DEFVAR *SYSTEMDEFINITIONS* NULL
  "A list of all defined systems.")

;;; (DEFUN (MAKE-SYSTEM-DEFINITION-FILE-NAME FILE-NAME) ...)

(CL:DEFUN MAKE-SYSTEM-DEFINITION-FILE-NAME (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM MAKE-SYSTEM-DEFINITION-FILE-NAME
   (CONCATENATE (SYSTEM-DEFINITIONS-DIRECTORY)
    (DIRECTORY-SEPARATOR-STRING) (STRING-DOWNCASE NAME) "-system.ste")))

;;; (DEFUN (PARSE-LIST-OF-FILE-PATHS (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN PARSE-LIST-OF-FILE-PATHS (FILES)
  (CL:LET* ((STRINGS NIL))
   (CL:LET* ((FILESPEC NULL) (ITER-000 FILES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ FILESPEC (%%VALUE ITER-000))
     (CL:SETQ STRINGS
      (CONS (WRAP-STRING (IMPLODE-PATHNAME FILESPEC)) STRINGS))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM PARSE-LIST-OF-FILE-PATHS (REVERSE STRINGS))))

;;; (DEFUN (DEFINE-SYSTEM SYSTEM-DEFINITION) ...)

(CL:DEFUN DEFINE-SYSTEM (NAME OPTIONS)
  (CL:LET* ((STRINGNAME STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGNAME))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NAME)))
    (CL:COND
     ((SUBTYPE-OF-STRING? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ STRINGNAME (%STRING-WRAPPER.WRAPPER-VALUE NAME))))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ STRINGNAME
        (STRING-DOWNCASE (%SYMBOL.SYMBOL-NAME NAME)))))
     (CL:T
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Illegal system name: " NAME)
      (CL:RETURN-FROM DEFINE-SYSTEM NULL))))
   (CL:LET* ((SELF-000 (NEW-SYSTEM-DEFINITION)))
    (CL:SETF (%SYSTEM-DEFINITION.NAME SELF-000) STRINGNAME)
    (CL:LET* ((SYSTEM SELF-000))
     (CL:LET* ((SELF-001 (NEW-PROPERTY-LIST)))
      (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-001) OPTIONS)
      (CL:LET* ((PLIST SELF-001))
       (CL:LET* ((VALUE-000 NULL))
        (CL:LET*
         ((S NULL)
          (ITER-000 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ S (%%VALUE ITER-000))
          (CL:WHEN (STRING-EQL? (%SYSTEM-DEFINITION.NAME S) STRINGNAME)
           (CL:SETQ VALUE-000 S) (CL:RETURN))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:LET* ((OLDSYSTEM VALUE-000))
         (CL:LET*
          ((KEY NULL) (VALUE NULL)
           (ITER-001 (%PROPERTY-LIST.THE-PLIST PLIST)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ KEY (%%VALUE ITER-001))
           (CL:SETQ VALUE (%%VALUE (%%REST ITER-001)))
           (CL:LET* ((TEST-VALUE-001 KEY))
            (CL:COND
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-DIRECTORY)
              (CL:SETF (%SYSTEM-DEFINITION.DIRECTORY SYSTEM)
               (IMPLODE-PATHNAME VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-REQUIRED-SYSTEMS)
              (CL:SETF (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS SYSTEM)
               VALUE)
              (CL:LET* ((SYS NULL) (ITER-002 VALUE))
               (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
                (CL:SETQ SYS (%%VALUE ITER-002))
                (GET-SYSTEM-DEFINITION
                 (%STRING-WRAPPER.WRAPPER-VALUE SYS))
                (CL:WHEN
                 (CL:NOT
                  (SYSTEM-LOADED-OR-STARTED-UP?
                   (%STRING-WRAPPER.WRAPPER-VALUE SYS)))
                 (CL:LET*
                  ((CURRENTACTION KWD-SYSTEMS-LOAD-SYSTEM)
                   (CURRENTLANGUAGE (RUNNING-IN-LANGUAGE)))
                  (CL:WHEN
                   (CL:NOT (CL:EQ *CURRENT-SYSTEM-ACTION* NULL))
                   (CL:SETQ CURRENTACTION
                    (LOOKUP-WITH-DEFAULT *CURRENT-SYSTEM-ACTION*
                     KWD-SYSTEMS-ACTION CURRENTACTION))
                   (CL:SETQ CURRENTLANGUAGE
                    (LOOKUP-WITH-DEFAULT *CURRENT-SYSTEM-ACTION*
                     KWD-SYSTEMS-LANGUAGE CURRENTLANGUAGE)))
                  (CL:COND
                   ((CL:EQ CURRENTACTION KWD-SYSTEMS-MAKE-SYSTEM)
                    (%%PRINT-STREAM
                     (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
                     "Making required system " (UNWRAP-STRING SYS) EOL)
                    (%MAKE-SYSTEM (%STRING-WRAPPER.WRAPPER-VALUE SYS)
                     (CONS-LIST CURRENTLANGUAGE)))
                   (CL:T
                    (%%PRINT-STREAM
                     (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
                     "Loading required system " (UNWRAP-STRING SYS)
                     EOL)
                    (%LOAD-SYSTEM (%STRING-WRAPPER.WRAPPER-VALUE SYS)
                     (CONS-LIST CURRENTLANGUAGE))))))
                (CL:SETQ ITER-002 (%%REST ITER-002)))))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-LISP-ONLY-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.LISP-ONLY-FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-CPP-ONLY-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.CPP-ONLY-FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-JAVA-ONLY-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.JAVA-ONLY-FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-DATA-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.DATA-FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-PREPROCESSED-FILES)
              (CL:SETF (%SYSTEM-DEFINITION.PREPROCESSED-FILES SYSTEM)
               (PARSE-LIST-OF-FILE-PATHS VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-CARDINAL-MODULE)
              (CL:SETF (%SYSTEM-DEFINITION.CARDINAL-MODULE SYSTEM)
               (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY)
              (CL:SETF
               (%SYSTEM-DEFINITION.SOURCE-ROOT-DIRECTORY SYSTEM)
               (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY)
              (CL:SETF
               (%SYSTEM-DEFINITION.NATIVE-ROOT-DIRECTORY SYSTEM)
               (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-ROOT-BINARY-DIRECTORY)
              (CL:SETF
               (%SYSTEM-DEFINITION.BINARY-ROOT-DIRECTORY SYSTEM)
               (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
             ((CL:OR (CL:EQ TEST-VALUE-001 KWD-SYSTEMS-BANNER)
               (CL:EQ TEST-VALUE-001 KWD-SYSTEMS-COPYRIGHT-HEADER))
              (CL:SETF (%SYSTEM-DEFINITION.BANNER SYSTEM)
               (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-PRODUCTION-SETTINGS)
              (CL:SETF (%SYSTEM-DEFINITION.PRODUCTION-SETTINGS SYSTEM)
               VALUE))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-DEVELOPMENT-SETTINGS)
              (CL:SETF (%SYSTEM-DEFINITION.DEVELOPMENT-SETTINGS SYSTEM)
               VALUE))
             ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-FINALIZATION-FUNCTION)
              (CL:SETF
               (%SYSTEM-DEFINITION.FINALIZATION-FUNCTION SYSTEM)
               VALUE))
             (CL:T
              (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
               (%%PRINT-STREAM
                (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
                TEST-VALUE-001 "' is not a valid case option")
               (CL:ERROR
                (NEW-STELLA-EXCEPTION
                 (THE-STRING-READER STREAM-000)))))))
           (CL:SETQ ITER-001 (%%REST (%%REST ITER-001)))))
         (CL:WHEN
          (CL:EQ (%SYSTEM-DEFINITION.DIRECTORY SYSTEM)
           STELLA::NULL-STRING)
          (CL:SETF (%SYSTEM-DEFINITION.DIRECTORY SYSTEM)
           (%SYSTEM-DEFINITION.NAME SYSTEM)))
         (PUSH *SYSTEMDEFINITIONS* SYSTEM)
         (CL:WHEN (CL:NOT (CL:EQ OLDSYSTEM NULL))
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
           "Redefining system `" (%SYSTEM-DEFINITION.NAME SYSTEM) "'"
           EOL EOL)
          (REMOVE *SYSTEMDEFINITIONS* OLDSYSTEM))
         (CL:RETURN-FROM DEFINE-SYSTEM SYSTEM)))))))))

;;; (DEFUN (DEFSYSTEM SYSTEM-DEFINITION) ...)

(CL:DEFUN %DEFSYSTEM (NAME OPTIONS)
  "Define a system of files that collectively define
a Stella application.
   Required options are:
   :directory -- the relative path from the respective source/native/binary root directory
                 to the directory containing the system files.  Can be a string or a list
                 of strings (do not include directory separators).
   :files -- a list of files in the system, containing strings and lists
             of strings; the latter defines exploded paths to files
             in subdirectories.
   Optional options are:
   :data-files       -- a list of files like the :files keyword, which contain
                        data or other content that should not be processed, but
                        instead copied verbatim to the native directory
   :required-systems -- a list of systems (strings) that should be loaded
                        prior to loading this system.
   :cardinal-module -- the name (a string) of the principal module for this
                       system.
   :copyright-header -- string with a header for inclusion into all translated
                        files produced by Stella.
   :lisp-only-files  -- Like the :files keyword, but these are only included
   :cpp-only-files      in the translation for the specific language, namely
   :java-only-files     Common Lisp, C++ or Java"
  (CL:RETURN-FROM %DEFSYSTEM (DEFINE-SYSTEM NAME OPTIONS)))

(CL:DEFUN DEFSYSTEM-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM DEFSYSTEM-EVALUATOR-WRAPPER
   (%DEFSYSTEM (%%VALUE ARGUMENTS) (%%REST ARGUMENTS))))

(CL:DEFMACRO DEFSYSTEM (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Define a system of files that collectively define
a Stella application.
   Required options are:
   :directory -- the relative path from the respective source/native/binary root directory
                 to the directory containing the system files.  Can be a string or a list
                 of strings (do not include directory separators).
   :files -- a list of files in the system, containing strings and lists
             of strings; the latter defines exploded paths to files
             in subdirectories.
   Optional options are:
   :data-files       -- a list of files like the :files keyword, which contain
                        data or other content that should not be processed, but
                        instead copied verbatim to the native directory
   :required-systems -- a list of systems (strings) that should be loaded
                        prior to loading this system.
   :cardinal-module -- the name (a string) of the principal module for this
                       system.
   :copyright-header -- string with a header for inclusion into all translated
                        files produced by Stella.
   :lisp-only-files  -- Like the :files keyword, but these are only included
   :cpp-only-files      in the translation for the specific language, namely
   :java-only-files     Common Lisp, C++ or Java"
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/DEFSYSTEM|)) (CL:MACRO-FUNCTION (CL:QUOTE DEFSYSTEM)))

;;; (DEFUN (GET-SYSTEM-DEFINITION SYSTEM-DEFINITION) ...)

(CL:DEFUN GET-SYSTEM-DEFINITION (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((VALUE-000 NULL))
   (CL:LET*
    ((S NULL) (ITER-000 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ S (%%VALUE ITER-000))
     (CL:WHEN (STRING-EQUAL? (%SYSTEM-DEFINITION.NAME S) NAME)
      (CL:SETQ VALUE-000 S) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((SYSTEM VALUE-000))
    (CL:WHEN (CL:EQ SYSTEM NULL)
     (CL:LET*
      ((SYSTEMFILENAME (MAKE-SYSTEM-DEFINITION-FILE-NAME NAME)))
      (CL:WHEN (CL:NOT (PROBE-FILE? SYSTEMFILENAME))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        "ERROR>> File " SYSTEMFILENAME " does not exist." EOL
        "   Can't define system " NAME EOL)
       (CL:RETURN-FROM GET-SYSTEM-DEFINITION NULL))
      (%LOAD-FILE SYSTEMFILENAME)
      (CL:LET* ((VALUE-001 NULL))
       (CL:LET*
        ((S NULL) (ITER-001 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ S (%%VALUE ITER-001))
         (CL:WHEN (STRING-EQUAL? (%SYSTEM-DEFINITION.NAME S) NAME)
          (CL:SETQ VALUE-001 S) (CL:RETURN))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:SETQ SYSTEM VALUE-001))
      (CL:WHEN (CL:EQ SYSTEM NULL)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        "ERROR>>  Can't find a system definition for system " NAME EOL
        "   within file " SYSTEMFILENAME "." EOL))))
    (CL:RETURN-FROM GET-SYSTEM-DEFINITION SYSTEM))))

;;; (DEFUN (GET-CARDINAL-MODULE MODULE) ...)

(CL:DEFUN GET-CARDINAL-MODULE (SYSTEM)
  (CL:LET*
   ((NAME (%SYSTEM-DEFINITION.CARDINAL-MODULE SYSTEM)) (MODULE NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
   (CL:WHEN (CL:NOT (CL:EQ NAME STELLA::NULL-STRING))
    (CL:SETQ MODULE (GET-STELLA-MODULE NAME CL:NIL))
    (CL:WHEN (CL:EQ MODULE NULL)
     (CL:SETQ MODULE (GET-STELLA-MODULE (STRING-UPCASE NAME) CL:NIL))))
   (CL:WHEN (CL:EQ MODULE NULL)
    (CL:WARN "No cardinal module defined for system: `~A'~%" SYSTEM))
   (CL:RETURN-FROM GET-CARDINAL-MODULE MODULE)))

;;; (DEFUN HELP-GET-SYSTEM-FILES ...)

(CL:DEFUN HELP-GET-SYSTEM-FILES (FILENAME COLLECTION PROBEFILE?)
  (CL:WHEN (CL:OR (CL:NOT PROBEFILE?) (PROBE-FILE? FILENAME))
   (PUSH COLLECTION (WRAP-STRING FILENAME)))
  :VOID)

;;; (DEFUN (GET-SYSTEM-FILES (LIST OF STRING-WRAPPER)) ...)

(CL:DEFUN GET-SYSTEM-FILES (SYSTEM TYPE PROBEFILES?)
  (CL:LET* ((FILES (NEW-LIST)) (FILENAME STELLA::NULL-STRING))
   (CL:LET*
    ((*CURRENTSYSTEMDEFINITION*
      (GET-SYSTEM-DEFINITION (%SYSTEM-DEFINITION.NAME SYSTEM)))
     (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
      (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
       (%SYSTEM-DEFINITION.DIRECTORY *CURRENTSYSTEMDEFINITION*)
       STELLA::NULL-STRING)))
    (CL:DECLARE
     (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
      *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
    (CL:DECLARE
     (CL:TYPE CL:SIMPLE-STRING *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
    (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
     (CL:PROGN
      (CL:LET*
       ((F NULL)
        (ITER-000
         (%SYSTEM-DEFINITION.FILES *CURRENTSYSTEMDEFINITION*)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ F (%%VALUE ITER-000))
        (CL:COND
         ((CL:EQ TYPE KWD-SYSTEMS-JAVA)
          (CL:SETQ FILENAME
           (%STRING-WRAPPER.WRAPPER-VALUE
            (JAVA-TRANSLATE-CLASS-NAMESTRING
             (WRAP-STRING
              (CONCATENATE "_STARTUP-"
               (STRING-UPCASE (%STRING-WRAPPER.WRAPPER-VALUE F))))))))
         (CL:T
          (CL:SETQ FILENAME
           (MAKE-FILE-NAME-FROM-RELATIVE-PATH F TYPE))))
        (HELP-GET-SYSTEM-FILES FILENAME FILES PROBEFILES?)
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:COND
       ((CL:EQ TYPE KWD-SYSTEMS-JAVA)
        (CL:WHEN
         (CL:EQ (GET-CARDINAL-MODULE *CURRENTSYSTEMDEFINITION*) NULL)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "No cardinal module defined for system `"
          (%SYSTEM-DEFINITION.NAME SYSTEM) "'" EOL EOL)
         (CL:RETURN-FROM GET-SYSTEM-FILES NIL-LIST))
        (CL:LET*
         ((CLASS NULL)
          (ITER-001
           (ALL-CLASSES (GET-CARDINAL-MODULE *CURRENTSYSTEMDEFINITION*)
            CL:T)))
         (CL:LOOP WHILE (NEXT? ITER-001) DO
          (CL:SETQ CLASS (%ITERATOR.VALUE ITER-001))
          (CL:SETQ FILENAME
           (JAVA-MAKE-CODE-OUTPUT-FILE-NAME CLASS CL:NIL))
          (HELP-GET-SYSTEM-FILES FILENAME FILES PROBEFILES?)))
        (CL:SETQ FILENAME
         (JAVA-MAKE-CODE-OUTPUT-FILE-NAME
          (JAVA-YIELD-FLOTSAM-CLASS-NAME
           (GET-CARDINAL-MODULE *CURRENTSYSTEMDEFINITION*))
          CL:NIL))
        (HELP-GET-SYSTEM-FILES FILENAME FILES PROBEFILES?))
       (CL:T)))
     (CL:WARN "Can't find a system named `~A'~%"
      (%SYSTEM-DEFINITION.NAME SYSTEM))))
   (CL:RETURN-FROM GET-SYSTEM-FILES FILES)))

;;; (DEFUN CLEAN-SYSTEM ...)

(CL:DEFUN CLEAN-SYSTEM (SYSTEMNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET* ((SYSTEM (GET-SYSTEM-DEFINITION SYSTEMNAME)))
   (CL:WHEN (CL:EQ SYSTEM NULL) (CL:RETURN-FROM CLEAN-SYSTEM))
   (CL:LET*
    ((F NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST
       (GET-SYSTEM-FILES SYSTEM KWD-SYSTEMS-LISP CL:T))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ F (%%VALUE ITER-000))
     (DELETE-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((F NULL)
     (ITER-001
      (%LIST.THE-CONS-LIST
       (GET-SYSTEM-FILES SYSTEM KWD-SYSTEMS-JAVA CL:T))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ F (%%VALUE ITER-001))
     (DELETE-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET*
    ((F NULL)
     (ITER-002
      (%LIST.THE-CONS-LIST
       (GET-SYSTEM-FILES SYSTEM KWD-SYSTEMS-CPP CL:T))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ F (%%VALUE ITER-002))
     (DELETE-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:LET*
    ((F NULL)
     (ITER-003
      (%LIST.THE-CONS-LIST
       (GET-SYSTEM-FILES SYSTEM KWD-SYSTEMS-LISP-BINARY CL:T))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
     (CL:SETQ F (%%VALUE ITER-003))
     (DELETE-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
     (CL:SETQ ITER-003 (%%REST ITER-003)))))
  :VOID)

;;; (DEFUN COMPUTE-OPTIMIZATION-LEVELS ...)

(CL:DEFUN COMPUTE-OPTIMIZATION-LEVELS (SYSTEM PRODUCTIONMODE?)
  (CL:LET* ((SETTINGS NULL))
   (CL:IF PRODUCTIONMODE?
    (CL:SETQ SETTINGS (%SYSTEM-DEFINITION.PRODUCTION-SETTINGS SYSTEM))
    (CL:SETQ SETTINGS
     (%SYSTEM-DEFINITION.DEVELOPMENT-SETTINGS SYSTEM)))
   (CL:WHEN (CL:EQ SETTINGS NULL)
    (CL:SETQ SETTINGS
     (GET-QUOTED-TREE "((3 2 3 3) \"/STELLA\")" "/STELLA")))
   (SET-OPTIMIZATION-LEVELS
    (%INTEGER-WRAPPER.WRAPPER-VALUE (NTH SETTINGS 0))
    (%INTEGER-WRAPPER.WRAPPER-VALUE (NTH SETTINGS 1))
    (%INTEGER-WRAPPER.WRAPPER-VALUE (NTH SETTINGS 2))
    (%INTEGER-WRAPPER.WRAPPER-VALUE (NTH SETTINGS 3))))
  :VOID)

;;; (DEFSPECIAL *CURRENT-SYSTEM-ACTION* ...)

(CL:DEFVAR *CURRENT-SYSTEM-ACTION* NULL
  "Holds the action and options of the current system action
such as :make-system, :load-system or :translate-system.  This is used to
perform the appropriate actions on required systems in `define-system'.")

;;; (DEFUN (MAKE-SYSTEM BOOLEAN) ...)

(CL:DEFUN %MAKE-SYSTEM (SYSTEMNAME |LANGUAGE&OPTIONS|)
  "Translate all out-of-date files of system `systemName'
into `language' (the first optional argument of `language&options') and
then compile and load them (the latter is only possible for Lisp right now).
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:two-pass?': if true, all files will be scanned twice, once to
load the signatures of objects defined in them, and once to actually
translate the definitions.  Otherwise, the translator will make one pass in
the case that the system is already loaded (and is being remade), and two
passes otherwise.

`:development-settings?' (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of `:development-settings' on the system definition).  If false, efficiency
will be favored instead (according to the value of `:production-settings'
on the system definition).

`:production-settings?' (default true): inverse to `:development-settings?'.

`:force-translation?' (default false): if true, files will be translated
whether or not their translations are up-to-date.

`:force-recompilation?' (default false): if true, translated files will be
recompiled whether or not their compilations are up-to-date (only supported
in Lisp right now).

`:load-system?' (default true): if true, compiled files will be loaded into
the current STELLA image (only supported in Lisp and Java right now).

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((OPTIONS |LANGUAGE&OPTIONS|)
    (LANGUAGE
     (CL:IF
      (MEMBER?
       (GET-QUOTED-TREE "((:COMMON-LISP :CPP :JAVA) \"/STELLA\")"
        "/STELLA")
       (%%VALUE OPTIONS))
      (%%VALUE OPTIONS) (RUNNING-IN-LANGUAGE)))
    (PLIST
     (VET-OPTIONS
      (CL:IF (CL:EQ (%%VALUE OPTIONS) LANGUAGE) (%%REST OPTIONS)
       OPTIONS)
      (GET-QUOTED-TREE
       "((:TWO-PASS? :DEVELOPMENT-SETTINGS? :PRODUCTION-SETTINGS? :FORCE-TRANSLATION? :FORCE-RECOMPILATION? :LOAD-SYSTEM? :LANGUAGE :ACTION) \"/STELLA\")"
       "/STELLA")))
    (DEVELOPMENTSETTINGS? CL:NIL) (FORCETRANSLATION? CL:NIL)
    (FORCERECOMPILATION? CL:NIL)
    (TWOPASS? (CL:NOT (SYSTEM-LOADED-OR-STARTED-UP? SYSTEMNAME)))
    (LOADSYSTEM? CL:NIL) (STARTUPSYSTEM? CL:NIL) (SYSTEM NULL)
    (UPDATEDSYSTEM? CL:NIL))
   (CL:SETQ LANGUAGE
    (LOOKUP-WITH-DEFAULT PLIST KWD-SYSTEMS-LANGUAGE LANGUAGE))
   (INSERT-AT PLIST KWD-SYSTEMS-LANGUAGE LANGUAGE)
   (CL:SETQ LOADSYSTEM? (CL:EQ LANGUAGE KWD-SYSTEMS-COMMON-LISP))
   (CL:SETQ STARTUPSYSTEM? (CL:EQ LANGUAGE KWD-SYSTEMS-COMMON-LISP))
   (INSERT-AT PLIST KWD-SYSTEMS-ACTION
    (LOOKUP-WITH-DEFAULT PLIST KWD-SYSTEMS-ACTION
     KWD-SYSTEMS-MAKE-SYSTEM))
   (CL:LET*
    ((KEY NULL) (VALUE NULL)
     (ITER-000 (%PROPERTY-LIST.THE-PLIST PLIST)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ KEY (%%VALUE ITER-000))
     (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
     (CL:LET* ((TRUEVALUE? (EQL? VALUE TRUE-WRAPPER)))
      (CL:LET* ((TEST-VALUE-000 KEY))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-DEVELOPMENT-SETTINGS?)
         (CL:SETQ DEVELOPMENTSETTINGS? TRUEVALUE?))
        ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-PRODUCTION-SETTINGS?)
         (CL:SETQ DEVELOPMENTSETTINGS? (CL:NOT TRUEVALUE?)))
        ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-FORCE-TRANSLATION?)
         (CL:SETQ FORCETRANSLATION? TRUEVALUE?))
        ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-FORCE-RECOMPILATION?)
         (CL:SETQ FORCERECOMPILATION? TRUEVALUE?))
        ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-TWO-PASS?)
         (CL:SETQ TWOPASS? TRUEVALUE?))
        ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-LOAD-SYSTEM?)
         (CL:SETQ LOADSYSTEM? TRUEVALUE?))
        ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-STARTUP?)
         (CL:SETQ STARTUPSYSTEM? TRUEVALUE?))
        (CL:T))))
     (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
   (CL:LET* ((*CURRENT-SYSTEM-ACTION* (COPY PLIST)))
    (CL:DECLARE (CL:SPECIAL *CURRENT-SYSTEM-ACTION*))
    (CL:SETQ SYSTEM (GET-SYSTEM-DEFINITION SYSTEMNAME))
    (CL:WHEN (CL:EQ SYSTEM NULL)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Can't find a declaration for system named " SYSTEMNAME EOL
      "  Possibly a global path name needs to be set." EOL)
     (CL:RETURN-FROM %MAKE-SYSTEM CL:NIL))
    (CL:WHEN
     (CL:OR FORCERECOMPILATION?
      (CL:AND (CL:NOT (SYSTEM-LOADED-OR-STARTED-UP? SYSTEMNAME))
       (CL:OR FORCETRANSLATION?
        (SYSTEM-NEEDS-TRANSLATION? SYSTEMNAME LANGUAGE))))
     (LOAD-PREPROCESSED-FILES SYSTEMNAME))
    (CL:SETQ UPDATEDSYSTEM?
     (%TRANSLATE-SYSTEM SYSTEMNAME
      (CONS-LIST LANGUAGE KWD-SYSTEMS-TWO-PASS?
       (CL:IF TWOPASS? TRUE-WRAPPER FALSE-WRAPPER)
       KWD-SYSTEMS-FORCE-TRANSLATION?
       (CL:IF FORCETRANSLATION? TRUE-WRAPPER FALSE-WRAPPER)
       KWD-SYSTEMS-DEVELOPMENT-SETTINGS?
       (CL:IF DEVELOPMENTSETTINGS? TRUE-WRAPPER FALSE-WRAPPER))))
    (CL:WHEN
     (CL:AND LOADSYSTEM?
      (%LOAD-SYSTEM SYSTEMNAME
       (CONS-LIST LANGUAGE KWD-SYSTEMS-FORCE-RECOMPILATION?
        (CL:IF FORCERECOMPILATION? TRUE-WRAPPER FALSE-WRAPPER)
        KWD-SYSTEMS-STARTUP?
        (CL:IF STARTUPSYSTEM? TRUE-WRAPPER FALSE-WRAPPER))))
     (CL:SETQ UPDATEDSYSTEM? CL:T))
    (CL:RETURN-FROM %MAKE-SYSTEM UPDATEDSYSTEM?))))

(CL:DEFUN MAKE-SYSTEM-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM MAKE-SYSTEM-EVALUATOR-WRAPPER
   (CL:IF
    (%MAKE-SYSTEM (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
     (%%REST ARGUMENTS))
    TRUE-WRAPPER FALSE-WRAPPER)))

(CL:DEFMACRO MAKE-SYSTEM (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Translate all out-of-date files of system `systemName'
into `language' (the first optional argument of `language&options') and
then compile and load them (the latter is only possible for Lisp right now).
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:two-pass?': if true, all files will be scanned twice, once to
load the signatures of objects defined in them, and once to actually
translate the definitions.  Otherwise, the translator will make one pass in
the case that the system is already loaded (and is being remade), and two
passes otherwise.

`:development-settings?' (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of `:development-settings' on the system definition).  If false, efficiency
will be favored instead (according to the value of `:production-settings'
on the system definition).

`:production-settings?' (default true): inverse to `:development-settings?'.

`:force-translation?' (default false): if true, files will be translated
whether or not their translations are up-to-date.

`:force-recompilation?' (default false): if true, translated files will be
recompiled whether or not their compilations are up-to-date (only supported
in Lisp right now).

`:load-system?' (default true): if true, compiled files will be loaded into
the current STELLA image (only supported in Lisp and Java right now).

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/MAKE-SYSTEM|)) (CL:MACRO-FUNCTION (CL:QUOTE MAKE-SYSTEM)))

;;; (DEFUN RUN-SYSTEM-FINALIZATION ...)

(CL:DEFUN RUN-SYSTEM-FINALIZATION (SYSTEM)
  (CL:SETQ SYSTEM SYSTEM)
  (CL:LET* ((FNNAME STELLA::NULL-STRING) (FINALIZATIONFN NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FNNAME))
   (CL:WHEN (CL:NOT (CL:EQ FNNAME STELLA::NULL-STRING))
    (CL:SETQ FINALIZATIONFN (LOOKUP-FUNCTION-BY-NAME FNNAME)))
   (CL:WHEN (CL:NOT (CL:EQ FINALIZATIONFN NULL))
    (CL:FUNCALL (%METHOD-SLOT.FUNCTION-CODE FINALIZATIONFN))))
  :VOID)

;;; (DEFUN (SYSTEM-DEFINITION-SOURCE-FILES (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN SYSTEM-DEFINITION-SOURCE-FILES (SYSTEM)
  (CL:LET* ((FILES (COPY-CONS-LIST (%SYSTEM-DEFINITION.FILES SYSTEM))))
   (CL:COND
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-COMMON-LISP)
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.JAVA-ONLY-FILES SYSTEM)))
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.CPP-ONLY-FILES SYSTEM))))
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-JAVA)
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.LISP-ONLY-FILES SYSTEM)))
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.CPP-ONLY-FILES SYSTEM))))
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-CPP)
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.LISP-ONLY-FILES SYSTEM)))
     (CL:SETQ FILES
      (SUBTRACT FILES (%SYSTEM-DEFINITION.JAVA-ONLY-FILES SYSTEM))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:RETURN-FROM SYSTEM-DEFINITION-SOURCE-FILES FILES)))

;;; (DEFUN (FILES-PLUS-SYSTEM-STARTUP (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN FILES-PLUS-SYSTEM-STARTUP (FILES)
  (CL:RETURN-FROM FILES-PLUS-SYSTEM-STARTUP
   (CONCATENATE FILES
    (CONS-LIST (WRAP-STRING (SYSTEM-STARTUP-FILE-NAME NULL))))))

;;; (DEFUN (SYSTEM-DEFINITION-NATIVE-FILES (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN SYSTEM-DEFINITION-NATIVE-FILES (SYSTEM)
  (CL:LET* ((FILES (COPY-CONS-LIST (%SYSTEM-DEFINITION.FILES SYSTEM))))
   (CL:COND
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-COMMON-LISP)
     (CL:SETQ FILES
      (UNION FILES (%SYSTEM-DEFINITION.LISP-ONLY-FILES SYSTEM)))
     (CL:WHEN
      (MEMB? *CURRENT-STELLA-FEATURES*
       KWD-SYSTEMS-USE-COMMON-LISP-STRUCTS)
      (CL:SETQ FILES
       (CONS
        (WRAP-STRING
         (CL-YIELD-STRUCT-CLASS-FILE-NAME
          (%SYSTEM-DEFINITION.NAME SYSTEM)))
        FILES))))
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-JAVA)
     (CL:SETQ FILES
      (UNION FILES (%SYSTEM-DEFINITION.JAVA-ONLY-FILES SYSTEM))))
    ((CL:EQ *TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-CPP)
     (CL:SETQ FILES
      (UNION FILES (%SYSTEM-DEFINITION.CPP-ONLY-FILES SYSTEM))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" *TRANSLATOROUTPUTLANGUAGE* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:RETURN-FROM SYSTEM-DEFINITION-NATIVE-FILES FILES)))

;;; (DEFUN (SYSTEM-LOADED? BOOLEAN) ...)

(CL:DEFUN SYSTEM-LOADED? (NAME)
  "Return `true' if system `name' has been loaded."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF (STRING-EQUAL? NAME "STELLA") (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((SYS NULL) (ITER-000 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SYS (%%VALUE ITER-000))
       (CL:WHEN
        (CL:AND (STRING-EQUAL? (%SYSTEM-DEFINITION.NAME SYS) NAME)
         (%SYSTEM-DEFINITION.LOADED? SYS))
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM SYSTEM-LOADED? VALUE-000))))

;;; (DEFUN (SYSTEM-LOADED-OR-STARTED-UP? BOOLEAN) ...)

(CL:DEFUN SYSTEM-LOADED-OR-STARTED-UP? (NAME)
  "Return `true' if system `name' has either been loaded
or initialized with its startup function."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF (STRING-EQUAL? NAME "STELLA") (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((SYS NULL) (ITER-000 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SYS (%%VALUE ITER-000))
       (CL:WHEN
        (CL:AND (STRING-EQUAL? (%SYSTEM-DEFINITION.NAME SYS) NAME)
         (CL:OR (%SYSTEM-DEFINITION.LOADED? SYS)
          (SYSTEM-STARTED-UP? (%SYSTEM-DEFINITION.NAME SYS)
           (%SYSTEM-DEFINITION.CARDINAL-MODULE SYS))))
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM SYSTEM-LOADED-OR-STARTED-UP? VALUE-000))))

;;; (DEFUN CLEAR-SYSTEM ...)

(CL:DEFUN CLEAR-SYSTEM (NAME)
  "Clears out the system definition named `name'.  If
`name' is `null', then clear out all system definitions.  This function
is useful when changes have been made to the system definition, and one
wants to have it reloaded from the standard location in the file system."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:IF (CL:EQ NAME STELLA::NULL-STRING)
   (CL:SETQ *SYSTEMDEFINITIONS* (NEW-LIST))
   (CL:LET* ((VALUE-000 NULL))
    (CL:LET*
     ((S NULL) (ITER-000 (%LIST.THE-CONS-LIST *SYSTEMDEFINITIONS*)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ S (%%VALUE ITER-000))
      (CL:WHEN (STRING-EQL? (%SYSTEM-DEFINITION.NAME S) NAME)
       (CL:SETQ VALUE-000 S) (CL:RETURN))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:LET* ((SYS VALUE-000))
     (CL:WHEN (CL:NOT (CL:EQ SYS NULL))
      (REMOVE *SYSTEMDEFINITIONS* SYS)))))
  :VOID)

;;; (DEFUN LOAD-PREPROCESSED-FILES ...)

(CL:DEFUN LOAD-PREPROCESSED-FILES (SYSTEMNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:WHEN
   (CL:OR (CL:NOT (RUNNING-AS-LISP?))
    (CL:EQ
     (%SYSTEM-DEFINITION.PREPROCESSED-FILES
      (GET-SYSTEM-DEFINITION SYSTEMNAME))
     NULL))
   (CL:RETURN-FROM LOAD-PREPROCESSED-FILES))
  (CL:LET* ((*TRANSLATOROUTPUTLANGUAGE* KWD-SYSTEMS-COMMON-LISP))
   (CL:DECLARE (CL:SPECIAL *TRANSLATOROUTPUTLANGUAGE*))
   (CL:LET*
    ((*CURRENTSYSTEMDEFINITION* (GET-SYSTEM-DEFINITION SYSTEMNAME))
     (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
      (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
       (%SYSTEM-DEFINITION.DIRECTORY *CURRENTSYSTEMDEFINITION*)
       STELLA::NULL-STRING)))
    (CL:DECLARE
     (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
      *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
    (CL:DECLARE
     (CL:TYPE CL:SIMPLE-STRING *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
    (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
     (CL:PROGN
      (CL:LET* ((PREPROCESSEDFILES NIL))
       (CL:LET*
        ((F NULL)
         (ITER-000
          (%SYSTEM-DEFINITION.PREPROCESSED-FILES
           *CURRENTSYSTEMDEFINITION*))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ F (%%VALUE ITER-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000
            (CONS
             (WRAP-STRING
              (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE F)
               KWD-SYSTEMS-STELLA CL:T))
             NIL))
           (CL:IF (CL:EQ PREPROCESSEDFILES NIL)
            (CL:SETQ PREPROCESSEDFILES COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST PREPROCESSEDFILES
             COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000)
            (CONS
             (WRAP-STRING
              (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE F)
               KWD-SYSTEMS-STELLA CL:T))
             NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:LET*
        ((*CURRENT-STELLA-FEATURES* (COPY *CURRENT-STELLA-FEATURES*)))
        (CL:DECLARE (CL:SPECIAL *CURRENT-STELLA-FEATURES*))
        (%UNSET-STELLA-FEATURE
         (CONS-LIST KWD-SYSTEMS-WARN-ABOUT-UNDEFINED-METHODS))
        (CL:LET* ((F NULL) (ITER-001 PREPROCESSEDFILES))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ F (%%VALUE ITER-001))
          (TRANSLATE-FILE (%STRING-WRAPPER.WRAPPER-VALUE F)
           *TRANSLATOROUTPUTLANGUAGE* CL:NIL)
          (CL:SETQ ITER-001 (%%REST ITER-001)))))
       (COMPILE-AND-LOAD-FILES
        (%SYSTEM-DEFINITION.PREPROCESSED-FILES
         *CURRENTSYSTEMDEFINITION*)
        *TRANSLATOROUTPUTLANGUAGE* CL:NIL)
       (CL:WHEN
        (MEMB? *CURRENT-STELLA-FEATURES*
         KWD-SYSTEMS-USE-COMMON-LISP-STRUCTS)
        (CL:LET*
         ((F NULL)
          (ITER-002
           (%SYSTEM-DEFINITION.PREPROCESSED-FILES
            *CURRENTSYSTEMDEFINITION*)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
          (CL:SETQ F (%%VALUE ITER-002))
          (DELETE-FILE
           (MAKE-FILE-NAME (%STRING-WRAPPER.WRAPPER-VALUE F)
            KWD-SYSTEMS-LISP CL:T))
          (CL:SETQ ITER-002 (%%REST ITER-002)))))
       (CL:LET*
        ((STARTUPFN NULL)
         (ITER-003
          (STARTUP-NAMES-FROM-FILES
           (%SYSTEM-DEFINITION.PREPROCESSED-FILES
            *CURRENTSYSTEMDEFINITION*))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
         (CL:SETQ STARTUPFN (%%VALUE ITER-003))
         (CL:funcall (lispify startupFn))
         (CL:SETQ ITER-003 (%%REST ITER-003))))))
     (CL:WARN "Can't find a system named `~A'~%" SYSTEMNAME))))
  :VOID)

;;; (DEFUN (LOAD-SYSTEM BOOLEAN) ...)

(CL:DEFUN %LOAD-SYSTEM (SYSTEMNAME |LANGUAGE&OPTIONS|)
  "Natively `language'-compile out-of-date translated files of system
`systemName' (only supported for Lisp at the moment) and then load them
into the running system.  Return true if at least one file was compiled.
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:force-recompilation?' (default false): if true, files will be compiled
whether or not their compilations are up-to-date.

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((OPTIONS |LANGUAGE&OPTIONS|)
    (LANGUAGE
     (CL:IF
      (MEMBER?
       (GET-QUOTED-TREE "((:COMMON-LISP :CPP :JAVA) \"/STELLA\")"
        "/STELLA")
       (%%VALUE OPTIONS))
      (%%VALUE OPTIONS) (RUNNING-IN-LANGUAGE)))
    (PLIST
     (VET-OPTIONS
      (CL:IF (CL:EQ (%%VALUE OPTIONS) LANGUAGE) (%%REST OPTIONS)
       OPTIONS)
      (GET-QUOTED-TREE
       "((:FORCE-RECOMPILATION? :STARTUP? :LANGUAGE :ACTION) \"/STELLA\")"
       "/STELLA")))
    (FORCERECOMPILATION? CL:NIL) (STARTUPSYSTEM? CL:T)
    (TRANSLATEDFILE? CL:NIL))
   (CL:SETQ LANGUAGE
    (LOOKUP-WITH-DEFAULT PLIST KWD-SYSTEMS-LANGUAGE LANGUAGE))
   (INSERT-AT PLIST KWD-SYSTEMS-LANGUAGE LANGUAGE)
   (INSERT-AT PLIST KWD-SYSTEMS-ACTION
    (LOOKUP-WITH-DEFAULT PLIST KWD-SYSTEMS-ACTION
     KWD-SYSTEMS-LOAD-SYSTEM))
   (CL:LET*
    ((KEY NULL) (VALUE NULL)
     (ITER-000 (%PROPERTY-LIST.THE-PLIST PLIST)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ KEY (%%VALUE ITER-000))
     (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
     (CL:LET* ((TEST-VALUE-000 KEY))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-FORCE-RECOMPILATION?)
        (CL:SETQ FORCERECOMPILATION? (EQL? VALUE TRUE-WRAPPER)))
       ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-STARTUP?)
        (CL:SETQ STARTUPSYSTEM? (EQL? VALUE TRUE-WRAPPER)))
       (CL:T)))
     (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
   (CL:LET* ((*CURRENT-SYSTEM-ACTION* (COPY PLIST)))
    (CL:DECLARE (CL:SPECIAL *CURRENT-SYSTEM-ACTION*))
    (CL:LET*
     ((*CURRENTSYSTEMDEFINITION* (GET-SYSTEM-DEFINITION SYSTEMNAME))
      (*CURRENTSYSTEMDEFINITIONSUBDIRECTORY*
       (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
        (%SYSTEM-DEFINITION.DIRECTORY *CURRENTSYSTEMDEFINITION*)
        STELLA::NULL-STRING)))
     (CL:DECLARE
      (CL:SPECIAL *CURRENTSYSTEMDEFINITION*
       *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
     (CL:DECLARE
      (CL:TYPE CL:SIMPLE-STRING *CURRENTSYSTEMDEFINITIONSUBDIRECTORY*))
     (CL:IF (CL:NOT (CL:EQ *CURRENTSYSTEMDEFINITION* NULL))
      (CL:PROGN
       (CL:WHEN (%SYSTEM-DEFINITION.LOADED? *CURRENTSYSTEMDEFINITION*)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "Loading system `" SYSTEMNAME "' over top of itself." EOL
         EOL))
       (CL:WHEN (RUNNING-AS-LISP?)
        (CL:SETQ TRANSLATEDFILE?
         (COMPILE-AND-LOAD-FILES
          (FILES-PLUS-SYSTEM-STARTUP
           (SYSTEM-DEFINITION-NATIVE-FILES *CURRENTSYSTEMDEFINITION*))
          LANGUAGE FORCERECOMPILATION?)))
       (CL:SETF (%SYSTEM-DEFINITION.LOADED? *CURRENTSYSTEMDEFINITION*)
        CL:T)
       (CL:WHEN STARTUPSYSTEM?
        (RUN-SYSTEM-STARTUP-FUNCTION *CURRENTSYSTEMDEFINITION*)))
      (CL:WARN "Can't find a system named `~A'~%" SYSTEMNAME)))
    (CL:RETURN-FROM %LOAD-SYSTEM TRANSLATEDFILE?))))

(CL:DEFUN LOAD-SYSTEM-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM LOAD-SYSTEM-EVALUATOR-WRAPPER
   (CL:IF
    (%LOAD-SYSTEM (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))
     (%%REST ARGUMENTS))
    TRUE-WRAPPER FALSE-WRAPPER)))

(CL:DEFMACRO LOAD-SYSTEM (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Natively `language'-compile out-of-date translated files of system
`systemName' (only supported for Lisp at the moment) and then load them
into the running system.  Return true if at least one file was compiled.
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:force-recompilation?' (default false): if true, files will be compiled
whether or not their compilations are up-to-date.

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/LOAD-SYSTEM|)) (CL:MACRO-FUNCTION (CL:QUOTE LOAD-SYSTEM)))

;;; (DEFUN (COMPILE-AND-LOAD-FILES BOOLEAN) ...)

(CL:DEFUN COMPILE-AND-LOAD-FILES (FILES LANGUAGE FORCERECOMPILATION?)
  (CL:COND
   ((CL:EQ LANGUAGE KWD-SYSTEMS-COMMON-LISP)
    (CL:RETURN-FROM COMPILE-AND-LOAD-FILES
     (CL-COMPILE-AND-LOAD-FILES FILES CL:T FORCERECOMPILATION?)))
   (CL:T
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "'compile-and-load-files' NOT IMPLEMENTED FOR " LANGUAGE EOL)
    (CL:RETURN-FROM COMPILE-AND-LOAD-FILES CL:NIL))))

;;; (DEFUN RUN-SYSTEM-STARTUP-FUNCTION ...)

(CL:DEFUN RUN-SYSTEM-STARTUP-FUNCTION (SYSTEM)
  (CL:LET* ((STARTUPFNSYMBOL (SYSTEM-STARTUP-FUNCTION-SYMBOL SYSTEM)))
   (CL:FUNCALL (LISPIFY STARTUPFNSYMBOL)))
  :VOID)

;;; (DEFMETHOD (SYSTEM-STARTUP-FUNCTION-NAME STRING) ...)

(CL:DEFMETHOD SYSTEM-STARTUP-FUNCTION-NAME ((SYSTEM SYSTEM-DEFINITION))
  (CL:RETURN-FROM SYSTEM-STARTUP-FUNCTION-NAME
   (SYSTEM-STARTUP-FUNCTION-NAME (%SYSTEM-DEFINITION.NAME SYSTEM))))

;;; (DEFMETHOD (SYSTEM-STARTUP-FUNCTION-NAME STRING) ...)

(CL:DEFMETHOD SYSTEM-STARTUP-FUNCTION-NAME ((SYSTEMNAME CL:STRING))
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM SYSTEM-STARTUP-FUNCTION-NAME
   (CONCATENATE "STARTUP-" (STRING-UPCASE SYSTEMNAME) "-SYSTEM")))

;;; (DEFUN (SYSTEM-STARTUP-FUNCTION-SYMBOL SYMBOL) ...)

(CL:DEFUN SYSTEM-STARTUP-FUNCTION-SYMBOL (SYSTEM)
  (CL:RETURN-FROM SYSTEM-STARTUP-FUNCTION-SYMBOL
   (INTERN-SYMBOL-IN-MODULE (SYSTEM-STARTUP-FUNCTION-NAME SYSTEM)
    (GET-CARDINAL-MODULE SYSTEM) CL:T)))

;;; (DEFUN (STARTUP-NAME-FROM-FILE SYMBOL) ...)

(CL:DEFUN STARTUP-NAME-FROM-FILE (FILE)
  (CL:WHEN
   (CL:NOT (PROBE-FILE? (MAKE-FILE-NAME FILE KWD-SYSTEMS-STELLA CL:T)))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "STELLA source file `"
     (MAKE-FILE-NAME FILE KWD-SYSTEMS-STELLA CL:T) "' does not exist")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((LONGNAME (MAKE-FILE-NAME FILE KWD-SYSTEMS-STELLA CL:T))
    (SAVEDMODULE *MODULE*) (SEENINMODULE? CL:NIL) (UNUSED? CL:NIL)
    (STARTUPFNNAME NULL))
   (CL:LET* ((INPUTSTREAM NULL))
    (CL:UNWIND-PROTECT
     (CL:PROGN (CL:SETQ INPUTSTREAM (OPEN-INPUT-FILE LONGNAME))
      (CL:LET* ((*TRANSIENTOBJECTS?* CL:T))
       (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
       (CL:LET* ((TREE NULL) (ITER-000 (S-EXPRESSIONS INPUTSTREAM)))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ TREE (%S-EXPRESSION-ITERATOR.VALUE ITER-000))
         (CL:LET* ((*TRANSIENTOBJECTS?* CL:NIL))
          (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
          (CL:COND
           ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-SYSTEMS-STELLA-CONS)
            (CL:PROGN
             (CL:MULTIPLE-VALUE-SETQ (UNUSED? SEENINMODULE?)
              (HANDLE-IN-MODULE-TREE TREE SEENINMODULE? CL:T))
             (CL:SETQ UNUSED? UNUSED?)
             (CL:WHEN SEENINMODULE?
              (CL:SETQ STARTUPFNNAME
               (YIELD-STARTUP-FUNCTION-NAME FILE))
              (CHANGE-MODULE SAVEDMODULE)
              (CL:RETURN-FROM STARTUP-NAME-FROM-FILE STARTUPFNNAME))))
           (CL:T)))))))
     (CL:WHEN (CL:NOT (CL:EQ INPUTSTREAM NULL)) (FREE INPUTSTREAM))))
   (CL:WARN "Missing IN-MODULE declaration for file `~A'~%" FILE))
  (CL:RETURN-FROM STARTUP-NAME-FROM-FILE NULL))

;;; (DEFUN (STARTUP-NAMES-FROM-FILES (CONS OF SYMBOL)) ...)

(CL:DEFUN STARTUP-NAMES-FROM-FILES (FILES)
  (CL:LET* ((NAMES NIL))
   (CL:LET* ((F NULL) (ITER-000 FILES) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ F (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (STARTUP-NAME-FROM-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
         NIL))
       (CL:IF (CL:EQ NAMES NIL) (CL:SETQ NAMES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST NAMES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (STARTUP-NAME-FROM-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM STARTUP-NAMES-FROM-FILES NAMES)))

;;; (DEFUN (SYSTEM-STARTUP-FILE-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  SYSTEM-STARTUP-FILE-NAME))
(CL:DEFUN SYSTEM-STARTUP-FILE-NAME (SYSTEM)
  (CL:WHEN (CL:EQ SYSTEM NULL)
   (CL:SETQ SYSTEM *CURRENTSYSTEMDEFINITION*))
  (CL:IF (CL:NOT (CL:EQ SYSTEM NULL))
   (CL:RETURN-FROM SYSTEM-STARTUP-FILE-NAME "startup-system")
   (CL:RETURN-FROM SYSTEM-STARTUP-FILE-NAME STELLA::NULL-STRING)))

;;; (DEFUN (SYSTEM-STARTUP-FILE? BOOLEAN) ...)

(CL:DEFUN SYSTEM-STARTUP-FILE? (FILE)
  (CL:WHEN (CL:EQ FILE STELLA::NULL-STRING)
   (CL:SETQ FILE *CURRENTFILE*))
  (CL:RETURN-FROM SYSTEM-STARTUP-FILE?
   (CL:AND (CL:NOT (CL:EQ FILE STELLA::NULL-STRING))
    (STRING-EQL? (FILE-BASE-NAME FILE)
     (SYSTEM-STARTUP-FILE-NAME NULL)))))

;;; (DEFUN (SYSTEM-STARTED-UP? BOOLEAN) ...)

(CL:DEFUN SYSTEM-STARTED-UP? (SYSTEMNAME SYSTEMMODULENAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEMNAME SYSTEMMODULENAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SYSTEMMODULENAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ *FUNCTION-LOOKUP-TABLE* NULL)
   (CL:RETURN-FROM SYSTEM-STARTED-UP? CL:NIL))
  (CL:WHEN (STRING-EQUAL? SYSTEMNAME "STELLA")
   (CL:RETURN-FROM SYSTEM-STARTED-UP?
    (CL:NOT (CL:EQ *FUNCTION-LOOKUP-TABLE* NULL))))
  (CL:WHEN (CL:EQ (GET-STELLA-MODULE SYSTEMMODULENAME CL:NIL) NULL)
   (CL:RETURN-FROM SYSTEM-STARTED-UP? CL:NIL))
  (CL:LET*
   ((STARTUPFUNCTIONSYMBOL
     (LOOKUP-SYMBOL-IN-MODULE (SYSTEM-STARTUP-FUNCTION-NAME SYSTEMNAME)
      (GET-STELLA-MODULE SYSTEMMODULENAME CL:NIL) CL:T))
    (STARTUPFUNCTION
     (CL:IF (CL:NOT (CL:EQ STARTUPFUNCTIONSYMBOL NULL))
      (LOOKUP-FUNCTION STARTUPFUNCTIONSYMBOL) NULL)))
   (CL:RETURN-FROM SYSTEM-STARTED-UP?
    (CL:AND (CL:NOT (CL:EQ STARTUPFUNCTION NULL))
     (CL:NOT
      (CL:EQ (%METHOD-SLOT.FUNCTION-CODE STARTUPFUNCTION) NULL))))))

;;; (DEFUN (YIELD-STARTUP-REQUIRED-SYSTEMS CONS) ...)

(CL:DEFUN YIELD-STARTUP-REQUIRED-SYSTEMS (SYSTEM)
  (CL:LET* ((STARTUPFORMS NIL))
   (CL:LET*
    ((SYSTEMNAME NULL)
     (ITER-000 (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS SYSTEM))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SYSTEMNAME (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (LIST* SYM-SYSTEMS-STELLA-UNLESS
          (LIST* SYM-SYSTEMS-STELLA-SYSTEM-STARTED-UP? SYSTEMNAME
           (CONS
            (WRAP-STRING
             (%MODULE.MODULE-FULL-NAME
              (GET-CARDINAL-MODULE
               (GET-SYSTEM-DEFINITION
                (%STRING-WRAPPER.WRAPPER-VALUE SYSTEMNAME)))))
            NIL))
          (CONS
           (SYSTEM-STARTUP-FUNCTION-SYMBOL
            (GET-SYSTEM-DEFINITION
             (%STRING-WRAPPER.WRAPPER-VALUE SYSTEMNAME)))
           NIL)
          NIL)
         NIL))
       (CL:IF (CL:EQ STARTUPFORMS NIL)
        (CL:SETQ STARTUPFORMS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST STARTUPFORMS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (LIST* SYM-SYSTEMS-STELLA-UNLESS
          (LIST* SYM-SYSTEMS-STELLA-SYSTEM-STARTED-UP? SYSTEMNAME
           (CONS
            (WRAP-STRING
             (%MODULE.MODULE-FULL-NAME
              (GET-CARDINAL-MODULE
               (GET-SYSTEM-DEFINITION
                (%STRING-WRAPPER.WRAPPER-VALUE SYSTEMNAME)))))
            NIL))
          (CONS
           (SYSTEM-STARTUP-FUNCTION-SYMBOL
            (GET-SYSTEM-DEFINITION
             (%STRING-WRAPPER.WRAPPER-VALUE SYSTEMNAME)))
           NIL)
          NIL)
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM YIELD-STARTUP-REQUIRED-SYSTEMS
    (LIST* SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN
     KWD-SYSTEMS-EARLY-INITS (CONCATENATE STARTUPFORMS NIL)))))

;;; (DEFUN (COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE (CONS OF CONS)) ...)

(CL:DEFUN COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE (SYSTEM)
  (CL:LET*
   ((SYSTEMFILENAME
     (MAKE-SYSTEM-DEFINITION-FILE-NAME
      (%SYSTEM-DEFINITION.NAME SYSTEM)))
    (MODULE NULL) (STARTUPFORM NULL) (STARTUPFORMS NIL))
   (CL:LET* ((*MODULE* *MODULE*) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET* ((INPUTSTREAM NULL))
     (CL:UNWIND-PROTECT
      (CL:PROGN (CL:SETQ INPUTSTREAM (OPEN-INPUT-FILE SYSTEMFILENAME))
       (CL:LET*
        ((TREE NULL) (ITER-000 (S-EXPRESSIONS INPUTSTREAM))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ TREE (%S-EXPRESSION-ITERATOR.VALUE ITER-000))
         (CL:TAGBODY (CL:SETQ STARTUPFORM NULL)
          (CL:COND
           ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-SYSTEMS-STELLA-CONS)
            (CL:PROGN
             (CL:WHEN
              (CL:EQ (%%VALUE TREE) SYM-SYSTEMS-STELLA-DEFMODULE)
              (%EVALUATE TREE)
              (CL:SETQ MODULE
               (GET-STELLA-MODULE
                (COERCE-TO-MODULE-NAME (%%VALUE (%%REST TREE)) CL:T)
                CL:T))
              (CL:WHEN (CL:NOT (CL:EQ MODULE NULL))
               (CL:SETQ STARTUPFORM
                (LIST* SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN
                 KWD-SYSTEMS-MODULES (YIELD-DEFINE-MODULE MODULE)
                 NIL))))
             (CL:WHEN
              (CL:EQ (%%VALUE TREE) SYM-SYSTEMS-STELLA-IN-MODULE)
              (%EVALUATE TREE))))
           (CL:T))
          (CL:WHEN (CL:EQ STARTUPFORM NULL) (CL:GO :CONTINUE))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS STARTUPFORM NIL))
            (CL:IF (CL:EQ STARTUPFORMS NIL)
             (CL:SETQ STARTUPFORMS COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST STARTUPFORMS COLLECT-000)))
           (CL:PROGN
            (CL:SETF (%%REST COLLECT-000) (CONS STARTUPFORM NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
          :CONTINUE))))
      (CL:WHEN (CL:NOT (CL:EQ INPUTSTREAM NULL)) (FREE INPUTSTREAM))))
    (CL:RETURN-FROM COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE
     STARTUPFORMS))))

;;; (DEFUN CREATE-SYSTEM-STARTUP-FILE ...)

(CL:DEFUN CREATE-SYSTEM-STARTUP-FILE (SYSTEM)
  (CL:WHEN (CL:EQ *CURRENTSYSTEMDEFINITION* NULL)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Must be within a system environment to create startup file " EOL
    "   for system `" (%SYSTEM-DEFINITION.NAME SYSTEM) "'." EOL EOL)
   (CL:RETURN-FROM CREATE-SYSTEM-STARTUP-FILE))
  (CL:LET*
   ((*MODULE* (GET-CARDINAL-MODULE SYSTEM)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET*
    ((FILE
      (MAKE-FILE-NAME (SYSTEM-STARTUP-FILE-NAME SYSTEM)
       KWD-SYSTEMS-STELLA CL:T))
     (STARTUPFNNAMES NIL) (STARTUPFORMS NIL))
    (CL:LET* ((OUTPUTSTREAM NULL))
     (CL:UNWIND-PROTECT
      (CL:PROGN (CL:SETQ OUTPUTSTREAM (OPEN-OUTPUT-FILE FILE))
       (CL:LET*
        ((F NULL) (ITER-000 (SYSTEM-DEFINITION-SOURCE-FILES SYSTEM))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ F (%%VALUE ITER-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000
            (CONS
             (STARTUP-NAME-FROM-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
             NIL))
           (CL:IF (CL:EQ STARTUPFNNAMES NIL)
            (CL:SETQ STARTUPFNNAMES COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST STARTUPFNNAMES COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000)
            (CONS
             (STARTUP-NAME-FROM-FILE (%STRING-WRAPPER.WRAPPER-VALUE F))
             NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL-OUTPUT-FILE-HEADER OUTPUTSTREAM FILE CL:NIL)
       (CL:SETQ STARTUPFORMS
        (CONS
         (LIST* SYM-SYSTEMS-STELLA-IN-MODULE
          (WRAP-STRING
           (%MODULE.MODULE-FULL-NAME (GET-CARDINAL-MODULE SYSTEM)))
          NIL)
         STARTUPFORMS))
       (CL:SETQ STARTUPFORMS
        (CONS
         (LIST* SYM-SYSTEMS-STELLA-DEFUN
          (SYSTEM-STARTUP-FUNCTION-SYMBOL SYSTEM)
          (LIST* NIL KWD-SYSTEMS-PUBLIC? SYM-SYSTEMS-STELLA-TRUE NIL))
         STARTUPFORMS))
       (CL:COND
        ((STRING-EQUAL? (%SYSTEM-DEFINITION.NAME SYSTEM) "STELLA")
         (CL:SETQ STARTUPFORMS
          (CONS
           (LIST* SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN
            KWD-SYSTEMS-EARLY-INITS
            (LIST* SYM-SYSTEMS-STELLA-UNLESS
             (LIST* SYM-SYSTEMS-STELLA-SYSTEM-STARTED-UP?
              (WRAP-STRING "stella") (WRAP-STRING "/STELLA") NIL)
             (LIST* SYM-SYSTEMS-STELLA-STARTUP SYM-SYSTEMS-STELLA-FALSE
              NIL)
             NIL)
            NIL)
           STARTUPFORMS)))
        (CL:T
         (CL:WHEN
          (CL:NOT
           (CL:EQ (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS SYSTEM) NULL))
          (CL:SETQ STARTUPFORMS
           (CONS (YIELD-STARTUP-REQUIRED-SYSTEMS SYSTEM)
            STARTUPFORMS)))
         (CL:LET*
          ((FORM NULL)
           (ITER-001 (COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE SYSTEM)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ FORM (%%VALUE ITER-001))
           (CL:SETQ STARTUPFORMS (CONS FORM STARTUPFORMS))
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (CL:LET* ((STARTUPFN NULL) (ITER-002 STARTUPFNNAMES))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
           (CL:SETQ STARTUPFN (%%VALUE ITER-002))
           (CL:WHEN (CL:EQ (LOOKUP-FUNCTION STARTUPFN) NULL)
            (CL:LET*
             ((*MODULE* (HOME-MODULE STARTUPFN)) (*CONTEXT* *MODULE*))
             (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
             (DEFINE-METHOD-FROM-PARSE-TREE
              (LIST* SYM-SYSTEMS-STELLA-DEFUN STARTUPFN
               (LIST* NIL KWD-SYSTEMS-PUBLIC? SYM-SYSTEMS-STELLA-TRUE
                NIL)))))
           (CL:SETQ ITER-002 (%%REST ITER-002))))
         (CL:LET* ((STARTUPFNCALLS NIL))
          (CL:LET*
           ((STARTUPFN NULL) (ITER-003 STARTUPFNNAMES)
            (COLLECT-001 NULL))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
            (CL:SETQ STARTUPFN (%%VALUE ITER-003))
            (CL:IF (CL:EQ COLLECT-001 NULL)
             (CL:PROGN
              (CL:SETQ COLLECT-001 (CONS (CONS STARTUPFN NIL) NIL))
              (CL:IF (CL:EQ STARTUPFNCALLS NIL)
               (CL:SETQ STARTUPFNCALLS COLLECT-001)
               (ADD-CONS-TO-END-OF-CONS-LIST STARTUPFNCALLS
                COLLECT-001)))
             (CL:PROGN
              (CL:SETF (%%REST COLLECT-001)
               (CONS (CONS STARTUPFN NIL) NIL))
              (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
            (CL:SETQ ITER-003 (%%REST ITER-003))))
          (CL:SETQ STARTUPFORMS
           (CONS
            (LIST* SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN
             (LIST* SYM-SYSTEMS-STELLA-FOREACH SYM-SYSTEMS-STELLA-PHASE
              SYM-SYSTEMS-STELLA-IN
              (LIST* SYM-SYSTEMS-STELLA-INTERVAL
               (LIST* SYM-SYSTEMS-STELLA-PHASE-TO-INTEGER
                KWD-SYSTEMS-EARLY-INITS NIL)
               (LIST* SYM-SYSTEMS-STELLA-PHASE-TO-INTEGER
                KWD-SYSTEMS-FINAL NIL)
               NIL)
              SYM-SYSTEMS-STELLA-DO
              (LIST* SYM-SYSTEMS-STELLA-SETQ
               SYM-SYSTEMS-STELLA-*STARTUP-TIME-PHASE*
               SYM-SYSTEMS-STELLA-PHASE NIL)
              (CONCATENATE STARTUPFNCALLS NIL))
             (LIST* SYM-SYSTEMS-STELLA-SETQ
              SYM-SYSTEMS-STELLA-*STARTUP-TIME-PHASE*
              (WRAP-INTEGER 999) NIL)
             NIL)
            STARTUPFORMS)))))
       (CL:LET* ((*PRINTREADABLY?* CL:T) (*PRINTPRETTY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?* *PRINTPRETTY?*))
        (CL:LET* ((FORM NULL) (ITER-004 (REVERSE STARTUPFORMS)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
          (CL:SETQ FORM (%%VALUE ITER-004))
          (%%PRINT-STREAM
           (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUTPUTSTREAM) FORM EOL
           EOL)
          (CL:SETQ ITER-004 (%%REST ITER-004))))))
      (CL:WHEN (CL:NOT (CL:EQ OUTPUTSTREAM NULL))
       (FREE OUTPUTSTREAM))))))
  :VOID)

;;; (DEFUN (HELP-ALL-REQUIRED-SYSTEMS (LIST OF STRING-WRAPPER)) ...)

(CL:DEFUN HELP-ALL-REQUIRED-SYSTEMS (SYSTEM-NAME FOUND)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEM-NAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEM-NAME CL:SIMPLE-STRING)
  (CL:LET* ((SYSTEM (GET-SYSTEM-DEFINITION SYSTEM-NAME)))
   (CL:WHEN (CL:EQ SYSTEM NULL)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Couldn't find system `" SYSTEM-NAME "'")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (CL:LET*
    ((REQUIRED-SYSTEM-NAMES
      (%SYSTEM-DEFINITION.REQUIRED-SYSTEMS SYSTEM)))
    (CL:WHEN (CL:NOT (CL:EQ REQUIRED-SYSTEM-NAMES NULL))
     (CL:LET* ((SYS NULL) (ITER-000 REQUIRED-SYSTEM-NAMES))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SYS (%%VALUE ITER-000))
       (CL:WHEN (CL:NOT (MEMBER? FOUND SYS))
        (HELP-ALL-REQUIRED-SYSTEMS (%STRING-WRAPPER.WRAPPER-VALUE SYS)
         FOUND)
        (PUSH FOUND SYS))
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:RETURN-FROM HELP-ALL-REQUIRED-SYSTEMS FOUND))))

;;; (DEFUN (ALL-REQUIRED-SYSTEMS (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN ALL-REQUIRED-SYSTEMS (SYSTEM-NAME)
  "Returns a CONS of all of the systems required by `system-name'"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYSTEM-NAME))
  #+MCL
  (CL:CHECK-TYPE SYSTEM-NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM ALL-REQUIRED-SYSTEMS
   (%LIST.THE-CONS-LIST
    (HELP-ALL-REQUIRED-SYSTEMS SYSTEM-NAME (NEW-LIST)))))

;;; (DEFUN (AUTOLOAD FUNCTION-CODE) ...)

(CL:DEFUN AUTOLOAD (QUALIFIEDNAME SYSTEMNAME CACHE ERROR?)
  "Autoload function `qualifiedName' from system `systemName'.
If it is already present in the system, simply return its code.  If `cache'
is defined, return its value if defined, otherwise, set its value to the
function found.  If the function failed to be defined by loading `systemName'
and `error?' is true, raise an error.  Otherwise, simply return NULL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUALIFIEDNAME SYSTEMNAME))
  #+MCL
  (CL:CHECK-TYPE QUALIFIEDNAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SYSTEMNAME CL:SIMPLE-STRING)
  (CL:LET* ((FUNCTION NULL))
   (CL:WHEN (CL:NOT (CL:EQ CACHE NULL))
    (CL:LET* ((FUNCTIONWRAPPER (%SURROGATE.SURROGATE-VALUE CACHE)))
     (CL:WHEN (CL:NOT (CL:EQ FUNCTIONWRAPPER NULL))
      (CL:RETURN-FROM AUTOLOAD
       (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE FUNCTIONWRAPPER)))))
   (CL:HANDLER-CASE
    (CL:LET*
     ((FUNCTIONNAME STELLA::NULL-STRING)
      (FUNCTIONMODULENAME STELLA::NULL-STRING) (TYPE NULL))
     (CL:DECLARE
      (CL:TYPE CL:SIMPLE-STRING FUNCTIONNAME FUNCTIONMODULENAME))
     (CL:MULTIPLE-VALUE-SETQ (FUNCTIONNAME FUNCTIONMODULENAME TYPE)
      (PARSE-STELLA-NAME QUALIFIEDNAME CL:NIL))
     (CL:SETQ TYPE TYPE)
     (CL:LET*
      ((FUNCTIONMODULE NULL) (FUNCTIONNAMESYMBOL NULL)
       (FUNCTIONOBJECT NULL))
      (CL:WHEN (CL:NOT (CL:EQ FUNCTIONMODULENAME STELLA::NULL-STRING))
       (CL:SETQ FUNCTIONMODULE
        (GET-STELLA-MODULE FUNCTIONMODULENAME
         (CL:AND ERROR? (CL:EQ SYSTEMNAME STELLA::NULL-STRING)))))
      (CL:WHEN (CL:NOT (CL:EQ FUNCTIONMODULE NULL))
       (CL:SETQ FUNCTIONNAMESYMBOL
        (LOOKUP-SYMBOL-IN-MODULE FUNCTIONNAME FUNCTIONMODULE CL:NIL)))
      (CL:WHEN (CL:NOT (CL:EQ FUNCTIONNAMESYMBOL NULL))
       (CL:SETQ FUNCTIONOBJECT (LOOKUP-FUNCTION FUNCTIONNAMESYMBOL)))
      (CL:COND
       ((CL:NOT (CL:EQ FUNCTIONOBJECT NULL))
        (CL:SETQ FUNCTION (%METHOD-SLOT.FUNCTION-CODE FUNCTIONOBJECT)))
       ((CL:AND (CL:NOT (CL:EQ SYSTEMNAME STELLA::NULL-STRING))
         (CL:NOT (SYSTEM-LOADED? SYSTEMNAME)))
        (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
         (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
         (%MAKE-SYSTEM SYSTEMNAME NIL))
        (CL:RETURN-FROM AUTOLOAD
         (AUTOLOAD QUALIFIEDNAME STELLA::NULL-STRING CACHE ERROR?))))))
    (STELLA-EXCEPTION (E)
     (CL:WHEN ERROR?
      (CL:IF (CL:NOT (CL:EQ SYSTEMNAME STELLA::NULL-STRING))
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "autoload: failed to define `" QUALIFIEDNAME "': `"
         (EXCEPTION-MESSAGE E) "'")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
       (CL:ERROR E)))))
   (CL:WHEN (CL:EQ FUNCTION NULL)
    (CL:IF ERROR?
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "autoload: failed to define `" QUALIFIEDNAME "'")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))
     (CL:RETURN-FROM AUTOLOAD NULL)))
   (CL:WHEN (CL:NOT (CL:EQ CACHE NULL))
    (CL:SETF (%SURROGATE.SURROGATE-VALUE CACHE)
     (WRAP-FUNCTION-CODE FUNCTION)))
   (CL:RETURN-FROM AUTOLOAD FUNCTION)))

;;; (DEFUN MAKE-STELLA ...)

(CL:DEFUN MAKE-STELLA (FORCERECOMPILATION?)
  (%MAKE-SYSTEM "STELLA"
   (CONS-LIST KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FORCE-TRANSLATION?
    (CL:IF FORCERECOMPILATION? TRUE-WRAPPER FALSE-WRAPPER)
    KWD-SYSTEMS-DEVELOPMENT-SETTINGS? FALSE-WRAPPER))
  :VOID)

;;; (DEFUN (PARSE-CONFIGURATION-FILE-LINE STRING-WRAPPER WRAPPER KEYWORD) ...)

(CL:DEFUN PARSE-CONFIGURATION-FILE-LINE (LINE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
  #+MCL
  (CL:CHECK-TYPE LINE CL:SIMPLE-STRING)
  (CL:LET*
   ((START 0) (HASHPOS (POSITION LINE #\# 0))
    (EQUALPOS (POSITION LINE #\= 0)) (END EQUALPOS)
    (LENGTH (CL:THE CL:FIXNUM (CL:LENGTH LINE)))
    (PROPERTY STELLA::NULL-STRING) (VALUESTRING STELLA::NULL-STRING)
    (VALUE NULL) (OPERATOR KWD-SYSTEMS-SET))
   (CL:DECLARE (CL:TYPE CL:FIXNUM START HASHPOS EQUALPOS END LENGTH)
    (CL:TYPE CL:SIMPLE-STRING PROPERTY VALUESTRING))
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 0)
      (UPPER-BOUND-000
       (CL:1-
        (CL:IF (CL:NOT (CL:= HASHPOS NULL-INTEGER)) HASHPOS LENGTH))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
      (CL:SETQ I ITER-000)
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (CL:AREF *CHARACTER-TYPE-TABLE*
          (CL:THE CL:FIXNUM
           (CL:CHAR-CODE
            (CL:LET ((SELF LINE) (POSITION I))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
              (CL:TYPE CL:FIXNUM POSITION))
             (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
              (CL:THE CL:FIXNUM POSITION))))))
         KWD-SYSTEMS-WHITE-SPACE))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    (CL:WHEN ALWAYS?-000
     (CL:RETURN-FROM PARSE-CONFIGURATION-FILE-LINE
      (CL:VALUES NULL NULL NULL))))
   (CL:WHEN (CL:OR (CL:= EQUALPOS NULL-INTEGER) (CL:= EQUALPOS 0))
    (CL:WARN "Illegal line in configuration file: `~A'" LINE)
    (CL:RETURN-FROM PARSE-CONFIGURATION-FILE-LINE
     (CL:VALUES NULL NULL NULL)))
   (CL:LOOP WHILE
    (CL:EQ
     (CL:AREF *CHARACTER-TYPE-TABLE*
      (CL:THE CL:FIXNUM
       (CL:CHAR-CODE
        (CL:LET ((SELF LINE) (POSITION START))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))))
     KWD-SYSTEMS-WHITE-SPACE)
    DO (CL:SETQ START (CL:1+ START)))
   (CL:WHEN
    (CL:EQL
     (CL:LET ((SELF LINE) (POSITION (CL:1- END)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION)))
     #\+)
    (CL:SETQ OPERATOR KWD-SYSTEMS-ADD) (CL:SETQ END (CL:1- END)))
   (CL:LOOP WHILE
    (CL:EQ
     (CL:AREF *CHARACTER-TYPE-TABLE*
      (CL:THE CL:FIXNUM
       (CL:CHAR-CODE
        (CL:LET ((SELF LINE) (POSITION (CL:1- END)))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))))
     KWD-SYSTEMS-WHITE-SPACE)
    DO (CL:SETQ END (CL:1- END)))
   (CL:WHEN (CL:<= END START)
    (CL:WARN "Illegal property in configuration file: `~A'" LINE)
    (CL:RETURN-FROM PARSE-CONFIGURATION-FILE-LINE
     (CL:VALUES NULL NULL NULL)))
   (CL:SETQ PROPERTY (SUBSEQUENCE LINE START END))
   (CL:SETQ VALUESTRING (SUBSEQUENCE LINE (CL:1+ EQUALPOS) LENGTH))
   (CL:COND
    ((STRING-EQUAL? VALUESTRING "TRUE") (CL:SETQ VALUE TRUE-WRAPPER))
    ((STRING-EQUAL? VALUESTRING "FALSE") (CL:SETQ VALUE FALSE-WRAPPER))
    (CL:T
     (CL:HANDLER-CASE
      (CL:LET*
       ((TEST-VALUE-000
         (SAFE-PRIMARY-TYPE
          (CL:SETQ VALUE
           (READ-S-EXPRESSION-FROM-STRING VALUESTRING)))))
       (CL:COND
        ((CL:OR (SUBTYPE-OF-INTEGER? TEST-VALUE-000)
          (SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
          (SUBTYPE-OF-FLOAT? TEST-VALUE-000)))
        (CL:T (CL:SETQ VALUE (WRAP-STRING VALUESTRING)))))
      (READ-EXCEPTION () (CL:SETQ VALUE (WRAP-STRING VALUESTRING))))))
   (CL:RETURN-FROM PARSE-CONFIGURATION-FILE-LINE
    (CL:VALUES (WRAP-STRING PROPERTY) VALUE OPERATOR))))

;;; (DEFGLOBAL *SYSTEM-CONFIGURATION-TABLE* ...)

(CL:DEFVAR *SYSTEM-CONFIGURATION-TABLE* NULL)

;;; (DEFUN (LOAD-CONFIGURATION-FILE CONFIGURATION-TABLE) ...)

(CL:DEFUN %LOAD-CONFIGURATION-FILE (FILE)
  "Read a configuration `file' and return its content as a configuration table.
Also enter each property read into the global system configuration table.
Assumes Java-style property file syntax.  Each property name is represented
as a wrapped string and each value as a wrapped string/integer/float or boolean."
  (CL:LET* ((TEMP-000 (FIND-FILE-IN-LOAD-PATH FILE NULL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-000))
   (CL:SETQ FILE
    (CL:IF (CL:NOT (CL:EQ TEMP-000 STELLA::NULL-STRING)) TEMP-000
     FILE)))
  (ENSURE-FILE-EXISTS FILE "load-configuration-file")
  (CL:LET* ((CONFIGURATION (NEW-KEY-VALUE-LIST)))
   (CL:LET* ((IN NULL))
    (CL:UNWIND-PROTECT
     (CL:PROGN (CL:SETQ IN (OPEN-INPUT-FILE FILE))
      (CL:LET* ((LINE STELLA::NULL-STRING) (ITER-000 (LINES IN)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ LINE (%LINE-ITERATOR.VALUE ITER-000))
        (CL:LET* ((KEY NULL) (VALUE NULL) (OPERATOR NULL))
         (CL:MULTIPLE-VALUE-SETQ (KEY VALUE OPERATOR)
          (PARSE-CONFIGURATION-FILE-LINE LINE))
         (CL:WHEN (CL:NOT (CL:EQ KEY NULL))
          (CL:COND
           ((CL:EQ OPERATOR KWD-SYSTEMS-SET)
            (SET-CONFIGURATION-PROPERTY
             (%STRING-WRAPPER.WRAPPER-VALUE KEY) VALUE CONFIGURATION)
            (SET-CONFIGURATION-PROPERTY
             (%STRING-WRAPPER.WRAPPER-VALUE KEY) VALUE NULL))
           ((CL:EQ OPERATOR KWD-SYSTEMS-ADD)
            (ADD-CONFIGURATION-PROPERTY
             (%STRING-WRAPPER.WRAPPER-VALUE KEY) VALUE CONFIGURATION)
            (ADD-CONFIGURATION-PROPERTY
             (%STRING-WRAPPER.WRAPPER-VALUE KEY) VALUE NULL))
           (CL:T
            (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
              OPERATOR "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION
               (THE-STRING-READER STREAM-000)))))))))))
     (CL:WHEN (CL:NOT (CL:EQ IN NULL)) (FREE IN))))
   (CL:RETURN-FROM %LOAD-CONFIGURATION-FILE CONFIGURATION)))

(CL:DEFUN LOAD-CONFIGURATION-FILE-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM LOAD-CONFIGURATION-FILE-EVALUATOR-WRAPPER
   (%LOAD-CONFIGURATION-FILE
    (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS)))))

(CL:DEFMACRO LOAD-CONFIGURATION-FILE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Read a configuration `file' and return its content as a configuration table.
Also enter each property read into the global system configuration table.
Assumes Java-style property file syntax.  Each property name is represented
as a wrapped string and each value as a wrapped string/integer/float or boolean."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/LOAD-CONFIGURATION-FILE|)) (CL:MACRO-FUNCTION (CL:QUOTE LOAD-CONFIGURATION-FILE)))

;;; (DEFUN SAVE-CONFIGURATION-VALUE ...)

(CL:DEFUN SAVE-CONFIGURATION-VALUE (STREAM VALUE)
  "Save `value' to `stream' as a properly formatted configuration
value."
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (%STRING-WRAPPER.WRAPPER-VALUE VALUE))))
    ((SUBTYPE-OF-BOOLEAN? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (CL:EQ VALUE TRUE-WRAPPER)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "true")
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
        "false"))))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (INTEGER-TO-STRING
        (CL:TRUNCATE (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))))))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (INTEGER-TO-STRING
        (%LONG-INTEGER-WRAPPER.WRAPPER-VALUE VALUE)))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (FLOAT-TO-STRING (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE)))))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) VALUE)))))
  :VOID)

;;; (DEFUN SAVE-CONFIGURATION-FILE ...)

(CL:DEFUN SAVE-CONFIGURATION-FILE (TABLE FILE TITLE)
  "Save `table' as a configuration file.  Uses a Java-style property file syntax."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TITLE))
  #+MCL
  (CL:CHECK-TYPE TITLE CL:SIMPLE-STRING)
  (CL:LET* ((*PRINTREADABLY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:LET* ((OUT NULL))
    (CL:UNWIND-PROTECT
     (CL:PROGN (CL:SETQ OUT (OPEN-OUTPUT-FILE FILE))
      (CL:WHEN (CL:NOT (CL:EQ TITLE STELLA::NULL-STRING))
       (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUT) "# "
        TITLE EOL))
      (CL:LET*
       ((KEY NULL) (VALUE NULL)
        (ITER-000 (%KEY-VALUE-LIST.THE-KV-LIST TABLE)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
        (CL:SETQ KEY (%KV-CONS.KEY ITER-000))
        (CL:SETQ VALUE (%KV-CONS.VALUE ITER-000))
        (CL:COND
         ((CL:EQ (SAFE-PRIMARY-TYPE VALUE) SGT-SYSTEMS-STELLA-CONS)
          (CL:PROGN
           (CL:LET* ((V NULL) (ITER-001 VALUE))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
             (CL:SETQ V (%%VALUE ITER-001))
             (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUT)
              (UNWRAP-STRING KEY) " +=")
             (SAVE-CONFIGURATION-VALUE OUT V)
             (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUT)
              EOL)
             (CL:SETQ ITER-001 (%%REST ITER-001))))))
         (CL:T
          (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUT)
           (UNWRAP-STRING KEY) " =")
          (SAVE-CONFIGURATION-VALUE OUT VALUE)
          (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM OUT)
           EOL)))
        (CL:SETQ ITER-000 (%KV-CONS.REST ITER-000)))))
     (CL:WHEN (CL:NOT (CL:EQ OUT NULL)) (FREE OUT)))))
  :VOID)

;;; (DEFUN (LOOKUP-CONFIGURATION-PROPERTY OBJECT) ...)

(CL:DEFUN LOOKUP-CONFIGURATION-PROPERTY (PROPERTY DEFAULTVALUE CONFIGURATION)
  "Lookup `property' in `configuration' and return its value.
Use the global system configuration table if `configuration' is NULL.  Return
`defaultValue' if `property' is not defined."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (CL:LET* ((VALUE (LOOKUP CONFIGURATION (WRAP-STRING PROPERTY))))
   (CL:IF (CL:NOT (CL:EQ VALUE NULL))
    (CL:RETURN-FROM LOOKUP-CONFIGURATION-PROPERTY VALUE)
    (CL:RETURN-FROM LOOKUP-CONFIGURATION-PROPERTY DEFAULTVALUE))))

;;; (DEFUN (LOOKUP-CONFIGURATION-PROPERTY-VALUES CONS) ...)

(CL:DEFUN LOOKUP-CONFIGURATION-PROPERTY-VALUES (PROPERTY DEFAULTVALUE CONFIGURATION)
  "Lookup `property' in `configuration', assume it is a multi-valued
property and return its value(s) as a list.  Use the global system configuration table
if `configuration' is NULL.  Return `defaultValue' if `property' is not defined or
NIL is no default value is specified."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (CL:LET* ((VALUE (LOOKUP CONFIGURATION (WRAP-STRING PROPERTY))))
   (CL:COND
    ((CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM LOOKUP-CONFIGURATION-PROPERTY-VALUES
      (CONSIFY VALUE)))
    ((CL:NOT (CL:EQ DEFAULTVALUE NULL))
     (CL:RETURN-FROM LOOKUP-CONFIGURATION-PROPERTY-VALUES
      (CONSIFY DEFAULTVALUE)))
    (CL:T (CL:RETURN-FROM LOOKUP-CONFIGURATION-PROPERTY-VALUES NIL)))))

;;; (DEFUN (SET-CONFIGURATION-PROPERTY OBJECT) ...)

(CL:DEFUN SET-CONFIGURATION-PROPERTY (PROPERTY VALUE CONFIGURATION)
  "Set `property' in `configuration' to `value' and return it.
Use the global system configuration table if `configuration' is NULL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (INSERT-AT CONFIGURATION (WRAP-STRING PROPERTY) VALUE)
  (CL:RETURN-FROM SET-CONFIGURATION-PROPERTY VALUE))

;;; (DEFUN (ADD-CONFIGURATION-PROPERTY OBJECT) ...)

(CL:DEFUN ADD-CONFIGURATION-PROPERTY (PROPERTY VALUE CONFIGURATION)
  "Add `value' to `property' in `configuration' and return it.
If a previous value exists add `value' to the end (listify the old value
if it is not yet a list).  Otherwise, create a new list containing `value'.
Use the global system configuration table if `configuration' is NULL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (CL:LET* ((TEMP-000 (LOOKUP CONFIGURATION (WRAP-STRING PROPERTY))))
   (INSERT-AT CONFIGURATION (WRAP-STRING PROPERTY)
    (CONCATENATE
     (CONSIFY (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 NIL))
     (CONS VALUE NIL))))
  (CL:RETURN-FROM ADD-CONFIGURATION-PROPERTY VALUE))

;;; (DEFUN (CLEAR-CONFIGURATION-PROPERTY OBJECT) ...)

(CL:DEFUN CLEAR-CONFIGURATION-PROPERTY (PROPERTY CONFIGURATION)
  "Remove `property' in `configuration' and return the previous
value.
Use the global system configuration table if `configuration' is NULL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (CL:LET*
   ((CURRENT-VALUE (LOOKUP CONFIGURATION (WRAP-STRING PROPERTY))))
   (REMOVE-AT CONFIGURATION (WRAP-STRING PROPERTY))
   (CL:RETURN-FROM CLEAR-CONFIGURATION-PROPERTY CURRENT-VALUE)))

;;; (DEFUN (REMOVE-CONFIGURATION-PROPERTY OBJECT) ...)

(CL:DEFUN REMOVE-CONFIGURATION-PROPERTY (PROPERTY VALUE CONFIGURATION)
  "Remove `value' from `property' in `configuration' and return it.
Use the global system configuration table if `configuration' is NULL."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
  #+MCL
  (CL:CHECK-TYPE PROPERTY CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ CONFIGURATION NULL)
   (CL:SETQ CONFIGURATION *SYSTEM-CONFIGURATION-TABLE*))
  (CL:LET*
   ((CURRENT-VALUE (LOOKUP CONFIGURATION (WRAP-STRING PROPERTY))))
   (CL:WHEN (CL:NOT (CL:EQ CURRENT-VALUE NULL))
    (INSERT-AT CONFIGURATION (WRAP-STRING PROPERTY)
     (REMOVE CURRENT-VALUE VALUE)))
   (CL:RETURN-FROM REMOVE-CONFIGURATION-PROPERTY VALUE)))

;;; (DEFUN PRINT-CONFIGURATION-PROPERTIES ...)

(CL:DEFUN PRINT-CONFIGURATION-PROPERTIES (CONFIGURATION STREAM)
  "Print all properties defined in `configuration' to `stream'."
  (CL:LET* ((*PRINTREADABLY?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:LET*
    ((ENTRY NULL)
     (ITER-000 (SORT-TUPLES (CONSIFY CONFIGURATION) 0 NULL)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ENTRY (%%VALUE ITER-000))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
      (UNWRAP-STRING (%%VALUE ENTRY)) " = ")
     (CL:IF (STRING? (%%VALUE (%%REST ENTRY)))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (UNWRAP-STRING (%%VALUE (%%REST ENTRY))) EOL)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
       (%%VALUE (%%REST ENTRY)) EOL))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  :VOID)

;;; (DEFUN CONFIGURE-STELLA ...)

(CL:DEFUN CONFIGURE-STELLA (FILE)
  "Perform STELLA run-time configuration.  If supplied, load the
configuration file `file' first which should be supplied with a physical pathname."
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ FILE STELLA::NULL-STRING))
    (CL:NOT
     (CL:EQ (FIND-FILE-IN-LOAD-PATH FILE NULL) STELLA::NULL-STRING)))
   (%LOAD-CONFIGURATION-FILE FILE))
  (DEFINE-LOGICAL-HOST-PROPERTY "PL" KWD-SYSTEMS-ROOT-DIRECTORY
   (LOOKUP-CONFIGURATION-PROPERTY "PowerLoomRootDirectory" NULL NULL))
  :VOID)

;;; (DEFUN (GET-PROPERTY OBJECT) ...)

(CL:DEFUN %GET-PROPERTY (PROPERTY DEFAULTVALUE)
  "Lookup `property' (a string or symbol) in the configuration
table and return its value.  If it is undefined, return the optional `defaultValue'.
Note that `property' is evaluated and will need to be quoted if supplied as a
symbol.  Symbols will also be upcased if this command is run in a non-case-
sensitive module."
  (CL:LET*
   ((KEY (COERCE-TO-STRING PROPERTY)) (DEFAULT (%%VALUE DEFAULTVALUE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
   (CL:RETURN-FROM %GET-PROPERTY
    (LOOKUP-CONFIGURATION-PROPERTY KEY DEFAULT
     *SYSTEM-CONFIGURATION-TABLE*))))

(CL:DEFUN GET-PROPERTY-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:RETURN-FROM GET-PROPERTY-EVALUATOR-WRAPPER
   (%GET-PROPERTY (%%VALUE ARGUMENTS) (%%REST ARGUMENTS))))

(CL:DEFMACRO GET-PROPERTY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Lookup `property' (a string or symbol) in the configuration
table and return its value.  If it is undefined, return the optional `defaultValue'.
Note that `property' is evaluated and will need to be quoted if supplied as a
symbol.  Symbols will also be upcased if this command is run in a non-case-
sensitive module."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/GET-PROPERTY|)) (CL:MACRO-FUNCTION (CL:QUOTE GET-PROPERTY)))

;;; (DEFUN SET-PROPERTY ...)

(CL:DEFUN %SET-PROPERTY (PROPERTY VALUE)
  "Set `property' (a string or symbol) in the configuration
table to `value'.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in
a non-case-sensitive module."
  (CL:LET* ((KEY (COERCE-TO-STRING PROPERTY)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
   (SET-CONFIGURATION-PROPERTY KEY VALUE *SYSTEM-CONFIGURATION-TABLE*))
  :VOID)

(CL:DEFMACRO SET-PROPERTY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set `property' (a string or symbol) in the configuration
table to `value'.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in
a non-case-sensitive module."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/SET-PROPERTY|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-PROPERTY)))

;;; (DEFUN ADD-PROPERTY-VALUE ...)

(CL:DEFUN %ADD-PROPERTY-VALUE (PROPERTY VALUE)
  "Add `value' to the end of `property's (a string or symbol) value
list in the configuration table.  Coerces the current value to a list or initializes
the list if it is as yet undefined.  Allows incremental addition of values to
list-valued propertys.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in a
non-case-sensitive module."
  (CL:LET* ((KEY (COERCE-TO-STRING PROPERTY)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
   (ADD-CONFIGURATION-PROPERTY KEY VALUE *SYSTEM-CONFIGURATION-TABLE*))
  :VOID)

(CL:DEFMACRO ADD-PROPERTY-VALUE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Add `value' to the end of `property's (a string or symbol) value
list in the configuration table.  Coerces the current value to a list or initializes
the list if it is as yet undefined.  Allows incremental addition of values to
list-valued propertys.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in a
non-case-sensitive module."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/ADD-PROPERTY-VALUE|)) (CL:MACRO-FUNCTION (CL:QUOTE ADD-PROPERTY-VALUE)))

;;; (DEFUN PRINT-PROPERTIES ...)

(CL:DEFUN PRINT-PROPERTIES ()
  "Print all current configuration property information to
standard output."
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "------------------------------------------------------------" EOL
   "# Loaded System Configuration" EOL)
  (PRINT-CONFIGURATION-PROPERTIES *SYSTEM-CONFIGURATION-TABLE*
   STANDARD-OUTPUT)
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "------------------------------------------------------------" EOL)
  :VOID)

(CL:DEFUN NEW-CMD-LINE-OPTION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-CMD-LINE-OPTION))
   (CL:SETF (%CMD-LINE-OPTION.ERROR-ACTION SELF) KWD-SYSTEMS-ERROR)
   (CL:SETF (%CMD-LINE-OPTION.HANDLER SELF)
    (CL:FUNCTION DEFAULT-CMD-LINE-OPTION-HANDLER))
   (CL:SETF (%CMD-LINE-OPTION.CONFIGURATION-PROPERTY SELF)
    STELLA::NULL-STRING)
   (CL:SETF (%CMD-LINE-OPTION.DEFAULT-VALUE SELF) NULL)
   (CL:SETF (%CMD-LINE-OPTION.N-ARGUMENTS SELF) 0)
   (CL:SETF (%CMD-LINE-OPTION.MULTI-VALUED? SELF) CL:NIL)
   (CL:SETF (%CMD-LINE-OPTION.VALUE-TYPE SELF)
    SGT-SYSTEMS-STELLA-STRING)
   (CL:SETF (%CMD-LINE-OPTION.KEYS SELF) NIL)
   (CL:SETF (%CMD-LINE-OPTION.DOCUMENTATION SELF) "Not documented.")
   (CL:RETURN-FROM NEW-CMD-LINE-OPTION SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CMD-LINE-OPTION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-SYSTEMS-STELLA-CMD-LINE-OPTION))

(CL:DEFUN ACCESS-CMD-LINE-OPTION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-DOCUMENTATION)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.DOCUMENTATION SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-STRING (%CMD-LINE-OPTION.DOCUMENTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-KEYS)
    (CL:IF SETVALUE? (CL:SETF (%CMD-LINE-OPTION.KEYS SELF) VALUE)
     (CL:SETQ VALUE (%CMD-LINE-OPTION.KEYS SELF))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-VALUE-TYPE)
    (CL:IF SETVALUE? (CL:SETF (%CMD-LINE-OPTION.VALUE-TYPE SELF) VALUE)
     (CL:SETQ VALUE (%CMD-LINE-OPTION.VALUE-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-MULTI-VALUED?)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.MULTI-VALUED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CMD-LINE-OPTION.MULTI-VALUED? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-N-ARGUMENTS)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.N-ARGUMENTS SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%CMD-LINE-OPTION.N-ARGUMENTS SELF)))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-DEFAULT-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.DEFAULT-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%CMD-LINE-OPTION.DEFAULT-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-CONFIGURATION-PROPERTY)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.CONFIGURATION-PROPERTY SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-STRING (%CMD-LINE-OPTION.CONFIGURATION-PROPERTY SELF)))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-HANDLER)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.HANDLER SELF)
      (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE (%CMD-LINE-OPTION.HANDLER SELF)))))
   ((CL:EQ SLOTNAME SYM-SYSTEMS-STELLA-ERROR-ACTION)
    (CL:IF SETVALUE?
     (CL:SETF (%CMD-LINE-OPTION.ERROR-ACTION SELF) VALUE)
     (CL:SETQ VALUE (%CMD-LINE-OPTION.ERROR-ACTION SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-CMD-LINE-OPTION-SLOT-VALUE VALUE))

;;; (DEFGLOBAL *REGISTERED-COMMAND-LINE-OPTIONS* ...)

(CL:DEFVAR *REGISTERED-COMMAND-LINE-OPTIONS* NULL)

;;; (DEFUN REGISTER-CMD-LINE-OPTION ...)

(CL:DEFUN REGISTER-CMD-LINE-OPTION (CL:&REST OPTIONS)
  "Register a command line option.  :key identifies the name of the option which
will usually start with a dash such as `-e' or `--eval'.  :key2 and :key3 can be used to supply
additional options (e.g., long option formats).  To supply even more keys, a list can be supplied
with the :keys option.  If a :property is supplied, this option simply sets or adds to the values
of the specified system configuration property.  If a :handler name is specified, its function
will be used to interpret the values of the option.  :documentation can be used to supply a
documentation string which will be printed by the `help-option-handler' (usually bound to `-?').
:value-type describes what type an option value should be coerced to before assigning it to the
specified configuration :property.  :n-arguments describes how many arguments this option
takes.  This will be 0 for simple switches and can be 1 or greater than one for option handlers
that need one or more arguments.  :default-value defines the value to use for zero-argument
:property options.  If :multi-valued? is true, values of multiple occurrences of the option will be
added to the specified configuration :property.  :error-action can be one of :ignore, :warn or
:error to specify what to do in case an error is encountered during option processing."
  (CL:LET* ((ARGLIST-000 NIL))
   (CL:LET* ((ARG-000 NULL) (ITER-000 OPTIONS) (COLLECT-000 NULL))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ ARG-000 (CL:POP ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG-000 NIL))
       (CL:IF (CL:EQ ARGLIST-000 NIL) (CL:SETQ ARGLIST-000 COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ARGLIST-000 COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG-000 NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:LET*
    ((THEOPTIONS
      (PARSE-OPTIONS ARGLIST-000
       (LIST* KWD-SYSTEMS-DOCUMENTATION SGT-SYSTEMS-STELLA-STRING
        KWD-SYSTEMS-KEY SGT-SYSTEMS-STELLA-STRING KWD-SYSTEMS-KEY2
        SGT-SYSTEMS-STELLA-STRING KWD-SYSTEMS-KEY3
        SGT-SYSTEMS-STELLA-STRING KWD-SYSTEMS-KEYS
        SGT-SYSTEMS-STELLA-CONS KWD-SYSTEMS-VALUE-TYPE
        SGT-SYSTEMS-STELLA-TYPE KWD-SYSTEMS-MULTI-VALUED?
        SGT-SYSTEMS-STELLA-BOOLEAN KWD-SYSTEMS-N-ARGUMENTS
        SGT-SYSTEMS-STELLA-INTEGER KWD-SYSTEMS-DEFAULT-VALUE
        SGT-SYSTEMS-STELLA-OBJECT KWD-SYSTEMS-PROPERTY
        SGT-SYSTEMS-STELLA-STRING KWD-SYSTEMS-HANDLER
        SGT-SYSTEMS-STELLA-SYMBOL KWD-SYSTEMS-ERROR-ACTION
        SGT-SYSTEMS-STELLA-KEYWORD NIL)
       CL:T CL:NIL))
     (CMDLINEOPTION (NEW-CMD-LINE-OPTION)) (VALUE NULL))
    (CL:SETF (%CMD-LINE-OPTION.DOCUMENTATION CMDLINEOPTION)
     (%STRING-WRAPPER.WRAPPER-VALUE
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-DOCUMENTATION
       (WRAP-STRING "Not documented."))))
    (CL:SETQ VALUE (LOOKUP THEOPTIONS KWD-SYSTEMS-KEY))
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:SETF (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)
      (CONS VALUE (%CMD-LINE-OPTION.KEYS CMDLINEOPTION))))
    (CL:SETQ VALUE (LOOKUP THEOPTIONS KWD-SYSTEMS-KEY2))
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:SETF (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)
      (CONS VALUE (%CMD-LINE-OPTION.KEYS CMDLINEOPTION))))
    (CL:SETQ VALUE (LOOKUP THEOPTIONS KWD-SYSTEMS-KEY3))
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:SETF (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)
      (CONS VALUE (%CMD-LINE-OPTION.KEYS CMDLINEOPTION))))
    (CL:LET*
     ((VAL NULL)
      (ITER-001 (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-KEYS NIL)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ VAL (%%VALUE ITER-001))
      (CL:SETQ VALUE
       (COERCE-VALUE-TO-TYPE VAL SGT-SYSTEMS-STELLA-STRING CL:T))
      (CL:SETF (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)
       (CONS VALUE (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)))
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (CL:SETF (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)
     (REVERSE (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)))
    (CL:SETF (%CMD-LINE-OPTION.VALUE-TYPE CMDLINEOPTION)
     (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-VALUE-TYPE
      SGT-SYSTEMS-STELLA-STRING))
    (CL:SETF (%CMD-LINE-OPTION.MULTI-VALUED? CMDLINEOPTION)
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-MULTI-VALUED?
       FALSE-WRAPPER)))
    (CL:SETF (%CMD-LINE-OPTION.N-ARGUMENTS CMDLINEOPTION)
     (%INTEGER-WRAPPER.WRAPPER-VALUE
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-N-ARGUMENTS
       (WRAP-INTEGER 0))))
    (CL:SETF (%CMD-LINE-OPTION.DEFAULT-VALUE CMDLINEOPTION)
     (LOOKUP THEOPTIONS KWD-SYSTEMS-DEFAULT-VALUE))
    (CL:SETF (%CMD-LINE-OPTION.CONFIGURATION-PROPERTY CMDLINEOPTION)
     (%STRING-WRAPPER.WRAPPER-VALUE
      (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-PROPERTY
       NULL-STRING-WRAPPER)))
    (CL:SETQ VALUE (LOOKUP THEOPTIONS KWD-SYSTEMS-HANDLER))
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:SETQ VALUE (LOOKUP-FUNCTION VALUE))
     (CL:WHEN (CL:EQ VALUE NULL)
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "register-cmd-line-option: cannot find handler function: `"
        (LOOKUP THEOPTIONS KWD-SYSTEMS-HANDLER) "'")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
     (CL:SETF (%CMD-LINE-OPTION.HANDLER CMDLINEOPTION)
      (%METHOD-SLOT.FUNCTION-CODE VALUE)))
    (CL:SETF (%CMD-LINE-OPTION.ERROR-ACTION CMDLINEOPTION)
     (LOOKUP-WITH-DEFAULT THEOPTIONS KWD-SYSTEMS-ERROR-ACTION
      KWD-SYSTEMS-ERROR))
    (CL:LET*
     ((KEY NULL) (ITER-002 (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:SETQ KEY (%%VALUE ITER-002))
      (INSERT-AT *REGISTERED-COMMAND-LINE-OPTIONS* KEY CMDLINEOPTION)
      (CL:SETQ ITER-002 (%%REST ITER-002))))))
  :VOID)

;;; (DEFUN UNREGISTER-CMD-LINE-OPTION ...)

(CL:DEFUN UNREGISTER-CMD-LINE-OPTION (KEY)
  "Unregister the command line option identified by `key' under all its keys."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEY))
  #+MCL
  (CL:CHECK-TYPE KEY CL:SIMPLE-STRING)
  (CL:LET*
   ((CMDLINEOPTION
     (LOOKUP *REGISTERED-COMMAND-LINE-OPTIONS* (WRAP-STRING KEY))))
   (CL:WHEN (CL:NOT (CL:EQ CMDLINEOPTION NULL))
    (CL:LET*
     ((REGISTEREDKEY NULL)
      (ITER-000 (%CMD-LINE-OPTION.KEYS CMDLINEOPTION)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ REGISTEREDKEY (%%VALUE ITER-000))
      (REMOVE-AT *REGISTERED-COMMAND-LINE-OPTIONS* REGISTEREDKEY)
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (REMOVE-AT *REGISTERED-COMMAND-LINE-OPTIONS* (WRAP-STRING KEY))))
  :VOID)

;;; (DEFUN UNREGISTER-ALL-CMD-LINE-OPTIONS ...)

(CL:DEFUN UNREGISTER-ALL-CMD-LINE-OPTIONS ()
  "Unregister all currently registered command line options."
  (CLEAR *REGISTERED-COMMAND-LINE-OPTIONS*)
  :VOID)

;;; (DEFUN DEFAULT-CMD-LINE-OPTION-HANDLER ...)

(CL:DEFUN DEFAULT-CMD-LINE-OPTION-HANDLER (OPTION VALUE)
  "Default handler that tries to set a system property based on `option' and `value'."
  (CL:LET*
   ((PROPERTY (%CMD-LINE-OPTION.CONFIGURATION-PROPERTY OPTION))
    (DEFAULTVALUE (%CMD-LINE-OPTION.DEFAULT-VALUE OPTION)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PROPERTY))
   (CL:WHEN (CL:EQ PROPERTY STELLA::NULL-STRING) (CL:SETQ PROPERTY "")
    (CL:LET* ((KEY NULL) (ITER-000 (%CMD-LINE-OPTION.KEYS OPTION)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ KEY (%%VALUE ITER-000))
      (CL:WHEN
       (CL:>
        (CL:THE CL:FIXNUM
         (CL:LENGTH (CL:THE CL:SIMPLE-STRING (UNWRAP-STRING KEY))))
        (CL:THE CL:FIXNUM (CL:LENGTH PROPERTY)))
       (CL:SETQ PROPERTY (%STRING-WRAPPER.WRAPPER-VALUE KEY)))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CL:WHEN
    (CL:AND (CL:EQ DEFAULTVALUE NULL)
     (CL:EQ (%CMD-LINE-OPTION.VALUE-TYPE OPTION)
      SGT-SYSTEMS-STELLA-BOOLEAN))
    (CL:SETQ DEFAULTVALUE TRUE-WRAPPER))
   (CL:WHEN (CL:EQ VALUE NULL) (CL:SETQ VALUE DEFAULTVALUE))
   (CL:IF (%CMD-LINE-OPTION.MULTI-VALUED? OPTION)
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE VALUE) SGT-SYSTEMS-STELLA-CONS)
      (CL:PROGN
       (CL:LET* ((VAL NULL) (ITER-001 VALUE))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ VAL (%%VALUE ITER-001))
         (ADD-CONFIGURATION-PROPERTY PROPERTY VAL NULL)
         (CL:SETQ ITER-001 (%%REST ITER-001))))))
     (CL:T (ADD-CONFIGURATION-PROPERTY PROPERTY VALUE NULL)))
    (SET-CONFIGURATION-PROPERTY PROPERTY VALUE NULL)))
  :VOID)

;;; (DEFGLOBAL *UNPROCESSED-COMMAND-LINE-ARGUMENTS* ...)

(CL:DEFVAR *UNPROCESSED-COMMAND-LINE-ARGUMENTS* NULL)

;;; (DEFUN PROCESS-COMMAND-LINE-ARGUMENTS ...)

(CL:DEFUN PROCESS-COMMAND-LINE-ARGUMENTS (COUNT ARGUMENTS UNHANDLEDOPTIONACTION)
  "Interpret any command line `arguments' for which handlers have been registered.
Leave any remaining unprocessed arguments in `*unprocessed-command-line-arguments*'.
If any unprocessed arguments use option syntax (that is they start with a `-'), proceed
according to `unhandledOptionAction' which can be one of :ignore, :warn or :error.
This ensures that at any point in the option processing, `*unprocessed-command-line-arguments*'
accurately reflects the arguments which have been either skipped or not handled yet."
  (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT)
   (CL:TYPE CL:SIMPLE-VECTOR ARGUMENTS))
  #+MCL
  (CL:CHECK-TYPE COUNT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE ARGUMENTS CL:SIMPLE-VECTOR)
  (CL:WHEN (CL:EQ *UNPROCESSED-COMMAND-LINE-ARGUMENTS* NULL)
   (CL:SETQ *UNPROCESSED-COMMAND-LINE-ARGUMENTS*
    (CONSIFY-COMMAND-LINE-ARGUMENTS COUNT ARGUMENTS)))
  (CL:LET*
   ((CMDLINEARGS (COPY-CONS-LIST *UNPROCESSED-COMMAND-LINE-ARGUMENTS*))
    (ARGUMENT STELLA::NULL-STRING) (NARGS (LENGTH CMDLINEARGS))
    (OPTION NULL) (VALUE NULL)
    (UNPROCESSEDARGS (CONS NULL *UNPROCESSED-COMMAND-LINE-ARGUMENTS*))
    (UNPROCESSEDTRAILER UNPROCESSEDARGS))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING ARGUMENT)
    (CL:TYPE CL:FIXNUM NARGS))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CMDLINEARGS NIL)) DO
    (CL:TAGBODY
     (CL:LET* ((HEAD-000 (%%VALUE CMDLINEARGS)))
      (CL:SETQ CMDLINEARGS (%%REST CMDLINEARGS))
      (CL:SETQ ARGUMENT (%STRING-WRAPPER.WRAPPER-VALUE HEAD-000)))
     (CL:SETQ NARGS (CL:1- NARGS))
     (CL:SETQ OPTION
      (LOOKUP *REGISTERED-COMMAND-LINE-OPTIONS*
       (WRAP-STRING ARGUMENT)))
     (CL:SETQ VALUE NULL)
     (CL:COND
      ((CL:NOT (CL:EQ OPTION NULL))
       (CL:WHEN (CL:< NARGS (%CMD-LINE-OPTION.N-ARGUMENTS OPTION))
        (CL:LET*
         ((TEST-VALUE-000 (%CMD-LINE-OPTION.ERROR-ACTION OPTION)))
         (CL:COND
          ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-ERROR)
           (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
             "process-command-line-arguments: missing value for option: `"
             ARGUMENT "'")
            (CL:ERROR
             (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
          ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-WARN)
           (CL:WARN
            "process-command-line-arguments: missing value for option: `~A'"
            ARGUMENT))
          ((CL:EQ TEST-VALUE-000 KWD-SYSTEMS-IGNORE))
          (CL:T
           (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
             TEST-VALUE-000 "' is not a valid case option")
            (CL:ERROR
             (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
        (CL:GO :CONTINUE))
       (CL:CASE (%CMD-LINE-OPTION.N-ARGUMENTS OPTION) (0)
        (1
         (CL:LET* ((HEAD-001 (%%VALUE CMDLINEARGS)))
          (CL:SETQ CMDLINEARGS (%%REST CMDLINEARGS))
          (CL:SETQ VALUE HEAD-001))
         (CL:SETQ NARGS (CL:1- NARGS)))
        (CL:OTHERWISE
         (CL:LET* ((VALUE-000 NIL))
          (CL:LET*
           ((ARG NULL) (ITER-000 CMDLINEARGS) (I NULL-INTEGER)
            (ITER-001 1)
            (UPPER-BOUND-000 (%CMD-LINE-OPTION.N-ARGUMENTS OPTION))
            (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER))
            (COLLECT-000 NULL))
           (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
           (CL:LOOP WHILE
            (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
             (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
            DO (CL:SETQ ARG (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
            (CL:IF (CL:EQ COLLECT-000 NULL)
             (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG NIL))
              (CL:IF (CL:EQ VALUE-000 NIL)
               (CL:SETQ VALUE-000 COLLECT-000)
               (ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
             (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG NIL))
              (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
            (CL:SETQ ITER-000 (%%REST ITER-000))
            (CL:SETQ ITER-001 (CL:1+ ITER-001))))
          (CL:SETQ VALUE VALUE-000))
         (CL:SETQ CMDLINEARGS
          (NTH-REST CMDLINEARGS (%CMD-LINE-OPTION.N-ARGUMENTS OPTION)))
         (CL:SETQ NARGS
          (CL:- NARGS (%CMD-LINE-OPTION.N-ARGUMENTS OPTION)))))
       (CL:SETF (%%REST UNPROCESSEDTRAILER)
        (NTH-REST UNPROCESSEDTRAILER
         (CL:+ (%CMD-LINE-OPTION.N-ARGUMENTS OPTION) 2)))
       (CL:SETQ *UNPROCESSED-COMMAND-LINE-ARGUMENTS*
        (%%REST UNPROCESSEDARGS))
       (CL:HANDLER-CASE
        (CL:FUNCALL (%CMD-LINE-OPTION.HANDLER OPTION) OPTION VALUE)
        (CL:CONDITION (E)
         (CL:LET*
          ((TEST-VALUE-001 (%CMD-LINE-OPTION.ERROR-ACTION OPTION)))
          (CL:COND
           ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-ERROR)
            (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
              "Error during processing of `" ARGUMENT "' option: `"
              (EXCEPTION-MESSAGE E) "'")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))
           ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-WARN)
            (CL:WARN "Error during processing of `~A' option: `~A'"
             ARGUMENT (EXCEPTION-MESSAGE E)))
           ((CL:EQ TEST-VALUE-001 KWD-SYSTEMS-IGNORE))
           (CL:T
            (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003) "`"
              TEST-VALUE-001 "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION
               (THE-STRING-READER STREAM-003))))))))))
      (CL:T (CL:SETQ UNPROCESSEDTRAILER (%%REST UNPROCESSEDTRAILER))))
     :CONTINUE))
   (CL:SETQ *UNPROCESSED-COMMAND-LINE-ARGUMENTS*
    (%%REST UNPROCESSEDARGS))
   (CL:LET*
    ((ARG NULL) (ITER-002 *UNPROCESSED-COMMAND-LINE-ARGUMENTS*))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ ARG (%%VALUE ITER-002))
     (CL:WHEN (STARTS-WITH? (UNWRAP-STRING ARG) "-" 0)
      (CL:COND
       ((CL:EQ UNHANDLEDOPTIONACTION KWD-SYSTEMS-WARN)
        (CL:WARN "Unhandled command line option: `~A'"
         (UNWRAP-STRING ARG)))
       ((CL:EQ UNHANDLEDOPTIONACTION KWD-SYSTEMS-ERROR)
        (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004)
          "Unhandled command line option: `" (UNWRAP-STRING ARG) "'")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-004)))))
       ((CL:EQ UNHANDLEDOPTIONACTION KWD-SYSTEMS-IGNORE) (CL:RETURN))
       (CL:T
        (CL:LET* ((STREAM-005 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-005) "`"
          UNHANDLEDOPTIONACTION "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-005)))))))
     (CL:SETQ ITER-002 (%%REST ITER-002)))))
  :VOID)

;;; (DEFUN (UNPROCESSED-COMMAND-LINE-ARGUMENTS (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN UNPROCESSED-COMMAND-LINE-ARGUMENTS ()
  "Return all command line arguments which have not yet been processed
by (or been ignored by) `process-command-line-arguments'.  If arguments have not yet
been processed, this will return NULL."
  (CL:RETURN-FROM UNPROCESSED-COMMAND-LINE-ARGUMENTS
   *UNPROCESSED-COMMAND-LINE-ARGUMENTS*))

;;; (DEFUN EVAL-OPTION-HANDLER ...)

(CL:DEFUN EVAL-OPTION-HANDLER (OPTION VALUE)
  "Interpret an --eval option by evaluating `value'."
  (CL:SETQ OPTION OPTION)
  (%EVALUATE
   (CL:IF (STRING? VALUE)
    (READ-S-EXPRESSION-FROM-STRING
     (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
    VALUE))
  :VOID)

;;; (DEFUN EVAL-IN-MODULE-OPTION-HANDLER ...)

(CL:DEFUN EVAL-IN-MODULE-OPTION-HANDLER (OPTION VALUE)
  "Interpret an --eval-in-module option.  `value' is expected
to be of the form `(<module-name> <s-expression>)'."
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE VALUE) SGT-SYSTEMS-STELLA-CONS)
    (CL:PROGN
     (CL:LET*
      ((*MODULE* (COERCE-TO-MODULE (%%VALUE VALUE) CL:T))
       (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (EVAL-OPTION-HANDLER OPTION (%%VALUE (%%REST VALUE))))))
   (CL:T))
  :VOID)

;;; (DEFUN LOAD-PATH-OPTION-HANDLER ...)

(CL:DEFUN LOAD-PATH-OPTION-HANDLER (OPTION VALUE)
  "Modify the current file load path according to `option' and `value'."
  (CL:COND
   ((MEMBER? (%CMD-LINE-OPTION.KEYS OPTION) (WRAP-STRING "--path="))
    (%SET-LOAD-PATH (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
   ((MEMBER? (%CMD-LINE-OPTION.KEYS OPTION) (WRAP-STRING "--path=+"))
    (%ADD-LOAD-PATH (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
   (CL:T (%PUSH-LOAD-PATH (%STRING-WRAPPER.WRAPPER-VALUE VALUE))))
  :VOID)

;;; (DEFUN CONFIG-FILE-OPTION-HANDLER ...)

(CL:DEFUN CONFIG-FILE-OPTION-HANDLER (OPTION VALUE)
  "Load the configuration file `value'.  This will
modify currently set system properties defined in `value' with new
values but leave all other currently set properties as they are."
  (CL:SETQ OPTION OPTION)
  (CL:LET* ((CURRENTCONFIG *SYSTEM-CONFIGURATION-TABLE*))
   (CL:HANDLER-CASE
    (CL:PROGN
     (CL:SETQ *SYSTEM-CONFIGURATION-TABLE* (COPY CURRENTCONFIG))
     (%LOAD-CONFIGURATION-FILE (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
    (CL:CONDITION ()
     (CL:SETQ *SYSTEM-CONFIGURATION-TABLE* CURRENTCONFIG))))
  :VOID)

;;; (DEFUN LOAD-FILE-OPTION-HANDLER ...)

(CL:DEFUN LOAD-FILE-OPTION-HANDLER (OPTION VALUE)
  "Load the file `value' using the STELLA `load-file' command."
  (CL:SETQ OPTION OPTION)
  (%LOAD-FILE (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
  :VOID)

;;; (DEFUN DEFINE-PROPERTY-OPTION-HANDLER ...)

(CL:DEFUN DEFINE-PROPERTY-OPTION-HANDLER (OPTION VALUE)
  (CL:SETQ OPTION OPTION)
  (CL:LET* ((PROP NULL) (VAL NULL) (OP NULL))
   (CL:MULTIPLE-VALUE-SETQ (PROP VAL OP)
    (PARSE-CONFIGURATION-FILE-LINE
     (%STRING-WRAPPER.WRAPPER-VALUE VALUE)))
   (CL:IF (CL:EQ OP KWD-SYSTEMS-ADD)
    (ADD-CONFIGURATION-PROPERTY (%STRING-WRAPPER.WRAPPER-VALUE PROP)
     VAL NULL)
    (SET-CONFIGURATION-PROPERTY (%STRING-WRAPPER.WRAPPER-VALUE PROP)
     VAL NULL)))
  :VOID)

;;; (DEFGLOBAL *COMMAND-LINE-HELP-HEADER* ...)

(CL:DEFVAR *COMMAND-LINE-HELP-HEADER* ""
  "Documentation to be printed at the beginning of command line help.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *COMMAND-LINE-HELP-HEADER*))

;;; (DEFGLOBAL *COMMAND-LINE-HELP-TRAILER* ...)

(CL:DEFVAR *COMMAND-LINE-HELP-TRAILER* ""
  "Documentation to be printed at the end of command line help.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *COMMAND-LINE-HELP-TRAILER*))

;;; (DEFUN HELP-OPTION-HANDLER ...)

(CL:DEFUN HELP-OPTION-HANDLER (OPTION VALUE)
  "Print documentation about all currently registered option handlers."
  (CL:SETQ VALUE VALUE)
  (CL:LET* ((SORTEDOPTIONS NIL))
   (CL:LET*
    ((KEY NULL) (OPTION NULL)
     (ITER-000 (ALLOCATE-ITERATOR *REGISTERED-COMMAND-LINE-OPTIONS*))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ KEY (%DICTIONARY-ITERATOR.KEY ITER-000))
     (CL:SETQ OPTION (%DICTIONARY-ITERATOR.VALUE ITER-000))
     (CL:WHEN (EQL? KEY (%%VALUE (%CMD-LINE-OPTION.KEYS OPTION)))
      (CL:LOOP WHILE
       (STARTS-WITH? (%STRING-WRAPPER.WRAPPER-VALUE KEY) "-" 0) DO
       (CL:SETQ KEY
        (WRAP-STRING
         (SUBSEQUENCE (UNWRAP-STRING KEY) 1 NULL-INTEGER))))
      (CL:SETQ KEY
       (WRAP-STRING
        (STRING-DOWNCASE (%STRING-WRAPPER.WRAPPER-VALUE KEY))))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000 (CONS (CONS-LIST KEY OPTION) NIL))
        (CL:IF (CL:EQ SORTEDOPTIONS NIL)
         (CL:SETQ SORTEDOPTIONS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST SORTEDOPTIONS COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (CONS-LIST KEY OPTION) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:SETQ SORTEDOPTIONS
    (SORT-TUPLES (REMOVE-DUPLICATES SORTEDOPTIONS) 0 NULL))
   (CL:WHEN (CL:NOT (BLANK-STRING? *COMMAND-LINE-HELP-HEADER*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     *COMMAND-LINE-HELP-HEADER* EOL))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "The following command line options are supported:" EOL)
   (CL:LET* ((TUPLE NULL) (ITER-001 SORTEDOPTIONS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ TUPLE (%%VALUE ITER-001))
     (CL:SETQ OPTION (%%VALUE (%%REST TUPLE)))
     (CL:LET*
      ((KEY NULL) (ITER-002 (%CMD-LINE-OPTION.KEYS OPTION))
       (I NULL-INTEGER) (ITER-003 1))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ KEY (%%VALUE ITER-002)) (CL:SETQ I ITER-003)
       (CL:WHEN (CL:> I 1)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         ", "))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        (UNWRAP-STRING KEY))
       (CL:SETQ ITER-002 (%%REST ITER-002))
       (CL:SETQ ITER-003 (CL:1+ ITER-003))))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      " ")
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      (%CMD-LINE-OPTION.DOCUMENTATION OPTION) EOL)
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:WHEN (CL:NOT (BLANK-STRING? *COMMAND-LINE-HELP-TRAILER*))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     *COMMAND-LINE-HELP-TRAILER* EOL))
   (SET-CONFIGURATION-PROPERTY "stella.showInfoOnly" TRUE-WRAPPER NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYSTEMS1 ()
  (CL:PROGN
   (CL:SETQ SYM-SYSTEMS-STELLA-SET-LOAD-PATH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-LOAD-PATH" NULL 0))
   (CL:SETQ KWD-SYSTEMS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-SYSTEMS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-PUSH-LOAD-PATH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUSH-LOAD-PATH" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-ADD-LOAD-PATH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-LOAD-PATH" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DROP-LOAD-PATH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DROP-LOAD-PATH" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ KWD-SYSTEMS-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ KWD-SYSTEMS-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 2))
   (CL:SETQ SGT-SYSTEMS-STELLA-UNKNOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-NUMBER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-PROPERTY-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY-LIST" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
   (CL:SETQ SGT-SYSTEMS-STELLA-IDENTITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IDENTITY" NULL 1))
   (CL:SETQ KWD-SYSTEMS-DEFINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-IN-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-MODULE" NULL 0))
   (CL:SETQ KWD-SYSTEMS-FINALIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFMODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMODULE" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFSYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSYSTEM" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFCLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCLASS" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFSLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSLOT" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFUN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFUN" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFMETHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMETHOD" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-LOAD-FILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-FILE" NULL 0))
   (CL:SETQ KWD-SYSTEMS-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTORY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-REQUIRED-SYSTEMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REQUIRED-SYSTEMS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-LOAD-SYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-SYSTEM" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTION" NULL 2))
   (CL:SETQ KWD-SYSTEMS-LANGUAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LANGUAGE" NULL 2))
   (CL:SETQ KWD-SYSTEMS-MAKE-SYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAKE-SYSTEM" NULL 2))
   (CL:SETQ KWD-SYSTEMS-LISP-ONLY-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-ONLY-FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-CPP-ONLY-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-ONLY-FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-JAVA-ONLY-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-ONLY-FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-DATA-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DATA-FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-PREPROCESSED-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREPROCESSED-FILES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-CARDINAL-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CARDINAL-MODULE" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ROOT-SOURCE-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-SOURCE-DIRECTORY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ROOT-NATIVE-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-NATIVE-DIRECTORY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ROOT-BINARY-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-BINARY-DIRECTORY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-BANNER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BANNER" NULL 2))
   (CL:SETQ KWD-SYSTEMS-COPYRIGHT-HEADER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COPYRIGHT-HEADER" NULL 2))
   (CL:SETQ KWD-SYSTEMS-PRODUCTION-SETTINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRODUCTION-SETTINGS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-DEVELOPMENT-SETTINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEVELOPMENT-SETTINGS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-FINALIZATION-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZATION-FUNCTION" NULL 2))
   (CL:SETQ KWD-SYSTEMS-JAVA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA" NULL 2))
   (CL:SETQ KWD-SYSTEMS-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP" NULL 2))
   (CL:SETQ KWD-SYSTEMS-CPP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP" NULL 2))
   (CL:SETQ KWD-SYSTEMS-LISP-BINARY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-BINARY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-DEVELOPMENT-SETTINGS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEVELOPMENT-SETTINGS?" NULL 2)))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYSTEMS2 ()
  (CL:PROGN
   (CL:SETQ KWD-SYSTEMS-PRODUCTION-SETTINGS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRODUCTION-SETTINGS?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-FORCE-TRANSLATION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORCE-TRANSLATION?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-FORCE-RECOMPILATION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORCE-RECOMPILATION?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-TWO-PASS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TWO-PASS?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-LOAD-SYSTEM?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-SYSTEM?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-STARTUP?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP?" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-MAKE-SYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAKE-SYSTEM" NULL 0))
   (CL:SETQ KWD-SYSTEMS-USE-COMMON-LISP-STRUCTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USE-COMMON-LISP-STRUCTS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-STELLA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA" NULL 2))
   (CL:SETQ KWD-SYSTEMS-WARN-ABOUT-UNDEFINED-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN-ABOUT-UNDEFINED-METHODS" NULL
     2))
   (CL:SETQ SYM-SYSTEMS-STELLA-LOAD-SYSTEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-SYSTEM" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-UNLESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNLESS" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-SYSTEM-STARTED-UP?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYSTEM-STARTED-UP?" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-STARTUP-TIME-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-TIME-PROGN" NULL 0))
   (CL:SETQ KWD-SYSTEMS-EARLY-INITS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EARLY-INITS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-MODULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULES" NULL 2))
   (CL:SETQ KWD-SYSTEMS-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-STARTUP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-FOREACH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FOREACH" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-PHASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PHASE" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-IN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-INTERVAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-PHASE-TO-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PHASE-TO-INTEGER" NULL 0))
   (CL:SETQ KWD-SYSTEMS-FINAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINAL" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-DO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DO" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-*STARTUP-TIME-PHASE*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*STARTUP-TIME-PHASE*" NULL 0))
   (CL:SETQ KWD-SYSTEMS-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET" NULL 2))
   (CL:SETQ KWD-SYSTEMS-WHITE-SPACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHITE-SPACE" NULL 2))
   (CL:SETQ KWD-SYSTEMS-ADD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-CONFIGURATION-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFIGURATION-TABLE" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-LOAD-CONFIGURATION-FILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-CONFIGURATION-FILE" NULL 0))
   (CL:SETQ KWD-SYSTEMS-ROOT-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-DIRECTORY" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-GET-PROPERTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-PROPERTY" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-SET-PROPERTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-PROPERTY" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-ADD-PROPERTY-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-PROPERTY-VALUE" NULL 0))
   (CL:SETQ KWD-SYSTEMS-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SGT-SYSTEMS-STELLA-CMD-LINE-OPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CMD-LINE-OPTION" NULL 1))
   (CL:SETQ SYM-SYSTEMS-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-KEYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYS" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-VALUE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE-TYPE" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-MULTI-VALUED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MULTI-VALUED?" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-N-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "N-ARGUMENTS" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFAULT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT-VALUE" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-CONFIGURATION-PROPERTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFIGURATION-PROPERTY" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HANDLER" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-ERROR-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR-ACTION" NULL 0))
   (CL:SETQ KWD-SYSTEMS-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ KWD-SYSTEMS-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-KEY2
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY2" NULL 2))
   (CL:SETQ KWD-SYSTEMS-KEY3
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY3" NULL 2))
   (CL:SETQ KWD-SYSTEMS-KEYS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-VALUE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE-TYPE" NULL 2))
   (CL:SETQ SGT-SYSTEMS-STELLA-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 1))
   (CL:SETQ KWD-SYSTEMS-MULTI-VALUED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MULTI-VALUED?" NULL 2))
   (CL:SETQ KWD-SYSTEMS-N-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "N-ARGUMENTS" NULL 2))
   (CL:SETQ KWD-SYSTEMS-DEFAULT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT-VALUE" NULL 2))
   (CL:SETQ SGT-SYSTEMS-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
   (CL:SETQ KWD-SYSTEMS-PROPERTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY" NULL 2))
   (CL:SETQ KWD-SYSTEMS-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HANDLER" NULL 2)))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYSTEMS3 ()
  (CL:PROGN
   (CL:SETQ KWD-SYSTEMS-ERROR-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR-ACTION" NULL 2))
   (CL:SETQ KWD-SYSTEMS-WARN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WARN" NULL 2))
   (CL:SETQ KWD-SYSTEMS-IGNORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IGNORE" NULL 2))
   (CL:SETQ SYM-SYSTEMS-STELLA-EVAL-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVAL-OPTION-HANDLER" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-EVAL-IN-MODULE-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVAL-IN-MODULE-OPTION-HANDLER"
     NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-LOAD-PATH-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-PATH-OPTION-HANDLER" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-CONFIG-FILE-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONFIG-FILE-OPTION-HANDLER" NULL
     0))
   (CL:SETQ SYM-SYSTEMS-STELLA-LOAD-FILE-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-FILE-OPTION-HANDLER" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-DEFINE-PROPERTY-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE-PROPERTY-OPTION-HANDLER"
     NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-HELP-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HELP-OPTION-HANDLER" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-STARTUP-SYSTEMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-SYSTEMS" NULL 0))
   (CL:SETQ SYM-SYSTEMS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYSTEMS4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "PARSE-DIRECTORY-PATH"
    "(DEFUN (PARSE-DIRECTORY-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)))"
    (CL:FUNCTION PARSE-DIRECTORY-PATH) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-LOAD-PATH"
    "(DEFUN (SET-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Set the STELLA load path to the |-separated
directories listed in `path'.  Return the resulting load path.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %SET-LOAD-PATH)
    (CL:FUNCTION SET-LOAD-PATH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "GET-LOAD-PATH"
    "(DEFUN (GET-LOAD-PATH (CONS OF STRING-WRAPPER)) () :DOCUMENTATION \"Return the current STELLA load path.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION GET-LOAD-PATH) NULL)
   (DEFINE-FUNCTION-OBJECT "PUSH-LOAD-PATH"
    "(DEFUN (PUSH-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Add the directories listed in the |-separated
`path' to the front of the STELLA load path.  Return the
resulting load path.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %PUSH-LOAD-PATH)
    (CL:FUNCTION PUSH-LOAD-PATH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "POP-LOAD-PATH"
    "(DEFUN (POP-LOAD-PATH STRING) () :DOCUMENTATION \"Remove the first element from the STELLA load path
and return the removed element.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION POP-LOAD-PATH)
    (CL:FUNCTION POP-LOAD-PATH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "ADD-LOAD-PATH"
    "(DEFUN (ADD-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Append the directories listed in the |-separated
`path' to the end of the STELLA load path.  Return the resulting
load path.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %ADD-LOAD-PATH)
    (CL:FUNCTION ADD-LOAD-PATH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DROP-LOAD-PATH"
    "(DEFUN (DROP-LOAD-PATH (CONS OF STRING-WRAPPER)) ((PATH STRING)) :DOCUMENTATION \"Remove the directories listed in the |-separated
`path' from the PowerLoom load path.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %DROP-LOAD-PATH)
    (CL:FUNCTION DROP-LOAD-PATH-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "FIND-FILE-IN-LOAD-PATH"
    "(DEFUN (FIND-FILE-IN-LOAD-PATH STRING) ((FILE STRING) (EXTENSIONS (CONS OF STRING-WRAPPER))) :DOCUMENTATION \"Try to find `file' in the current load path and, if found,
return its full name.  If `file' can't be found literally, try to find it
with any of the listed `extensions' added.  If `extensions' is NULL it defaults
to `*stella-file-extensions*', therefore, to not default to any extensions
the value has to be supplied as NIL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FIND-FILE-IN-LOAD-PATH) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-VALUE-TO-BOOLEAN"
    "(DEFUN (COERCE-VALUE-TO-BOOLEAN BOOLEAN-WRAPPER) ((VALUE OBJECT) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return the boolean object represented by `value'.  Return NULL
if coercion is not possible or raise an error if `error?' is TRUE.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-VALUE-TO-BOOLEAN) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-BOOLEAN"
    "(DEFUN (COERCE-TO-BOOLEAN BOOLEAN-WRAPPER) ((OBJECT OBJECT)) :DOCUMENTATION \"Return the boolean object represented by `object'.
Return NULL if coercion is not possible.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-BOOLEAN) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-VALUE-TO-STRING"
    "(DEFUN (COERCE-VALUE-TO-STRING STRING) ((VALUE OBJECT) (ERROR? BOOLEAN)) :DOCUMENTATION \"Coerce `value' into a string if possible, return NULL
otherwise or raise an error if `error?' is true.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-VALUE-TO-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-STRING"
    "(DEFUN (COERCE-TO-STRING STRING) ((OBJECT OBJECT)) :DOCUMENTATION \"Coerce `object' into a string.  If no standard coercion
is possible, simply stringify `object'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-VALUE-TO-FLOAT"
    "(DEFUN (COERCE-VALUE-TO-FLOAT FLOAT) ((VALUE OBJECT) (ERROR? BOOLEAN)) :DOCUMENTATION \"Coerce `value' to a float value if possible, return
NULL otherwise or raise an error if `error?' is true.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-VALUE-TO-FLOAT) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-FLOAT"
    "(DEFUN (COERCE-TO-FLOAT FLOAT) ((OBJECT OBJECT)) :DOCUMENTATION \"Coerce `number' to a float value or NULL if not possible.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-TO-FLOAT) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-VALUE-TO-TYPE"
    "(DEFUN (COERCE-VALUE-TO-TYPE OBJECT) ((VALUE OBJECT) (TYPE TYPE) (ERROR? BOOLEAN)) :DOCUMENTATION \"Coerce `value' to `type'.  Return NULL if not possible
or raise an error if `error?' is TRUE.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-VALUE-TO-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-OPTION-VALUE"
    "(DEFUN (COERCE-OPTION-VALUE OBJECT) ((VALUE OBJECT) (TYPE TYPE)) :DOCUMENTATION \"Coerce `value' to `type'.  Return NULL if not possible.\" :PUBLIC? TRUE)"
    (CL:FUNCTION COERCE-OPTION-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "VET-OPTIONS"
    "(DEFUN (VET-OPTIONS PROPERTY-LIST) ((PLIST OBJECT) (LEGALOPTIONS (CONS OF KEYWORD))))"
    (CL:FUNCTION VET-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-OPTIONS"
    "(DEFUN (PARSE-OPTIONS PROPERTY-LIST) ((OPTIONS OBJECT) (|LEGALOPTIONS&TYPES| CONS) (COERCIONERROR? BOOLEAN) (ALLOWOTHERKEYS? BOOLEAN)) :DOCUMENTATION \"Parse `options', check their validity according to
`legalOptions&Types' and return the result as a PROPERTY-LIST.
`legalOptions&Types' has to either be NULL or a flat list of legal
<keyword> <coercionType> pairs.  A type specifcation of @IDENTITY
means don't perform any coercion.
If `coercionError?' is TRUE, raise an error if a coercion failed.
If `allowOtherKeys?' is TRUE options other than those specified in
`legalOptions&Types' are allowed but won't be coerced since we don't
know their type.\" :PUBLIC? TRUE)" (CL:FUNCTION PARSE-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-COMMAND"
    "(DEFUN (EVALUATE-COMMAND OBJECT) ((COMMAND OBJECT) (FINALIZE? BOOLEAN)))"
    (CL:FUNCTION EVALUATE-COMMAND) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-FILE"
    "(DEFUN LOAD-FILE ((FILE STRING)) :DOCUMENTATION \"Read STELLA commands from `file' and evaluate them.
The file should begin with an `in-module' declaration that specifies
the module within which all remaining commands are to be evaluated
The remaining commands are evaluated one-by-one, applying the function
`evaluate' to each of them.\" :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %LOAD-FILE) (CL:FUNCTION LOAD-FILE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "MAKE-SYSTEM-DEFINITION-FILE-NAME"
    "(DEFUN (MAKE-SYSTEM-DEFINITION-FILE-NAME FILE-NAME) ((NAME STRING)))"
    (CL:FUNCTION MAKE-SYSTEM-DEFINITION-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-LIST-OF-FILE-PATHS"
    "(DEFUN (PARSE-LIST-OF-FILE-PATHS (CONS OF STRING-WRAPPER)) ((FILES CONS)))"
    (CL:FUNCTION PARSE-LIST-OF-FILE-PATHS) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-SYSTEM"
    "(DEFUN (DEFINE-SYSTEM SYSTEM-DEFINITION) ((NAME OBJECT) (OPTIONS CONS)))"
    (CL:FUNCTION DEFINE-SYSTEM) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFSYSTEM"
    "(DEFUN (DEFSYSTEM SYSTEM-DEFINITION) ((NAME SYMBOL) |&REST| (OPTIONS OBJECT)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE :DOCUMENTATION \"Define a system of files that collectively define
a Stella application.
   Required options are:
   :directory -- the relative path from the respective source/native/binary root directory
                 to the directory containing the system files.  Can be a string or a list
                 of strings (do not include directory separators).
   :files -- a list of files in the system, containing strings and lists
             of strings; the latter defines exploded paths to files
             in subdirectories.
   Optional options are:
   :data-files       -- a list of files like the :files keyword, which contain
                        data or other content that should not be processed, but
                        instead copied verbatim to the native directory
   :required-systems -- a list of systems (strings) that should be loaded
                        prior to loading this system.
   :cardinal-module -- the name (a string) of the principal module for this
                       system.
   :copyright-header -- string with a header for inclusion into all translated
                        files produced by Stella.
   :lisp-only-files  -- Like the :files keyword, but these are only included
   :cpp-only-files      in the translation for the specific language, namely
   :java-only-files     Common Lisp, C++ or Java\")"
    (CL:FUNCTION %DEFSYSTEM) (CL:FUNCTION DEFSYSTEM-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "GET-SYSTEM-DEFINITION"
    "(DEFUN (GET-SYSTEM-DEFINITION SYSTEM-DEFINITION) ((NAME STRING)))"
    (CL:FUNCTION GET-SYSTEM-DEFINITION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-CARDINAL-MODULE"
    "(DEFUN (GET-CARDINAL-MODULE MODULE) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION GET-CARDINAL-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-GET-SYSTEM-FILES"
    "(DEFUN HELP-GET-SYSTEM-FILES ((FILENAME FILE-NAME) (COLLECTION LIST) (PROBEFILE? BOOLEAN)))"
    (CL:FUNCTION HELP-GET-SYSTEM-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SYSTEM-FILES"
    "(DEFUN (GET-SYSTEM-FILES (LIST OF STRING-WRAPPER)) ((SYSTEM SYSTEM-DEFINITION) (TYPE KEYWORD) (PROBEFILES? BOOLEAN)))"
    (CL:FUNCTION GET-SYSTEM-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAN-SYSTEM"
    "(DEFUN CLEAN-SYSTEM ((SYSTEMNAME STRING)))"
    (CL:FUNCTION CLEAN-SYSTEM) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-OPTIMIZATION-LEVELS"
    "(DEFUN COMPUTE-OPTIMIZATION-LEVELS ((SYSTEM SYSTEM-DEFINITION) (PRODUCTIONMODE? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-OPTIMIZATION-LEVELS) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-SYSTEM"
    "(DEFUN (MAKE-SYSTEM BOOLEAN) ((SYSTEMNAME STRING) |&REST| (|LANGUAGE&OPTIONS| OBJECT)) :DOCUMENTATION \"Translate all out-of-date files of system `systemName'
into `language' (the first optional argument of `language&options') and
then compile and load them (the latter is only possible for Lisp right now).
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:two-pass?': if true, all files will be scanned twice, once to
load the signatures of objects defined in them, and once to actually
translate the definitions.  Otherwise, the translator will make one pass in
the case that the system is already loaded (and is being remade), and two
passes otherwise.

`:development-settings?' (default false): if true translation will favor
safe, readable and debuggable code over efficiency (according to the value
of `:development-settings' on the system definition).  If false, efficiency
will be favored instead (according to the value of `:production-settings'
on the system definition).

`:production-settings?' (default true): inverse to `:development-settings?'.

`:force-translation?' (default false): if true, files will be translated
whether or not their translations are up-to-date.

`:force-recompilation?' (default false): if true, translated files will be
recompiled whether or not their compilations are up-to-date (only supported
in Lisp right now).

`:load-system?' (default true): if true, compiled files will be loaded into
the current STELLA image (only supported in Lisp and Java right now).

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %MAKE-SYSTEM)
    (CL:FUNCTION MAKE-SYSTEM-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "RUN-SYSTEM-FINALIZATION"
    "(DEFUN RUN-SYSTEM-FINALIZATION ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION RUN-SYSTEM-FINALIZATION) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-DEFINITION-SOURCE-FILES"
    "(DEFUN (SYSTEM-DEFINITION-SOURCE-FILES (CONS OF STRING-WRAPPER)) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION SYSTEM-DEFINITION-SOURCE-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "FILES-PLUS-SYSTEM-STARTUP"
    "(DEFUN (FILES-PLUS-SYSTEM-STARTUP (CONS OF STRING-WRAPPER)) ((FILES (CONS OF STRING-WRAPPER))))"
    (CL:FUNCTION FILES-PLUS-SYSTEM-STARTUP) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-DEFINITION-NATIVE-FILES"
    "(DEFUN (SYSTEM-DEFINITION-NATIVE-FILES (CONS OF STRING-WRAPPER)) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION SYSTEM-DEFINITION-NATIVE-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-LOADED?"
    "(DEFUN (SYSTEM-LOADED? BOOLEAN) ((NAME STRING)) :DOCUMENTATION \"Return `true' if system `name' has been loaded.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SYSTEM-LOADED?) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-LOADED-OR-STARTED-UP?"
    "(DEFUN (SYSTEM-LOADED-OR-STARTED-UP? BOOLEAN) ((NAME STRING)) :DOCUMENTATION \"Return `true' if system `name' has either been loaded
or initialized with its startup function.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SYSTEM-LOADED-OR-STARTED-UP?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-SYSTEM"
    "(DEFUN CLEAR-SYSTEM ((NAME STRING)) :DOCUMENTATION \"Clears out the system definition named `name'.  If
`name' is `null', then clear out all system definitions.  This function
is useful when changes have been made to the system definition, and one
wants to have it reloaded from the standard location in the file system.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR-SYSTEM) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-PREPROCESSED-FILES"
    "(DEFUN LOAD-PREPROCESSED-FILES ((SYSTEMNAME STRING)))"
    (CL:FUNCTION LOAD-PREPROCESSED-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-SYSTEM"
    "(DEFUN (LOAD-SYSTEM BOOLEAN) ((SYSTEMNAME STRING) |&REST| (|LANGUAGE&OPTIONS| OBJECT)) :DOCUMENTATION \"Natively `language'-compile out-of-date translated files of system
`systemName' (only supported for Lisp at the moment) and then load them
into the running system.  Return true if at least one file was compiled.
The following keyword/value `options' are recognized:

`:language': can be used as an alternative to the optional language argument.
If not specified, the language of the running implementation is assumed.

`:force-recompilation?' (default false): if true, files will be compiled
whether or not their compilations are up-to-date.

`:startup?' (default true): if true, the system startup function will
be called once all files have been loaded.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %LOAD-SYSTEM)
    (CL:FUNCTION LOAD-SYSTEM-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "COMPILE-AND-LOAD-FILES"
    "(DEFUN (COMPILE-AND-LOAD-FILES BOOLEAN) ((FILES (CONS OF STRING-WRAPPER)) (LANGUAGE KEYWORD) (FORCERECOMPILATION? BOOLEAN)))"
    (CL:FUNCTION COMPILE-AND-LOAD-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "RUN-SYSTEM-STARTUP-FUNCTION"
    "(DEFUN RUN-SYSTEM-STARTUP-FUNCTION ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION RUN-SYSTEM-STARTUP-FUNCTION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SYSTEM-STARTUP-FUNCTION-NAME STRING) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION SYSTEM-STARTUP-FUNCTION-NAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SYSTEM-STARTUP-FUNCTION-NAME STRING) ((SYSTEMNAME STRING)))"
    (CL:FUNCTION SYSTEM-STARTUP-FUNCTION-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-STARTUP-FUNCTION-SYMBOL"
    "(DEFUN (SYSTEM-STARTUP-FUNCTION-SYMBOL SYMBOL) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION SYSTEM-STARTUP-FUNCTION-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-NAME-FROM-FILE"
    "(DEFUN (STARTUP-NAME-FROM-FILE SYMBOL) ((FILE FILE-NAME)))"
    (CL:FUNCTION STARTUP-NAME-FROM-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-NAMES-FROM-FILES"
    "(DEFUN (STARTUP-NAMES-FROM-FILES (CONS OF SYMBOL)) ((FILES (CONS OF STRING-WRAPPER))))"
    (CL:FUNCTION STARTUP-NAMES-FROM-FILES) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-STARTUP-FILE-NAME"
    "(DEFUN (SYSTEM-STARTUP-FILE-NAME STRING) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION SYSTEM-STARTUP-FILE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-STARTUP-FILE?"
    "(DEFUN (SYSTEM-STARTUP-FILE? BOOLEAN) ((FILE FILE-NAME)))"
    (CL:FUNCTION SYSTEM-STARTUP-FILE?) NULL)
   (DEFINE-FUNCTION-OBJECT "SYSTEM-STARTED-UP?"
    "(DEFUN (SYSTEM-STARTED-UP? BOOLEAN) ((SYSTEMNAME STRING) (SYSTEMMODULENAME STRING)))"
    (CL:FUNCTION SYSTEM-STARTED-UP?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-STARTUP-REQUIRED-SYSTEMS"
    "(DEFUN (YIELD-STARTUP-REQUIRED-SYSTEMS CONS) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION YIELD-STARTUP-REQUIRED-SYSTEMS) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE"
    "(DEFUN (COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE (CONS OF CONS)) ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION COLLECT-STARTUP-FORMS-FROM-SYSTEM-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-SYSTEM-STARTUP-FILE"
    "(DEFUN CREATE-SYSTEM-STARTUP-FILE ((SYSTEM SYSTEM-DEFINITION)))"
    (CL:FUNCTION CREATE-SYSTEM-STARTUP-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-ALL-REQUIRED-SYSTEMS"
    "(DEFUN (HELP-ALL-REQUIRED-SYSTEMS (LIST OF STRING-WRAPPER)) ((SYSTEM-NAME STRING) (FOUND (LIST OF STRING-WRAPPER))))"
    (CL:FUNCTION HELP-ALL-REQUIRED-SYSTEMS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-REQUIRED-SYSTEMS"
    "(DEFUN (ALL-REQUIRED-SYSTEMS (CONS OF STRING-WRAPPER)) ((SYSTEM-NAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns a CONS of all of the systems required by `system-name'\")"
    (CL:FUNCTION ALL-REQUIRED-SYSTEMS) NULL)
   (DEFINE-FUNCTION-OBJECT "AUTOLOAD"
    "(DEFUN (AUTOLOAD FUNCTION-CODE) ((QUALIFIEDNAME STRING) (SYSTEMNAME STRING) (CACHE SURROGATE) (ERROR? BOOLEAN)) :DOCUMENTATION \"Autoload function `qualifiedName' from system `systemName'.
If it is already present in the system, simply return its code.  If `cache'
is defined, return its value if defined, otherwise, set its value to the
function found.  If the function failed to be defined by loading `systemName'
and `error?' is true, raise an error.  Otherwise, simply return NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION AUTOLOAD) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-STELLA"
    "(DEFUN MAKE-STELLA ((FORCERECOMPILATION? BOOLEAN)))"
    (CL:FUNCTION MAKE-STELLA) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-CONFIGURATION-FILE-LINE"
    "(DEFUN (PARSE-CONFIGURATION-FILE-LINE STRING-WRAPPER WRAPPER KEYWORD) ((LINE STRING)))"
    (CL:FUNCTION PARSE-CONFIGURATION-FILE-LINE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-CONFIGURATION-FILE"
    "(DEFUN (LOAD-CONFIGURATION-FILE CONFIGURATION-TABLE) ((FILE FILE-NAME)) :DOCUMENTATION \"Read a configuration `file' and return its content as a configuration table.
Also enter each property read into the global system configuration table.
Assumes Java-style property file syntax.  Each property name is represented
as a wrapped string and each value as a wrapped string/integer/float or boolean.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %LOAD-CONFIGURATION-FILE)
    (CL:FUNCTION LOAD-CONFIGURATION-FILE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SAVE-CONFIGURATION-VALUE"
    "(DEFUN SAVE-CONFIGURATION-VALUE ((STREAM OUTPUT-STREAM) (VALUE OBJECT)) :DOCUMENTATION \"Save `value' to `stream' as a properly formatted configuration
value.\")" (CL:FUNCTION SAVE-CONFIGURATION-VALUE) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYSTEMS5 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "SAVE-CONFIGURATION-FILE"
    "(DEFUN SAVE-CONFIGURATION-FILE ((TABLE CONFIGURATION-TABLE) (FILE FILE-NAME) (TITLE STRING)) :DOCUMENTATION \"Save `table' as a configuration file.  Uses a Java-style property file syntax.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SAVE-CONFIGURATION-FILE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-CONFIGURATION-PROPERTY"
    "(DEFUN (LOOKUP-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (DEFAULTVALUE WRAPPER) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Lookup `property' in `configuration' and return its value.
Use the global system configuration table if `configuration' is NULL.  Return
`defaultValue' if `property' is not defined.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-CONFIGURATION-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-CONFIGURATION-PROPERTY-VALUES"
    "(DEFUN (LOOKUP-CONFIGURATION-PROPERTY-VALUES CONS) ((PROPERTY STRING) (DEFAULTVALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Lookup `property' in `configuration', assume it is a multi-valued
property and return its value(s) as a list.  Use the global system configuration table
if `configuration' is NULL.  Return `defaultValue' if `property' is not defined or
NIL is no default value is specified.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-CONFIGURATION-PROPERTY-VALUES) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-CONFIGURATION-PROPERTY"
    "(DEFUN (SET-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (VALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Set `property' in `configuration' to `value' and return it.
Use the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SET-CONFIGURATION-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-CONFIGURATION-PROPERTY"
    "(DEFUN (ADD-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (VALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Add `value' to `property' in `configuration' and return it.
If a previous value exists add `value' to the end (listify the old value
if it is not yet a list).  Otherwise, create a new list containing `value'.
Use the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ADD-CONFIGURATION-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-CONFIGURATION-PROPERTY"
    "(DEFUN (CLEAR-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Remove `property' in `configuration' and return the previous
value.
Use the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR-CONFIGURATION-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-CONFIGURATION-PROPERTY"
    "(DEFUN (REMOVE-CONFIGURATION-PROPERTY OBJECT) ((PROPERTY STRING) (VALUE OBJECT) (CONFIGURATION CONFIGURATION-TABLE)) :DOCUMENTATION \"Remove `value' from `property' in `configuration' and return it.
Use the global system configuration table if `configuration' is NULL.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REMOVE-CONFIGURATION-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-CONFIGURATION-PROPERTIES"
    "(DEFUN PRINT-CONFIGURATION-PROPERTIES ((CONFIGURATION CONFIGURATION-TABLE) (STREAM OUTPUT-STREAM)) :DOCUMENTATION \"Print all properties defined in `configuration' to `stream'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PRINT-CONFIGURATION-PROPERTIES) NULL)
   (DEFINE-FUNCTION-OBJECT "CONFIGURE-STELLA"
    "(DEFUN CONFIGURE-STELLA ((FILE FILE-NAME)) :DOCUMENTATION \"Perform STELLA run-time configuration.  If supplied, load the
configuration file `file' first which should be supplied with a physical pathname.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONFIGURE-STELLA) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-PROPERTY"
    "(DEFUN (GET-PROPERTY OBJECT) ((PROPERTY NAME) |&REST| (DEFAULTVALUE OBJECT)) :DOCUMENTATION \"Lookup `property' (a string or symbol) in the configuration
table and return its value.  If it is undefined, return the optional `defaultValue'.
Note that `property' is evaluated and will need to be quoted if supplied as a
symbol.  Symbols will also be upcased if this command is run in a non-case-
sensitive module.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %GET-PROPERTY)
    (CL:FUNCTION GET-PROPERTY-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-PROPERTY"
    "(DEFUN SET-PROPERTY ((PROPERTY NAME) (VALUE OBJECT)) :DOCUMENTATION \"Set `property' (a string or symbol) in the configuration
table to `value'.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in
a non-case-sensitive module.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %SET-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-PROPERTY-VALUE"
    "(DEFUN ADD-PROPERTY-VALUE ((PROPERTY NAME) (VALUE OBJECT)) :DOCUMENTATION \"Add `value' to the end of `property's (a string or symbol) value
list in the configuration table.  Coerces the current value to a list or initializes
the list if it is as yet undefined.  Allows incremental addition of values to
list-valued propertys.  Note that `property' is evaluated and will need to be quoted
if supplied as a symbol.  Symbols will also be upcased if this command is run in a
non-case-sensitive module.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION %ADD-PROPERTY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-PROPERTIES"
    "(DEFUN PRINT-PROPERTIES () :DOCUMENTATION \"Print all current configuration property information to
standard output.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION PRINT-PROPERTIES) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-CMD-LINE-OPTION"
    "(DEFUN REGISTER-CMD-LINE-OPTION (|&REST| (OPTIONS OBJECT)) :DOCUMENTATION \"Register a command line option.  :key identifies the name of the option which
will usually start with a dash such as `-e' or `--eval'.  :key2 and :key3 can be used to supply
additional options (e.g., long option formats).  To supply even more keys, a list can be supplied
with the :keys option.  If a :property is supplied, this option simply sets or adds to the values
of the specified system configuration property.  If a :handler name is specified, its function
will be used to interpret the values of the option.  :documentation can be used to supply a
documentation string which will be printed by the `help-option-handler' (usually bound to `-?').
:value-type describes what type an option value should be coerced to before assigning it to the
specified configuration :property.  :n-arguments describes how many arguments this option
takes.  This will be 0 for simple switches and can be 1 or greater than one for option handlers
that need one or more arguments.  :default-value defines the value to use for zero-argument
:property options.  If :multi-valued? is true, values of multiple occurrences of the option will be
added to the specified configuration :property.  :error-action can be one of :ignore, :warn or
:error to specify what to do in case an error is encountered during option processing.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REGISTER-CMD-LINE-OPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "UNREGISTER-CMD-LINE-OPTION"
    "(DEFUN UNREGISTER-CMD-LINE-OPTION ((KEY STRING)) :DOCUMENTATION \"Unregister the command line option identified by `key' under all its keys.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNREGISTER-CMD-LINE-OPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "UNREGISTER-ALL-CMD-LINE-OPTIONS"
    "(DEFUN UNREGISTER-ALL-CMD-LINE-OPTIONS () :DOCUMENTATION \"Unregister all currently registered command line options.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNREGISTER-ALL-CMD-LINE-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFAULT-CMD-LINE-OPTION-HANDLER"
    "(DEFUN DEFAULT-CMD-LINE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Default handler that tries to set a system property based on `option' and `value'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DEFAULT-CMD-LINE-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "PROCESS-COMMAND-LINE-ARGUMENTS"
    "(DEFUN PROCESS-COMMAND-LINE-ARGUMENTS ((COUNT INTEGER) (ARGUMENTS (ARRAY () OF STRING)) (UNHANDLEDOPTIONACTION KEYWORD)) :DOCUMENTATION \"Interpret any command line `arguments' for which handlers have been registered.
Leave any remaining unprocessed arguments in `*unprocessed-command-line-arguments*'.
If any unprocessed arguments use option syntax (that is they start with a `-'), proceed
according to `unhandledOptionAction' which can be one of :ignore, :warn or :error.
This ensures that at any point in the option processing, `*unprocessed-command-line-arguments*'
accurately reflects the arguments which have been either skipped or not handled yet.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PROCESS-COMMAND-LINE-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNPROCESSED-COMMAND-LINE-ARGUMENTS"
    "(DEFUN (UNPROCESSED-COMMAND-LINE-ARGUMENTS (CONS OF STRING-WRAPPER)) () :DOCUMENTATION \"Return all command line arguments which have not yet been processed
by (or been ignored by) `process-command-line-arguments'.  If arguments have not yet
been processed, this will return NULL.\" :PUBLIC? TRUE :COMMAND? TRUE)"
    (CL:FUNCTION UNPROCESSED-COMMAND-LINE-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "EVAL-OPTION-HANDLER"
    "(DEFUN EVAL-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Interpret an --eval option by evaluating `value'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION EVAL-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "EVAL-IN-MODULE-OPTION-HANDLER"
    "(DEFUN EVAL-IN-MODULE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Interpret an --eval-in-module option.  `value' is expected
to be of the form `(<module-name> <s-expression>)'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION EVAL-IN-MODULE-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-PATH-OPTION-HANDLER"
    "(DEFUN LOAD-PATH-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Modify the current file load path according to `option' and `value'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOAD-PATH-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "CONFIG-FILE-OPTION-HANDLER"
    "(DEFUN CONFIG-FILE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Load the configuration file `value'.  This will
modify currently set system properties defined in `value' with new
values but leave all other currently set properties as they are.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CONFIG-FILE-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "LOAD-FILE-OPTION-HANDLER"
    "(DEFUN LOAD-FILE-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Load the file `value' using the STELLA `load-file' command.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOAD-FILE-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-PROPERTY-OPTION-HANDLER"
    "(DEFUN DEFINE-PROPERTY-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)))"
    (CL:FUNCTION DEFINE-PROPERTY-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-OPTION-HANDLER"
    "(DEFUN HELP-OPTION-HANDLER ((OPTION CMD-LINE-OPTION) (VALUE OBJECT)) :DOCUMENTATION \"Print documentation about all currently registered option handlers.\" :PUBLIC? TRUE)"
    (CL:FUNCTION HELP-OPTION-HANDLER) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-SYSTEMS"
    "(DEFUN STARTUP-SYSTEMS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-SYSTEMS) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-SYSTEMS-STELLA-STARTUP-SYSTEMS)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-SYSTEMS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupSystems") NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFUN STARTUP-SYSTEMS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-SYSTEMS1)
    (HELP-STARTUP-SYSTEMS2) (HELP-STARTUP-SYSTEMS3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *FILE-LOAD-PATH* NIL)
    (CL:SETQ *STELLA-FILE-EXTENSIONS* (CONS-LIST (WRAP-STRING ".ste")))
    (CL:SETQ *SYSTEMDEFINITIONS* (NEW-LIST))
    (CL:SETQ *SYSTEM-CONFIGURATION-TABLE* (NEW-KEY-VALUE-LIST))
    (CL:SETQ *REGISTERED-COMMAND-LINE-OPTIONS* (NEW-KEY-VALUE-MAP)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE CONFIGURATION-TABLE (KEY-VALUE-LIST OF STRING-WRAPPER OBJECT))")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CMD-LINE-OPTION"
        "(DEFCLASS CMD-LINE-OPTION (STANDARD-OBJECT) :SLOTS ((DOCUMENTATION :TYPE STRING :INITIALLY \"Not documented.\") (KEYS :TYPE (CONS OF STRING-WRAPPER) :INITIALLY NIL) (VALUE-TYPE :TYPE TYPE :INITIALLY @STRING) (MULTI-VALUED? :TYPE BOOLEAN :INITIALLY FALSE) (N-ARGUMENTS :TYPE INTEGER :INITIALLY 0 :DOCUMENTATION \"The number of args expected by this option.
Common values are 0 or 1, but certain options might take more than one argument.\") (DEFAULT-VALUE :TYPE OBJECT :DOCUMENTATION \"The value to use for 0-arg options.
Defaults to TRUE for 0-arg options with boolean value type.\") (CONFIGURATION-PROPERTY :TYPE STRING) (HANDLER :TYPE FUNCTION-CODE :INITIALLY (THE-CODE :FUNCTION DEFAULT-CMD-LINE-OPTION-HANDLER)) (ERROR-ACTION :TYPE KEYWORD :INITIALLY :ERROR :DOCUMENTATION \"One of :ignore, :warn, :error.\")))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CMD-LINE-OPTION))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CMD-LINE-OPTION-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-SYSTEMS4)
    (HELP-STARTUP-SYSTEMS5))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "STELLA")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FILE-LOAD-PATH* (CONS OF STRING-WRAPPER) NIL)")
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-SET-LOAD-PATH
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-PUSH-LOAD-PATH
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-ADD-LOAD-PATH
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-DROP-LOAD-PATH
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STELLA-FILE-EXTENSIONS* CONS (CONS-LIST \".ste\") :DOCUMENTATION \"File extensions to append by default when a
file is looked up by `find-file-in-load-path'.\" :PUBLIC? TRUE)")
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-LOAD-FILE
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SYSTEMDEFINITIONS* (LIST OF SYSTEM-DEFINITION) (NEW LIST) :DOCUMENTATION \"A list of all defined systems.\")")
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-DEFSYSTEM
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CURRENT-SYSTEM-ACTION* PROPERTY-LIST NULL :DOCUMENTATION \"Holds the action and options of the current system action
such as :make-system, :load-system or :translate-system.  This is used to
perform the appropriate actions on required systems in `define-system'.\")")
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-MAKE-SYSTEM
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-LOAD-SYSTEM
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SYSTEM-CONFIGURATION-TABLE* CONFIGURATION-TABLE (NEW CONFIGURATION-TABLE))")
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-LOAD-CONFIGURATION-FILE
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-GET-PROPERTY
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-SET-PROPERTY
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-SYSTEMS-STELLA-ADD-PROPERTY-VALUE
     KWD-SYSTEMS-COMMON-LISP KWD-SYSTEMS-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *REGISTERED-COMMAND-LINE-OPTIONS* (KEY-VALUE-MAP OF STRING-WRAPPER CMD-LINE-OPTION) (NEW KEY-VALUE-MAP))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *UNPROCESSED-COMMAND-LINE-ARGUMENTS* (CONS OF STRING-WRAPPER) NULL)")
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "-e")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--eval") KWD-SYSTEMS-KEY3
     (WRAP-STRING "-eval") KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<s-expression>
  Evaluate the STELLA <s-expression> in the current module.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-EVAL-OPTION-HANDLER KWD-SYSTEMS-ERROR-ACTION
     KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY
     (WRAP-STRING "--eval-in-module") KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<module-name> <s-expression>
  Evaluate the STELLA <s-expression> in module <module-name>.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 2) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-EVAL-IN-MODULE-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "--path")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--path+=")
     KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<path>
  Add <path> to the front of the current file load path.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-LOAD-PATH-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "--path=")
     KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<path>
  Set the current file load path to <path>.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-LOAD-PATH-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "--path=+")
     KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<path>
  Add <path> at the end of the current file load path.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-LOAD-PATH-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "-c")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--configuration-file")
     KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<file>
  Load the STELLA configuration file <file>.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-CONFIG-FILE-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "-l")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--load") KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<file>
  Load the STELLA file <file>.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-LOAD-FILE-OPTION-HANDLER
     KWD-SYSTEMS-ERROR-ACTION KWD-SYSTEMS-WARN)
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "-D")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--define")
     KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "<property>{=|+=|-=}<value>}
  Set the STELLA configuration <property> to <value>.  Multi-valued properties can be
  added to via the `+=' and removed from via the `-=' assignment operator.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 1) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-DEFINE-PROPERTY-OPTION-HANDLER)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *COMMAND-LINE-HELP-HEADER* STRING \"\" :DOCUMENTATION \"Documentation to be printed at the beginning of command line help.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *COMMAND-LINE-HELP-TRAILER* STRING \"\" :DOCUMENTATION \"Documentation to be printed at the end of command line help.\" :PUBLIC? TRUE)")
    (REGISTER-CMD-LINE-OPTION KWD-SYSTEMS-KEY (WRAP-STRING "-?")
     KWD-SYSTEMS-KEY2 (WRAP-STRING "--help") KWD-SYSTEMS-DOCUMENTATION
     (WRAP-STRING "
  Print this command line help message.")
     KWD-SYSTEMS-N-ARGUMENTS (WRAP-INTEGER 0) KWD-SYSTEMS-HANDLER
     SYM-SYSTEMS-STELLA-HELP-OPTION-HANDLER)))
  :VOID)
