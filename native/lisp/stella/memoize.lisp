;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; memoize.lisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2014      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-MEMOIZE-STELLA-MEMOIZATION-TABLE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-HASH-TABLE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-TABLE-NAME NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-CURRENT-TIMESTAMP NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-TIMESTAMPS NULL)
(CL:DEFVAR SGT-MEMOIZE-STELLA-MRU-MEMOIZATION-TABLE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-MRU-BUCKETS-VECTOR NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-LRU-BUCKETS-VECTOR NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-MRU-TIMESTAMP NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-LRU-TIMESTAMP NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-NOF-BUCKETS NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-FREE-ENTRIES NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-MAX-ENTRIES NULL)
(CL:DEFVAR KWD-MEMOIZE-MAX-VALUES NULL)
(CL:DEFVAR KWD-MEMOIZE-TIMESTAMPS NULL)
(CL:DEFVAR KWD-MEMOIZE-NAME NULL)
(CL:DEFVAR SGT-MEMOIZE-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SGT-MEMOIZE-STELLA-STANDARD-OBJECT NULL)
(CL:DEFVAR SGT-MEMOIZE-STELLA-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SGT-MEMOIZE-STELLA-BOOLEAN NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-LOOKUP-MEMOIZED-VALUE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-LOOKUP-MEMOIZED-VALUEN NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-LOOKUP-MRU-MEMOIZED-VALUE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-LOOKUP-MRU-MEMOIZED-VALUEN NULL)
(CL:DEFVAR SGT-MEMOIZE-STELLA-OBJECT NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-MEMOIZED-NULL-VALUE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-NULL NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-CONS-LIST NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-VRLET NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-MEMOIZATION-TABLE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-CONS NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-OBJECT NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-WHEN NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-*MEMOIZATION-ENABLED?* NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-SETQ NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-SURROGATE-VALUE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-NULL? NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-INITIALIZE-MEMOIZATION-TABLE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-FIRST NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-COND NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-DEFINED? NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-EQL? NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-OTHERWISE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-SETF NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-VALUE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-CHOOSE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-CAST NULL)
(CL:DEFVAR SGT-MEMOIZE-STELLA-MEMOIZABLE-ITERATOR NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-BASE-ITERATOR NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-ITERATOR-AND-VALUES NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-CURSOR NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-STARTUP-MEMOIZE NULL)
(CL:DEFVAR SYM-MEMOIZE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* STANDARD-ERROR EOL NULL-INTEGER
  *INTEGER-MSB-MASK* NIL))

;;; (DEFCLASS MEMOIZATION-TABLE ...)

(CL:DEFCLASS MEMOIZATION-TABLE (STANDARD-OBJECT)
  ((HASH-TABLE :DOCUMENTATION "The table holding the memoized values.
We use an integer table, since we explicitly compute a hash code by combining
hash codes of argument values." :ALLOCATION :INSTANCE :ACCESSOR
    %HASH-TABLE)
   (TABLE-NAME :DOCUMENTATION
    "The surrogate used to point to this table.
Used at the memoization site for quick memo table lookup." :ALLOCATION
    :INSTANCE :ACCESSOR %TABLE-NAME)
   (CURRENT-TIMESTAMP :DOCUMENTATION
    "Marker value used to indicate valid memoized entries.
This marker changes everytime one of the `timestamps' gets bumped."
    :ALLOCATION :INSTANCE :ACCESSOR %CURRENT-TIMESTAMP)
   (TIMESTAMPS :DOCUMENTATION
    "Names of timestamps that trigger invalidation of
memoized entries when they get bumped." :ALLOCATION :INSTANCE :ACCESSOR
    %TIMESTAMPS))
  (:DOCUMENTATION
   "Table that maps argument values onto computed results for
one individual memoization site."))

(CL:DEFUN NEW-MEMOIZATION-TABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE MEMOIZATION-TABLE)))
   (CL:SETF (%TIMESTAMPS SELF) NIL)
   (CL:SETF (%CURRENT-TIMESTAMP SELF) NULL)
   (CL:SETF (%TABLE-NAME SELF) NULL) (CL:SETF (%HASH-TABLE SELF) NULL)
   (CL:RETURN-FROM NEW-MEMOIZATION-TABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF MEMOIZATION-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-MEMOIZE-STELLA-MEMOIZATION-TABLE))

(CL:DEFUN ACCESS-MEMOIZATION-TABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-HASH-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%HASH-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%HASH-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-TABLE-NAME)
    (CL:IF SETVALUE? (CL:SETF (%TABLE-NAME SELF) VALUE)
     (CL:SETQ VALUE (%TABLE-NAME SELF))))
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-CURRENT-TIMESTAMP)
    (CL:IF SETVALUE? (CL:SETF (%CURRENT-TIMESTAMP SELF) VALUE)
     (CL:SETQ VALUE (%CURRENT-TIMESTAMP SELF))))
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-TIMESTAMPS)
    (CL:IF SETVALUE? (CL:SETF (%TIMESTAMPS SELF) VALUE)
     (CL:SETQ VALUE (%TIMESTAMPS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-MEMOIZATION-TABLE-SLOT-VALUE VALUE))

;;; (DEFGLOBAL *ALL-MEMOIZATION-TABLES* ...)

(CL:DEFVAR *ALL-MEMOIZATION-TABLES* NULL
  "Holds all currently active memoization tables for timestamp
maintenance and clearance purposes.")

;;; (DEFGLOBAL *MEMOIZATION-ENABLED?* ...)

(CL:DEFVAR *MEMOIZATION-ENABLED?* CL:NIL)

;;; (DEFUN ENABLE-MEMOIZATION ...)

(CL:DEFUN ENABLE-MEMOIZATION ()
  "Enable memoization and use of memoized expression results."
  (CL:SETQ *MEMOIZATION-ENABLED?* CL:T)
  :VOID)

;;; (DEFUN DISABLE-MEMOIZATION ...)

(CL:DEFUN DISABLE-MEMOIZATION ()
  "Enable memoization and use of memoized expression results."
  (CL:SETQ *MEMOIZATION-ENABLED?* CL:NIL)
  :VOID)

;;; (DEFCONSTANT MEMOIZED-NULL-VALUE ...)

(CL:DEFVAR MEMOIZED-NULL-VALUE NULL
  "Used by memoization to indicate that a NULL value
was cached.  Needed to distinguish between an undefined value and a
cached NULL.")

;;; (DEFGLOBAL *TOTAL-MEMOIZATION-LOOKUPS* ...)

(CL:DEFVAR *TOTAL-MEMOIZATION-LOOKUPS* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *TOTAL-MEMOIZATION-LOOKUPS*))

;;; (DEFGLOBAL *FAILED-MEMOIZATION-LOOKUPS* ...)

(CL:DEFVAR *FAILED-MEMOIZATION-LOOKUPS* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *FAILED-MEMOIZATION-LOOKUPS*))

;;; (DEFUN (HASH-MEMOIZED-ARGUMENTS INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:T CL:T CL:FIXNUM) CL:FIXNUM)
  HASH-MEMOIZED-ARGUMENTS))
(CL:DEFUN HASH-MEMOIZED-ARGUMENTS (ARG1 ARG2 ARG3 ARG4 EQVECTOR)
  (CL:DECLARE (CL:TYPE CL:FIXNUM EQVECTOR))
  #+MCL
  (CL:CHECK-TYPE EQVECTOR CL:FIXNUM)
  (CL:LET* ((HASHCODE 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM HASHCODE))
   (CL:COND
    ((CL:< EQVECTOR 0)
     (CL:WHEN (CL:EQ ARG1 NULL) (CL:SETQ ARG1 MEMOIZED-NULL-VALUE))
     (CL:SETQ HASHCODE
      (CL:LET ((SELF ARG1))
       (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF))))
     (CL:LOOP (CL:WHEN (CL:EQ ARG2 MEMOIZED-NULL-VALUE) (CL:RETURN))
      (CL:WHEN (CL:EQ ARG2 NULL) (CL:SETQ ARG2 MEMOIZED-NULL-VALUE))
      (CL:SETQ HASHCODE
       (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND HASHCODE 1)) 0)
        (CL:LET ((ARG HASHCODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
         (CL:THE CL:FIXNUM
          (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
           *INTEGER-UNSIGNED-BITS-MASK*)))
        (CL:THE CL:FIXNUM
         (CL:LOGIOR
          (CL:THE CL:FIXNUM
           (CL:LET ((ARG HASHCODE) (COUNT 1))
            (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
            (CL:THE CL:FIXNUM
             (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
          *INTEGER-MSB-MASK*))))
      (CL:SETQ HASHCODE
       (CL:THE CL:FIXNUM
        (CL:LOGXOR HASHCODE
         (CL:THE CL:FIXNUM
          (CL:LET ((SELF ARG2))
           (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF)))))))
      (CL:WHEN (CL:EQ ARG3 MEMOIZED-NULL-VALUE) (CL:RETURN))
      (CL:WHEN (CL:EQ ARG3 NULL) (CL:SETQ ARG3 MEMOIZED-NULL-VALUE))
      (CL:SETQ HASHCODE
       (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND HASHCODE 1)) 0)
        (CL:LET ((ARG HASHCODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
         (CL:THE CL:FIXNUM
          (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
           *INTEGER-UNSIGNED-BITS-MASK*)))
        (CL:THE CL:FIXNUM
         (CL:LOGIOR
          (CL:THE CL:FIXNUM
           (CL:LET ((ARG HASHCODE) (COUNT 1))
            (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
            (CL:THE CL:FIXNUM
             (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
          *INTEGER-MSB-MASK*))))
      (CL:SETQ HASHCODE
       (CL:THE CL:FIXNUM
        (CL:LOGXOR HASHCODE
         (CL:THE CL:FIXNUM
          (CL:LET ((SELF ARG3))
           (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF)))))))
      (CL:WHEN (CL:EQ ARG4 MEMOIZED-NULL-VALUE) (CL:RETURN))
      (CL:WHEN (CL:EQ ARG4 NULL) (CL:SETQ ARG4 MEMOIZED-NULL-VALUE))
      (CL:SETQ HASHCODE
       (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND HASHCODE 1)) 0)
        (CL:LET ((ARG HASHCODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
         (CL:THE CL:FIXNUM
          (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
           *INTEGER-UNSIGNED-BITS-MASK*)))
        (CL:THE CL:FIXNUM
         (CL:LOGIOR
          (CL:THE CL:FIXNUM
           (CL:LET ((ARG HASHCODE) (COUNT 1))
            (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
            (CL:THE CL:FIXNUM
             (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
          *INTEGER-MSB-MASK*))))
      (CL:SETQ HASHCODE
       (CL:THE CL:FIXNUM
        (CL:LOGXOR HASHCODE
         (CL:THE CL:FIXNUM
          (CL:LET ((SELF ARG4))
           (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF)))))))
      (CL:RETURN)))
    (CL:T
     (CL:WHEN (CL:EQ ARG1 NULL) (CL:SETQ ARG1 MEMOIZED-NULL-VALUE))
     (CL:SETQ HASHCODE
      (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND EQVECTOR 1)) 0)
       (HASH-CODE ARG1)
       (CL:LET ((SELF ARG1))
        (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF)))))
     (CL:LOOP (CL:WHEN (CL:EQ ARG2 MEMOIZED-NULL-VALUE) (CL:RETURN))
      (CL:WHEN (CL:EQ ARG2 NULL) (CL:SETQ ARG2 MEMOIZED-NULL-VALUE))
      (CL:SETQ HASHCODE
       (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND HASHCODE 1)) 0)
        (CL:LET ((ARG HASHCODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
         (CL:THE CL:FIXNUM
          (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
           *INTEGER-UNSIGNED-BITS-MASK*)))
        (CL:THE CL:FIXNUM
         (CL:LOGIOR
          (CL:THE CL:FIXNUM
           (CL:LET ((ARG HASHCODE) (COUNT 1))
            (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
            (CL:THE CL:FIXNUM
             (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
          *INTEGER-MSB-MASK*))))
      (CL:SETQ HASHCODE
       (CL:THE CL:FIXNUM
        (CL:LOGXOR HASHCODE
         (CL:THE CL:FIXNUM
          (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND EQVECTOR 2)) 0)
           (HASH-CODE ARG2)
           (CL:LET ((SELF ARG2))
            (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF))))))))
      (CL:WHEN (CL:EQ ARG3 MEMOIZED-NULL-VALUE) (CL:RETURN))
      (CL:WHEN (CL:EQ ARG3 NULL) (CL:SETQ ARG3 MEMOIZED-NULL-VALUE))
      (CL:SETQ HASHCODE
       (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND HASHCODE 1)) 0)
        (CL:LET ((ARG HASHCODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
         (CL:THE CL:FIXNUM
          (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
           *INTEGER-UNSIGNED-BITS-MASK*)))
        (CL:THE CL:FIXNUM
         (CL:LOGIOR
          (CL:THE CL:FIXNUM
           (CL:LET ((ARG HASHCODE) (COUNT 1))
            (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
            (CL:THE CL:FIXNUM
             (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
          *INTEGER-MSB-MASK*))))
      (CL:SETQ HASHCODE
       (CL:THE CL:FIXNUM
        (CL:LOGXOR HASHCODE
         (CL:THE CL:FIXNUM
          (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND EQVECTOR 4)) 0)
           (HASH-CODE ARG3)
           (CL:LET ((SELF ARG3))
            (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF))))))))
      (CL:WHEN (CL:EQ ARG4 MEMOIZED-NULL-VALUE) (CL:RETURN))
      (CL:WHEN (CL:EQ ARG4 NULL) (CL:SETQ ARG4 MEMOIZED-NULL-VALUE))
      (CL:SETQ HASHCODE
       (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND HASHCODE 1)) 0)
        (CL:LET ((ARG HASHCODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
         (CL:THE CL:FIXNUM
          (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
           *INTEGER-UNSIGNED-BITS-MASK*)))
        (CL:THE CL:FIXNUM
         (CL:LOGIOR
          (CL:THE CL:FIXNUM
           (CL:LET ((ARG HASHCODE) (COUNT 1))
            (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
            (CL:THE CL:FIXNUM
             (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
          *INTEGER-MSB-MASK*))))
      (CL:SETQ HASHCODE
       (CL:THE CL:FIXNUM
        (CL:LOGXOR HASHCODE
         (CL:THE CL:FIXNUM
          (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND EQVECTOR 8)) 0)
           (HASH-CODE ARG4)
           (CL:LET ((SELF ARG4))
            (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF))))))))
      (CL:RETURN))))
   (CL:RETURN-FROM HASH-MEMOIZED-ARGUMENTS HASHCODE)))

;;; (DEFUN (HASH-MEMOIZED-ARGUMENTSN INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:FIXNUM) CL:FIXNUM)
  HASH-MEMOIZED-ARGUMENTSN))
(CL:DEFUN HASH-MEMOIZED-ARGUMENTSN (TUPLE EQVECTOR)
  (CL:DECLARE (CL:TYPE CL:FIXNUM EQVECTOR))
  #+MCL
  (CL:CHECK-TYPE EQVECTOR CL:FIXNUM)
  (CL:LET* ((HASHCODE 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM HASHCODE))
   (CL:COND
    ((CL:< EQVECTOR 0)
     (CL:LET* ((ARG NULL) (ITER-000 TUPLE))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ ARG (%%VALUE ITER-000))
       (CL:WHEN (CL:EQ ARG NULL) (CL:SETQ ARG MEMOIZED-NULL-VALUE))
       (CL:SETQ HASHCODE
        (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND HASHCODE 1)) 0)
         (CL:LET ((ARG HASHCODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
          (CL:THE CL:FIXNUM
           (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
            *INTEGER-UNSIGNED-BITS-MASK*)))
         (CL:THE CL:FIXNUM
          (CL:LOGIOR
           (CL:THE CL:FIXNUM
            (CL:LET ((ARG HASHCODE) (COUNT 1))
             (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
             (CL:THE CL:FIXNUM
              (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
           *INTEGER-MSB-MASK*))))
       (CL:SETQ HASHCODE
        (CL:THE CL:FIXNUM
         (CL:LOGXOR HASHCODE
          (CL:THE CL:FIXNUM
           (CL:LET ((SELF ARG))
            (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF)))))))
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:T
     (CL:LET* ((ARG NULL) (ITER-001 TUPLE))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ ARG (%%VALUE ITER-001))
       (CL:WHEN (CL:EQ ARG NULL) (CL:SETQ ARG MEMOIZED-NULL-VALUE))
       (CL:SETQ HASHCODE
        (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND HASHCODE 1)) 0)
         (CL:LET ((ARG HASHCODE)) (CL:DECLARE (CL:TYPE CL:FIXNUM ARG))
          (CL:THE CL:FIXNUM
           (CL:LOGAND (CL:THE CL:FIXNUM (CL:ASH ARG -1))
            *INTEGER-UNSIGNED-BITS-MASK*)))
         (CL:THE CL:FIXNUM
          (CL:LOGIOR
           (CL:THE CL:FIXNUM
            (CL:LET ((ARG HASHCODE) (COUNT 1))
             (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
             (CL:THE CL:FIXNUM
              (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
           *INTEGER-MSB-MASK*))))
       (CL:SETQ HASHCODE
        (CL:THE CL:FIXNUM
         (CL:LOGXOR HASHCODE
          (CL:THE CL:FIXNUM
           (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LOGAND EQVECTOR 1)) 0)
            (HASH-CODE ARG)
            (CL:LET ((SELF ARG))
             (CL:THE CL:FIXNUM (STELLA::%%OBJECT-HASH-CODE SELF))))))))
       (CL:SETQ EQVECTOR
        (CL:LET ((ARG EQVECTOR) (COUNT 1))
         (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
         (CL:THE CL:FIXNUM
          (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT))))))
       (CL:SETQ ITER-001 (%%REST ITER-001))))))
   (CL:RETURN-FROM HASH-MEMOIZED-ARGUMENTSN HASHCODE)))

;;; (DEFUN (MAKE-MEMOIZED-VALUE-ENTRY (CONS OF CONS)) ...)

(CL:DEFUN MAKE-MEMOIZED-VALUE-ENTRY (VALUE ARG1 ARG2 ARG3 ARG4)
  (CL:LET* ((ENTRY NIL) (CURSOR NIL) (CELL NIL))
   (CL:SETQ ENTRY (CL:CONS CL:NIL CL:NIL))
   (CL:SETF (%%VALUE ENTRY) VALUE)
   (CL:SETQ CELL (CL:CONS CL:NIL CL:NIL)) (CL:SETF (%%REST ENTRY) CELL)
   (CL:SETF (%%VALUE CELL) ARG1)
   (CL:WHEN (CL:EQ ARG2 MEMOIZED-NULL-VALUE)
    (CL:SETF (%%REST CELL) NIL)
    (CL:RETURN-FROM MAKE-MEMOIZED-VALUE-ENTRY ENTRY))
   (CL:SETQ CURSOR CELL) (CL:SETQ CELL (CL:CONS CL:NIL CL:NIL))
   (CL:SETF (%%REST CURSOR) CELL) (CL:SETF (%%VALUE CELL) ARG2)
   (CL:WHEN (CL:EQ ARG3 MEMOIZED-NULL-VALUE)
    (CL:SETF (%%REST CELL) NIL)
    (CL:RETURN-FROM MAKE-MEMOIZED-VALUE-ENTRY ENTRY))
   (CL:SETQ CURSOR CELL) (CL:SETQ CELL (CL:CONS CL:NIL CL:NIL))
   (CL:SETF (%%REST CURSOR) CELL) (CL:SETF (%%VALUE CELL) ARG3)
   (CL:WHEN (CL:EQ ARG4 MEMOIZED-NULL-VALUE)
    (CL:SETF (%%REST CELL) NIL)
    (CL:RETURN-FROM MAKE-MEMOIZED-VALUE-ENTRY ENTRY))
   (CL:SETQ CURSOR CELL) (CL:SETQ CELL (CL:CONS CL:NIL CL:NIL))
   (CL:SETF (%%REST CURSOR) CELL) (CL:SETF (%%VALUE CELL) ARG4)
   (CL:SETF (%%REST CELL) NIL)
   (CL:RETURN-FROM MAKE-MEMOIZED-VALUE-ENTRY ENTRY)))

;;; (DEFUN (MAKE-MEMOIZED-VALUE-ENTRYN (CONS OF CONS)) ...)

(CL:DEFUN MAKE-MEMOIZED-VALUE-ENTRYN (VALUE ARGS)
  (CL:RETURN-FROM MAKE-MEMOIZED-VALUE-ENTRYN (CONS VALUE ARGS)))

;;; (DEFUN (FIND-MEMOIZED-VALUE-ENTRY CONS) ...)

(CL:DEFUN FIND-MEMOIZED-VALUE-ENTRY (BUCKET ARG1 ARG2 ARG3 ARG4 EQVECTOR DELETEENTRY?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM EQVECTOR))
  #+MCL
  (CL:CHECK-TYPE EQVECTOR CL:FIXNUM)
  (CL:LET* ((ENTRIES (%%REST BUCKET)) (ARGS NIL) (RESULT NULL))
   (CL:COND
    ((CL:< EQVECTOR 0)
     (CL:LOOP WHILE (CL:NOT (CL:EQ ENTRIES NIL)) DO
      (CL:SETQ ARGS (%%REST (%%VALUE ENTRIES)))
      (CL:WHEN (CL:EQ (%%VALUE ARGS) ARG1)
       (CL:WHEN (CL:EQ ARG2 MEMOIZED-NULL-VALUE)
        (CL:SETQ RESULT (%%VALUE ENTRIES)) (CL:RETURN))
       (CL:SETQ ARGS (%%REST ARGS))
       (CL:WHEN (CL:EQ (%%VALUE ARGS) ARG2)
        (CL:WHEN (CL:EQ ARG3 MEMOIZED-NULL-VALUE)
         (CL:SETQ RESULT (%%VALUE ENTRIES)) (CL:RETURN))
        (CL:SETQ ARGS (%%REST ARGS))
        (CL:WHEN (CL:EQ (%%VALUE ARGS) ARG3)
         (CL:WHEN (CL:EQ ARG4 MEMOIZED-NULL-VALUE)
          (CL:SETQ RESULT (%%VALUE ENTRIES)) (CL:RETURN))
         (CL:SETQ ARGS (%%REST ARGS))
         (CL:WHEN (CL:EQ (%%VALUE ARGS) ARG4)
          (CL:SETQ RESULT (%%VALUE ENTRIES)) (CL:RETURN)))))
      (CL:SETQ ENTRIES (%%REST ENTRIES))))
    (CL:T
     (CL:LET* ((ARG NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ENTRIES NIL)) DO
       (CL:SETQ ARGS (%%REST (%%VALUE ENTRIES)))
       (CL:SETQ ARG (%%VALUE ARGS))
       (CL:WHEN
        (CL:OR (CL:EQ ARG ARG1)
         (CL:AND (CL:= (CL:THE CL:FIXNUM (CL:LOGAND EQVECTOR 1)) 0)
          (CL:NOT (CL:EQ ARG NULL)) (CL:NOT (CL:EQ ARG1 NULL))
          (OBJECT-EQL? ARG ARG1)))
        (CL:WHEN (CL:EQ ARG2 MEMOIZED-NULL-VALUE)
         (CL:SETQ RESULT (%%VALUE ENTRIES)) (CL:RETURN))
        (CL:SETQ ARGS (%%REST ARGS)) (CL:SETQ ARG (%%VALUE ARGS))
        (CL:WHEN
         (CL:OR (CL:EQ ARG ARG2)
          (CL:AND (CL:= (CL:THE CL:FIXNUM (CL:LOGAND EQVECTOR 2)) 0)
           (CL:NOT (CL:EQ ARG NULL)) (CL:NOT (CL:EQ ARG2 NULL))
           (OBJECT-EQL? ARG ARG2)))
         (CL:WHEN (CL:EQ ARG3 MEMOIZED-NULL-VALUE)
          (CL:SETQ RESULT (%%VALUE ENTRIES)) (CL:RETURN))
         (CL:SETQ ARGS (%%REST ARGS)) (CL:SETQ ARG (%%VALUE ARGS))
         (CL:WHEN
          (CL:OR (CL:EQ ARG ARG3)
           (CL:AND (CL:= (CL:THE CL:FIXNUM (CL:LOGAND EQVECTOR 4)) 0)
            (CL:NOT (CL:EQ ARG NULL)) (CL:NOT (CL:EQ ARG3 NULL))
            (OBJECT-EQL? ARG ARG3)))
          (CL:WHEN (CL:EQ ARG4 MEMOIZED-NULL-VALUE)
           (CL:SETQ RESULT (%%VALUE ENTRIES)) (CL:RETURN))
          (CL:SETQ ARGS (%%REST ARGS)) (CL:SETQ ARG (%%VALUE ARGS))
          (CL:WHEN
           (CL:OR (CL:EQ ARG ARG4)
            (CL:AND (CL:= (CL:THE CL:FIXNUM (CL:LOGAND EQVECTOR 8)) 0)
             (CL:NOT (CL:EQ ARG NULL)) (CL:NOT (CL:EQ ARG4 NULL))
             (OBJECT-EQL? ARG ARG4)))
           (CL:SETQ RESULT (%%VALUE ENTRIES)) (CL:RETURN)))))
       (CL:SETQ ENTRIES (%%REST ENTRIES))))))
   (CL:WHEN (CL:AND DELETEENTRY? (CL:NOT (CL:EQ RESULT NULL)))
    (CL:SETF (%%VALUE ENTRIES) (%%VALUE (%%REST BUCKET)))
    (CL:WHEN
     (CL:EQ (CL:SETF (%%REST BUCKET) (%%REST (%%REST BUCKET))) NIL)
     (CL:SETF (%%REST BUCKET) NIL)))
   (CL:RETURN-FROM FIND-MEMOIZED-VALUE-ENTRY RESULT)))

;;; (DEFUN (FIND-MEMOIZED-VALUE-ENTRYN CONS) ...)

(CL:DEFUN FIND-MEMOIZED-VALUE-ENTRYN (BUCKET TUPLE EQVECTOR DELETEENTRY?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM EQVECTOR))
  #+MCL
  (CL:CHECK-TYPE EQVECTOR CL:FIXNUM)
  (CL:LET* ((ENTRIES (%%REST BUCKET)) (RESULT NULL))
   (CL:COND
    ((CL:< EQVECTOR 0)
     (CL:LOOP WHILE (CL:NOT (CL:EQ ENTRIES NIL)) DO
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET*
        ((ENTRYARG NULL) (ITER-000 (%%REST (%%VALUE ENTRIES)))
         (INPUTARG NULL) (ITER-001 TUPLE))
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
          (CL:NOT (CL:EQ ITER-001 NIL)))
         DO (CL:SETQ ENTRYARG (%%VALUE ITER-000))
         (CL:SETQ INPUTARG (%%VALUE ITER-001))
         (CL:WHEN (CL:NOT (CL:EQ ENTRYARG INPUTARG))
          (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:WHEN ALWAYS?-000 (CL:SETQ RESULT (%%VALUE ENTRIES))
        (CL:RETURN)))
      (CL:SETQ ENTRIES (%%REST ENTRIES))))
    (CL:T
     (CL:LOOP WHILE (CL:NOT (CL:EQ ENTRIES NIL)) DO
      (CL:SETQ RESULT (%%VALUE ENTRIES))
      (CL:LET*
       ((ENTRYARG NULL) (ITER-002 (%%REST RESULT)) (INPUTARG NULL)
        (ITER-003 TUPLE))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-002 NIL))
         (CL:NOT (CL:EQ ITER-003 NIL)))
        DO (CL:SETQ ENTRYARG (%%VALUE ITER-002))
        (CL:SETQ INPUTARG (%%VALUE ITER-003))
        (CL:COND
         ((CL:OR (CL:EQ ENTRYARG INPUTARG)
           (CL:AND (CL:= (CL:THE CL:FIXNUM (CL:LOGAND EQVECTOR 1)) 0)
            (EQL? ENTRYARG INPUTARG)))
          (CL:SETQ EQVECTOR
           (CL:LET ((ARG EQVECTOR) (COUNT 1))
            (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
            (CL:THE CL:FIXNUM
             (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT)))))))
         (CL:T (CL:SETQ RESULT NULL) (CL:RETURN)))
        (CL:SETQ ITER-002 (%%REST ITER-002))
        (CL:SETQ ITER-003 (%%REST ITER-003))))
      (CL:IF (CL:NOT (CL:EQ RESULT NULL)) (CL:RETURN)
       (CL:SETQ ENTRIES (%%REST ENTRIES))))))
   (CL:WHEN (CL:AND DELETEENTRY? (CL:NOT (CL:EQ RESULT NULL)))
    (CL:SETF (%%VALUE ENTRIES) (%%VALUE (%%REST BUCKET)))
    (CL:WHEN
     (CL:EQ (CL:SETF (%%REST BUCKET) (%%REST (%%REST BUCKET))) NIL)
     (CL:SETF (%%REST BUCKET) NIL)))
   (CL:RETURN-FROM FIND-MEMOIZED-VALUE-ENTRYN RESULT)))

;;; (DEFUN (LOOKUP-MEMOIZED-VALUE CONS) ...)

(CL:DEFUN LOOKUP-MEMOIZED-VALUE (MEMOTABLE ARG1 ARG2 ARG3 ARG4 EQVECTOR)
  (CL:DECLARE (CL:TYPE CL:FIXNUM EQVECTOR))
  #+MCL
  (CL:CHECK-TYPE EQVECTOR CL:FIXNUM)
  (CL:LET*
   ((HASHTABLE (%HASH-TABLE MEMOTABLE)) (TIMESTAMP NULL) (HASHCODE 0)
    (ENTRY NIL) (BUCKET NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM HASHCODE))
   (CL:WHEN (CL:EQ HASHTABLE NULL)
    (CL:SETQ HASHTABLE (NEW-INTEGER-HASH-TABLE))
    (CL:SETF (%HASH-TABLE MEMOTABLE) HASHTABLE)
    (CL:SETF (%CURRENT-TIMESTAMP MEMOTABLE) (CONS NULL NIL)))
   (CL:SETQ TIMESTAMP (%CURRENT-TIMESTAMP MEMOTABLE))
   (CL:SETQ HASHCODE
    (HASH-MEMOIZED-ARGUMENTS ARG1 ARG2 ARG3 ARG4 EQVECTOR))
   (CL:SETQ BUCKET (LOOKUP HASHTABLE HASHCODE))
   (CL:WHEN (CL:NOT (CL:EQ BUCKET NULL))
    (CL:COND
     ((CL:EQ (%%VALUE BUCKET) TIMESTAMP)
      (CL:SETQ ENTRY
       (FIND-MEMOIZED-VALUE-ENTRY BUCKET ARG1 ARG2 ARG3 ARG4 EQVECTOR
        CL:NIL))
      (CL:WHEN (CL:NOT (CL:EQ ENTRY NULL))
       (CL:RETURN-FROM LOOKUP-MEMOIZED-VALUE ENTRY)))
     (CL:T (CL:SETF (%%VALUE BUCKET) TIMESTAMP)
      (CL:SETF (%%REST BUCKET) NIL))))
   (CL:SETQ ENTRY (MAKE-MEMOIZED-VALUE-ENTRY NULL ARG1 ARG2 ARG3 ARG4))
   (CL:IF (CL:NOT (CL:EQ BUCKET NULL))
    (CL:SETF (%%REST BUCKET) (CONS ENTRY (%%REST BUCKET)))
    (INSERT-AT HASHTABLE HASHCODE (CONS TIMESTAMP (CONS ENTRY NIL))))
   (CL:RETURN-FROM LOOKUP-MEMOIZED-VALUE ENTRY)))

;;; (DEFUN (LOOKUP-MEMOIZED-VALUEN CONS) ...)

(CL:DEFUN LOOKUP-MEMOIZED-VALUEN (MEMOTABLE ARGS EQVECTOR)
  (CL:DECLARE (CL:TYPE CL:FIXNUM EQVECTOR))
  #+MCL
  (CL:CHECK-TYPE EQVECTOR CL:FIXNUM)
  (CL:LET*
   ((HASHTABLE (%HASH-TABLE MEMOTABLE)) (TIMESTAMP NULL) (HASHCODE 0)
    (ENTRY NIL) (BUCKET NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM HASHCODE))
   (CL:WHEN (CL:EQ HASHTABLE NULL)
    (CL:SETQ HASHTABLE (NEW-INTEGER-HASH-TABLE))
    (CL:SETF (%HASH-TABLE MEMOTABLE) HASHTABLE)
    (CL:SETF (%CURRENT-TIMESTAMP MEMOTABLE) (CONS NULL NIL)))
   (CL:SETQ TIMESTAMP (%CURRENT-TIMESTAMP MEMOTABLE))
   (CL:SETQ HASHCODE (HASH-MEMOIZED-ARGUMENTSN ARGS EQVECTOR))
   (CL:SETQ BUCKET (LOOKUP HASHTABLE HASHCODE))
   (CL:WHEN (CL:NOT (CL:EQ BUCKET NULL))
    (CL:COND
     ((CL:EQ (%%VALUE BUCKET) TIMESTAMP)
      (CL:SETQ ENTRY
       (FIND-MEMOIZED-VALUE-ENTRYN BUCKET ARGS EQVECTOR CL:NIL))
      (CL:WHEN (CL:NOT (CL:EQ ENTRY NULL))
       (CL:RETURN-FROM LOOKUP-MEMOIZED-VALUEN ENTRY)))
     (CL:T (CL:SETF (%%VALUE BUCKET) TIMESTAMP)
      (CL:SETF (%%REST BUCKET) NIL))))
   (CL:SETQ ENTRY (CONS NULL ARGS))
   (CL:IF (CL:NOT (CL:EQ BUCKET NULL))
    (CL:SETF (%%REST BUCKET) (CONS ENTRY (%%REST BUCKET)))
    (INSERT-AT HASHTABLE HASHCODE (CONS TIMESTAMP (CONS ENTRY NIL))))
   (CL:RETURN-FROM LOOKUP-MEMOIZED-VALUEN ENTRY)))

;;; (DEFCLASS MRU-MEMOIZATION-TABLE ...)

(CL:DEFCLASS MRU-MEMOIZATION-TABLE (MEMOIZATION-TABLE)
  ((MRU-BUCKETS-VECTOR :ALLOCATION :INSTANCE :ACCESSOR
    %MRU-BUCKETS-VECTOR)
   (LRU-BUCKETS-VECTOR :ALLOCATION :INSTANCE :ACCESSOR
    %LRU-BUCKETS-VECTOR)
   (MRU-BUCKETS :TYPE CL:SIMPLE-VECTOR :INITFORM
    STELLA::NULL-NATIVE-VECTOR :ALLOCATION :INSTANCE :ACCESSOR
    %MRU-BUCKETS)
   (LRU-BUCKETS :TYPE CL:SIMPLE-VECTOR :INITFORM
    STELLA::NULL-NATIVE-VECTOR :ALLOCATION :INSTANCE :ACCESSOR
    %LRU-BUCKETS)
   (MRU-TIMESTAMP :ALLOCATION :INSTANCE :ACCESSOR %MRU-TIMESTAMP)
   (LRU-TIMESTAMP :ALLOCATION :INSTANCE :ACCESSOR %LRU-TIMESTAMP)
   (NOF-BUCKETS :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %NOF-BUCKETS)
   (FREE-ENTRIES :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %FREE-ENTRIES)
   (MAX-ENTRIES :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %MAX-ENTRIES)))

(CL:DEFUN NEW-MRU-MEMOIZATION-TABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE MRU-MEMOIZATION-TABLE)))
   (CL:SETF (%TIMESTAMPS SELF) NIL)
   (CL:SETF (%CURRENT-TIMESTAMP SELF) NULL)
   (CL:SETF (%TABLE-NAME SELF) NULL) (CL:SETF (%HASH-TABLE SELF) NULL)
   (CL:SETF (%MAX-ENTRIES SELF) NULL-INTEGER)
   (CL:SETF (%FREE-ENTRIES SELF) NULL-INTEGER)
   (CL:SETF (%NOF-BUCKETS SELF) NULL-INTEGER)
   (CL:SETF (%LRU-TIMESTAMP SELF) NULL)
   (CL:SETF (%MRU-TIMESTAMP SELF) NULL)
   (CL:SETF (%LRU-BUCKETS SELF) STELLA::NULL-NATIVE-VECTOR)
   (CL:SETF (%MRU-BUCKETS SELF) STELLA::NULL-NATIVE-VECTOR)
   (CL:SETF (%LRU-BUCKETS-VECTOR SELF) NULL)
   (CL:SETF (%MRU-BUCKETS-VECTOR SELF) NULL)
   (CL:RETURN-FROM NEW-MRU-MEMOIZATION-TABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF MRU-MEMOIZATION-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-MEMOIZE-STELLA-MRU-MEMOIZATION-TABLE))

(CL:DEFUN ACCESS-MRU-MEMOIZATION-TABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-MRU-BUCKETS-VECTOR)
    (CL:IF SETVALUE? (CL:SETF (%MRU-BUCKETS-VECTOR SELF) VALUE)
     (CL:SETQ VALUE (%MRU-BUCKETS-VECTOR SELF))))
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-LRU-BUCKETS-VECTOR)
    (CL:IF SETVALUE? (CL:SETF (%LRU-BUCKETS-VECTOR SELF) VALUE)
     (CL:SETQ VALUE (%LRU-BUCKETS-VECTOR SELF))))
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-MRU-TIMESTAMP)
    (CL:IF SETVALUE? (CL:SETF (%MRU-TIMESTAMP SELF) VALUE)
     (CL:SETQ VALUE (%MRU-TIMESTAMP SELF))))
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-LRU-TIMESTAMP)
    (CL:IF SETVALUE? (CL:SETF (%LRU-TIMESTAMP SELF) VALUE)
     (CL:SETQ VALUE (%LRU-TIMESTAMP SELF))))
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-NOF-BUCKETS)
    (CL:IF SETVALUE?
     (CL:SETF (%NOF-BUCKETS SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%NOF-BUCKETS SELF)))))
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-FREE-ENTRIES)
    (CL:IF SETVALUE?
     (CL:SETF (%FREE-ENTRIES SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%FREE-ENTRIES SELF)))))
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-MAX-ENTRIES)
    (CL:IF SETVALUE?
     (CL:SETF (%MAX-ENTRIES SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%MAX-ENTRIES SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-MRU-MEMOIZATION-TABLE-SLOT-VALUE VALUE))

;;; (DEFUN INITIALIZE-MRU-BUCKET-TABLES ...)

(CL:DEFUN INITIALIZE-MRU-BUCKET-TABLES (MEMOTABLE)
  (CL:SETF (%NOF-BUCKETS MEMOTABLE)
   (PICK-HASH-TABLE-SIZE-PRIME (%MAX-ENTRIES MEMOTABLE)))
  (CL:SETF (%MRU-BUCKETS-VECTOR MEMOTABLE)
   (NEW-VECTOR (%NOF-BUCKETS MEMOTABLE)))
  (CL:SETF (%LRU-BUCKETS-VECTOR MEMOTABLE)
   (NEW-VECTOR (%NOF-BUCKETS MEMOTABLE)))
  (CL:SETF (%MRU-BUCKETS MEMOTABLE)
   (%THE-ARRAY (%MRU-BUCKETS-VECTOR MEMOTABLE)))
  (CL:SETF (%LRU-BUCKETS MEMOTABLE)
   (%THE-ARRAY (%LRU-BUCKETS-VECTOR MEMOTABLE)))
  (CL:SETF (%FREE-ENTRIES MEMOTABLE) (%MAX-ENTRIES MEMOTABLE))
  (CL:SETF (%CURRENT-TIMESTAMP MEMOTABLE) (CONS NULL NIL))
  (CL:SETF (%MRU-TIMESTAMP MEMOTABLE) (%CURRENT-TIMESTAMP MEMOTABLE))
  (CL:SETF (%LRU-TIMESTAMP MEMOTABLE) (%CURRENT-TIMESTAMP MEMOTABLE))
  :VOID)

;;; (DEFUN (LOOKUP-MRU-MEMOIZED-VALUE CONS) ...)

(CL:DEFUN LOOKUP-MRU-MEMOIZED-VALUE (MEMOTABLE ARG1 ARG2 ARG3 ARG4 EQVECTOR)
  (CL:DECLARE (CL:TYPE CL:FIXNUM EQVECTOR))
  #+MCL
  (CL:CHECK-TYPE EQVECTOR CL:FIXNUM)
  (CL:LET*
   ((MRUBUCKETS (%MRU-BUCKETS MEMOTABLE))
    (LRUBUCKETS STELLA::NULL-NATIVE-VECTOR) (MRUBUCKET NIL)
    (LRUBUCKET NIL) (MRUTIMESTAMP NULL) (HASHCODE 0) (BUCKETINDEX 0)
    (ENTRY NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR MRUBUCKETS LRUBUCKETS)
    (CL:TYPE CL:FIXNUM HASHCODE BUCKETINDEX))
   (CL:WHEN (CL:EQ MRUBUCKETS STELLA::NULL-NATIVE-VECTOR)
    (INITIALIZE-MRU-BUCKET-TABLES MEMOTABLE)
    (CL:SETQ MRUBUCKETS (%MRU-BUCKETS MEMOTABLE)))
   (CL:SETQ MRUTIMESTAMP (%MRU-TIMESTAMP MEMOTABLE))
   (CL:WHEN
    (CL:NOT (CL:EQ (%CURRENT-TIMESTAMP MEMOTABLE) MRUTIMESTAMP))
    (CL:SETQ MRUTIMESTAMP (%CURRENT-TIMESTAMP MEMOTABLE))
    (CL:SETF (%MRU-TIMESTAMP MEMOTABLE) MRUTIMESTAMP)
    (CL:SETF (%LRU-TIMESTAMP MEMOTABLE) MRUTIMESTAMP)
    (CL:SETF (%FREE-ENTRIES MEMOTABLE) (%MAX-ENTRIES MEMOTABLE)))
   (CL:SETQ HASHCODE
    (HASH-MEMOIZED-ARGUMENTS ARG1 ARG2 ARG3 ARG4 EQVECTOR))
   (CL:SETQ BUCKETINDEX
    (CL:LET ((CODE HASHCODE) (SIZE (%NOF-BUCKETS MEMOTABLE)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
     (CL:THE CL:FIXNUM
      (CL:REM
       (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
       SIZE))))
   (CL:SETQ MRUBUCKET (CL:AREF MRUBUCKETS BUCKETINDEX))
   (CL:WHEN (CL:NOT (CL:EQ MRUBUCKET NULL))
    (CL:COND
     ((CL:EQ (%%VALUE MRUBUCKET) MRUTIMESTAMP)
      (CL:SETQ ENTRY
       (FIND-MEMOIZED-VALUE-ENTRY MRUBUCKET ARG1 ARG2 ARG3 ARG4
        EQVECTOR CL:NIL))
      (CL:WHEN (CL:NOT (CL:EQ ENTRY NULL))
       (CL:RETURN-FROM LOOKUP-MRU-MEMOIZED-VALUE ENTRY)))
     (CL:T (CL:SETF (%%VALUE MRUBUCKET) MRUTIMESTAMP)
      (CL:SETF (%%REST MRUBUCKET) NIL))))
   (CL:SETQ LRUBUCKETS (%LRU-BUCKETS MEMOTABLE))
   (CL:SETQ LRUBUCKET (CL:AREF LRUBUCKETS BUCKETINDEX))
   (CL:WHEN (CL:NOT (CL:EQ LRUBUCKET NULL))
    (CL:COND
     ((CL:EQ (%%VALUE LRUBUCKET) (%LRU-TIMESTAMP MEMOTABLE))
      (CL:SETQ ENTRY
       (FIND-MEMOIZED-VALUE-ENTRY LRUBUCKET ARG1 ARG2 ARG3 ARG4
        EQVECTOR CL:T)))
     (CL:T (CL:SETF (%%REST LRUBUCKET) NIL))))
   (CL:WHEN (CL:EQ ENTRY NULL)
    (CL:SETQ ENTRY
     (MAKE-MEMOIZED-VALUE-ENTRY NULL ARG1 ARG2 ARG3 ARG4)))
   (CL:IF (CL:NOT (CL:EQ MRUBUCKET NULL))
    (CL:SETF (%%REST MRUBUCKET) (CONS ENTRY (%%REST MRUBUCKET)))
    (CL:LET
     ((SELF MRUBUCKETS) (VALUE (CONS MRUTIMESTAMP (CONS ENTRY NIL)))
      (POSITION BUCKETINDEX))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE)))
   (CL:WHEN
    (CL:=
     (CL:SETF (%FREE-ENTRIES MEMOTABLE)
      (CL:1- (%FREE-ENTRIES MEMOTABLE)))
     0)
    (CL:SETF (%MRU-BUCKETS MEMOTABLE) LRUBUCKETS)
    (CL:SETF (%LRU-BUCKETS MEMOTABLE) MRUBUCKETS)
    (CL:SETF (%MRU-TIMESTAMP MEMOTABLE) (CONS NULL NIL))
    (CL:SETF (%CURRENT-TIMESTAMP MEMOTABLE) (%MRU-TIMESTAMP MEMOTABLE))
    (CL:SETF (%LRU-TIMESTAMP MEMOTABLE) MRUTIMESTAMP)
    (CL:SETF (%FREE-ENTRIES MEMOTABLE) (%MAX-ENTRIES MEMOTABLE)))
   (CL:RETURN-FROM LOOKUP-MRU-MEMOIZED-VALUE ENTRY)))

;;; (DEFUN (LOOKUP-MRU-MEMOIZED-VALUEN CONS) ...)

(CL:DEFUN LOOKUP-MRU-MEMOIZED-VALUEN (MEMOTABLE ARGS EQVECTOR)
  (CL:DECLARE (CL:TYPE CL:FIXNUM EQVECTOR))
  #+MCL
  (CL:CHECK-TYPE EQVECTOR CL:FIXNUM)
  (CL:LET*
   ((MRUBUCKETS (%MRU-BUCKETS MEMOTABLE))
    (LRUBUCKETS STELLA::NULL-NATIVE-VECTOR) (MRUBUCKET NIL)
    (LRUBUCKET NIL) (MRUTIMESTAMP NULL) (HASHCODE 0) (BUCKETINDEX 0)
    (ENTRY NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR MRUBUCKETS LRUBUCKETS)
    (CL:TYPE CL:FIXNUM HASHCODE BUCKETINDEX))
   (CL:WHEN (CL:EQ MRUBUCKETS STELLA::NULL-NATIVE-VECTOR)
    (INITIALIZE-MRU-BUCKET-TABLES MEMOTABLE)
    (CL:SETQ MRUBUCKETS (%MRU-BUCKETS MEMOTABLE)))
   (CL:SETQ MRUTIMESTAMP (%MRU-TIMESTAMP MEMOTABLE))
   (CL:WHEN
    (CL:NOT (CL:EQ (%CURRENT-TIMESTAMP MEMOTABLE) MRUTIMESTAMP))
    (CL:SETQ MRUTIMESTAMP (%CURRENT-TIMESTAMP MEMOTABLE))
    (CL:SETF (%MRU-TIMESTAMP MEMOTABLE) MRUTIMESTAMP)
    (CL:SETF (%LRU-TIMESTAMP MEMOTABLE) MRUTIMESTAMP)
    (CL:SETF (%FREE-ENTRIES MEMOTABLE) (%MAX-ENTRIES MEMOTABLE)))
   (CL:SETQ HASHCODE (HASH-MEMOIZED-ARGUMENTSN ARGS EQVECTOR))
   (CL:SETQ BUCKETINDEX
    (CL:LET ((CODE HASHCODE) (SIZE (%NOF-BUCKETS MEMOTABLE)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM CODE SIZE))
     (CL:THE CL:FIXNUM
      (CL:REM
       (CL:THE CL:FIXNUM (CL:LOGAND CODE *INTEGER-UNSIGNED-BITS-MASK*))
       SIZE))))
   (CL:SETQ MRUBUCKET (CL:AREF MRUBUCKETS BUCKETINDEX))
   (CL:WHEN (CL:NOT (CL:EQ MRUBUCKET NULL))
    (CL:COND
     ((CL:EQ (%%VALUE MRUBUCKET) MRUTIMESTAMP)
      (CL:SETQ ENTRY
       (FIND-MEMOIZED-VALUE-ENTRYN MRUBUCKET ARGS EQVECTOR CL:NIL))
      (CL:WHEN (CL:NOT (CL:EQ ENTRY NULL))
       (CL:RETURN-FROM LOOKUP-MRU-MEMOIZED-VALUEN ENTRY)))
     (CL:T (CL:SETF (%%VALUE MRUBUCKET) MRUTIMESTAMP)
      (CL:SETF (%%REST MRUBUCKET) NIL))))
   (CL:SETQ LRUBUCKETS (%LRU-BUCKETS MEMOTABLE))
   (CL:SETQ LRUBUCKET (CL:AREF LRUBUCKETS BUCKETINDEX))
   (CL:WHEN (CL:NOT (CL:EQ LRUBUCKET NULL))
    (CL:COND
     ((CL:EQ (%%VALUE LRUBUCKET) (%LRU-TIMESTAMP MEMOTABLE))
      (CL:SETQ ENTRY
       (FIND-MEMOIZED-VALUE-ENTRYN LRUBUCKET ARGS EQVECTOR CL:T)))
     (CL:T (CL:SETF (%%REST LRUBUCKET) NIL))))
   (CL:WHEN (CL:EQ ENTRY NULL) (CL:SETQ ENTRY (CONS NULL ARGS)))
   (CL:IF (CL:NOT (CL:EQ MRUBUCKET NULL))
    (CL:SETF (%%REST MRUBUCKET) (CONS ENTRY (%%REST MRUBUCKET)))
    (CL:LET
     ((SELF MRUBUCKETS) (VALUE (CONS MRUTIMESTAMP (CONS ENTRY NIL)))
      (POSITION BUCKETINDEX))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE)))
   (CL:WHEN
    (CL:=
     (CL:SETF (%FREE-ENTRIES MEMOTABLE)
      (CL:1- (%FREE-ENTRIES MEMOTABLE)))
     0)
    (CL:SETF (%MRU-BUCKETS MEMOTABLE) LRUBUCKETS)
    (CL:SETF (%LRU-BUCKETS MEMOTABLE) MRUBUCKETS)
    (CL:SETF (%MRU-TIMESTAMP MEMOTABLE) (CONS NULL NIL))
    (CL:SETF (%CURRENT-TIMESTAMP MEMOTABLE) (%MRU-TIMESTAMP MEMOTABLE))
    (CL:SETF (%LRU-TIMESTAMP MEMOTABLE) MRUTIMESTAMP)
    (CL:SETF (%FREE-ENTRIES MEMOTABLE) (%MAX-ENTRIES MEMOTABLE)))
   (CL:RETURN-FROM LOOKUP-MRU-MEMOIZED-VALUEN ENTRY)))

;;; (DEFUN INITIALIZE-MEMOIZATION-TABLE ...)

(CL:DEFUN INITIALIZE-MEMOIZATION-TABLE (MEMOTABLESURROGATE OPTIONS)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OPTIONS))
  #+MCL
  (CL:CHECK-TYPE OPTIONS CL:SIMPLE-STRING)
  (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
   (CL:SETF (%THE-PLIST SELF-000)
    (READ-S-EXPRESSION-FROM-STRING OPTIONS))
   (CL:LET*
    ((THEOPTIONS SELF-000)
     (OLDTABLE (%SURROGATE-VALUE MEMOTABLESURROGATE))
     (SIZE (LOOKUP THEOPTIONS KWD-MEMOIZE-MAX-VALUES)))
    (CL:LET* ((CHOOSE-VALUE-000 NULL))
     (CL:IF (CL:NOT (CL:EQ SIZE NULL))
      (CL:LET* ((SELF-001 (NEW-MRU-MEMOIZATION-TABLE)))
       (CL:SETF (%MAX-ENTRIES SELF-001) (%WRAPPER-VALUE SIZE))
       (CL:SETQ CHOOSE-VALUE-000 SELF-001))
      (CL:SETQ CHOOSE-VALUE-000 (NEW-MEMOIZATION-TABLE)))
     (CL:LET* ((TABLE CHOOSE-VALUE-000))
      (CL:SETF (%TABLE-NAME TABLE) MEMOTABLESURROGATE)
      (CL:WHEN
       (CL:NOT (CL:EQ (LOOKUP THEOPTIONS KWD-MEMOIZE-TIMESTAMPS) NULL))
       (CL:SETF (%TIMESTAMPS TABLE)
        (LOOKUP THEOPTIONS KWD-MEMOIZE-TIMESTAMPS)))
      (REMOVE *ALL-MEMOIZATION-TABLES* OLDTABLE)
      (INSERT *ALL-MEMOIZATION-TABLES* TABLE)
      (CL:SETF (%SURROGATE-VALUE MEMOTABLESURROGATE) TABLE)))))
  :VOID)

;;; (DEFUN CLEAR-ALL-MEMOIZATION-TABLES ...)

(CL:DEFUN CLEAR-ALL-MEMOIZATION-TABLES ()
  (CL:LET*
   ((TABLE NULL) (ITER-000 (%THE-CONS-LIST *ALL-MEMOIZATION-TABLES*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ TABLE (%%VALUE ITER-000))
    (CL:SETF (%SURROGATE-VALUE (%TABLE-NAME TABLE)) NULL)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CLEAR *ALL-MEMOIZATION-TABLES*)
  :VOID)

;;; (DEFUN CLEAR-MEMOIZATION-TABLES ...)

(CL:DEFUN CLEAR-MEMOIZATION-TABLES (TIMESTAMPNAME)
  (CL:LET*
   ((TABLE NULL) (ITER-000 (%THE-CONS-LIST *ALL-MEMOIZATION-TABLES*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ TABLE (%%VALUE ITER-000))
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET* ((TS NULL) (ITER-001 (%TIMESTAMPS TABLE)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ TS (%%VALUE ITER-001))
       (CL:WHEN (CL:EQ TS TIMESTAMPNAME) (CL:SETQ FOUND?-000 CL:T)
        (CL:RETURN))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:WHEN FOUND?-000
      (CL:COND
       ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TABLE)
         SGT-MEMOIZE-STELLA-MRU-MEMOIZATION-TABLE)
        (CL:PROGN
         (CL:WHEN (CL:NOT (CL:EQ (%MRU-BUCKETS-VECTOR TABLE) NULL))
          (CLEAR (%MRU-BUCKETS-VECTOR TABLE)))
         (CL:WHEN (CL:NOT (CL:EQ (%LRU-BUCKETS-VECTOR TABLE) NULL))
          (CLEAR (%LRU-BUCKETS-VECTOR TABLE)))
         (CL:SETF (%FREE-ENTRIES TABLE) (%MAX-ENTRIES TABLE))))
       (CL:T (CL:SETF (%HASH-TABLE TABLE) NULL)))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

;;; (DEFUN BUMP-MEMOIZATION-TIMESTAMP ...)

(CL:DEFUN BUMP-MEMOIZATION-TIMESTAMP (TIMESTAMPNAME)
  (CL:LET*
   ((TABLE NULL) (ITER-000 (%THE-CONS-LIST *ALL-MEMOIZATION-TABLES*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ TABLE (%%VALUE ITER-000))
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET* ((TS NULL) (ITER-001 (%TIMESTAMPS TABLE)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ TS (%%VALUE ITER-001))
       (CL:WHEN (CL:EQ TS TIMESTAMPNAME) (CL:SETQ FOUND?-000 CL:T)
        (CL:RETURN))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:WHEN FOUND?-000
      (CL:SETF (%CURRENT-TIMESTAMP TABLE) (CONS NULL NIL))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

;;; (DEFUN (MAKE-MEMOIZATION-TABLE-SURROGATE SURROGATE) ...)

(CL:DEFUN MAKE-MEMOIZATION-TABLE-SURROGATE (MEMONAME)
  (CL:WHEN (CL:EQ MEMONAME NULL)
   (CL:SETQ MEMONAME (METHOD-GENSYM "MEMO-TABLE")))
  (CL:RETURN-FROM MAKE-MEMOIZATION-TABLE-SURROGATE
   (SURROGATIFY MEMONAME)))

;;; (DEFUN (PARSE-MEMOIZE-OPTIONS PROPERTY-LIST) ...)

(CL:DEFUN PARSE-MEMOIZE-OPTIONS (OPTIONS)
  (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
   (CL:SETF (%THE-PLIST SELF-000) OPTIONS)
   (CL:LET*
    ((GIVENOPTIONS SELF-000) (PARSEDOPTIONS (NEW-PROPERTY-LIST)))
    (CL:LET*
     ((KEY NULL) (VALUE NULL) (ITER-000 (%THE-PLIST GIVENOPTIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ KEY (%%VALUE ITER-000))
      (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
      (CL:LET* ((TEST-VALUE-000 KEY))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 KWD-MEMOIZE-TIMESTAMPS)
         (CL:WHEN (CL:NOT (CONS? VALUE))
          (CL:SETQ VALUE (CONS VALUE NIL)))
         (CL:LET* ((TEST-VALUE-001 CL:NIL))
          (CL:LET* ((ALWAYS?-000 CL:T))
           (CL:LET* ((TS NULL) (ITER-001 VALUE))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
             (CL:SETQ TS (%%VALUE ITER-001))
             (CL:WHEN (CL:NOT (KEYWORD? TS))
              (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
             (CL:SETQ ITER-001 (%%REST ITER-001))))
           (CL:SETQ TEST-VALUE-001 ALWAYS?-000))
          (CL:SETQ TEST-VALUE-001 (CL:NOT TEST-VALUE-001))
          (CL:IF TEST-VALUE-001
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (SIGNAL-TRANSLATION-ERROR)
            (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
             (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
             (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
              " Illegal :timestamp value in memoize: `"
              (DE-UGLIFY-PARSE-TREE VALUE) "'." EOL)))
           (INSERT-AT PARSEDOPTIONS KEY VALUE))))
        ((CL:EQ TEST-VALUE-000 KWD-MEMOIZE-NAME)
         (CL:IF
          (CL:NOT (ISA? VALUE SGT-MEMOIZE-STELLA-GENERALIZED-SYMBOL))
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
            (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
             " Illegal :name value in memoize: `"
             (DE-UGLIFY-PARSE-TREE VALUE) "'." EOL)))
          (INSERT-AT PARSEDOPTIONS KEY
           (MAKE-MEMOIZATION-TABLE-SURROGATE
            (INTERN-DERIVED-SYMBOL VALUE (%SYMBOL-NAME VALUE))))))
        ((CL:EQ TEST-VALUE-000 KWD-MEMOIZE-MAX-VALUES)
         (CL:IF (CL:NOT (INTEGER? VALUE))
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
            (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
             " Illegal :max-values value in memoize: `"
             (DE-UGLIFY-PARSE-TREE VALUE) "'." EOL)))
          (INSERT-AT PARSEDOPTIONS KEY VALUE)))
        (CL:T
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
            " Illegal memoize option: `" (DE-UGLIFY-PARSE-TREE KEY)
            "'." EOL))))))
      (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
    (CL:RETURN-FROM PARSE-MEMOIZE-OPTIONS PARSEDOPTIONS))))

;;; (DEFMACRO MEMOIZE ...)

(CL:DEFUN MEMOIZE (INPUTARGS BODY)
  "Compute the value of an expression and memoize it relative to
   the values of `inputArgs'.
`inputArgs' should characterize the complete set of values upon which
   the computation of the result depended.
Calls to `memoize' should be of the form

      (memoize (<arg>+) {:<option> <value>}* <expression>)

   and have the status of an expression.
   The following options are supported:

      :timestamps   A single or list of keywords specifying the names of
                    timestamps which when bumped should invalidate all
                    entries currently memoized in this table.
      :name         Names the memoization table so it can be shared by other
                    memoization sites.  By default, a gensymed name is used.
                    CAUTION: IT IS ASSUMED THAT ALL ENTRIES IN A MEMOZATION
                    TABLE DEPEND ON THE SAME NUMBER OF ARGUMENTS!!
      :max-values   The maximum number of values to be memoized.  Only the
                    `:max-values' most recently used values will be kept
                    in the memoization table, older values will be discarded
                    and recomputed if needed.  Without a `:max-values'
                    specification, the memoization table will grow
                    indefinitely.

PERFORMANCE NOTES: For most efficient lookup, input arguments that vary the most
should be listed first.  Also, arguments of type STANDARD-OBJECT (and all its
subtypes) can be memoized more efficiently than arguments of type OBJECT or
wrapped literals (with the exception of BOOLEANs)."
  (CL:LET*
   ((MEMONAME NULL) (MEMOTABLEVAR (LOCAL-GENSYM "MEMO-TABLE"))
    (MEMOENTRYVAR (LOCAL-GENSYM "MEMOIZED-ENTRY"))
    (MEMOVALUEVAR (LOCAL-GENSYM "MEMOIZED-VALUE"))
    (NOFINPUTS (LENGTH INPUTARGS)) (OPTIONS NULL) (LOOKUPFUNCTION NULL)
    (LOOKUPTREE NIL) (VALUETYPESPEC NULL) (ALLEQ? CL:T) (EQVECTOR 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFINPUTS EQVECTOR))
   (CL:SETQ BODY (CONS NIL BODY))
   (CL:SETQ OPTIONS
    (PARSE-MEMOIZE-OPTIONS (EXTRACT-OPTIONS BODY NULL)))
   (CL:SETQ BODY (%%REST BODY))
   (CL:SETQ MEMONAME (LOOKUP OPTIONS KWD-MEMOIZE-NAME))
   (CL:WHEN (CL:EQ MEMONAME NULL)
    (CL:SETQ MEMONAME (MAKE-MEMOIZATION-TABLE-SURROGATE NULL)))
   (CL:LET*
    ((IT (ALLOCATE-ITERATOR INPUTARGS)) (INDEX NULL-INTEGER)
     (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX ITER-000))
    (CL:LOOP WHILE (NEXT? IT) DO (CL:SETQ INDEX ITER-000)
     (CL:LET* ((WALKEDARG NULL) (TYPE NULL))
      (CL:MULTIPLE-VALUE-SETQ (WALKEDARG TYPE)
       (WALK-A-TREE (%VALUE IT)))
      (CL:COND
       ((CL:OR
         (SUB-TYPE-SPEC-OF? TYPE SGT-MEMOIZE-STELLA-STANDARD-OBJECT)
         (SUB-TYPE-SPEC-OF? TYPE SGT-MEMOIZE-STELLA-BOOLEAN-WRAPPER)
         (SUB-TYPE-SPEC-OF? TYPE SGT-MEMOIZE-STELLA-BOOLEAN))
        (CL:WHEN (CL:< INDEX 12)
         (CL:SETQ EQVECTOR
          (CL:THE CL:FIXNUM
           (CL:LOGIOR EQVECTOR (CL:THE CL:FIXNUM (CL:ASH 1 INDEX)))))))
       (CL:T (CL:SETQ ALLEQ? CL:NIL)))
      (VALUE-SETTER IT (SYS-TREE WALKEDARG TYPE)))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETQ LOOKUPFUNCTION
    (CL:IF (CL:EQ (LOOKUP OPTIONS KWD-MEMOIZE-MAX-VALUES) NULL)
     (CL:IF (CL:<= NOFINPUTS 4)
      SYM-MEMOIZE-STELLA-LOOKUP-MEMOIZED-VALUE
      SYM-MEMOIZE-STELLA-LOOKUP-MEMOIZED-VALUEN)
     (CL:IF (CL:<= NOFINPUTS 4)
      SYM-MEMOIZE-STELLA-LOOKUP-MRU-MEMOIZED-VALUE
      SYM-MEMOIZE-STELLA-LOOKUP-MRU-MEMOIZED-VALUEN)))
   (CL:CASE NOFINPUTS
    (0
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
        " Missing memoization input argument specification." EOL)))
     (CL:RETURN-FROM MEMOIZE
      (WALK-DONT-CALL-ME-TREE BODY SGT-MEMOIZE-STELLA-OBJECT)))
    (1
     (CL:SETQ LOOKUPTREE
      (CONS LOOKUPFUNCTION
       (CONS MEMOTABLEVAR
        (CONS (%%VALUE INPUTARGS)
         (LIST* SYM-MEMOIZE-STELLA-MEMOIZED-NULL-VALUE
          SYM-MEMOIZE-STELLA-NULL SYM-MEMOIZE-STELLA-NULL
          (CL:IF ALLEQ? (WRAP-INTEGER -1) (WRAP-INTEGER EQVECTOR))
          NIL))))))
    (2
     (CL:SETQ LOOKUPTREE
      (CONS LOOKUPFUNCTION
       (CONS MEMOTABLEVAR
        (CONS (%%VALUE INPUTARGS)
         (CONS (%%VALUE (%%REST INPUTARGS))
          (LIST* SYM-MEMOIZE-STELLA-MEMOIZED-NULL-VALUE
           SYM-MEMOIZE-STELLA-NULL
           (CL:IF ALLEQ? (WRAP-INTEGER -1) (WRAP-INTEGER EQVECTOR))
           NIL)))))))
    (3
     (CL:SETQ LOOKUPTREE
      (CONS LOOKUPFUNCTION
       (CONS MEMOTABLEVAR
        (CONS (%%VALUE INPUTARGS)
         (CONS (%%VALUE (%%REST INPUTARGS))
          (CONS (%%VALUE (%%REST (%%REST INPUTARGS)))
           (LIST* SYM-MEMOIZE-STELLA-MEMOIZED-NULL-VALUE
            (CL:IF ALLEQ? (WRAP-INTEGER -1) (WRAP-INTEGER EQVECTOR))
            NIL))))))))
    (4
     (CL:SETQ LOOKUPTREE
      (CONS LOOKUPFUNCTION
       (CONS MEMOTABLEVAR
        (CONS (%%VALUE INPUTARGS)
         (CONS (%%VALUE (%%REST INPUTARGS))
          (CONS (%%VALUE (%%REST (%%REST INPUTARGS)))
           (CONS (FOURTH INPUTARGS)
            (CONS
             (CL:IF ALLEQ? (WRAP-INTEGER -1) (WRAP-INTEGER EQVECTOR))
             NIL)))))))))
    (CL:OTHERWISE
     (CL:SETQ LOOKUPTREE
      (CONS LOOKUPFUNCTION
       (CONS MEMOTABLEVAR
        (LIST*
         (CONS SYM-MEMOIZE-STELLA-CONS-LIST
          (CONCATENATE INPUTARGS NIL))
         (CL:IF ALLEQ? (WRAP-INTEGER -1) (WRAP-INTEGER EQVECTOR))
         NIL))))))
   (CL:SETQ VALUETYPESPEC
    (COMPUTE-EXPRESSION-TYPE (%%VALUE BODY) CL:T))
   (CL:RETURN-FROM MEMOIZE
    (LIST* SYM-MEMOIZE-STELLA-VRLET
     (LIST*
      (CONS MEMOTABLEVAR
       (LIST* SYM-MEMOIZE-STELLA-MEMOIZATION-TABLE
        SYM-MEMOIZE-STELLA-NULL NIL))
      (CONS MEMOENTRYVAR
       (LIST* SYM-MEMOIZE-STELLA-CONS SYM-MEMOIZE-STELLA-NULL NIL))
      (CONS MEMOVALUEVAR
       (LIST* SYM-MEMOIZE-STELLA-OBJECT SYM-MEMOIZE-STELLA-NULL NIL))
      NIL)
     (LIST* SYM-MEMOIZE-STELLA-WHEN
      SYM-MEMOIZE-STELLA-*MEMOIZATION-ENABLED?*
      (LIST* SYM-MEMOIZE-STELLA-SETQ MEMOTABLEVAR
       (CONS (LIST* SYM-MEMOIZE-STELLA-SURROGATE-VALUE MEMONAME NIL)
        NIL))
      (LIST* SYM-MEMOIZE-STELLA-WHEN
       (LIST* SYM-MEMOIZE-STELLA-NULL? MEMOTABLEVAR NIL)
       (LIST* SYM-MEMOIZE-STELLA-INITIALIZE-MEMOIZATION-TABLE MEMONAME
        (CONS (WRAP-STRING (STRINGIFY (%THE-PLIST OPTIONS))) NIL))
       (LIST* SYM-MEMOIZE-STELLA-SETQ MEMOTABLEVAR
        (CONS (LIST* SYM-MEMOIZE-STELLA-SURROGATE-VALUE MEMONAME NIL)
         NIL))
       NIL)
      (LIST* SYM-MEMOIZE-STELLA-SETQ MEMOENTRYVAR
       (CONS LOOKUPTREE NIL))
      (LIST* SYM-MEMOIZE-STELLA-SETQ MEMOVALUEVAR
       (CONS (LIST* SYM-MEMOIZE-STELLA-FIRST MEMOENTRYVAR NIL) NIL))
      NIL)
     (LIST* SYM-MEMOIZE-STELLA-COND
      (LIST* (LIST* SYM-MEMOIZE-STELLA-DEFINED? MEMOVALUEVAR NIL)
       (LIST* SYM-MEMOIZE-STELLA-WHEN
        (LIST* SYM-MEMOIZE-STELLA-EQL? MEMOVALUEVAR
         (CONS SYM-MEMOIZE-STELLA-MEMOIZED-NULL-VALUE NIL))
        (LIST* SYM-MEMOIZE-STELLA-SETQ MEMOVALUEVAR
         (CONS SYM-MEMOIZE-STELLA-NULL NIL))
        NIL)
       NIL)
      (LIST* SYM-MEMOIZE-STELLA-OTHERWISE
       (LIST* SYM-MEMOIZE-STELLA-SETQ MEMOVALUEVAR
        (CONCATENATE BODY NIL))
       (LIST* SYM-MEMOIZE-STELLA-WHEN
        SYM-MEMOIZE-STELLA-*MEMOIZATION-ENABLED?*
        (LIST* SYM-MEMOIZE-STELLA-SETF
         (LIST* SYM-MEMOIZE-STELLA-VALUE MEMOENTRYVAR NIL)
         (LIST* SYM-MEMOIZE-STELLA-CHOOSE
          (LIST* SYM-MEMOIZE-STELLA-NULL? MEMOVALUEVAR NIL)
          SYM-MEMOIZE-STELLA-MEMOIZED-NULL-VALUE MEMOVALUEVAR NIL)
         NIL)
        NIL)
       NIL)
      NIL)
     (LIST* SYM-MEMOIZE-STELLA-CAST MEMOVALUEVAR
      (CONS (YIELD-TYPE-SPEC-TREE VALUETYPESPEC) NIL))
     NIL))))

;;; (DEFCLASS MEMOIZABLE-ITERATOR ...)

(CL:DEFCLASS MEMOIZABLE-ITERATOR (ITERATOR)
  ((BASE-ITERATOR :DOCUMENTATION
    "This slot is only needed to pass the base iterator
to the constructor.  Once `self' is initialized it will be cleared."
    :ALLOCATION :INSTANCE :ACCESSOR %BASE-ITERATOR)
   (ITERATOR-AND-VALUES :DOCUMENTATION
    "Holds the base iterator and the values generated
so far.  This slot is structure shared between the memoized iterator and
all its clones to make sure everybody sees any new values generated by
any one of the clones, and that everybody can see when the base iterator
is exhausted." :ALLOCATION :INSTANCE :ACCESSOR %ITERATOR-AND-VALUES)
   (CURSOR :DOCUMENTATION
    "Trailing cursor to the list of values generated
so far.  Once the end of the list is reached this slot is used to add new
values to the end of `iterator-and-values'." :ALLOCATION :INSTANCE
    :ACCESSOR %CURSOR))
  (:DOCUMENTATION
   "Iterator class with value buffering that can be used to memoize some
`base-iterator' without having to generate all its values first.  The
memoized iterator needs to be cloned to allow multiple iterations over
the collection represented by the memoized iterator.  Use the following
idiom to memoize some arbitrary iterator and return a properly cloned value:
	 
 (clone-memoized-iterator
   (memoize (...) <options>*
            (new MEMOIZABLE-ITERATOR
                 :base-iterator <base-iterator>)))
	
This will ensure that <base-iterator> is exhausted exactly once even if
there are multiple clones for the same memoized value, and that each value
is generated as late as absolutely possible.  THIS IS NOT YET THREAD SAFE!"))

(CL:DEFUN NEW-MEMOIZABLE-ITERATOR (BASE-ITERATOR)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE MEMOIZABLE-ITERATOR)))
   (CL:SETF (%BASE-ITERATOR SELF) BASE-ITERATOR)
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%CURSOR SELF) NULL)
   (CL:SETF (%ITERATOR-AND-VALUES SELF) NULL)
   (INITIALIZE-MEMOIZABLE-ITERATOR SELF)
   (CL:RETURN-FROM NEW-MEMOIZABLE-ITERATOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF MEMOIZABLE-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-MEMOIZE-STELLA-MEMOIZABLE-ITERATOR))

(CL:DEFUN ACCESS-MEMOIZABLE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-BASE-ITERATOR)
    (CL:IF SETVALUE? (CL:SETF (%BASE-ITERATOR SELF) VALUE)
     (CL:SETQ VALUE (%BASE-ITERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-ITERATOR-AND-VALUES)
    (CL:IF SETVALUE? (CL:SETF (%ITERATOR-AND-VALUES SELF) VALUE)
     (CL:SETQ VALUE (%ITERATOR-AND-VALUES SELF))))
   ((CL:EQ SLOTNAME SYM-MEMOIZE-STELLA-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%CURSOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-MEMOIZABLE-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFMETHOD INITIALIZE-MEMOIZABLE-ITERATOR ...)

(CL:DEFMETHOD INITIALIZE-MEMOIZABLE-ITERATOR ((SELF MEMOIZABLE-ITERATOR))
  (CL:LET* ((ITERANDVALUES (CONS (%BASE-ITERATOR SELF) NIL)))
   (CL:SETF (%ITERATOR-AND-VALUES SELF) ITERANDVALUES)
   (CL:SETF (%CURSOR SELF) ITERANDVALUES)
   (CL:SETF (%BASE-ITERATOR SELF) NULL))
  :VOID)

;;; (DEFUN (CLONE-MEMOIZED-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFUN CLONE-MEMOIZED-ITERATOR (SELF)
  "Clone the memoized iterator `self' so it can be used to
iterate over the collection represented by `self', while allowing to iterate
over it multiple times via multiple clones."
  (CL:LET* ((ITERANDVALUES (%ITERATOR-AND-VALUES SELF)))
   (CL:COND
    ((CL:NOT (CL:EQ (%%VALUE ITERANDVALUES) NULL))
     (CL:LET*
      ((CHILD (CL:MAKE-INSTANCE (CL:QUOTE MEMOIZABLE-ITERATOR))))
      (CL:SETF (%FIRST-ITERATION? CHILD) CL:T)
      (CL:SETF (%ITERATOR-AND-VALUES CHILD) ITERANDVALUES)
      (CL:SETF (%CURSOR CHILD) ITERANDVALUES)
      (CL:RETURN-FROM CLONE-MEMOIZED-ITERATOR CHILD)))
    (CL:T
     (CL:RETURN-FROM CLONE-MEMOIZED-ITERATOR
      (ALLOCATE-ITERATOR (%%REST ITERANDVALUES)))))))

;;; (DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ...)

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF MEMOIZABLE-ITERATOR))
  "Alias for `clone-memoized-iterator'."
  (CL:RETURN-FROM ALLOCATE-ITERATOR (CLONE-MEMOIZED-ITERATOR SELF)))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF MEMOIZABLE-ITERATOR))
  "Generate the next value of the memoized iterator `self' (or
one of its clones) by either using one of the values generated so far or by
generating and saving the next value of the `base-iterator'."
  (CL:LET*
   ((ITERATOR NULL) (CURSOR (%CURSOR SELF)) (VALUES (%%REST CURSOR)))
   (CL:WHEN (CL:NOT (CL:EQ VALUES NIL))
    (CL:SETF (%VALUE SELF) (%%VALUE VALUES))
    (CL:SETF (%CURSOR SELF) VALUES) (CL:RETURN-FROM NEXT? CL:T))
   (CL:SETQ ITERATOR (%%VALUE (%ITERATOR-AND-VALUES SELF)))
   (CL:WHEN (CL:NOT (CL:EQ ITERATOR NULL))
    (CL:WHEN (NEXT? ITERATOR) (CL:SETF (%VALUE SELF) (%VALUE ITERATOR))
     (CL:SETF (%%REST CURSOR) (CONS (%VALUE SELF) NIL))
     (CL:SETF (%CURSOR SELF) (%%REST CURSOR))
     (CL:RETURN-FROM NEXT? CL:T))
    (FIRST-SETTER (%ITERATOR-AND-VALUES SELF) NULL))
   (CL:RETURN-FROM NEXT? CL:NIL)))

(CL:DEFUN HELP-STARTUP-MEMOIZE1 ()
  (CL:PROGN
   (CL:SETQ SGT-MEMOIZE-STELLA-MEMOIZATION-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMOIZATION-TABLE" NULL 1))
   (CL:SETQ SYM-MEMOIZE-STELLA-HASH-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HASH-TABLE" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-TABLE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE-NAME" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-CURRENT-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-TIMESTAMP" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-TIMESTAMPS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMESTAMPS" NULL 0))
   (CL:SETQ SGT-MEMOIZE-STELLA-MRU-MEMOIZATION-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MRU-MEMOIZATION-TABLE" NULL 1))
   (CL:SETQ SYM-MEMOIZE-STELLA-MRU-BUCKETS-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MRU-BUCKETS-VECTOR" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-LRU-BUCKETS-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LRU-BUCKETS-VECTOR" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-MRU-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MRU-TIMESTAMP" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-LRU-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LRU-TIMESTAMP" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-NOF-BUCKETS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOF-BUCKETS" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-FREE-ENTRIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FREE-ENTRIES" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-MAX-ENTRIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAX-ENTRIES" NULL 0))
   (CL:SETQ KWD-MEMOIZE-MAX-VALUES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAX-VALUES" NULL 2))
   (CL:SETQ KWD-MEMOIZE-TIMESTAMPS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMESTAMPS" NULL 2))
   (CL:SETQ KWD-MEMOIZE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAME" NULL 2))
   (CL:SETQ SGT-MEMOIZE-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 1))
   (CL:SETQ SGT-MEMOIZE-STELLA-STANDARD-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STANDARD-OBJECT" NULL 1))
   (CL:SETQ SGT-MEMOIZE-STELLA-BOOLEAN-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-WRAPPER" NULL 1))
   (CL:SETQ SGT-MEMOIZE-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ SYM-MEMOIZE-STELLA-LOOKUP-MEMOIZED-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-MEMOIZED-VALUE" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-LOOKUP-MEMOIZED-VALUEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-MEMOIZED-VALUEN" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-LOOKUP-MRU-MEMOIZED-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-MRU-MEMOIZED-VALUE" NULL
     0))
   (CL:SETQ SYM-MEMOIZE-STELLA-LOOKUP-MRU-MEMOIZED-VALUEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-MRU-MEMOIZED-VALUEN" NULL
     0))
   (CL:SETQ SGT-MEMOIZE-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
   (CL:SETQ SYM-MEMOIZE-STELLA-MEMOIZED-NULL-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMOIZED-NULL-VALUE" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-CONS-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS-LIST" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-VRLET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VRLET" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-MEMOIZATION-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMOIZATION-TABLE" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-WHEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-*MEMOIZATION-ENABLED?*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*MEMOIZATION-ENABLED?*" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-SURROGATE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-NULL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL?" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-INITIALIZE-MEMOIZATION-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIALIZE-MEMOIZATION-TABLE" NULL
     0))
   (CL:SETQ SYM-MEMOIZE-STELLA-FIRST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-COND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COND" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-DEFINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-EQL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQL?" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-OTHERWISE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-SETF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETF" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-CHOOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHOOSE" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-CAST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CAST" NULL 0))
   (CL:SETQ SGT-MEMOIZE-STELLA-MEMOIZABLE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMOIZABLE-ITERATOR" NULL 1))
   (CL:SETQ SYM-MEMOIZE-STELLA-BASE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BASE-ITERATOR" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-ITERATOR-AND-VALUES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-AND-VALUES" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURSOR" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-STARTUP-MEMOIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-MEMOIZE" NULL 0))
   (CL:SETQ SYM-MEMOIZE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN STARTUP-MEMOIZE ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-MEMOIZE1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *ALL-MEMOIZATION-TABLES* (NEW-LIST))
    (CL:LET* ((SELF-069 (NEW-SYMBOL "MEMOIZED-NULL-VALUE")))
     (CL:SETF (%HOME-CONTEXT SELF-069) NULL)
     (CL:SETQ MEMOIZED-NULL-VALUE SELF-069)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "MEMOIZATION-TABLE"
        "(DEFCLASS MEMOIZATION-TABLE (STANDARD-OBJECT) :DOCUMENTATION \"Table that maps argument values onto computed results for
one individual memoization site.\" :SLOTS ((HASH-TABLE :TYPE (INTEGER-HASH-TABLE OF INTEGER (CONS OF CONS)) :DOCUMENTATION \"The table holding the memoized values.
We use an integer table, since we explicitly compute a hash code by combining
hash codes of argument values.\") (TABLE-NAME :TYPE SURROGATE :DOCUMENTATION \"The surrogate used to point to this table.
Used at the memoization site for quick memo table lookup.\") (CURRENT-TIMESTAMP :TYPE CONS :DOCUMENTATION \"Marker value used to indicate valid memoized entries.
This marker changes everytime one of the `timestamps' gets bumped.\") (TIMESTAMPS :TYPE (CONS OF KEYWORD) :INITIALLY NIL :DOCUMENTATION \"Names of timestamps that trigger invalidation of
memoized entries when they get bumped.\")))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-MEMOIZATION-TABLE))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-MEMOIZATION-TABLE-SLOT-VALUE)))
    (CL:SETQ *MEMOIZATION-ENABLED?* CL:T)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "MRU-MEMOIZATION-TABLE"
        "(DEFCLASS MRU-MEMOIZATION-TABLE (MEMOIZATION-TABLE) :SLOTS ((MRU-BUCKETS-VECTOR :TYPE (VECTOR OF (CONS OF CONS))) (LRU-BUCKETS-VECTOR :TYPE (VECTOR OF (CONS OF CONS))) (MRU-BUCKETS :TYPE (NATIVE-VECTOR OF (CONS OF CONS))) (LRU-BUCKETS :TYPE (NATIVE-VECTOR OF (CONS OF CONS))) (MRU-TIMESTAMP :TYPE CONS) (LRU-TIMESTAMP :TYPE CONS) (NOF-BUCKETS :TYPE INTEGER) (FREE-ENTRIES :TYPE INTEGER) (MAX-ENTRIES :TYPE INTEGER)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-MRU-MEMOIZATION-TABLE))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-MRU-MEMOIZATION-TABLE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "MEMOIZABLE-ITERATOR"
        "(DEFCLASS MEMOIZABLE-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator class with value buffering that can be used to memoize some
`base-iterator' without having to generate all its values first.  The
memoized iterator needs to be cloned to allow multiple iterations over
the collection represented by the memoized iterator.  Use the following
idiom to memoize some arbitrary iterator and return a properly cloned value:
	 
 (clone-memoized-iterator
   (memoize (...) <options>*
            (new MEMOIZABLE-ITERATOR
                 :base-iterator <base-iterator>)))
	
This will ensure that <base-iterator> is exhausted exactly once even if
there are multiple clones for the same memoized value, and that each value
is generated as late as absolutely possible.  THIS IS NOT YET THREAD SAFE!\" :PUBLIC? TRUE :SLOTS ((BASE-ITERATOR :TYPE ITERATOR :REQUIRED? TRUE :DOCUMENTATION \"This slot is only needed to pass the base iterator
to the constructor.  Once `self' is initialized it will be cleared.\") (ITERATOR-AND-VALUES :TYPE CONS :INITIALLY NULL :DOCUMENTATION \"Holds the base iterator and the values generated
so far.  This slot is structure shared between the memoized iterator and
all its clones to make sure everybody sees any new values generated by
any one of the clones, and that everybody can see when the base iterator
is exhausted.\") (CURSOR :TYPE CONS :INITIALLY NULL :DOCUMENTATION \"Trailing cursor to the list of values generated
so far.  Once the end of the list is reached this slot is used to add new
values to the end of `iterator-and-values'.\")) :INITIALIZER INITIALIZE-MEMOIZABLE-ITERATOR)")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-MEMOIZABLE-ITERATOR))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-MEMOIZABLE-ITERATOR-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "ENABLE-MEMOIZATION"
     "(DEFUN ENABLE-MEMOIZATION () :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Enable memoization and use of memoized expression results.\")"
     (CL:FUNCTION ENABLE-MEMOIZATION) NULL)
    (DEFINE-FUNCTION-OBJECT "DISABLE-MEMOIZATION"
     "(DEFUN DISABLE-MEMOIZATION () :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Enable memoization and use of memoized expression results.\")"
     (CL:FUNCTION DISABLE-MEMOIZATION) NULL)
    (DEFINE-FUNCTION-OBJECT "HASH-MEMOIZED-ARGUMENTS"
     "(DEFUN (HASH-MEMOIZED-ARGUMENTS INTEGER) ((ARG1 OBJECT) (ARG2 OBJECT) (ARG3 OBJECT) (ARG4 OBJECT) (EQVECTOR INTEGER)))"
     (CL:FUNCTION HASH-MEMOIZED-ARGUMENTS) NULL)
    (DEFINE-FUNCTION-OBJECT "HASH-MEMOIZED-ARGUMENTSN"
     "(DEFUN (HASH-MEMOIZED-ARGUMENTSN INTEGER) ((TUPLE CONS) (EQVECTOR INTEGER)))"
     (CL:FUNCTION HASH-MEMOIZED-ARGUMENTSN) NULL)
    (DEFINE-FUNCTION-OBJECT "MAKE-MEMOIZED-VALUE-ENTRY"
     "(DEFUN (MAKE-MEMOIZED-VALUE-ENTRY (CONS OF CONS)) ((VALUE OBJECT) (ARG1 OBJECT) (ARG2 OBJECT) (ARG3 OBJECT) (ARG4 OBJECT)))"
     (CL:FUNCTION MAKE-MEMOIZED-VALUE-ENTRY) NULL)
    (DEFINE-FUNCTION-OBJECT "MAKE-MEMOIZED-VALUE-ENTRYN"
     "(DEFUN (MAKE-MEMOIZED-VALUE-ENTRYN (CONS OF CONS)) ((VALUE OBJECT) (ARGS CONS)) :GLOBALLY-INLINE? TRUE (RETURN (CONS VALUE ARGS)))"
     (CL:FUNCTION MAKE-MEMOIZED-VALUE-ENTRYN) NULL)
    (DEFINE-FUNCTION-OBJECT "FIND-MEMOIZED-VALUE-ENTRY"
     "(DEFUN (FIND-MEMOIZED-VALUE-ENTRY CONS) ((BUCKET (CONS OF CONS)) (ARG1 OBJECT) (ARG2 OBJECT) (ARG3 OBJECT) (ARG4 OBJECT) (EQVECTOR INTEGER) (DELETEENTRY? BOOLEAN)))"
     (CL:FUNCTION FIND-MEMOIZED-VALUE-ENTRY) NULL)
    (DEFINE-FUNCTION-OBJECT "FIND-MEMOIZED-VALUE-ENTRYN"
     "(DEFUN (FIND-MEMOIZED-VALUE-ENTRYN CONS) ((BUCKET (CONS OF CONS)) (TUPLE CONS) (EQVECTOR INTEGER) (DELETEENTRY? BOOLEAN)))"
     (CL:FUNCTION FIND-MEMOIZED-VALUE-ENTRYN) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-MEMOIZED-VALUE"
     "(DEFUN (LOOKUP-MEMOIZED-VALUE CONS) ((MEMOTABLE MEMOIZATION-TABLE) (ARG1 OBJECT) (ARG2 OBJECT) (ARG3 OBJECT) (ARG4 OBJECT) (EQVECTOR INTEGER)))"
     (CL:FUNCTION LOOKUP-MEMOIZED-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-MEMOIZED-VALUEN"
     "(DEFUN (LOOKUP-MEMOIZED-VALUEN CONS) ((MEMOTABLE MEMOIZATION-TABLE) (ARGS CONS) (EQVECTOR INTEGER)))"
     (CL:FUNCTION LOOKUP-MEMOIZED-VALUEN) NULL)
    (DEFINE-FUNCTION-OBJECT "INITIALIZE-MRU-BUCKET-TABLES"
     "(DEFUN INITIALIZE-MRU-BUCKET-TABLES ((MEMOTABLE MRU-MEMOIZATION-TABLE)))"
     (CL:FUNCTION INITIALIZE-MRU-BUCKET-TABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-MRU-MEMOIZED-VALUE"
     "(DEFUN (LOOKUP-MRU-MEMOIZED-VALUE CONS) ((MEMOTABLE MRU-MEMOIZATION-TABLE) (ARG1 OBJECT) (ARG2 OBJECT) (ARG3 OBJECT) (ARG4 OBJECT) (EQVECTOR INTEGER)))"
     (CL:FUNCTION LOOKUP-MRU-MEMOIZED-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-MRU-MEMOIZED-VALUEN"
     "(DEFUN (LOOKUP-MRU-MEMOIZED-VALUEN CONS) ((MEMOTABLE MRU-MEMOIZATION-TABLE) (ARGS CONS) (EQVECTOR INTEGER)))"
     (CL:FUNCTION LOOKUP-MRU-MEMOIZED-VALUEN) NULL)
    (DEFINE-FUNCTION-OBJECT "INITIALIZE-MEMOIZATION-TABLE"
     "(DEFUN INITIALIZE-MEMOIZATION-TABLE ((MEMOTABLESURROGATE SURROGATE) (OPTIONS STRING)))"
     (CL:FUNCTION INITIALIZE-MEMOIZATION-TABLE) NULL)
    (DEFINE-FUNCTION-OBJECT "CLEAR-ALL-MEMOIZATION-TABLES"
     "(DEFUN CLEAR-ALL-MEMOIZATION-TABLES ())"
     (CL:FUNCTION CLEAR-ALL-MEMOIZATION-TABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "CLEAR-MEMOIZATION-TABLES"
     "(DEFUN CLEAR-MEMOIZATION-TABLES ((TIMESTAMPNAME KEYWORD)))"
     (CL:FUNCTION CLEAR-MEMOIZATION-TABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "BUMP-MEMOIZATION-TIMESTAMP"
     "(DEFUN BUMP-MEMOIZATION-TIMESTAMP ((TIMESTAMPNAME KEYWORD)))"
     (CL:FUNCTION BUMP-MEMOIZATION-TIMESTAMP) NULL)
    (DEFINE-FUNCTION-OBJECT "MAKE-MEMOIZATION-TABLE-SURROGATE"
     "(DEFUN (MAKE-MEMOIZATION-TABLE-SURROGATE SURROGATE) ((MEMONAME SYMBOL)))"
     (CL:FUNCTION MAKE-MEMOIZATION-TABLE-SURROGATE) NULL)
    (DEFINE-FUNCTION-OBJECT "PARSE-MEMOIZE-OPTIONS"
     "(DEFUN (PARSE-MEMOIZE-OPTIONS PROPERTY-LIST) ((OPTIONS CONS)))"
     (CL:FUNCTION PARSE-MEMOIZE-OPTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "MEMOIZE"
     "(DEFUN MEMOIZE ((INPUTARGS CONS) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :DOCUMENTATION \"Compute the value of an expression and memoize it relative to
   the values of `inputArgs'.
`inputArgs' should characterize the complete set of values upon which
   the computation of the result depended.
Calls to `memoize' should be of the form

      (memoize (<arg>+) {:<option> <value>}* <expression>)

   and have the status of an expression.
   The following options are supported:

      :timestamps   A single or list of keywords specifying the names of
                    timestamps which when bumped should invalidate all
                    entries currently memoized in this table.
      :name         Names the memoization table so it can be shared by other
                    memoization sites.  By default, a gensymed name is used.
                    CAUTION: IT IS ASSUMED THAT ALL ENTRIES IN A MEMOZATION
                    TABLE DEPEND ON THE SAME NUMBER OF ARGUMENTS!!
      :max-values   The maximum number of values to be memoized.  Only the
                    `:max-values' most recently used values will be kept
                    in the memoization table, older values will be discarded
                    and recomputed if needed.  Without a `:max-values'
                    specification, the memoization table will grow
                    indefinitely.

PERFORMANCE NOTES: For most efficient lookup, input arguments that vary the most
should be listed first.  Also, arguments of type STANDARD-OBJECT (and all its
subtypes) can be memoized more efficiently than arguments of type OBJECT or
wrapped literals (with the exception of BOOLEANs).\" :PUBLIC? TRUE)"
     (CL:FUNCTION MEMOIZE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD INITIALIZE-MEMOIZABLE-ITERATOR ((SELF MEMOIZABLE-ITERATOR)))"
     (CL:FUNCTION INITIALIZE-MEMOIZABLE-ITERATOR) NULL)
    (DEFINE-FUNCTION-OBJECT "CLONE-MEMOIZED-ITERATOR"
     "(DEFUN (CLONE-MEMOIZED-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF MEMOIZABLE-ITERATOR)) :DOCUMENTATION \"Clone the memoized iterator `self' so it can be used to
iterate over the collection represented by `self', while allowing to iterate
over it multiple times via multiple clones.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CLONE-MEMOIZED-ITERATOR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (ALLOCATE-ITERATOR (ITERATOR OF (LIKE (ANY-VALUE SELF)))) ((SELF MEMOIZABLE-ITERATOR)) :DOCUMENTATION \"Alias for `clone-memoized-iterator'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION ALLOCATE-ITERATOR) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (NEXT? BOOLEAN) ((SELF MEMOIZABLE-ITERATOR)) :DOCUMENTATION \"Generate the next value of the memoized iterator `self' (or
one of its clones) by either using one of the values generated so far or by
generating and saving the next value of the `base-iterator'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION NEXT?) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-MEMOIZE"
     "(DEFUN STARTUP-MEMOIZE () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-MEMOIZE) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-MEMOIZE-STELLA-STARTUP-MEMOIZE)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-MEMOIZE-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupMemoize") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "STELLA")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ALL-MEMOIZATION-TABLES* (LIST OF MEMOIZATION-TABLE) (NEW LIST) :DOCUMENTATION \"Holds all currently active memoization tables for timestamp
maintenance and clearance purposes.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MEMOIZATION-ENABLED?* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT MEMOIZED-NULL-VALUE SYMBOL (NEW SYMBOL :SYMBOL-NAME \"MEMOIZED-NULL-VALUE\" :HOME-CONTEXT NULL) :DOCUMENTATION \"Used by memoization to indicate that a NULL value
was cached.  Needed to distinguish between an undefined value and a
cached NULL.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TOTAL-MEMOIZATION-LOOKUPS* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FAILED-MEMOIZATION-LOOKUPS* INTEGER 0)")))
  :VOID)
