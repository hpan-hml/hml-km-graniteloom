;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; read.lisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2010      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-READ-STELLA-TOKENIZER-TABLE NULL)
(CL:DEFVAR SYM-READ-STELLA-TRANSITIONS NULL)
(CL:DEFVAR SYM-READ-STELLA-UNIQUE-STATE-NAMES NULL)
(CL:DEFVAR SYM-READ-STELLA-STATE-NAMES NULL)
(CL:DEFVAR SYM-READ-STELLA-LEGAL-EOF-STATES NULL)
(CL:DEFVAR SYM-READ-STELLA-CHARACTER-SET NULL)
(CL:DEFVAR KWD-READ-ERROR NULL)
(CL:DEFVAR KWD-READ-START NULL)
(CL:DEFVAR KWD-READ-EOF NULL)
(CL:DEFVAR SGT-READ-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SGT-READ-STELLA-CONS NULL)
(CL:DEFVAR KWD-READ-BLOCK NULL)
(CL:DEFVAR KWD-READ-LINE NULL)
(CL:DEFVAR KWD-READ-CHARACTER NULL)
(CL:DEFVAR SGT-READ-STELLA-TOKENIZER-TOKEN NULL)
(CL:DEFVAR SYM-READ-STELLA-TYPE NULL)
(CL:DEFVAR SYM-READ-STELLA-CONTENT NULL)
(CL:DEFVAR SYM-READ-STELLA-NEXT NULL)
(CL:DEFVAR SGT-READ-STELLA-TOKENIZER-STREAM-STATE NULL)
(CL:DEFVAR SYM-READ-STELLA-BUFFER-SIZE NULL)
(CL:DEFVAR SYM-READ-STELLA-CURSOR NULL)
(CL:DEFVAR SYM-READ-STELLA-END NULL)
(CL:DEFVAR SYM-READ-STELLA-STATE NULL)
(CL:DEFVAR SYM-READ-STELLA-TABLE NULL)
(CL:DEFVAR SYM-READ-STELLA-STATE-DICTIONARY NULL)
(CL:DEFVAR SYM-READ-STELLA-TOKEN-LIST NULL)
(CL:DEFVAR SGT-READ-STELLA-INPUT-STREAM NULL)
(CL:DEFVAR SGT-READ-STELLA-STRING NULL)
(CL:DEFVAR SGT-READ-STELLA-VOID NULL)
(CL:DEFVAR SGT-READ-STELLA-MUTABLE-STRING NULL)
(CL:DEFVAR SYM-READ-STELLA-LET NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_TABLE_ NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_TRANSITIONS_ NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_STATENAMES_ NULL)
(CL:DEFVAR SYM-READ-STELLA-THE-ARRAY NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_TOKENSTART_ NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_ENDOFTOKENS?_ NULL)
(CL:DEFVAR SYM-READ-STELLA-FALSE NULL)
(CL:DEFVAR SYM-READ-STELLA-IGNORE NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_STREAMSTATE_ NULL)
(CL:DEFVAR SYM-READ-STELLA-TOKENIZER-STREAM-STATE NULL)
(CL:DEFVAR SYM-READ-STELLA-NULL NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_BUFFER_ NULL)
(CL:DEFVAR SYM-READ-STELLA-STRING-TO-TOKENIZER-BYTE-ARRAY NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_STATE_ NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_NEXTSTATE_ NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_CURSOR_ NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_SIZE_ NULL)
(CL:DEFVAR SYM-READ-STELLA-LENGTH NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_END_ NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_INPUTSTREAM_ NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_ECHOSTREAM_ NULL)
(CL:DEFVAR SYM-READ-STELLA-ECHO-STREAM NULL)
(CL:DEFVAR SYM-READ-STELLA-CHOOSE NULL)
(CL:DEFVAR SYM-READ-STELLA-NULL? NULL)
(CL:DEFVAR SYM-READ-STELLA-TOKENIZER-STATE NULL)
(CL:DEFVAR SYM-READ-STELLA-SETF NULL)
(CL:DEFVAR SYM-READ-STELLA-NEW NULL)
(CL:DEFVAR SYM-READ-STELLA-BUFFER NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-SAVED-STATE NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_CHECKPOINT_ NULL)
(CL:DEFVAR SYM-READ-STELLA-<= NULL)
(CL:DEFVAR SYM-READ-STELLA-END-OF-TOKENS? NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-TOKEN-TEXT NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-TOKEN-TEXT-INTERNAL NULL)
(CL:DEFVAR SYM-READ-STELLA-+ NULL)
(CL:DEFVAR SYM-READ-STELLA-< NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-TOKEN-TYPE NULL)
(CL:DEFVAR SYM-READ-STELLA-NTH NULL)
(CL:DEFVAR SYM-READ-STELLA-WHEN NULL)
(CL:DEFVAR SYM-READ-STELLA-DEFINED? NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-NEXT-TOKEN NULL)
(CL:DEFVAR SYM-READ-STELLA-SAVE-TOKENIZER-STREAM-STATE NULL)
(CL:DEFVAR SYM-READ-STELLA-TRUE NULL)
(CL:DEFVAR SYM-READ-STELLA-PROGN NULL)
(CL:DEFVAR SYM-READ-STELLA-SETQ NULL)
(CL:DEFVAR SYM-READ-STELLA-LOOP NULL)
(CL:DEFVAR SYM-READ-STELLA-CHARACTER-CODE NULL)
(CL:DEFVAR SYM-READ-STELLA-LOGOR NULL)
(CL:DEFVAR SYM-READ-STELLA-SHIFT-LEFT NULL)
(CL:DEFVAR SYM-READ-STELLA-BYTE-ARRAY-NTH NULL)
(CL:DEFVAR SYM-READ-STELLA-COND NULL)
(CL:DEFVAR SYM-READ-STELLA-= NULL)
(CL:DEFVAR SYM-READ-STELLA-LOGAND NULL)
(CL:DEFVAR SYM-READ-STELLA-++ NULL)
(CL:DEFVAR SYM-READ-STELLA-OTHERWISE NULL)
(CL:DEFVAR SYM-READ-STELLA-BREAK NULL)
(CL:DEFVAR SYM-READ-STELLA-READ-INTO-TOKENIZER-BUFFER NULL)
(CL:DEFVAR SYM-READ-STELLA-MOD NULL)
(CL:DEFVAR SYM-READ-STELLA-UNLESS NULL)
(CL:DEFVAR SYM-READ-STELLA-IF NULL)
(CL:DEFVAR SYM-READ-STELLA->= NULL)
(CL:DEFVAR SYM-READ-STELLA-PRINT-STREAM NULL)
(CL:DEFVAR SYM-READ-STELLA-1- NULL)
(CL:DEFVAR SGT-READ-STELLA-STREAM-TOKENIZER NULL)
(CL:DEFVAR SYM-READ-STELLA-STREAM NULL)
(CL:DEFVAR KWD-READ-INCLUDE NULL)
(CL:DEFVAR KWD-READ-DELIMITER NULL)
(CL:DEFVAR KWD-READ-ATOM NULL)
(CL:DEFVAR SYM-READ-STELLA-* NULL)
(CL:DEFVAR KWD-READ-OPEN-PAREN NULL)
(CL:DEFVAR KWD-READ-CLOSE-PAREN NULL)
(CL:DEFVAR KWD-READ-OPEN-STRING NULL)
(CL:DEFVAR KWD-READ-STRING NULL)
(CL:DEFVAR KWD-READ-SINGLE-QUOTE NULL)
(CL:DEFVAR KWD-READ-BACK-QUOTE NULL)
(CL:DEFVAR KWD-READ-COMMA NULL)
(CL:DEFVAR SYM-READ-STELLA-! NULL)
(CL:DEFVAR KWD-READ-COMMENT NULL)
(CL:DEFVAR KWD-READ-HASH NULL)
(CL:DEFVAR KWD-READ-WHITE-SPACE NULL)
(CL:DEFVAR KWD-READ-OTHERWISE NULL)
(CL:DEFVAR KWD-READ-PAREN-COMMENT NULL)
(CL:DEFVAR KWD-READ-PAREN-COMMENT-ESCAPE NULL)
(CL:DEFVAR KWD-READ-PAREN-COMMENT-BAR NULL)
(CL:DEFVAR KWD-READ-ANY NULL)
(CL:DEFVAR KWD-READ-COMMA-SPLICE NULL)
(CL:DEFVAR KWD-READ-SYMBOL-OR-SIGNED-NUMBER NULL)
(CL:DEFVAR KWD-READ-SYMBOL NULL)
(CL:DEFVAR KWD-READ-SYMBOL-OR-NUMBER NULL)
(CL:DEFVAR KWD-READ-INTEGER NULL)
(CL:DEFVAR KWD-READ-SYMBOL-OR-CL-SYMBOL NULL)
(CL:DEFVAR KWD-READ-OPEN-FULLY-ESCAPED-SYMBOL NULL)
(CL:DEFVAR KWD-READ-FULLY-ESCAPED-SYMBOL NULL)
(CL:DEFVAR KWD-READ-ESCAPED-SYMBOL-ESCAPE NULL)
(CL:DEFVAR KWD-READ-QUALIFIED-NAME NULL)
(CL:DEFVAR KWD-READ-OPEN-KEYWORD NULL)
(CL:DEFVAR KWD-READ-KEYWORD NULL)
(CL:DEFVAR KWD-READ-OPEN-SURROGATE NULL)
(CL:DEFVAR KWD-READ-SURROGATE NULL)
(CL:DEFVAR KWD-READ-CLOSE-STRING NULL)
(CL:DEFVAR KWD-READ-STRING-ESCAPE NULL)
(CL:DEFVAR KWD-READ-ESCAPED-STRING NULL)
(CL:DEFVAR KWD-READ-CHARACTER-CONSTANT NULL)
(CL:DEFVAR KWD-READ-SYMBOL-OR-MANTISSA NULL)
(CL:DEFVAR KWD-READ-SYMBOL-OR-MANTISSA2 NULL)
(CL:DEFVAR KWD-READ-FLOAT NULL)
(CL:DEFVAR KWD-READ-SYMBOL-OR-EXPONENT-DELIMITER NULL)
(CL:DEFVAR KWD-READ-SYMBOL-OR-EXPONENT NULL)
(CL:DEFVAR KWD-READ-SYMBOL-OR-EXPONENT2 NULL)
(CL:DEFVAR KWD-READ-SYMBOL-OR-CL-SYMBOL2 NULL)
(CL:DEFVAR KWD-READ-SYMBOL-OR-CL-SYMBOL3 NULL)
(CL:DEFVAR KWD-READ-CL-SYMBOL NULL)
(CL:DEFVAR KWD-READ-ESCAPED-SYMBOL NULL)
(CL:DEFVAR KWD-READ-CLOSE-FULLY-ESCAPED-NAME NULL)
(CL:DEFVAR KWD-READ-FULLY-ESCAPED-SYMBOL-ESCAPE NULL)
(CL:DEFVAR KWD-READ-FULLY-ESCAPED-KEYWORD NULL)
(CL:DEFVAR KWD-READ-ESCAPED-KEYWORD-ESCAPE NULL)
(CL:DEFVAR KWD-READ-ESCAPED-KEYWORD NULL)
(CL:DEFVAR KWD-READ-FULLY-ESCAPED-KEYWORD-ESCAPE NULL)
(CL:DEFVAR KWD-READ-FULLY-ESCAPED-SURROGATE NULL)
(CL:DEFVAR KWD-READ-ESCAPED-SURROGATE-ESCAPE NULL)
(CL:DEFVAR KWD-READ-ESCAPED-SURROGATE NULL)
(CL:DEFVAR KWD-READ-FULLY-ESCAPED-SURROGATE-ESCAPE NULL)
(CL:DEFVAR KWD-READ-QUALIFIED-SURROGATE NULL)
(CL:DEFVAR KWD-READ-QUALIFIED-ESCAPED-SYMBOL-ESCAPE NULL)
(CL:DEFVAR KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL NULL)
(CL:DEFVAR KWD-READ-QUALIFIED-SYMBOL NULL)
(CL:DEFVAR KWD-READ-QUALIFIED-ESCAPED-SURROGATE-ESCAPE NULL)
(CL:DEFVAR KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE NULL)
(CL:DEFVAR KWD-READ-QUALIFIED-ESCAPED-SYMBOL NULL)
(CL:DEFVAR KWD-READ-QUALIFIED-ESCAPED-SURROGATE NULL)
(CL:DEFVAR KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL-ESCAPE NULL)
(CL:DEFVAR KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE-ESCAPE NULL)
(CL:DEFVAR KWD-READ-CLOSE-BALANCED-QUOTE NULL)
(CL:DEFVAR SYM-READ-STELLA-WITH-TOKENIZER NULL)
(CL:DEFVAR SYM-READ-STELLA-*STELLA-TOKENIZER-TABLE* NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_STELLALOGICALSTATENAMES_ NULL)
(CL:DEFVAR SYM-READ-STELLA-*STELLA-LOGICAL-STATE-NAMES* NULL)
(CL:DEFVAR SYM-READ-STELLA-TOK_STELLALOGICALSTATENAME_ NULL)
(CL:DEFVAR SYM-READ-STELLA-KEYWORD NULL)
(CL:DEFVAR KWD-READ-NONE NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL NULL)
(CL:DEFVAR KWD-READ-FULLY-ESCAPED NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-TOKEN-INTEGER NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-TOKEN-INTEGER-INTERNAL NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-TOKEN-LONG-INTEGER NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-TOKEN-LONG-INTEGER-INTERNAL NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-TOKEN-FLOAT NULL)
(CL:DEFVAR SYM-READ-STELLA-GET-TOKEN-FLOAT-INTERNAL NULL)
(CL:DEFVAR SGT-READ-STELLA-STELLA-TOKEN NULL)
(CL:DEFVAR SYM-READ-STELLA-LOGICAL-TOKEN-TYPE NULL)
(CL:DEFVAR SYM-READ-STELLA-MODULE NULL)
(CL:DEFVAR SYM-READ-STELLA-ESCAPE-MODE NULL)
(CL:DEFVAR KWD-READ-FULL NULL)
(CL:DEFVAR KWD-READ-PARTIAL NULL)
(CL:DEFVAR KWD-READ-ESCAPED NULL)
(CL:DEFVAR |SYM-READ-STELLA-&| NULL)
(CL:DEFVAR |SYM-READ-STELLA-&&| NULL)
(CL:DEFVAR KWD-READ-TEXT NULL)
(CL:DEFVAR KWD-READ-PUNCTUATION NULL)
(CL:DEFVAR KWD-READ-QUOTE NULL)
(CL:DEFVAR KWD-READ-ESCAPE NULL)
(CL:DEFVAR SGT-READ-STELLA-F-TOKENIZE-STRING-MEMO-TABLE-000 NULL)
(CL:DEFVAR KWD-READ-INITIAL-LINEFEED NULL)
(CL:DEFVAR KWD-READ-INITIAL-RETURN NULL)
(CL:DEFVAR KWD-READ-LINEFEED NULL)
(CL:DEFVAR KWD-READ-RETURN NULL)
(CL:DEFVAR KWD-READ-RETURN-LINEFEED NULL)
(CL:DEFVAR KWD-READ-LF NULL)
(CL:DEFVAR KWD-READ-CRLF NULL)
(CL:DEFVAR KWD-READ-CR NULL)
(CL:DEFVAR KWD-READ-ASK NULL)
(CL:DEFVAR KWD-READ-YES NULL)
(CL:DEFVAR KWD-READ-NO NULL)
(CL:DEFVAR KWD-READ-YES-VERBOSE NULL)
(CL:DEFVAR KWD-READ-NO-VERBOSE NULL)
(CL:DEFVAR SYM-READ-STELLA-STARTUP-READ NULL)
(CL:DEFVAR SYM-READ-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* STANDARD-OUTPUT STANDARD-INPUT
  *MEMOIZATION-ENABLED?* MEMOIZED-NULL-VALUE *CHARACTER-TYPE-TABLE*
  *TRANSIENTOBJECTS?* KEYWORD-SYM *MODULE* MOST-POSITIVE-LONG-INTEGER
  NULL-LONG-INTEGER MOST-POSITIVE-INTEGER MOST-NEGATIVE-INTEGER
  MODULE-SEPARATOR-CHARACTER *CHARACTER-UPCASE-TABLE* ZERO-WRAPPER
  STANDARD-ERROR EOL EOL-STRING NIL-LIST NULL-CHARACTER NULL-INTEGER
  NIL TRUE-WRAPPER FALSE-WRAPPER))

;;; (DEFCLASS TOKENIZER-TABLE ...)

(CL:DEFCLASS TOKENIZER-TABLE (STANDARD-OBJECT)
  ((TRANSITIONS :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %TRANSITIONS)
   (UNIQUE-STATE-NAMES :ALLOCATION :INSTANCE :ACCESSOR
    %UNIQUE-STATE-NAMES)
   (STATE-NAMES :ALLOCATION :INSTANCE :ACCESSOR %STATE-NAMES)
   (LEGAL-EOF-STATES :ALLOCATION :INSTANCE :ACCESSOR %LEGAL-EOF-STATES)))

(CL:DEFUN NEW-TOKENIZER-TABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TOKENIZER-TABLE)))
   (CL:SETF (%LEGAL-EOF-STATES SELF) NULL)
   (CL:SETF (%STATE-NAMES SELF) NULL)
   (CL:SETF (%UNIQUE-STATE-NAMES SELF) NULL)
   (CL:SETF (%TRANSITIONS SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-TOKENIZER-TABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TOKENIZER-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-READ-STELLA-TOKENIZER-TABLE))

(CL:DEFUN ACCESS-TOKENIZER-TABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-READ-STELLA-TRANSITIONS)
    (CL:IF SETVALUE?
     (CL:SETF (%TRANSITIONS SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%TRANSITIONS SELF)))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-UNIQUE-STATE-NAMES)
    (CL:IF SETVALUE? (CL:SETF (%UNIQUE-STATE-NAMES SELF) VALUE)
     (CL:SETQ VALUE (%UNIQUE-STATE-NAMES SELF))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-STATE-NAMES)
    (CL:IF SETVALUE? (CL:SETF (%STATE-NAMES SELF) VALUE)
     (CL:SETQ VALUE (%STATE-NAMES SELF))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-LEGAL-EOF-STATES)
    (CL:IF SETVALUE? (CL:SETF (%LEGAL-EOF-STATES SELF) VALUE)
     (CL:SETQ VALUE (%LEGAL-EOF-STATES SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-TOKENIZER-TABLE-SLOT-VALUE VALUE))

;;; (DEFGLOBAL *MAX-TOKENIZER-STATES* ...)

(CL:DEFVAR *MAX-TOKENIZER-STATES* 64)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *MAX-TOKENIZER-STATES*))

;;; (DEFGLOBAL *MAX-TOKENIZER-CHARACTERS* ...)

(CL:DEFVAR *MAX-TOKENIZER-CHARACTERS* 256)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *MAX-TOKENIZER-CHARACTERS*))

;;; (DEFUN (PARSE-TOKENIZER-DEFINITION TOKENIZER-TABLE) ...)

(CL:DEFUN PARSE-TOKENIZER-DEFINITION (DEFINITION)
  (CL:LET*
   ((TRANSITIONTABLE (NEW-VECTOR *MAX-TOKENIZER-STATES*))
    (TRANSITIONS
     (CL:THE CL:SIMPLE-STRING
      (CL:MAKE-STRING *MAX-TOKENIZER-CHARACTERS* :INITIAL-ELEMENT
       NULL-CHARACTER)))
    (UNIQUESTATENAMES (NEW-VECTOR *MAX-TOKENIZER-STATES*))
    (STATENAMES (NEW-VECTOR *MAX-TOKENIZER-STATES*))
    (LEGALEOFSTATES (NEW-VECTOR *MAX-TOKENIZER-STATES*))
    (FROMSTATENAME NULL) (FROMSTATEID NULL-INTEGER) (TOSTATENAME NULL)
    (TOSTATEALIAS NULL) (TOSTATEID NULL-INTEGER) (FREESTATEID 2)
    (CHARACTERSPEC NULL) (CHARACTERSET NULL)
    (ALLCHARACTERSETS (NEW-LIST)) (STATEMODIFIERS 0) (ERRORS? CL:NIL)
    (TABLE (NEW-TOKENIZER-TABLE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TRANSITIONS)
    (CL:TYPE CL:FIXNUM FROMSTATEID TOSTATEID FREESTATEID
     STATEMODIFIERS))
   (CL:LET
    ((SELF (%THE-ARRAY UNIQUESTATENAMES)) (VALUE KWD-READ-ERROR)
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY STATENAMES)) (VALUE KWD-READ-ERROR)
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY UNIQUESTATENAMES)) (VALUE KWD-READ-START)
     (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY STATENAMES)) (VALUE KWD-READ-START)
     (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET* ((STATEDEFINITION NULL) (ITER-000 DEFINITION))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ STATEDEFINITION (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:WHEN
       (CL:NOT (LEGAL-TOKENIZER-FROM-STATE? (%%VALUE STATEDEFINITION)))
       (CL:WARN "Illegal from state: `~A'" (%%VALUE STATEDEFINITION))
       (CL:SETQ ERRORS? CL:T) (CL:GO :CONTINUE))
      (CL:SETQ FROMSTATENAME (%%VALUE STATEDEFINITION))
      (CL:SETQ STATEDEFINITION (%%REST STATEDEFINITION))
      (CL:SETQ FROMSTATEID (POSITION UNIQUESTATENAMES FROMSTATENAME 0))
      (CL:WHEN (CL:= FROMSTATEID NULL-INTEGER)
       (CL:WHEN (CL:= FREESTATEID *MAX-TOKENIZER-STATES*)
        (CL:WARN "Too many tokenizer states; maximum is `~A'"
         *MAX-TOKENIZER-STATES*)
        (CL:SETQ ERRORS? CL:T) (CL:RETURN))
       (CL:LET
        ((SELF (%THE-ARRAY UNIQUESTATENAMES)) (VALUE FROMSTATENAME)
         (POSITION FREESTATEID))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:LET
        ((SELF (%THE-ARRAY STATENAMES)) (VALUE FROMSTATENAME)
         (POSITION FREESTATEID))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ FROMSTATEID FREESTATEID)
       (CL:SETQ FREESTATEID (CL:1+ FREESTATEID)))
      (CLEAR ALLCHARACTERSETS)
      (CL:LET*
       ((I NULL-INTEGER) (ITER-001 0)
        (UPPER-BOUND-000 (CL:1- *MAX-TOKENIZER-CHARACTERS*)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-000) DO
        (CL:SETQ I ITER-001)
        (CL:LET ((SELF TRANSITIONS) (CH (CL:CODE-CHAR 0)) (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (SETF
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))
          (CL:THE CL:CHARACTER CH)))
        (CL:SETQ ITER-001 (CL:1+ ITER-001))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ STATEDEFINITION NIL)) DO
       (CL:TAGBODY
        (CL:WHEN (TOKENIZER-INCLUDE-SPEC? (%%VALUE STATEDEFINITION))
         (CL:WHEN
          (CL:NOT
           (LEGAL-TOKENIZER-FROM-STATE?
            (%%VALUE (%%REST STATEDEFINITION))))
          (CL:WARN "Illegal include specification for state `~A'"
           FROMSTATENAME)
          (CL:SETQ ERRORS? CL:T) (CL:RETURN))
         (CL:SETQ STATEDEFINITION (COPY-CONS-LIST STATEDEFINITION))
         (CL:LET* ((STATEDEF NULL) (ITER-002 DEFINITION))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
           (CL:SETQ STATEDEF (%%VALUE ITER-002))
           (CL:WHEN
            (EQL? (%%VALUE STATEDEF)
             (%%VALUE (%%REST STATEDEFINITION)))
            (FIRST-SETTER STATEDEFINITION (%%VALUE (%%REST STATEDEF)))
            (CL:SETF (%%REST STATEDEFINITION)
             (CONCATENATE (COPY-CONS-LIST (%%REST (%%REST STATEDEF)))
              (%%REST (%%REST STATEDEFINITION))))
            (CL:RETURN))
           (CL:SETQ ITER-002 (%%REST ITER-002))))
         (CL:GO :CONTINUE))
        (CL:SETQ STATEMODIFIERS
         (PARSE-TOKENIZER-STATE-MODIFIERS (%%VALUE STATEDEFINITION)))
        (CL:WHEN (CL:> STATEMODIFIERS 0)
         (CL:SETQ STATEDEFINITION (%%REST STATEDEFINITION)))
        (CL:SETQ CHARACTERSPEC (%%VALUE STATEDEFINITION))
        (CL:SETQ STATEDEFINITION (%%REST STATEDEFINITION))
        (CL:WHEN (CL:EQ CHARACTERSPEC NULL)
         (CL:WARN "Illegal definition of `~A' state" FROMSTATENAME)
         (CL:SETQ ERRORS? CL:T) (CL:RETURN))
        (CL:WHEN
         (CL:NOT (LEGAL-TOKENIZER-TO-STATE? (%%VALUE STATEDEFINITION)))
         (CL:WARN "Illegal to state `~A' for state `~A'"
          (%%VALUE STATEDEFINITION) FROMSTATENAME)
         (CL:SETQ ERRORS? CL:T) (CL:RETURN))
        (CL:WHEN (CL:EQ CHARACTERSPEC KWD-READ-EOF)
         (CL:LET
          ((SELF (%THE-ARRAY LEGALEOFSTATES)) (VALUE TRUE-WRAPPER)
           (POSITION FROMSTATEID))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:SETQ STATEDEFINITION (%%REST STATEDEFINITION))
         (CL:GO :CONTINUE))
        (CL:SETQ TOSTATENAME
         (TOKENIZER-TO-STATE-NAME (%%VALUE STATEDEFINITION)))
        (CL:SETQ TOSTATEALIAS
         (TOKENIZER-TO-STATE-ALIAS (%%VALUE STATEDEFINITION)))
        (CL:SETQ STATEDEFINITION (%%REST STATEDEFINITION))
        (CL:SETQ TOSTATEID (POSITION UNIQUESTATENAMES TOSTATENAME 0))
        (CL:WHEN (CL:= TOSTATEID NULL-INTEGER)
         (CL:WHEN (CL:= FREESTATEID *MAX-TOKENIZER-STATES*)
          (CL:WARN "Too many tokenizer states; maximum is `~A'"
           *MAX-TOKENIZER-STATES*)
          (CL:SETQ ERRORS? CL:T) (CL:RETURN))
         (CL:LET
          ((SELF (%THE-ARRAY UNIQUESTATENAMES)) (VALUE TOSTATENAME)
           (POSITION FREESTATEID))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:LET
          ((SELF (%THE-ARRAY STATENAMES)) (VALUE TOSTATEALIAS)
           (POSITION FREESTATEID))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:SETQ TOSTATEID FREESTATEID)
         (CL:SETQ FREESTATEID (CL:1+ FREESTATEID)))
        (CL:WHEN
         (CL:AND
          (CL:NOT
           (CL:EQ
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY STATENAMES))
             TOSTATEID)
            TOSTATEALIAS))
          (CL:NOT
           (CL:EQ
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY STATENAMES))
             TOSTATEID)
            NULL)))
         (CL:WARN
          "Illegal redefinition of alias `~A' for state `~A' in state `~A'"
          TOSTATEALIAS TOSTATENAME FROMSTATENAME)
         (CL:SETQ ERRORS? CL:T))
        (CL:SETQ CHARACTERSET
         (PARSE-TOKENIZER-CHARACTER-SPEC CHARACTERSPEC
          ALLCHARACTERSETS))
        (CL:WHEN (CL:EQ CHARACTERSET NULL)
         (CL:WARN "Illegal character specification `~A' for state `~A'"
          CHARACTERSPEC FROMSTATENAME)
         (CL:SETQ ERRORS? CL:T) (CL:GO :CONTINUE))
        (PUSH ALLCHARACTERSETS CHARACTERSET)
        (CL:LET* ((CHAR NULL) (ITER-003 CHARACTERSET))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
          (CL:SETQ CHAR (%%VALUE ITER-003))
          (CL:LET
           ((SELF TRANSITIONS)
            (CH
             (CL:CODE-CHAR
              (CL:THE CL:FIXNUM
               (CL:LOGIOR (CL:THE CL:FIXNUM (CL:ASH STATEMODIFIERS 6))
                TOSTATEID))))
            (POSITION
             (CL:THE CL:FIXNUM (CL:CHAR-CODE (%WRAPPER-VALUE CHAR)))))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (SETF
            (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
             (CL:THE CL:FIXNUM POSITION))
            (CL:THE CL:CHARACTER CH)))
          (CL:SETQ ITER-003 (%%REST ITER-003))))
        :CONTINUE))
      (CL:LET
       ((SELF (%THE-ARRAY TRANSITIONTABLE))
        (VALUE (WRAP-MUTABLE-STRING TRANSITIONS))
        (POSITION FROMSTATEID))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ TRANSITIONS
       (CL:THE CL:SIMPLE-STRING
        (CL:MAKE-STRING *MAX-TOKENIZER-CHARACTERS* :INITIAL-ELEMENT
         NULL-CHARACTER)))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-004 0)
     (UPPER-BOUND-001 (CL:1- FREESTATEID)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-004 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-004 UPPER-BOUND-001) DO
     (CL:SETQ I ITER-004)
     (CL:WHEN
      (CL:EQ
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY TRANSITIONTABLE))
        I)
       NULL)
      (CL:WARN "State `~A' is undefined"
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY UNIQUESTATENAMES))
        I))
      (CL:SETQ ERRORS? CL:T))
     (CL:SETQ ITER-004 (CL:1+ ITER-004))))
   (CL:WHEN ERRORS? (CL:RETURN-FROM PARSE-TOKENIZER-DEFINITION NULL))
   (CL:SETQ TRANSITIONS
    (CL:THE CL:SIMPLE-STRING
     (CL:MAKE-STRING
      (CL:THE CL:FIXNUM (CL:* FREESTATEID *MAX-TOKENIZER-CHARACTERS*))
      :INITIAL-ELEMENT NULL-CHARACTER)))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-005 0)
     (UPPER-BOUND-002 (CL:1- FREESTATEID)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-005 UPPER-BOUND-002))
    (CL:LOOP WHILE (CL:<= ITER-005 UPPER-BOUND-002) DO
     (CL:SETQ I ITER-005)
     (CL:LET*
      ((J NULL-INTEGER) (ITER-006 0)
       (UPPER-BOUND-003 (CL:1- *MAX-TOKENIZER-CHARACTERS*))
       (K NULL-INTEGER) (ITER-007 (CL:* *MAX-TOKENIZER-CHARACTERS* I)))
      (CL:DECLARE
       (CL:TYPE CL:FIXNUM J ITER-006 UPPER-BOUND-003 K ITER-007))
      (CL:LOOP WHILE (CL:<= ITER-006 UPPER-BOUND-003) DO
       (CL:SETQ J ITER-006) (CL:SETQ K ITER-007)
       (CL:LET
        ((SELF TRANSITIONS)
         (CH
          (CL:LET
           ((SELF
             (%WRAPPER-VALUE
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY TRANSITIONTABLE))
               I)))
            (POSITION J))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))))
         (POSITION K))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (SETF
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))
         (CL:THE CL:CHARACTER CH)))
       (CL:SETQ ITER-006 (CL:1+ ITER-006))
       (CL:SETQ ITER-007 (CL:1+ ITER-007))))
     (CL:SETQ ITER-005 (CL:1+ ITER-005))))
   (CL:SETF (%TRANSITIONS TABLE)
    (CL:LET ((S TRANSITIONS)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S)))
   (CL:SETF (%UNIQUE-STATE-NAMES TABLE) (NEW-VECTOR FREESTATEID))
   (CL:SETF (%STATE-NAMES TABLE) (NEW-VECTOR FREESTATEID))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-008 0)
     (UPPER-BOUND-004 (CL:1- FREESTATEID)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-008 UPPER-BOUND-004))
    (CL:LOOP WHILE (CL:<= ITER-008 UPPER-BOUND-004) DO
     (CL:SETQ I ITER-008)
     (CL:LET
      ((SELF (%THE-ARRAY (%UNIQUE-STATE-NAMES TABLE)))
       (VALUE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY UNIQUESTATENAMES)) I))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF (%THE-ARRAY (%STATE-NAMES TABLE)))
       (VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY STATENAMES)) I))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-008 (CL:1+ ITER-008))))
   (CL:SETF (%LEGAL-EOF-STATES TABLE) (NEW-VECTOR FREESTATEID))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-009 0)
     (UPPER-BOUND-005 (CL:1- FREESTATEID)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-009 UPPER-BOUND-005))
    (CL:LOOP WHILE (CL:<= ITER-009 UPPER-BOUND-005) DO
     (CL:SETQ I ITER-009)
     (CL:LET
      ((SELF (%THE-ARRAY (%LEGAL-EOF-STATES TABLE)))
       (VALUE
        (CL:IF
         (CL:EQ
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY LEGALEOFSTATES)) I)
          NULL)
         FALSE-WRAPPER
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY LEGALEOFSTATES))
          I)))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-009 (CL:1+ ITER-009))))
   (CL:RETURN-FROM PARSE-TOKENIZER-DEFINITION TABLE)))

;;; (DEFUN (LEGAL-TOKENIZER-STATE? BOOLEAN) ...)

(CL:DEFUN LEGAL-TOKENIZER-STATE? (X)
  (CL:RETURN-FROM LEGAL-TOKENIZER-STATE?
   (CL:OR (KEYWORD? X) (SYMBOL? X))))

;;; (DEFUN (LEGAL-TOKENIZER-FROM-STATE? BOOLEAN) ...)

(CL:DEFUN LEGAL-TOKENIZER-FROM-STATE? (X)
  (CL:RETURN-FROM LEGAL-TOKENIZER-FROM-STATE?
   (LEGAL-TOKENIZER-STATE? X)))

;;; (DEFUN (LEGAL-TOKENIZER-TO-STATE? BOOLEAN) ...)

(CL:DEFUN LEGAL-TOKENIZER-TO-STATE? (X)
  (CL:RETURN-FROM LEGAL-TOKENIZER-TO-STATE?
   (CL:OR (LEGAL-TOKENIZER-STATE? X)
    (CL:AND (CONS? X) (LEGAL-TOKENIZER-STATE? (%%VALUE X))
     (LEGAL-TOKENIZER-STATE? (%%VALUE (%%REST X)))))))

;;; (DEFUN (TOKENIZER-TO-STATE-NAME GENERALIZED-SYMBOL) ...)

(CL:DEFUN TOKENIZER-TO-STATE-NAME (STATE)
  (CL:IF (CONS? STATE)
   (CL:RETURN-FROM TOKENIZER-TO-STATE-NAME (%%VALUE STATE))
   (CL:RETURN-FROM TOKENIZER-TO-STATE-NAME STATE)))

;;; (DEFUN (TOKENIZER-TO-STATE-ALIAS GENERALIZED-SYMBOL) ...)

(CL:DEFUN TOKENIZER-TO-STATE-ALIAS (STATE)
  (CL:IF (CONS? STATE)
   (CL:RETURN-FROM TOKENIZER-TO-STATE-ALIAS (%%VALUE (%%REST STATE)))
   (CL:RETURN-FROM TOKENIZER-TO-STATE-ALIAS STATE)))

;;; (DEFUN (PARSE-TOKENIZER-STATE-MODIFIERS INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM)
  PARSE-TOKENIZER-STATE-MODIFIERS))
(CL:DEFUN PARSE-TOKENIZER-STATE-MODIFIERS (MODIFIER)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE MODIFIER)
     SGT-READ-STELLA-GENERALIZED-SYMBOL)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 (%SYMBOL-NAME MODIFIER)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEST-VALUE-000))
      (CL:COND
       ((STRING-EQL? TEST-VALUE-000 "*")
        (CL:RETURN-FROM PARSE-TOKENIZER-STATE-MODIFIERS 2))
       ((CL:OR (STRING-EQL? TEST-VALUE-000 "!")
         (STRING-EQL? TEST-VALUE-000 "*!")
         (STRING-EQL? TEST-VALUE-000 "!*"))
        (CL:RETURN-FROM PARSE-TOKENIZER-STATE-MODIFIERS 3))
       (CL:T (CL:RETURN-FROM PARSE-TOKENIZER-STATE-MODIFIERS 0))))))
   (CL:T (CL:RETURN-FROM PARSE-TOKENIZER-STATE-MODIFIERS 0))))

;;; (DEFUN (TOKENIZER-INCLUDE-SPEC? BOOLEAN) ...)

(CL:DEFUN TOKENIZER-INCLUDE-SPEC? (X)
  (CL:RETURN-FROM TOKENIZER-INCLUDE-SPEC?
   (CL:AND (ISA? X SGT-READ-STELLA-GENERALIZED-SYMBOL)
    (STRING-EQL? (%SYMBOL-NAME X) "INCLUDE"))))

;;; (DEFUN (PARSE-TOKENIZER-CHARACTER-SPEC CHARACTER-SET) ...)

(CL:DEFUN PARSE-TOKENIZER-CHARACTER-SPEC (CHARACTERSPEC ALLCHARACTERSETS)
  (CL:LET* ((CHARSET NIL) (COMPLEMENTSET NIL) (PARSEDSPEC NULL))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE CHARACTERSPEC)))
    (CL:COND
     ((SUBTYPE-OF-STRING? TEST-VALUE-001)
      (CL:PROGN
       (CL:LET*
        ((CHAR NULL-CHARACTER)
         (VECTOR-000 (%WRAPPER-VALUE CHARACTERSPEC)) (INDEX-000 0)
         (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000)))
         (COLLECT-000 NULL))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
         (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ CHAR
          (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000 (CONS (WRAP-CHARACTER CHAR) NIL))
           (CL:IF (CL:EQ CHARSET NIL) (CL:SETQ CHARSET COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST CHARSET COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000)
            (CONS (WRAP-CHARACTER CHAR) NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))))
     ((SUBTYPE-OF-CHARACTER? TEST-VALUE-001)
      (CL:PROGN (CL:SETQ CHARSET (CONS CHARACTERSPEC CHARSET))))
     ((CL:EQ TEST-VALUE-001 SGT-READ-STELLA-CONS)
      (CL:PROGN
       (CL:LET* ((SPEC NULL) (ITER-000 CHARACTERSPEC))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ SPEC (%%VALUE ITER-000))
         (CL:SETQ PARSEDSPEC
          (PARSE-TOKENIZER-CHARACTER-SPEC SPEC NIL-LIST))
         (CL:WHEN (CL:EQ PARSEDSPEC NULL)
          (CL:RETURN-FROM PARSE-TOKENIZER-CHARACTER-SPEC NULL))
         (CL:LET*
          ((CHAR NULL) (ITER-001 PARSEDSPEC) (COLLECT-001 NULL))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ CHAR (%%VALUE ITER-001))
           (CL:IF (CL:EQ COLLECT-001 NULL)
            (CL:PROGN (CL:SETQ COLLECT-001 (CONS CHAR NIL))
             (CL:IF (CL:EQ CHARSET NIL) (CL:SETQ CHARSET COLLECT-001)
              (ADD-CONS-TO-END-OF-CONS-LIST CHARSET COLLECT-001)))
            (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS CHAR NIL))
             (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (CL:SETQ ITER-000 (%%REST ITER-000))))))
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-READ-STELLA-GENERALIZED-SYMBOL)
      (CL:PROGN
       (CL:LET* ((TEST-VALUE-000 (%SYMBOL-NAME CHARACTERSPEC)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEST-VALUE-000))
        (CL:COND
         ((STRING-EQL? TEST-VALUE-000 "ANY")
          (CL:LET*
           ((I NULL-INTEGER) (ITER-002 0)
            (UPPER-BOUND-000 (CL:1- *MAX-TOKENIZER-CHARACTERS*))
            (COLLECT-002 NULL))
           (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
           (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-000) DO
            (CL:SETQ I ITER-002)
            (CL:IF (CL:EQ COLLECT-002 NULL)
             (CL:PROGN
              (CL:SETQ COLLECT-002
               (CONS (WRAP-CHARACTER (CL:CODE-CHAR I)) NIL))
              (CL:IF (CL:EQ CHARSET NIL) (CL:SETQ CHARSET COLLECT-002)
               (ADD-CONS-TO-END-OF-CONS-LIST CHARSET COLLECT-002)))
             (CL:PROGN
              (CL:SETF (%%REST COLLECT-002)
               (CONS (WRAP-CHARACTER (CL:CODE-CHAR I)) NIL))
              (CL:SETQ COLLECT-002 (%%REST COLLECT-002))))
            (CL:SETQ ITER-002 (CL:1+ ITER-002)))))
         ((STRING-EQL? TEST-VALUE-000 "OTHERWISE")
          (CL:LET*
           ((SET NULL) (ITER-003 (%THE-CONS-LIST ALLCHARACTERSETS)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
            (CL:SETQ SET (%%VALUE ITER-003))
            (CL:LET* ((CHAR NULL) (ITER-004 SET) (COLLECT-003 NULL))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
              (CL:SETQ CHAR (%%VALUE ITER-004))
              (CL:IF (CL:EQ COLLECT-003 NULL)
               (CL:PROGN (CL:SETQ COLLECT-003 (CONS CHAR NIL))
                (CL:IF (CL:EQ CHARSET NIL)
                 (CL:SETQ CHARSET COLLECT-003)
                 (ADD-CONS-TO-END-OF-CONS-LIST CHARSET COLLECT-003)))
               (CL:PROGN (CL:SETF (%%REST COLLECT-003) (CONS CHAR NIL))
                (CL:SETQ COLLECT-003 (%%REST COLLECT-003))))
              (CL:SETQ ITER-004 (%%REST ITER-004))))
            (CL:SETQ ITER-003 (%%REST ITER-003))))
          (CL:LET*
           ((I NULL-INTEGER) (ITER-005 0)
            (UPPER-BOUND-001 (CL:1- *MAX-TOKENIZER-CHARACTERS*))
            (COLLECT-004 NULL))
           (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-005 UPPER-BOUND-001))
           (CL:LOOP WHILE (CL:<= ITER-005 UPPER-BOUND-001) DO
            (CL:SETQ I ITER-005)
            (CL:WHEN
             (CL:NOT
              (MEMBER? CHARSET (WRAP-CHARACTER (CL:CODE-CHAR I))))
             (CL:IF (CL:EQ COLLECT-004 NULL)
              (CL:PROGN
               (CL:SETQ COLLECT-004
                (CONS (WRAP-CHARACTER (CL:CODE-CHAR I)) NIL))
               (CL:IF (CL:EQ COMPLEMENTSET NIL)
                (CL:SETQ COMPLEMENTSET COLLECT-004)
                (ADD-CONS-TO-END-OF-CONS-LIST COMPLEMENTSET
                 COLLECT-004)))
              (CL:PROGN
               (CL:SETF (%%REST COLLECT-004)
                (CONS (WRAP-CHARACTER (CL:CODE-CHAR I)) NIL))
               (CL:SETQ COLLECT-004 (%%REST COLLECT-004)))))
            (CL:SETQ ITER-005 (CL:1+ ITER-005))))
          (CL:SETQ CHARSET COMPLEMENTSET))
         (CL:T
          (CL:RETURN-FROM PARSE-TOKENIZER-CHARACTER-SPEC NULL))))))
     (CL:T (CL:RETURN-FROM PARSE-TOKENIZER-CHARACTER-SPEC NULL))))
   (CL:RETURN-FROM PARSE-TOKENIZER-CHARACTER-SPEC CHARSET)))

;;; (DEFUN (STRINGIFY-TOKENIZER-TABLE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  STRINGIFY-TOKENIZER-TABLE))
(CL:DEFUN STRINGIFY-TOKENIZER-TABLE (TABLE)
  (CL:LET*
   ((RESULT (NEW-OUTPUT-STRING-STREAM))
    (ACODE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A)))
    (TRANSITIONS (%TRANSITIONS TABLE))
    (ENCODEDTRANSITIONS
     (CL:THE CL:SIMPLE-STRING
      (CL:MAKE-STRING
       (CL:THE CL:FIXNUM
        (CL:* 2 *MAX-TOKENIZER-STATES* *MAX-TOKENIZER-CHARACTERS*))
       :INITIAL-ELEMENT NULL-CHARACTER)))
    (J -1) (UNIQUESTATENAMES (%UNIQUE-STATE-NAMES TABLE))
    (STATENAMES (%STATE-NAMES TABLE))
    (EOFSTATES (%LEGAL-EOF-STATES TABLE)) (SEPARATOR "|"))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ACODE J)
    (CL:TYPE CL:SIMPLE-STRING TRANSITIONS ENCODEDTRANSITIONS
     SEPARATOR))
   (%%PRINT-STREAM (%NATIVE-STREAM RESULT)
    (CL:* 2 *MAX-TOKENIZER-STATES* *MAX-TOKENIZER-CHARACTERS*)
    SEPARATOR)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000
      (CL:1-
       (CL:* *MAX-TOKENIZER-STATES* *MAX-TOKENIZER-CHARACTERS*))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF ENCODEDTRANSITIONS)
       (CH
        (CL:CODE-CHAR
         (CL:THE CL:FIXNUM
          (CL:+
           (CL:THE CL:FIXNUM
            (CL:LOGAND
             (CL:THE CL:FIXNUM
              (CL:CHAR-CODE
               (CL:LET ((SELF TRANSITIONS) (POSITION I))
                (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
                 (CL:TYPE CL:FIXNUM POSITION))
                (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                 (CL:THE CL:FIXNUM POSITION)))))
             15))
           ACODE))))
       (POSITION (CL:SETQ J (CL:1+ J))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:LET
      ((SELF ENCODEDTRANSITIONS)
       (CH
        (CL:CODE-CHAR
         (CL:THE CL:FIXNUM
          (CL:+
           (CL:LET
            ((ARG
              (CL:THE CL:FIXNUM
               (CL:CHAR-CODE
                (CL:LET ((SELF TRANSITIONS) (POSITION I))
                 (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
                  (CL:TYPE CL:FIXNUM POSITION))
                 (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                  (CL:THE CL:FIXNUM POSITION))))))
             (COUNT 4))
            (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
            (CL:THE CL:FIXNUM
             (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT)))))
           ACODE))))
       (POSITION (CL:SETQ J (CL:1+ J))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (%%PRINT-STREAM (%NATIVE-STREAM RESULT)
    (CL:LET ((S ENCODEDTRANSITIONS))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S))
    SEPARATOR)
   (%%PRINT-STREAM (%NATIVE-STREAM RESULT) (LENGTH UNIQUESTATENAMES)
    SEPARATOR)
   (CL:LET*
    ((STATE NULL) (VECTOR-000 UNIQUESTATENAMES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ STATE
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (%%PRINT-STREAM (%NATIVE-STREAM RESULT) (%SYMBOL-NAME STATE)
      SEPARATOR)
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (%%PRINT-STREAM (%NATIVE-STREAM RESULT) (LENGTH STATENAMES)
    SEPARATOR)
   (CL:LET*
    ((STATE NULL) (VECTOR-001 STATENAMES) (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
    (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
     (CL:SETQ STATE
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
       INDEX-001))
     (%%PRINT-STREAM (%NATIVE-STREAM RESULT) (%SYMBOL-NAME STATE)
      SEPARATOR)
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
   (%%PRINT-STREAM (%NATIVE-STREAM RESULT) (LENGTH EOFSTATES)
    SEPARATOR)
   (CL:LET*
    ((STATE NULL) (VECTOR-002 EOFSTATES) (INDEX-002 0)
     (LENGTH-002 (LENGTH VECTOR-002)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
    (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
     (CL:SETQ STATE
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
       INDEX-002))
     (%%PRINT-STREAM (%NATIVE-STREAM RESULT)
      (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN STATE) "T" "F"))
     (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
   (%%PRINT-STREAM (%NATIVE-STREAM RESULT) SEPARATOR)
   (CL:RETURN-FROM STRINGIFY-TOKENIZER-TABLE
    (THE-STRING-READER RESULT))))

;;; (DEFUN (UNSTRINGIFY-TOKENIZER-TABLE TOKENIZER-TABLE) ...)

(CL:DEFUN UNSTRINGIFY-TOKENIZER-TABLE (TABLE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TABLE))
  #+MCL
  (CL:CHECK-TYPE TABLE CL:SIMPLE-STRING)
  (CL:LET*
   ((RESULT (NEW-TOKENIZER-TABLE))
    (ACODE (CL:THE CL:FIXNUM (CL:CHAR-CODE #\A)))
    (LINE STELLA::NULL-STRING) (COUNT 0)
    (TRANSITIONS STELLA::NULL-STRING) (SEPARATOR #\|) (START 0)
    (END 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ACODE COUNT START END)
    (CL:TYPE CL:SIMPLE-STRING LINE TRANSITIONS))
   (CL:SETQ END (POSITION TABLE SEPARATOR START))
   (CL:SETQ LINE (SUBSEQUENCE TABLE START END))
   (CL:SETQ START (CL:1+ END))
   (CL:SETQ COUNT (CL:TRUNCATE (STRING-TO-INTEGER LINE)))
   (CL:SETQ END (POSITION TABLE SEPARATOR START))
   (CL:SETQ LINE (SUBSEQUENCE TABLE START END))
   (CL:SETQ START (CL:1+ END))
   (CL:SETQ TRANSITIONS
    (CL:THE CL:SIMPLE-STRING
     (CL:MAKE-STRING
      (CL:THE CL:FIXNUM (CL:TRUNCATE (CL:/ COUNT 2.0d0)))
      :INITIAL-ELEMENT NULL-CHARACTER)))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:TRUNCATE (CL:1- (CL:/ COUNT 2.0d0)))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF TRANSITIONS)
       (CH
        (CL:CODE-CHAR
         (CL:THE CL:FIXNUM
          (CL:LOGIOR
           (CL:THE CL:FIXNUM
            (CL:-
             (CL:THE CL:FIXNUM
              (CL:CHAR-CODE
               (CL:LET ((SELF LINE) (POSITION (CL:* 2 I)))
                (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
                 (CL:TYPE CL:FIXNUM POSITION))
                (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                 (CL:THE CL:FIXNUM POSITION)))))
             ACODE))
           (CL:THE CL:FIXNUM
            (CL:ASH
             (CL:THE CL:FIXNUM
              (CL:-
               (CL:THE CL:FIXNUM
                (CL:CHAR-CODE
                 (CL:LET ((SELF LINE) (POSITION (CL:1+ (CL:* 2 I))))
                  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
                   (CL:TYPE CL:FIXNUM POSITION))
                  (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                   (CL:THE CL:FIXNUM POSITION)))))
               ACODE))
             4))))))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETF (%TRANSITIONS RESULT)
    (CL:LET ((S TRANSITIONS)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S)))
   (CL:SETQ END (POSITION TABLE SEPARATOR START))
   (CL:SETQ LINE (SUBSEQUENCE TABLE START END))
   (CL:SETQ START (CL:1+ END))
   (CL:SETQ COUNT (CL:TRUNCATE (STRING-TO-INTEGER LINE)))
   (CL:SETF (%UNIQUE-STATE-NAMES RESULT) (NEW-VECTOR COUNT))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- COUNT)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
     (CL:SETQ I ITER-001)
     (CL:SETQ END (POSITION TABLE SEPARATOR START))
     (CL:SETQ LINE (SUBSEQUENCE TABLE START END))
     (CL:SETQ START (CL:1+ END))
     (CL:LET
      ((SELF (%THE-ARRAY (%UNIQUE-STATE-NAMES RESULT)))
       (VALUE (INTERN-KEYWORD LINE)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:SETQ END (POSITION TABLE SEPARATOR START))
   (CL:SETQ LINE (SUBSEQUENCE TABLE START END))
   (CL:SETQ START (CL:1+ END))
   (CL:SETQ COUNT (CL:TRUNCATE (STRING-TO-INTEGER LINE)))
   (CL:SETF (%STATE-NAMES RESULT) (NEW-VECTOR COUNT))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-002 (CL:1- COUNT)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-002))
    (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-002) DO
     (CL:SETQ I ITER-002)
     (CL:SETQ END (POSITION TABLE SEPARATOR START))
     (CL:SETQ LINE (SUBSEQUENCE TABLE START END))
     (CL:SETQ START (CL:1+ END))
     (CL:LET
      ((SELF (%THE-ARRAY (%STATE-NAMES RESULT)))
       (VALUE (INTERN-KEYWORD LINE)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))))
   (CL:SETQ END (POSITION TABLE SEPARATOR START))
   (CL:SETQ LINE (SUBSEQUENCE TABLE START END))
   (CL:SETQ START (CL:1+ END))
   (CL:SETQ COUNT (CL:TRUNCATE (STRING-TO-INTEGER LINE)))
   (CL:SETQ END (POSITION TABLE SEPARATOR START))
   (CL:SETQ LINE (SUBSEQUENCE TABLE START END))
   (CL:SETQ START (CL:1+ END))
   (CL:SETF (%LEGAL-EOF-STATES RESULT) (NEW-VECTOR COUNT))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-003 0) (UPPER-BOUND-003 (CL:1- COUNT)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003 UPPER-BOUND-003))
    (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-003) DO
     (CL:SETQ I ITER-003)
     (CL:ECASE
      (CL:LET ((SELF LINE) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION)))
      (#\T
       (CL:LET
        ((SELF (%THE-ARRAY (%LEGAL-EOF-STATES RESULT)))
         (VALUE TRUE-WRAPPER) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE)))
      (#\F
       (CL:LET
        ((SELF (%THE-ARRAY (%LEGAL-EOF-STATES RESULT)))
         (VALUE FALSE-WRAPPER) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))))
     (CL:SETQ ITER-003 (CL:1+ ITER-003))))
   (CL:RETURN-FROM UNSTRINGIFY-TOKENIZER-TABLE RESULT)))

;;; (DEFUN (MAKE-TOKENIZER-BYTE-ARRAY TOKENIZER-BYTE-ARRAY) ...)

(CL:DEFUN MAKE-TOKENIZER-BYTE-ARRAY (SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (CL:RETURN-FROM MAKE-TOKENIZER-BYTE-ARRAY (CL:MAKE-STRING SIZE)))

;;; (DEFUN (STRING-TO-TOKENIZER-BYTE-ARRAY TOKENIZER-BYTE-ARRAY) ...)

(CL:DEFUN STRING-TO-TOKENIZER-BYTE-ARRAY (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:RETURN-FROM STRING-TO-TOKENIZER-BYTE-ARRAY STRING))

;;; (DEFUN (TOKENIZER-BYTE-ARRAY-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  TOKENIZER-BYTE-ARRAY-TO-STRING))
(CL:DEFUN TOKENIZER-BYTE-ARRAY-TO-STRING (BYTES)
  (CL:RETURN-FROM TOKENIZER-BYTE-ARRAY-TO-STRING BYTES))

;;; (DEFMETHOD (BYTE-ARRAY-NTH CHARACTER) ...)

(CL:DEFMETHOD BYTE-ARRAY-NTH ((BUFFER CL:STRING) POSITION)
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  #+MCL
  (CL:CHECK-TYPE POSITION CL:FIXNUM)
  (CL:RETURN-FROM BYTE-ARRAY-NTH
   (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
    (CL:THE CL:FIXNUM POSITION))))

;;; (DEFMETHOD (BYTE-ARRAY-NTH-SETTER TOKENIZER-BYTE) ...)

(CL:DEFMETHOD BYTE-ARRAY-NTH-SETTER ((BUFFER CL:STRING) CH POSITION)
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  #+MCL
  (CL:CHECK-TYPE POSITION CL:FIXNUM)
  (CL:RETURN-FROM BYTE-ARRAY-NTH-SETTER
   (CL:SETF
    (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
     (CL:THE CL:FIXNUM POSITION))
    (CL:THE CL:CHARACTER CH))))

;;; (DEFUN (NATIVE-BYTE-ARRAY-READ-SEQUENCE INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:FIXNUM CL:FIXNUM) CL:FIXNUM)
  NATIVE-BYTE-ARRAY-READ-SEQUENCE))
(CL:DEFUN NATIVE-BYTE-ARRAY-READ-SEQUENCE (BUFFER STREAM START END)
  (CL:DECLARE (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:LET* ((N 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM N)) (setq n
    (- (%%read-sequence buffer stream :start start :end end) start))
   (CL:RETURN-FROM NATIVE-BYTE-ARRAY-READ-SEQUENCE (CL:+ N START))))

;;; (DEFUN (TOKENIZER-BYTE-ARRAY-READ-SEQUENCE INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:FIXNUM CL:FIXNUM) CL:FIXNUM)
  TOKENIZER-BYTE-ARRAY-READ-SEQUENCE))
(CL:DEFUN TOKENIZER-BYTE-ARRAY-READ-SEQUENCE (BUFFER STREAM START END)
  (CL:DECLARE (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:LET*
   ((STATE (%TOKENIZER-STATE STREAM)) (CURSOR (%CURSOR STATE))
    (INTERNAL-END (%END STATE)) (INTERNAL-SIZE (%BUFFER-SIZE STATE))
    (ECHOSTREAM (%ECHO-STREAM STREAM)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR INTERNAL-END INTERNAL-SIZE))
   (CL:WHEN (CL:= CURSOR INTERNAL-END)
    (CL:WHEN (READ-INTO-TOKENIZER-BUFFER STREAM STATE -1)
     (CL:RETURN-FROM TOKENIZER-BYTE-ARRAY-READ-SEQUENCE 0))
    (CL:SETQ CURSOR (%CURSOR STATE))
    (CL:SETQ INTERNAL-END (%END STATE))
    (CL:WHEN (CL:= CURSOR INTERNAL-SIZE) (CL:SETQ CURSOR 0)))
   (CL:LET*
    ((READ-SIZE (MIN (CL:- END START) (CL:- INTERNAL-END CURSOR)))
     (ORIGINAL-START START) (INTERNAL-BUFFER (%BUFFER STATE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM READ-SIZE ORIGINAL-START))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 READ-SIZE)
      (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
      (CL:SETQ I ITER-000) (CL:SETQ I I)
      (CL:LET
       ((BUFFER BUFFER)
        (CH
         (CL:LET ((BUFFER INTERNAL-BUFFER) (POSITION CURSOR))
          (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
           (CL:THE CL:FIXNUM POSITION))))
        (POSITION START))
       (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
         (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH)))
      (CL:SETQ START (CL:1+ START)) (CL:SETQ CURSOR (CL:1+ CURSOR))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    (CL:WHEN (CL:NOT (CL:EQ ECHOSTREAM NULL))
     (BYTE-ARRAY-WRITE-SEQUENCE BUFFER (%NATIVE-STREAM ECHOSTREAM)
      ORIGINAL-START END))
    (CL:SETF (%CURSOR STATE) CURSOR)
    (CL:RETURN-FROM TOKENIZER-BYTE-ARRAY-READ-SEQUENCE READ-SIZE))))

;;; (DEFUN (BYTE-ARRAY-READ-SEQUENCE INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:FIXNUM CL:FIXNUM) CL:FIXNUM)
  BYTE-ARRAY-READ-SEQUENCE))
(CL:DEFUN BYTE-ARRAY-READ-SEQUENCE (BUFFER STREAM START END)
  "Read from `stream' filling `buffer' between `start' and `end' (depending
on how many characters are available).
Return the actual end pointer to the input read into `buffer'.  EOF is
indicated by the return value being equal to start."
  (CL:DECLARE (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:IF (CL:NOT (CL:EQ (%TOKENIZER-STATE STREAM) NULL))
   (CL:RETURN-FROM BYTE-ARRAY-READ-SEQUENCE
    (TOKENIZER-BYTE-ARRAY-READ-SEQUENCE BUFFER STREAM START END))
   (CL:RETURN-FROM BYTE-ARRAY-READ-SEQUENCE
    (NATIVE-BYTE-ARRAY-READ-SEQUENCE BUFFER (%NATIVE-STREAM STREAM)
     START END))))

;;; (DEFUN NATIVE-BYTE-ARRAY-WRITE-SEQUENCE ...)

(CL:DEFUN NATIVE-BYTE-ARRAY-WRITE-SEQUENCE (BUFFER STREAM START END)
  (CL:DECLARE (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (%%write-sequence buffer stream :start start :end end)
  :VOID)

;;; (DEFUN BYTE-ARRAY-WRITE-SEQUENCE ...)

(CL:DEFUN BYTE-ARRAY-WRITE-SEQUENCE (BUFFER STREAM START END)
  "Write from `buffer' to `stream', using data in the buffer starting at position
`start' stopping just before `end'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (NATIVE-BYTE-ARRAY-WRITE-SEQUENCE BUFFER STREAM START END)
  :VOID)

;;; (DEFGLOBAL *TOKENIZER-INITIAL-BUFFER-SIZE* ...)

(CL:DEFVAR *TOKENIZER-INITIAL-BUFFER-SIZE* 2048)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *TOKENIZER-INITIAL-BUFFER-SIZE*))

;;; (DEFUN ENSURE-TOKENIZER-BUFFER-SIZE ...)

(CL:DEFUN ENSURE-TOKENIZER-BUFFER-SIZE (STATE CURRENTTOKENSTART REQUIREDSPACE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CURRENTTOKENSTART REQUIREDSPACE))
  #+MCL
  (CL:CHECK-TYPE CURRENTTOKENSTART CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE REQUIREDSPACE CL:FIXNUM)
  (CL:LET*
   ((SIZE (%BUFFER-SIZE STATE)) (NEWSIZE SIZE)
    (END
     (CL:THE CL:FIXNUM (CL:REM (CL:THE CL:FIXNUM (%END STATE)) SIZE)))
    (FREESPACE
     (CL:IF (CL:= CURRENTTOKENSTART -1) SIZE
      (CL:IF (CL:<= END CURRENTTOKENSTART) (CL:- CURRENTTOKENSTART END)
       (CL:+ CURRENTTOKENSTART (CL:- SIZE END)))))
    (BUFFER (%BUFFER STATE)) (NEWBUFFER BUFFER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE NEWSIZE END FREESPACE))
   (CL:LOOP WHILE (CL:< FREESPACE REQUIREDSPACE) DO
    (CL:SETQ FREESPACE (CL:+ FREESPACE NEWSIZE))
    (CL:SETQ NEWSIZE (CL:* NEWSIZE 2)))
   (CL:WHEN (CL:> NEWSIZE SIZE)
    (CL:SETQ NEWBUFFER (CL:MAKE-STRING NEWSIZE))
    (CL:COND
     ((CL:< CURRENTTOKENSTART 0) (CL:SETF (%CURSOR STATE) 0)
      (CL:SETF (%END STATE) NEWSIZE))
     ((CL:> END CURRENTTOKENSTART)
      (CL:LET*
       ((I NULL-INTEGER) (ITER-000 CURRENTTOKENSTART)
        (UPPER-BOUND-000 (CL:1- END)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
        (CL:SETQ I ITER-000)
        (CL:LET
         ((BUFFER NEWBUFFER)
          (CH
           (CL:LET ((BUFFER BUFFER) (POSITION I))
            (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
            (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
             (CL:THE CL:FIXNUM POSITION))))
          (POSITION I))
         (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
           (CL:THE CL:FIXNUM POSITION))
          (CL:THE CL:CHARACTER CH)))
        (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
     (CL:T
      (CL:LET*
       ((I NULL-INTEGER) (ITER-001 CURRENTTOKENSTART)
        (UPPER-BOUND-001 (CL:1- SIZE)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
       (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
        (CL:SETQ I ITER-001)
        (CL:LET
         ((BUFFER NEWBUFFER)
          (CH
           (CL:LET ((BUFFER BUFFER) (POSITION I))
            (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
            (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
             (CL:THE CL:FIXNUM POSITION))))
          (POSITION I))
         (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
           (CL:THE CL:FIXNUM POSITION))
          (CL:THE CL:CHARACTER CH)))
        (CL:SETQ ITER-001 (CL:1+ ITER-001))))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-002 (CL:1- END))
        (J NULL-INTEGER) (ITER-003 SIZE))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-002 J ITER-003))
       (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-002) DO
        (CL:SETQ I ITER-002) (CL:SETQ J ITER-003)
        (CL:LET
         ((BUFFER NEWBUFFER)
          (CH
           (CL:LET ((BUFFER BUFFER) (POSITION I))
            (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
            (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
             (CL:THE CL:FIXNUM POSITION))))
          (POSITION J))
         (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
           (CL:THE CL:FIXNUM POSITION))
          (CL:THE CL:CHARACTER CH)))
        (CL:SETQ ITER-002 (CL:1+ ITER-002))
        (CL:SETQ ITER-003 (CL:1+ ITER-003))))
      (CL:SETF (%END STATE) (CL:+ SIZE END))
      (CL:SETF (%CURSOR STATE) (%END STATE))))
    (CL:SETF (%BUFFER STATE) NEWBUFFER)
    (CL:SETF (%BUFFER-SIZE STATE) NEWSIZE)))
  :VOID)

;;; (DEFUN (READ-INTO-TOKENIZER-BUFFER BOOLEAN) ...)

(CL:DEFUN READ-INTO-TOKENIZER-BUFFER (STREAM STATE CURRENTTOKENSTART)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CURRENTTOKENSTART))
  #+MCL
  (CL:CHECK-TYPE CURRENTTOKENSTART CL:FIXNUM)
  (CL:LET*
   ((REQUIREDSPACE
     (CL:IF (CL:< (%BUFFER-SIZE STATE) *TOKENIZER-INITIAL-BUFFER-SIZE*)
      1
      (CL:LET ((ARG *TOKENIZER-INITIAL-BUFFER-SIZE*) (COUNT 1))
       (CL:DECLARE (CL:TYPE CL:FIXNUM ARG COUNT))
       (CL:THE CL:FIXNUM
        (CL:ASH ARG (CL:THE CL:FIXNUM (CL:- COUNT)))))))
    (INPUTCHAR NULL-CHARACTER) (INPUTLINE STELLA::NULL-STRING)
    (EOF? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM REQUIREDSPACE)
    (CL:TYPE CL:SIMPLE-STRING INPUTLINE))
   (CL:WHEN (CL:NOT (CL:EQ (%BUFFERING-SCHEME STREAM) KWD-READ-BLOCK))
    (CL:UNWIND-PROTECT
     (CL:PROGN (CL:SETF (%TOKENIZER-STATE STREAM) NULL)
      (CL:LET* ((TEST-VALUE-000 (%BUFFERING-SCHEME STREAM)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 KWD-READ-LINE)
         (CL:SETQ INPUTLINE (NATIVE-READ-LINE STREAM))
         (CL:WHEN (CL:EQ INPUTLINE STELLA::NULL-STRING)
          (CL:SETQ INPUTLINE "") (CL:SETQ EOF? CL:T))
         (CL:SETQ INPUTLINE (STRING-CONCATENATE INPUTLINE EOL-STRING)))
        ((CL:EQ TEST-VALUE-000 KWD-READ-CHARACTER)
         (CL:MULTIPLE-VALUE-SETQ (INPUTCHAR EOF?)
          (READ-CHARACTER STREAM))
         (CL:IF EOF? (CL:SETQ INPUTLINE "")
          (CL:SETQ INPUTLINE (MAKE-STRING 1 INPUTCHAR))))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
           TEST-VALUE-000 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
     (CL:SETF (%TOKENIZER-STATE STREAM) STATE))
    (CL:SETQ REQUIREDSPACE (CL:THE CL:FIXNUM (CL:LENGTH INPUTLINE))))
   (ENSURE-TOKENIZER-BUFFER-SIZE STATE CURRENTTOKENSTART REQUIREDSPACE)
   (CL:LET*
    ((NATIVESTREAM (%NATIVE-STREAM STREAM)) (BUFFER (%BUFFER STATE))
     (SIZE (%BUFFER-SIZE STATE)) (END (%END STATE)) (START -1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE END START))
    (CL:WHEN (CL:= END SIZE) (CL:SETQ END 0))
    (CL:COND
     ((CL:< CURRENTTOKENSTART 0) (CL:SETQ START 0) (CL:SETQ END SIZE)
      (CL:SETF (%CURSOR STATE) 0))
     ((CL:<= END CURRENTTOKENSTART) (CL:SETQ START END)
      (CL:SETQ END CURRENTTOKENSTART))
     ((CL:> END CURRENTTOKENSTART) (CL:SETQ START END)
      (CL:SETQ END SIZE)))
    (CL:COND
     ((CL:NOT (CL:EQ INPUTLINE STELLA::NULL-STRING))
      (CL:SETQ END START)
      (CL:LET*
       ((CH NULL-CHARACTER) (VECTOR-000 INPUTLINE) (INDEX-000 0)
        (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ CH
         (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))
        (CL:LET ((BUFFER BUFFER) (CH CH) (POSITION END))
         (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
           (CL:THE CL:FIXNUM POSITION))
          (CL:THE CL:CHARACTER CH)))
        (CL:SETQ END (CL:1+ END))
        (CL:WHEN (CL:= END SIZE) (CL:SETQ END 0))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
     (CL:T
      (CL:SETQ END
       (NATIVE-BYTE-ARRAY-READ-SEQUENCE BUFFER NATIVESTREAM START
        END))))
    (CL:SETF (%END STATE) END)
    (CL:RETURN-FROM READ-INTO-TOKENIZER-BUFFER
     (CL:OR EOF? (CL:= START END))))))

;;; (DEFUN (READ-CHARACTER-FROM-TOKENIZER-BUFFER CHARACTER BOOLEAN) ...)

(CL:DEFUN READ-CHARACTER-FROM-TOKENIZER-BUFFER (STREAM)
  (CL:LET*
   ((STATE (%TOKENIZER-STATE STREAM)) (CURSOR (%CURSOR STATE))
    (END (%END STATE)) (SIZE (%BUFFER-SIZE STATE))
    (ECHOSTREAM (%ECHO-STREAM STREAM)) (CH NULL-CHARACTER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR END SIZE))
   (CL:WHEN (CL:= CURSOR END)
    (CL:WHEN (READ-INTO-TOKENIZER-BUFFER STREAM STATE -1)
     (CL:RETURN-FROM READ-CHARACTER-FROM-TOKENIZER-BUFFER
      (CL:VALUES NULL-CHARACTER CL:T)))
    (CL:SETQ CURSOR (%CURSOR STATE))
    (CL:WHEN (CL:= CURSOR SIZE) (CL:SETQ CURSOR 0)))
   (CL:SETQ CH
    (CL:LET ((BUFFER (%BUFFER STATE)) (POSITION CURSOR))
     (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
     (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
      (CL:THE CL:FIXNUM POSITION))))
   (CL:WHEN (CL:NOT (CL:EQ ECHOSTREAM NULL))
    (%%PRINT-STREAM (%NATIVE-STREAM ECHOSTREAM) CH))
   (CL:SETF (%CURSOR STATE) (CL:1+ CURSOR))
   (CL:RETURN-FROM READ-CHARACTER-FROM-TOKENIZER-BUFFER
    (CL:VALUES CH CL:NIL))))

;;; (DEFUN UNREAD-CHARACTER-FROM-TOKENIZER-BUFFER ...)

(CL:DEFUN UNREAD-CHARACTER-FROM-TOKENIZER-BUFFER (CHAR STREAM)
  (CL:LET* ((STATE (%TOKENIZER-STATE STREAM)) (CURSOR (%CURSOR STATE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
   (CL:IF (CL:= CURSOR 0) (CL:SETQ CURSOR (CL:1- (%BUFFER-SIZE STATE)))
    (CL:SETQ CURSOR (CL:1- CURSOR)))
   (CL:WHEN
    (CL:NOT
     (CL:EQL CHAR
      (CL:LET ((BUFFER (%BUFFER STATE)) (POSITION CURSOR))
       (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
        (CL:THE CL:FIXNUM POSITION)))))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Unread character `"
      CHAR "' does not match last character read")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (CL:SETF (%CURSOR STATE) CURSOR))
  :VOID)

;;; (DEFUN (READ-LINE-FROM-TOKENIZER-BUFFER STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  READ-LINE-FROM-TOKENIZER-BUFFER))
(CL:DEFUN READ-LINE-FROM-TOKENIZER-BUFFER (STREAM)
  (CL:LET*
   ((BUFFER (NEW-OUTPUT-STRING-STREAM)) (LINE STELLA::NULL-STRING)
    (CH NULL-CHARACTER) (CH2 NULL-CHARACTER) (EOF? CL:NIL)
    (NEWLINE
     (CL:LET ((SELF EOL-STRING) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
   (CL:LOOP
    (CL:TAGBODY
     (CL:MULTIPLE-VALUE-SETQ (CH EOF?)
      (READ-CHARACTER-FROM-TOKENIZER-BUFFER STREAM))
     (CL:WHEN EOF? (CL:SETQ LINE (THE-STRING-READER BUFFER))
      (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LENGTH LINE)) 0)
       (CL:SETQ LINE STELLA::NULL-STRING) (CL:SETQ EOF? CL:NIL))
      (CL:RETURN))
     (CL:WHEN (CL:EQL CH NEWLINE)
      (CL:WHEN (CL:= (CL:THE CL:FIXNUM (CL:LENGTH EOL-STRING)) 2)
       (CL:MULTIPLE-VALUE-SETQ (CH2 EOF?)
        (READ-CHARACTER-FROM-TOKENIZER-BUFFER STREAM))
       (CL:WHEN EOF? (CL:SETQ LINE (THE-STRING-READER BUFFER))
        (CL:IF (CL:= (CL:THE CL:FIXNUM (CL:LENGTH LINE)) 0)
         (CL:SETQ LINE STELLA::NULL-STRING) (CL:SETQ EOF? CL:NIL))
        (CL:RETURN))
       (CL:WHEN
        (CL:NOT
         (CL:EQL CH2
          (CL:LET ((SELF EOL-STRING) (POSITION 1))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION)))))
        (%%PRINT-STREAM (%NATIVE-STREAM BUFFER) CH CH2)
        (CL:GO :CONTINUE)))
      (CL:SETQ LINE (THE-STRING-READER BUFFER)) (CL:RETURN))
     (%%PRINT-STREAM (%NATIVE-STREAM BUFFER) CH) :CONTINUE))
   (CL:RETURN-FROM READ-LINE-FROM-TOKENIZER-BUFFER LINE)))

;;; (DEFCLASS TOKENIZER-TOKEN ...)

(CL:DEFCLASS TOKENIZER-TOKEN (STANDARD-OBJECT)
  ((TYPE :ALLOCATION :INSTANCE :ACCESSOR %TYPE)
   (CONTENT :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %CONTENT)
   (NEXT :ALLOCATION :INSTANCE :ACCESSOR %NEXT)))

(CL:DEFUN NEW-TOKENIZER-TOKEN ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TOKENIZER-TOKEN)))
   (CL:SETF (%NEXT SELF) NULL)
   (CL:SETF (%CONTENT SELF) STELLA::NULL-STRING)
   (CL:SETF (%TYPE SELF) NULL)
   (CL:RETURN-FROM NEW-TOKENIZER-TOKEN SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TOKENIZER-TOKEN))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-READ-STELLA-TOKENIZER-TOKEN))

(CL:DEFUN ACCESS-TOKENIZER-TOKEN-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-READ-STELLA-TYPE)
    (CL:IF SETVALUE? (CL:SETF (%TYPE SELF) VALUE)
     (CL:SETQ VALUE (%TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-CONTENT)
    (CL:IF SETVALUE? (CL:SETF (%CONTENT SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%CONTENT SELF)))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-NEXT)
    (CL:IF SETVALUE? (CL:SETF (%NEXT SELF) VALUE)
     (CL:SETQ VALUE (%NEXT SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-TOKENIZER-TOKEN-SLOT-VALUE VALUE))

;;; (DEFCLASS TOKENIZER-STREAM-STATE ...)

(CL:DEFCLASS TOKENIZER-STREAM-STATE (STANDARD-OBJECT)
  ((BUFFER :ALLOCATION :INSTANCE :ACCESSOR %BUFFER)
   (BUFFER-SIZE :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %BUFFER-SIZE)
   (CURSOR :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %CURSOR)
   (END :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %END)
   (STATE :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %STATE)
   (TABLE :ALLOCATION :INSTANCE :ACCESSOR %TABLE)
   (STATE-DICTIONARY :ALLOCATION :INSTANCE :ACCESSOR %STATE-DICTIONARY)
   (TOKEN-LIST :ALLOCATION :INSTANCE :ACCESSOR %TOKEN-LIST)))

(CL:DEFUN NEW-TOKENIZER-STREAM-STATE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TOKENIZER-STREAM-STATE)))
   (CL:SETF (%TOKEN-LIST SELF) NULL)
   (CL:SETF (%STATE-DICTIONARY SELF) NULL) (CL:SETF (%TABLE SELF) NULL)
   (CL:SETF (%STATE SELF) 1)
   (CL:SETF (%END SELF) *TOKENIZER-INITIAL-BUFFER-SIZE*)
   (CL:SETF (%CURSOR SELF) *TOKENIZER-INITIAL-BUFFER-SIZE*)
   (CL:SETF (%BUFFER-SIZE SELF) *TOKENIZER-INITIAL-BUFFER-SIZE*)
   (CL:SETF (%BUFFER SELF)
    (CL:MAKE-STRING *TOKENIZER-INITIAL-BUFFER-SIZE*))
   (CL:RETURN-FROM NEW-TOKENIZER-STREAM-STATE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TOKENIZER-STREAM-STATE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-READ-STELLA-TOKENIZER-STREAM-STATE))

(CL:DEFUN ACCESS-TOKENIZER-STREAM-STATE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-READ-STELLA-BUFFER-SIZE)
    (CL:IF SETVALUE?
     (CL:SETF (%BUFFER-SIZE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%BUFFER-SIZE SELF)))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%CURSOR SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%CURSOR SELF)))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-END)
    (CL:IF SETVALUE? (CL:SETF (%END SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%END SELF)))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-STATE)
    (CL:IF SETVALUE? (CL:SETF (%STATE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%STATE SELF)))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%TABLE SELF) VALUE)
     (CL:SETQ VALUE (%TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-STATE-DICTIONARY)
    (CL:IF SETVALUE? (CL:SETF (%STATE-DICTIONARY SELF) VALUE)
     (CL:SETQ VALUE (%STATE-DICTIONARY SELF))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-TOKEN-LIST)
    (CL:IF SETVALUE? (CL:SETF (%TOKEN-LIST SELF) VALUE)
     (CL:SETQ VALUE (%TOKEN-LIST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-TOKENIZER-STREAM-STATE-SLOT-VALUE VALUE))

;;; (DEFMETHOD (BUFFERED-INPUT-LENGTH INTEGER) ...)

(CL:DEFMETHOD BUFFERED-INPUT-LENGTH ((STATE TOKENIZER-STREAM-STATE))
  (CL:LET* ((CURSOR (%CURSOR STATE)) (END (%END STATE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR END))
   (CL:IF (CL:>= END CURSOR)
    (CL:RETURN-FROM BUFFERED-INPUT-LENGTH (CL:- END CURSOR))
    (CL:RETURN-FROM BUFFERED-INPUT-LENGTH
     (CL:+ (CL:- (%BUFFER-SIZE STATE) CURSOR) END)))))

;;; (DEFMETHOD CLEAR ...)

(CL:DEFMETHOD CLEAR ((STATE TOKENIZER-STREAM-STATE))
  (CL:SETF (%CURSOR STATE) 0)
  (CL:SETF (%END STATE) 0)
  :VOID)

;;; (DEFMETHOD RESET ...)

(CL:DEFMETHOD RESET ((STATE TOKENIZER-STREAM-STATE))
  (CL:SETF (%STATE STATE) 1)
  (CL:SETF (%STATE-DICTIONARY STATE) NULL)
  :VOID)

;;; (DEFMETHOD (GET-SAVED-STATE INTEGER) ...)

(CL:DEFMETHOD GET-SAVED-STATE ((STATE-OBJECT TOKENIZER-STREAM-STATE) TABLE)
  (CL:COND
   ((CL:EQ (%TABLE STATE-OBJECT) NULL)
    (CL:SETF (%TABLE STATE-OBJECT) TABLE)
    (CL:RETURN-FROM GET-SAVED-STATE (%STATE STATE-OBJECT)))
   ((CL:EQ (%TABLE STATE-OBJECT) TABLE)
    (CL:RETURN-FROM GET-SAVED-STATE (%STATE STATE-OBJECT)))
   (CL:T
    (CL:WHEN (CL:EQ (%STATE-DICTIONARY STATE-OBJECT) NULL)
     (CL:SETF (%STATE-DICTIONARY STATE-OBJECT) (NEW-KEY-VALUE-LIST)))
    (INSERT-AT (%STATE-DICTIONARY STATE-OBJECT) (%TABLE STATE-OBJECT)
     (WRAP-INTEGER (%STATE STATE-OBJECT)))
    (CL:LET*
     ((SAVED-STATE (LOOKUP (%STATE-DICTIONARY STATE-OBJECT) TABLE)))
     (CL:IF (CL:NOT (CL:EQ SAVED-STATE NULL))
      (CL:RETURN-FROM GET-SAVED-STATE (%WRAPPER-VALUE SAVED-STATE))
      (CL:RETURN-FROM GET-SAVED-STATE 1))))))

;;; (DEFSPECIAL *WITHTOKENIZERINPUTTYPE* ...)

(CL:DEFVAR *WITHTOKENIZERINPUTTYPE* NULL)

;;; (DEFMACRO WITH-TOKENIZER ...)

(CL:DEFUN WITH-TOKENIZER (TABLE INPUT BODY)
  (CL:LET* ((INPUTTREE NULL) (INPUTTYPE NULL))
   (CL:MULTIPLE-VALUE-SETQ (INPUTTREE INPUTTYPE) (WALK-A-TREE INPUT))
   (CL:WHEN
    (CL:NOT
     (CL:OR (SUB-TYPE-SPEC-OF? INPUTTYPE SGT-READ-STELLA-INPUT-STREAM)
      (SUB-TYPE-SPEC-OF? INPUTTYPE SGT-READ-STELLA-STRING)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
       " with-tokenizer: Can't handle input of type `"
       (DE-UGLIFY-PARSE-TREE INPUTTYPE) "'." EOL)))
    (CL:RETURN-FROM WITH-TOKENIZER
     (WALK-DONT-CALL-ME-TREE BODY SGT-READ-STELLA-VOID)))
   (CL:LET*
    ((STRING?
      (CL:OR (SUB-TYPE-SPEC-OF? INPUTTYPE SGT-READ-STELLA-STRING)
       (SUB-TYPE-SPEC-OF? INPUTTYPE SGT-READ-STELLA-MUTABLE-STRING)))
     (EXPANSION
      (LIST* SYM-READ-STELLA-LET
       (LIST* (LIST* SYM-READ-STELLA-TOK_TABLE_ TABLE NIL)
        (LIST* SYM-READ-STELLA-TOK_TRANSITIONS_
         (LIST* SYM-READ-STELLA-TRANSITIONS SYM-READ-STELLA-TOK_TABLE_
          NIL)
         NIL)
        (LIST* SYM-READ-STELLA-TOK_STATENAMES_
         (LIST* SYM-READ-STELLA-THE-ARRAY
          (LIST* SYM-READ-STELLA-STATE-NAMES SYM-READ-STELLA-TOK_TABLE_
           NIL)
          NIL)
         NIL)
        (LIST* SYM-READ-STELLA-TOK_TOKENSTART_ (WRAP-INTEGER -1) NIL)
        (LIST* SYM-READ-STELLA-TOK_ENDOFTOKENS?_ SYM-READ-STELLA-FALSE
         NIL)
        (CONCATENATE
         (CL:IF STRING?
          (LIST*
           (LIST* SYM-READ-STELLA-TOK_STREAMSTATE_
            SYM-READ-STELLA-TOKENIZER-STREAM-STATE SYM-READ-STELLA-NULL
            NIL)
           (LIST* SYM-READ-STELLA-TOK_BUFFER_
            (LIST* SYM-READ-STELLA-STRING-TO-TOKENIZER-BYTE-ARRAY INPUT
             NIL)
            NIL)
           (LIST* SYM-READ-STELLA-TOK_STATE_ (WRAP-INTEGER 1) NIL)
           (LIST* SYM-READ-STELLA-TOK_NEXTSTATE_
            SYM-READ-STELLA-TOK_STATE_ NIL)
           (LIST* SYM-READ-STELLA-TOK_CURSOR_ (WRAP-INTEGER 0) NIL)
           (LIST* SYM-READ-STELLA-TOK_SIZE_
            (LIST* SYM-READ-STELLA-LENGTH INPUT NIL) NIL)
           (LIST* SYM-READ-STELLA-TOK_END_ SYM-READ-STELLA-TOK_SIZE_
            NIL)
           NIL)
          (LIST*
           (LIST* SYM-READ-STELLA-TOK_INPUTSTREAM_
            (SYS-TREE INPUTTREE INPUTTYPE) NIL)
           (LIST* SYM-READ-STELLA-TOK_ECHOSTREAM_
            (LIST* SYM-READ-STELLA-ECHO-STREAM
             SYM-READ-STELLA-TOK_INPUTSTREAM_ NIL)
            NIL)
           (LIST* SYM-READ-STELLA-TOK_STREAMSTATE_
            (LIST* SYM-READ-STELLA-CHOOSE
             (LIST* SYM-READ-STELLA-NULL?
              (LIST* SYM-READ-STELLA-TOKENIZER-STATE
               SYM-READ-STELLA-TOK_INPUTSTREAM_ NIL)
              NIL)
             (LIST* SYM-READ-STELLA-SETF
              (LIST* SYM-READ-STELLA-TOKENIZER-STATE
               SYM-READ-STELLA-TOK_INPUTSTREAM_ NIL)
              (LIST* SYM-READ-STELLA-NEW
               SYM-READ-STELLA-TOKENIZER-STREAM-STATE NIL)
              NIL)
             (LIST* SYM-READ-STELLA-TOKENIZER-STATE
              SYM-READ-STELLA-TOK_INPUTSTREAM_ NIL)
             NIL)
            NIL)
           (LIST* SYM-READ-STELLA-TOK_BUFFER_
            (LIST* SYM-READ-STELLA-BUFFER
             SYM-READ-STELLA-TOK_STREAMSTATE_ NIL)
            NIL)
           (LIST* SYM-READ-STELLA-TOK_SIZE_
            (LIST* SYM-READ-STELLA-BUFFER-SIZE
             SYM-READ-STELLA-TOK_STREAMSTATE_ NIL)
            NIL)
           (LIST* SYM-READ-STELLA-TOK_STATE_
            (LIST* SYM-READ-STELLA-GET-SAVED-STATE
             SYM-READ-STELLA-TOK_STREAMSTATE_
             SYM-READ-STELLA-TOK_TABLE_ NIL)
            NIL)
           (LIST* SYM-READ-STELLA-TOK_NEXTSTATE_
            SYM-READ-STELLA-TOK_STATE_ NIL)
           (LIST* SYM-READ-STELLA-TOK_CURSOR_
            (LIST* SYM-READ-STELLA-CURSOR
             SYM-READ-STELLA-TOK_STREAMSTATE_ NIL)
            NIL)
           (LIST* SYM-READ-STELLA-TOK_END_
            (LIST* SYM-READ-STELLA-END SYM-READ-STELLA-TOK_STREAMSTATE_
             NIL)
            NIL)
           (LIST* SYM-READ-STELLA-TOK_CHECKPOINT_
            (LIST* SYM-READ-STELLA-CHOOSE
             (LIST* SYM-READ-STELLA-<= SYM-READ-STELLA-TOK_CURSOR_
              SYM-READ-STELLA-TOK_END_ NIL)
             SYM-READ-STELLA-TOK_END_ SYM-READ-STELLA-TOK_SIZE_ NIL)
            NIL)
           NIL))
         NIL))
       (LIST* SYM-READ-STELLA-IGNORE SYM-READ-STELLA-TOK_STATENAMES_
        SYM-READ-STELLA-TOK_ENDOFTOKENS?_ NIL)
       (CONCATENATE
        (CL:IF STRING?
         (CONS
          (LIST* SYM-READ-STELLA-IGNORE
           SYM-READ-STELLA-TOK_STREAMSTATE_ NIL)
          NIL)
         NIL)
        (CONCATENATE BODY NIL)))))
    (CL:LET* ((*WITHTOKENIZERINPUTTYPE* INPUTTYPE))
     (CL:DECLARE (CL:SPECIAL *WITHTOKENIZERINPUTTYPE*))
     (CL:RETURN-FROM WITH-TOKENIZER
      (WALK-A-TREE (COPY-CONS-TREE EXPANSION)))))))

;;; (DEFUN (WITH-TOKENIZER-STRING-INPUT? BOOLEAN) ...)

(CL:DEFUN WITH-TOKENIZER-STRING-INPUT? ()
  (CL:RETURN-FROM WITH-TOKENIZER-STRING-INPUT?
   (CL:EQ *WITHTOKENIZERINPUTTYPE* SGT-READ-STELLA-STRING)))

;;; (DEFUN (INSIDE-WITH-TOKENIZER? BOOLEAN) ...)

(CL:DEFUN INSIDE-WITH-TOKENIZER? ()
  (CL:RETURN-FROM INSIDE-WITH-TOKENIZER?
   (CL:NOT (CL:EQ *WITHTOKENIZERINPUTTYPE* NULL))))

;;; (DEFMACRO END-OF-TOKENS? ...)

(CL:DEFUN END-OF-TOKENS? ()
  (CL:WHEN (CL:NOT (INSIDE-WITH-TOKENIZER?))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
      " Encountered `end-of-tokens?' outside of `with-tokenizer' macro.."
      EOL)))
   (CL:RETURN-FROM END-OF-TOKENS?
    (CONS SYM-READ-STELLA-END-OF-TOKENS? NIL)))
  (CL:RETURN-FROM END-OF-TOKENS? SYM-READ-STELLA-TOK_ENDOFTOKENS?_))

;;; (DEFMACRO GET-TOKEN-TEXT ...)

(CL:DEFUN GET-TOKEN-TEXT (OPTIONS)
  (CL:WHEN (CL:NOT (INSIDE-WITH-TOKENIZER?))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
      " Encountered `get-token-text' outside of `with-tokenizer' macro.."
      EOL)))
   (CL:RETURN-FROM GET-TOKEN-TEXT
    (CONS SYM-READ-STELLA-GET-TOKEN-TEXT NIL)))
  (CL:LET*
   ((UPCASE? (%%VALUE OPTIONS)) (START (%%VALUE (%%REST OPTIONS)))
    (END (%%VALUE (%%REST (%%REST OPTIONS)))))
   (CL:WHEN (CL:EQ UPCASE? SYM-READ-STELLA-FALSE)
    (CL:SETQ UPCASE? NULL))
   (CL:WHEN (EQL? START ZERO-WRAPPER) (CL:SETQ START NULL))
   (CL:RETURN-FROM GET-TOKEN-TEXT
    (LIST* SYM-READ-STELLA-GET-TOKEN-TEXT-INTERNAL
     SYM-READ-STELLA-TOK_BUFFER_
     (CL:IF (CL:EQ START NULL) SYM-READ-STELLA-TOK_TOKENSTART_
      (LIST* SYM-READ-STELLA-+ SYM-READ-STELLA-TOK_TOKENSTART_ START
       NIL))
     (CONS
      (CL:IF (CL:EQ END NULL) SYM-READ-STELLA-TOK_CURSOR_
       (CL:IF (INTEGER? END)
        (CL:IF (CL:< (%WRAPPER-VALUE END) 0)
         (LIST* SYM-READ-STELLA-+ SYM-READ-STELLA-TOK_CURSOR_ END NIL)
         (LIST* SYM-READ-STELLA-+ SYM-READ-STELLA-TOK_TOKENSTART_ END
          NIL))
        (LIST* SYM-READ-STELLA-CHOOSE
         (LIST* SYM-READ-STELLA-< END (CONS (WRAP-INTEGER 0) NIL))
         (LIST* SYM-READ-STELLA-+ SYM-READ-STELLA-TOK_CURSOR_ END NIL)
         (LIST* SYM-READ-STELLA-+ SYM-READ-STELLA-TOK_TOKENSTART_ END
          NIL)
         NIL)))
      (LIST* SYM-READ-STELLA-TOK_SIZE_
       (CL:IF (CL:NOT (CL:EQ UPCASE? NULL)) UPCASE?
        SYM-READ-STELLA-FALSE)
       NIL))))))

;;; (DEFUN (GET-TOKEN-TEXT-INTERNAL STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:T CL:FIXNUM CL:FIXNUM CL:FIXNUM CL:T)
   CL:SIMPLE-STRING)
  GET-TOKEN-TEXT-INTERNAL))
(CL:DEFUN GET-TOKEN-TEXT-INTERNAL (BUFFER START END SIZE UPCASE?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM START END SIZE))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (CL:COND ((CL:>= START SIZE) (CL:SETQ START (CL:- START SIZE)))
   ((CL:< START 0) (CL:SETQ START (CL:+ SIZE START))))
  (CL:COND ((CL:> END SIZE) (CL:SETQ END (CL:- END SIZE)))
   ((CL:< END 0) (CL:SETQ END (CL:+ SIZE END))))
  (CL:LET*
   ((LENGTH (CL:- END START)) (RESULT STELLA::NULL-STRING) (CURSOR 0)
    (AUXEND END))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH CURSOR AUXEND)
    (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:WHEN (CL:< LENGTH 0) (CL:SETQ LENGTH (CL:+ LENGTH SIZE))
    (CL:SETQ AUXEND SIZE))
   (CL:SETQ RESULT (MAKE-RAW-MUTABLE-STRING LENGTH))
   (CL:COND
    (UPCASE?
     (CL:LOOP
      (CL:LOOP WHILE (CL:< START AUXEND) DO
       (CL:LET
        ((SELF RESULT)
         (CH
          (CL:LET
           ((SELF *CHARACTER-UPCASE-TABLE*)
            (POSITION
             (CL:THE CL:FIXNUM
              (CL:CHAR-CODE
               (CL:LET ((BUFFER BUFFER) (POSITION START))
                (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
                (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
                 (CL:THE CL:FIXNUM POSITION)))))))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))))
         (POSITION CURSOR))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (SETF
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))
         (CL:THE CL:CHARACTER CH)))
       (CL:SETQ CURSOR (CL:1+ CURSOR)) (CL:SETQ START (CL:1+ START)))
      (CL:WHEN (CL:= AUXEND END) (CL:RETURN)) (CL:SETQ START 0)
      (CL:SETQ AUXEND END)))
    (CL:T
     (CL:LOOP
      (CL:LOOP WHILE (CL:< START AUXEND) DO
       (CL:LET
        ((SELF RESULT)
         (CH
          (CL:LET ((BUFFER BUFFER) (POSITION START))
           (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
            (CL:THE CL:FIXNUM POSITION))))
         (POSITION CURSOR))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (SETF
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))
         (CL:THE CL:CHARACTER CH)))
       (CL:SETQ CURSOR (CL:1+ CURSOR)) (CL:SETQ START (CL:1+ START)))
      (CL:WHEN (CL:= AUXEND END) (CL:RETURN)) (CL:SETQ START 0)
      (CL:SETQ AUXEND END))))
   (CL:RETURN-FROM GET-TOKEN-TEXT-INTERNAL
    (CL:LET ((S RESULT)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S)))))

;;; (DEFMACRO GET-TOKEN-TYPE ...)

(CL:DEFUN GET-TOKEN-TYPE ()
  (CL:WHEN (CL:NOT (INSIDE-WITH-TOKENIZER?))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
      " Encountered `get-token-type' outside of `with-tokenizer' macro.."
      EOL)))
   (CL:RETURN-FROM GET-TOKEN-TYPE
    (CONS SYM-READ-STELLA-GET-TOKEN-TYPE NIL)))
  (CL:RETURN-FROM GET-TOKEN-TYPE
   (LIST* SYM-READ-STELLA-NTH SYM-READ-STELLA-TOK_STATENAMES_
    SYM-READ-STELLA-TOK_STATE_ NIL)))

;;; (DEFMACRO SAVE-TOKENIZER-STREAM-STATE ...)

(CL:DEFUN SAVE-TOKENIZER-STREAM-STATE ()
  (CL:RETURN-FROM SAVE-TOKENIZER-STREAM-STATE
   (LIST* SYM-READ-STELLA-WHEN
    (LIST* SYM-READ-STELLA-DEFINED? SYM-READ-STELLA-TOK_STREAMSTATE_
     NIL)
    (LIST* SYM-READ-STELLA-SETF
     (LIST* SYM-READ-STELLA-CURSOR SYM-READ-STELLA-TOK_STREAMSTATE_
      NIL)
     SYM-READ-STELLA-TOK_CURSOR_ NIL)
    (LIST* SYM-READ-STELLA-SETF
     (LIST* SYM-READ-STELLA-TABLE SYM-READ-STELLA-TOK_STREAMSTATE_ NIL)
     SYM-READ-STELLA-TOK_TABLE_ NIL)
    (LIST* SYM-READ-STELLA-SETF
     (LIST* SYM-READ-STELLA-STATE SYM-READ-STELLA-TOK_STREAMSTATE_ NIL)
     SYM-READ-STELLA-TOK_STATE_ NIL)
    NIL)))

;;; (DEFMACRO GET-NEXT-TOKEN ...)

(CL:DEFUN GET-NEXT-TOKEN (OPTIONS)
  (CL:WHEN (CL:NOT (INSIDE-WITH-TOKENIZER?))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
      " Encountered `get-next-token' outside of `with-tokenizer' macro.."
      EOL)))
   (CL:RETURN-FROM GET-NEXT-TOKEN
    (CONS SYM-READ-STELLA-GET-NEXT-TOKEN NIL)))
  (CL:LET*
   ((SAVESTREAMSTATE? (%%VALUE OPTIONS))
    (SAVESTREAMSTATETREE
     (CONS (CONS SYM-READ-STELLA-SAVE-TOKENIZER-STREAM-STATE NIL)
      NIL)))
   (CL:COND
    ((CL:OR (CL:EQ SAVESTREAMSTATE? NULL)
      (CL:EQ SAVESTREAMSTATE? SYM-READ-STELLA-TRUE)))
    ((CL:EQ SAVESTREAMSTATE? SYM-READ-STELLA-FALSE)
     (CL:SETQ SAVESTREAMSTATETREE NIL))
    (CL:T
     (CL:SETQ SAVESTREAMSTATETREE
      (CONS
       (LIST* SYM-READ-STELLA-WHEN SAVESTREAMSTATE?
        (CONCATENATE SAVESTREAMSTATETREE NIL))
       NIL))))
   (CL:RETURN-FROM GET-NEXT-TOKEN
    (LIST* SYM-READ-STELLA-PROGN
     (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_TOKENSTART_
      (WRAP-INTEGER -1) NIL)
     (LIST* SYM-READ-STELLA-LOOP
      (CL:IF (WITH-TOKENIZER-STRING-INPUT?)
       (LIST* SYM-READ-STELLA-WHEN
        (LIST* SYM-READ-STELLA-= SYM-READ-STELLA-TOK_CURSOR_
         SYM-READ-STELLA-TOK_END_ NIL)
        (LIST* SYM-READ-STELLA-COND
         (LIST*
          (LIST* SYM-READ-STELLA-= SYM-READ-STELLA-TOK_NEXTSTATE_
           (WRAP-INTEGER -1) NIL)
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_ENDOFTOKENS?_
           SYM-READ-STELLA-TRUE NIL)
          NIL)
         (LIST*
          (LIST* SYM-READ-STELLA-NTH
           (LIST* SYM-READ-STELLA-LEGAL-EOF-STATES
            SYM-READ-STELLA-TOK_TABLE_ NIL)
           SYM-READ-STELLA-TOK_STATE_ NIL)
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_NEXTSTATE_
           (WRAP-INTEGER -1) NIL)
          (LIST* SYM-READ-STELLA-WHEN
           (LIST* SYM-READ-STELLA-= SYM-READ-STELLA-TOK_TOKENSTART_
            (WRAP-INTEGER -1) NIL)
           (LIST* SYM-READ-STELLA-SETQ
            SYM-READ-STELLA-TOK_ENDOFTOKENS?_ SYM-READ-STELLA-TRUE NIL)
           NIL)
          NIL)
         (LIST* SYM-READ-STELLA-OTHERWISE
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_STATE_
           (WRAP-INTEGER 0) NIL)
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_NEXTSTATE_
           (WRAP-INTEGER -1) NIL)
          NIL)
         NIL)
        (CONS SYM-READ-STELLA-BREAK NIL) NIL)
       (LIST* SYM-READ-STELLA-WHEN
        (LIST* SYM-READ-STELLA-= SYM-READ-STELLA-TOK_CURSOR_
         SYM-READ-STELLA-TOK_CHECKPOINT_ NIL)
        (LIST* SYM-READ-STELLA-COND
         (LIST*
          (LIST* SYM-READ-STELLA-= SYM-READ-STELLA-TOK_CURSOR_
           SYM-READ-STELLA-TOK_END_ NIL)
          (LIST* SYM-READ-STELLA-SETF
           (LIST* SYM-READ-STELLA-CURSOR
            SYM-READ-STELLA-TOK_STREAMSTATE_ NIL)
           SYM-READ-STELLA-TOK_CURSOR_ NIL)
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_ENDOFTOKENS?_
           (LIST* SYM-READ-STELLA-READ-INTO-TOKENIZER-BUFFER
            SYM-READ-STELLA-TOK_INPUTSTREAM_
            SYM-READ-STELLA-TOK_STREAMSTATE_
            SYM-READ-STELLA-TOK_TOKENSTART_ NIL)
           NIL)
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_BUFFER_
           (LIST* SYM-READ-STELLA-BUFFER
            SYM-READ-STELLA-TOK_STREAMSTATE_ NIL)
           NIL)
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_SIZE_
           (LIST* SYM-READ-STELLA-BUFFER-SIZE
            SYM-READ-STELLA-TOK_STREAMSTATE_ NIL)
           NIL)
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_CURSOR_
           (LIST* SYM-READ-STELLA-MOD
            (LIST* SYM-READ-STELLA-CURSOR
             SYM-READ-STELLA-TOK_STREAMSTATE_ NIL)
            SYM-READ-STELLA-TOK_SIZE_ NIL)
           NIL)
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_END_
           (LIST* SYM-READ-STELLA-END SYM-READ-STELLA-TOK_STREAMSTATE_
            NIL)
           NIL)
          (LIST* SYM-READ-STELLA-WHEN SYM-READ-STELLA-TOK_ENDOFTOKENS?_
           (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_CHECKPOINT_
            SYM-READ-STELLA-TOK_CURSOR_ NIL)
           (LIST* SYM-READ-STELLA-COND
            (CONS
             (LIST* SYM-READ-STELLA-= SYM-READ-STELLA-TOK_NEXTSTATE_
              (WRAP-INTEGER -1) NIL)
             NIL)
            (LIST*
             (LIST* SYM-READ-STELLA-NTH
              (LIST* SYM-READ-STELLA-LEGAL-EOF-STATES
               SYM-READ-STELLA-TOK_TABLE_ NIL)
              SYM-READ-STELLA-TOK_STATE_ NIL)
             (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_NEXTSTATE_
              (WRAP-INTEGER -1) NIL)
             (LIST* SYM-READ-STELLA-UNLESS
              (LIST* SYM-READ-STELLA-= SYM-READ-STELLA-TOK_TOKENSTART_
               (WRAP-INTEGER -1) NIL)
              (LIST* SYM-READ-STELLA-SETQ
               SYM-READ-STELLA-TOK_ENDOFTOKENS?_ SYM-READ-STELLA-FALSE
               NIL)
              NIL)
             NIL)
            (LIST* SYM-READ-STELLA-OTHERWISE
             (LIST* SYM-READ-STELLA-SETQ
              SYM-READ-STELLA-TOK_ENDOFTOKENS?_ SYM-READ-STELLA-FALSE
              NIL)
             (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_STATE_
              (WRAP-INTEGER 0) NIL)
             (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_NEXTSTATE_
              (WRAP-INTEGER -1) NIL)
             NIL)
            NIL)
           (CONS SYM-READ-STELLA-BREAK NIL) NIL)
          (LIST* SYM-READ-STELLA-IF
           (LIST* SYM-READ-STELLA->= SYM-READ-STELLA-TOK_CURSOR_
            SYM-READ-STELLA-TOK_END_ NIL)
           (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_CHECKPOINT_
            SYM-READ-STELLA-TOK_SIZE_ NIL)
           (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_CHECKPOINT_
            SYM-READ-STELLA-TOK_END_ NIL)
           NIL)
          NIL)
         (LIST* SYM-READ-STELLA-OTHERWISE
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_CHECKPOINT_
           SYM-READ-STELLA-TOK_END_ NIL)
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_CURSOR_
           (WRAP-INTEGER 0) NIL)
          NIL)
         NIL)
        NIL))
      (LIST*
       (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_NEXTSTATE_
        (LIST* SYM-READ-STELLA-CHARACTER-CODE
         (LIST* SYM-READ-STELLA-NTH SYM-READ-STELLA-TOK_TRANSITIONS_
          (LIST* SYM-READ-STELLA-LOGOR
           (LIST* SYM-READ-STELLA-SHIFT-LEFT SYM-READ-STELLA-TOK_STATE_
            (WRAP-INTEGER 8) NIL)
           (LIST* SYM-READ-STELLA-CHARACTER-CODE
            (LIST* SYM-READ-STELLA-BYTE-ARRAY-NTH
             SYM-READ-STELLA-TOK_BUFFER_ SYM-READ-STELLA-TOK_CURSOR_
             NIL)
            NIL)
           NIL)
          NIL)
         NIL)
        NIL)
       (LIST* SYM-READ-STELLA-COND
        (LIST*
         (LIST* SYM-READ-STELLA-=
          (LIST* SYM-READ-STELLA-LOGAND SYM-READ-STELLA-TOK_NEXTSTATE_
           (WRAP-INTEGER 128) NIL)
          (WRAP-INTEGER 0) NIL)
         (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_STATE_
          SYM-READ-STELLA-TOK_NEXTSTATE_ NIL)
         (LIST* SYM-READ-STELLA-++ SYM-READ-STELLA-TOK_CURSOR_ NIL)
         NIL)
        (LIST*
         (LIST* SYM-READ-STELLA-= SYM-READ-STELLA-TOK_TOKENSTART_
          (WRAP-INTEGER -1) NIL)
         (LIST* SYM-READ-STELLA-WHEN
          (LIST* SYM-READ-STELLA-=
           (LIST* SYM-READ-STELLA-LOGAND SYM-READ-STELLA-TOK_NEXTSTATE_
            (WRAP-INTEGER 64) NIL)
           (WRAP-INTEGER 0) NIL)
          (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_TOKENSTART_
           SYM-READ-STELLA-TOK_CURSOR_ NIL)
          NIL)
         (LIST* SYM-READ-STELLA-SETQ SYM-READ-STELLA-TOK_STATE_
          (LIST* SYM-READ-STELLA-LOGAND SYM-READ-STELLA-TOK_NEXTSTATE_
           (WRAP-INTEGER 63) NIL)
          NIL)
         (LIST* SYM-READ-STELLA-++ SYM-READ-STELLA-TOK_CURSOR_ NIL)
         NIL)
        (LIST* SYM-READ-STELLA-OTHERWISE
         (CONS SYM-READ-STELLA-BREAK NIL) NIL)
        NIL)
       (CONCATENATE
        (CL:IF (CL:NOT (WITH-TOKENIZER-STRING-INPUT?))
         (CONS
          (LIST* SYM-READ-STELLA-WHEN
           (LIST* SYM-READ-STELLA-DEFINED?
            SYM-READ-STELLA-TOK_ECHOSTREAM_ NIL)
           (LIST* SYM-READ-STELLA-PRINT-STREAM
            SYM-READ-STELLA-TOK_ECHOSTREAM_
            (LIST* SYM-READ-STELLA-BYTE-ARRAY-NTH
             SYM-READ-STELLA-TOK_BUFFER_
             (LIST* SYM-READ-STELLA-1- SYM-READ-STELLA-TOK_CURSOR_ NIL)
             NIL)
            NIL)
           NIL)
          NIL)
         NIL)
        NIL)))
     (CONCATENATE SAVESTREAMSTATETREE NIL)))))

;;; (DEFUN (UNESCAPE-TOKEN-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING CL:T CL:T) CL:SIMPLE-STRING)
  UNESCAPE-TOKEN-STRING))
(CL:DEFUN UNESCAPE-TOKEN-STRING (TOKEN ESCAPECHAR UPCASE?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOKEN))
  #+MCL
  (CL:CHECK-TYPE TOKEN CL:SIMPLE-STRING)
  (CL:LET*
   ((NOFESCAPES 0) (CURSOR 0) (CURSOR2 0)
    (SIZE (CL:THE CL:FIXNUM (CL:LENGTH TOKEN)))
    (RESULT STELLA::NULL-STRING) (ESCAPE? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFESCAPES CURSOR CURSOR2 SIZE)
    (CL:TYPE CL:SIMPLE-STRING RESULT))
   (CL:LOOP WHILE (CL:< CURSOR SIZE) DO
    (CL:WHEN
     (CL:EQL
      (CL:LET ((SELF TOKEN) (POSITION CURSOR))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION)))
      ESCAPECHAR)
     (CL:SETQ NOFESCAPES (CL:1+ NOFESCAPES))
     (CL:SETQ CURSOR (CL:1+ CURSOR)))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:WHEN (CL:= NOFESCAPES 0)
    (CL:RETURN-FROM UNESCAPE-TOKEN-STRING TOKEN))
   (CL:SETQ RESULT (MAKE-RAW-MUTABLE-STRING (CL:- SIZE NOFESCAPES)))
   (CL:SETQ CURSOR 0)
   (CL:LOOP WHILE (CL:< CURSOR SIZE) DO
    (CL:COND
     ((CL:AND
       (CL:EQL
        (CL:LET ((SELF TOKEN) (POSITION CURSOR))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION)))
        ESCAPECHAR)
       (CL:NOT ESCAPE?))
      (CL:SETQ ESCAPE? CL:T))
     ((CL:AND UPCASE? (CL:NOT ESCAPE?))
      (CL:LET
       ((SELF RESULT)
        (CH
         (CL:LET
          ((SELF *CHARACTER-UPCASE-TABLE*)
           (POSITION
            (CL:THE CL:FIXNUM
             (CL:CHAR-CODE
              (CL:LET ((SELF TOKEN) (POSITION CURSOR))
               (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
                (CL:TYPE CL:FIXNUM POSITION))
               (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                (CL:THE CL:FIXNUM POSITION)))))))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))
        (POSITION CURSOR2))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (SETF
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH)))
      (CL:SETQ CURSOR2 (CL:1+ CURSOR2)))
     (CL:T
      (CL:LET
       ((SELF RESULT)
        (CH
         (CL:LET ((SELF TOKEN) (POSITION CURSOR))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))
        (POSITION CURSOR2))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (SETF
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION))
        (CL:THE CL:CHARACTER CH)))
      (CL:SETQ ESCAPE? CL:NIL) (CL:SETQ CURSOR2 (CL:1+ CURSOR2))))
    (CL:SETQ CURSOR (CL:1+ CURSOR)))
   (CL:RETURN-FROM UNESCAPE-TOKEN-STRING
    (CL:LET ((S RESULT)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S)))))

;;; (DEFCLASS STREAM-TOKENIZER ...)

(CL:DEFCLASS STREAM-TOKENIZER (ITERATOR)
  ((STREAM :ALLOCATION :INSTANCE :ACCESSOR %STREAM)
   (TABLE :ALLOCATION :INSTANCE :ACCESSOR %TABLE))
  (:DOCUMENTATION
   "Iterator that generates tokens by tokenizing a `stream'
according to a particular tokenization `table'."))

(CL:DEFUN NEW-STREAM-TOKENIZER (STREAM TABLE)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STREAM-TOKENIZER)))
   (CL:SETF (%STREAM SELF) STREAM) (CL:SETF (%TABLE SELF) TABLE)
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:RETURN-FROM NEW-STREAM-TOKENIZER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STREAM-TOKENIZER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-READ-STELLA-STREAM-TOKENIZER))

(CL:DEFUN ACCESS-STREAM-TOKENIZER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-READ-STELLA-STREAM)
    (CL:IF SETVALUE? (CL:SETF (%STREAM SELF) VALUE)
     (CL:SETQ VALUE (%STREAM SELF))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%TABLE SELF) VALUE)
     (CL:SETQ VALUE (%TABLE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-STREAM-TOKENIZER-SLOT-VALUE VALUE))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF STREAM-TOKENIZER))
  (CL:LET*
   ((TOK_TABLE_ (%TABLE SELF))
    (TOK_TRANSITIONS_ (%TRANSITIONS TOK_TABLE_))
    (TOK_STATENAMES_ (%THE-ARRAY (%STATE-NAMES TOK_TABLE_)))
    (TOK_TOKENSTART_ -1) (TOK_ENDOFTOKENS?_ CL:NIL)
    (TOK_INPUTSTREAM_ (%STREAM SELF))
    (TOK_ECHOSTREAM_ (%ECHO-STREAM TOK_INPUTSTREAM_))
    (TOK_STREAMSTATE_
     (CL:IF (CL:EQ (%TOKENIZER-STATE TOK_INPUTSTREAM_) NULL)
      (CL:SETF (%TOKENIZER-STATE TOK_INPUTSTREAM_)
       (NEW-TOKENIZER-STREAM-STATE))
      (%TOKENIZER-STATE TOK_INPUTSTREAM_)))
    (TOK_BUFFER_ (%BUFFER TOK_STREAMSTATE_))
    (TOK_SIZE_ (%BUFFER-SIZE TOK_STREAMSTATE_))
    (TOK_STATE_ (GET-SAVED-STATE TOK_STREAMSTATE_ TOK_TABLE_))
    (TOK_NEXTSTATE_ TOK_STATE_)
    (TOK_CURSOR_ (%CURSOR TOK_STREAMSTATE_))
    (TOK_END_ (%END TOK_STREAMSTATE_))
    (TOK_CHECKPOINT_
     (CL:IF (CL:<= TOK_CURSOR_ TOK_END_) TOK_END_ TOK_SIZE_)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOK_TRANSITIONS_)
    (CL:TYPE CL:SIMPLE-VECTOR TOK_STATENAMES_)
    (CL:TYPE CL:FIXNUM TOK_TOKENSTART_ TOK_SIZE_ TOK_STATE_
     TOK_NEXTSTATE_ TOK_CURSOR_ TOK_END_ TOK_CHECKPOINT_))
   (CL:PROGN (CL:SETQ TOK_STATENAMES_ TOK_STATENAMES_)
    (CL:SETQ TOK_ENDOFTOKENS?_ TOK_ENDOFTOKENS?_))
   (CL:PROGN (CL:SETQ TOK_TOKENSTART_ -1)
    (CL:LOOP
     (CL:WHEN (CL:= TOK_CURSOR_ TOK_CHECKPOINT_)
      (CL:COND
       ((CL:= TOK_CURSOR_ TOK_END_)
        (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
        (CL:SETQ TOK_ENDOFTOKENS?_
         (READ-INTO-TOKENIZER-BUFFER TOK_INPUTSTREAM_ TOK_STREAMSTATE_
          TOK_TOKENSTART_))
        (CL:SETQ TOK_BUFFER_ (%BUFFER TOK_STREAMSTATE_))
        (CL:SETQ TOK_SIZE_ (%BUFFER-SIZE TOK_STREAMSTATE_))
        (CL:SETQ TOK_CURSOR_
         (MOD (%CURSOR TOK_STREAMSTATE_) TOK_SIZE_))
        (CL:SETQ TOK_END_ (%END TOK_STREAMSTATE_))
        (CL:WHEN TOK_ENDOFTOKENS?_
         (CL:SETQ TOK_CHECKPOINT_ TOK_CURSOR_)
         (CL:COND ((CL:= TOK_NEXTSTATE_ -1))
          ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%THE-ARRAY (%LEGAL-EOF-STATES TOK_TABLE_)))
             TOK_STATE_))
           (CL:SETQ TOK_NEXTSTATE_ -1)
           (CL:WHEN (CL:NOT (CL:= TOK_TOKENSTART_ -1))
            (CL:SETQ TOK_ENDOFTOKENS?_ CL:NIL)))
          (CL:T (CL:SETQ TOK_ENDOFTOKENS?_ CL:NIL)
           (CL:SETQ TOK_STATE_ 0) (CL:SETQ TOK_NEXTSTATE_ -1)))
         (CL:RETURN))
        (CL:IF (CL:>= TOK_CURSOR_ TOK_END_)
         (CL:SETQ TOK_CHECKPOINT_ TOK_SIZE_)
         (CL:SETQ TOK_CHECKPOINT_ TOK_END_)))
       (CL:T (CL:SETQ TOK_CHECKPOINT_ TOK_END_)
        (CL:SETQ TOK_CURSOR_ 0))))
     (CL:SETQ TOK_NEXTSTATE_
      (CL:THE CL:FIXNUM
       (CL:CHAR-CODE
        (CL:LET
         ((SELF TOK_TRANSITIONS_)
          (POSITION
           (CL:THE CL:FIXNUM
            (CL:LOGIOR (CL:THE CL:FIXNUM (CL:ASH TOK_STATE_ 8))
             (CL:THE CL:FIXNUM
              (CL:CHAR-CODE
               (CL:LET ((BUFFER TOK_BUFFER_) (POSITION TOK_CURSOR_))
                (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
                (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
                 (CL:THE CL:FIXNUM POSITION)))))))))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))))
     (CL:COND
      ((CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 128)) 0)
       (CL:SETQ TOK_STATE_ TOK_NEXTSTATE_)
       (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
      ((CL:= TOK_TOKENSTART_ -1)
       (CL:WHEN
        (CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 64)) 0)
        (CL:SETQ TOK_TOKENSTART_ TOK_CURSOR_))
       (CL:SETQ TOK_STATE_
        (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 63)))
       (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
      (CL:T (CL:RETURN)))
     (CL:WHEN (CL:NOT (CL:EQ TOK_ECHOSTREAM_ NULL))
      (%%PRINT-STREAM (%NATIVE-STREAM TOK_ECHOSTREAM_)
       (CL:LET ((BUFFER TOK_BUFFER_) (POSITION (CL:1- TOK_CURSOR_)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
         (CL:THE CL:FIXNUM POSITION))))))
    (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
     (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
     (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
     (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_)))
   (CL:IF TOK_ENDOFTOKENS?_ (CL:SETF (%VALUE SELF) NULL)
    (CL:LET* ((SELF-001 (NEW-TOKENIZER-TOKEN)))
     (CL:SETF (%TYPE SELF-001) (CL:AREF TOK_STATENAMES_ TOK_STATE_))
     (CL:SETF (%CONTENT SELF-001)
      (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_
       TOK_SIZE_ CL:NIL))
     (CL:SETF (%VALUE SELF) SELF-001))))
  (CL:RETURN-FROM NEXT? (CL:NOT (CL:EQ (%VALUE SELF) NULL))))

;;; (DEFGLOBAL *STELLA-TOKENIZER-TABLE-DEFINITION* ...)

(CL:DEFVAR *STELLA-TOKENIZER-TABLE-DEFINITION* NULL)

;;; (DEFGLOBAL *STELLA-TOKENIZER-TABLE* ...)

(CL:DEFVAR *STELLA-TOKENIZER-TABLE* NULL)

;;; (DEFGLOBAL *STELLA-LOGICAL-STATE-NAMES* ...)

(CL:DEFVAR *STELLA-LOGICAL-STATE-NAMES* NULL)

;;; (DEFGLOBAL *STELLA-LOGICAL-STATE-NAMES-TABLE* ...)

(CL:DEFVAR *STELLA-LOGICAL-STATE-NAMES-TABLE* NULL)

;;; (DEFMACRO WITH-STELLA-TOKENIZER ...)

(CL:DEFUN WITH-STELLA-TOKENIZER (INPUT BODY)
  (CL:RETURN-FROM WITH-STELLA-TOKENIZER
   (LIST* SYM-READ-STELLA-WITH-TOKENIZER
    SYM-READ-STELLA-*STELLA-TOKENIZER-TABLE* INPUT
    (CONS
     (LIST* SYM-READ-STELLA-LET
      (LIST*
       (LIST* SYM-READ-STELLA-TOK_STELLALOGICALSTATENAMES_
        (LIST* SYM-READ-STELLA-THE-ARRAY
         SYM-READ-STELLA-*STELLA-LOGICAL-STATE-NAMES* NIL)
        NIL)
       (LIST* SYM-READ-STELLA-TOK_STELLALOGICALSTATENAME_
        SYM-READ-STELLA-KEYWORD SYM-READ-STELLA-NULL NIL)
       NIL)
      (CONCATENATE BODY NIL))
     NIL))))

;;; (DEFMACRO GET-NEXT-STELLA-TOKEN ...)

(CL:DEFUN GET-NEXT-STELLA-TOKEN (OPTIONS)
  (CL:RETURN-FROM GET-NEXT-STELLA-TOKEN
   (LIST* SYM-READ-STELLA-PROGN
    (CONS SYM-READ-STELLA-GET-NEXT-TOKEN (CONCATENATE OPTIONS NIL))
    (LIST* SYM-READ-STELLA-SETQ
     SYM-READ-STELLA-TOK_STELLALOGICALSTATENAME_
     (LIST* SYM-READ-STELLA-NTH
      SYM-READ-STELLA-TOK_STELLALOGICALSTATENAMES_
      SYM-READ-STELLA-TOK_STATE_ NIL)
     NIL)
    NIL)))

;;; (DEFMACRO GET-STELLA-TOKEN-TYPE ...)

(CL:DEFUN GET-STELLA-TOKEN-TYPE ()
  (CL:RETURN-FROM GET-STELLA-TOKEN-TYPE
   SYM-READ-STELLA-TOK_STELLALOGICALSTATENAME_))

;;; (DEFMACRO GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION ...)

(CL:DEFUN GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION (ESCAPEMODE)
  (CL:LET* ((ESCAPE (%%VALUE ESCAPEMODE)))
   (CL:WHEN (CL:EQ ESCAPE NULL) (CL:SETQ ESCAPE KWD-READ-NONE))
   (CL:RETURN-FROM GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION
    (LIST*
     SYM-READ-STELLA-GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
     SYM-READ-STELLA-TOK_BUFFER_ SYM-READ-STELLA-TOK_TOKENSTART_
     SYM-READ-STELLA-TOK_CURSOR_ SYM-READ-STELLA-TOK_SIZE_ ESCAPE NIL))))

;;; (DEFUN (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:T CL:FIXNUM CL:FIXNUM CL:FIXNUM CL:T) CL:FIXNUM)
  GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL))
(CL:DEFUN GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL (BUFFER TOKENSTART TOKENEND SIZE ESCAPEMODE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM TOKENSTART TOKENEND SIZE))
  #+MCL
  (CL:CHECK-TYPE TOKENSTART CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE TOKENEND CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (CL:LET*
   ((CURSOR (CL:1- TOKENEND)) (SEPARATORPOSITION 0) (NOFESCAPES 0)
    (FULLYESCAPED? (CL:EQ ESCAPEMODE KWD-READ-FULLY-ESCAPED))
    (TARGETCHAR (CL:IF FULLYESCAPED? #\| MODULE-SEPARATOR-CHARACTER)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR SEPARATORPOSITION NOFESCAPES))
   (CL:LOOP
    (CL:LOOP WHILE (CL:>= CURSOR 0) DO
     (CL:COND
      ((CL:EQL
        (CL:LET ((BUFFER BUFFER) (POSITION CURSOR))
         (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
          (CL:THE CL:FIXNUM POSITION)))
        TARGETCHAR)
       (CL:SETQ SEPARATORPOSITION CURSOR)
       (CL:SETQ CURSOR (CL:1- CURSOR))
       (CL:WHEN (CL:< CURSOR 0) (CL:SETQ CURSOR (CL:1- SIZE)))
       (CL:SETQ NOFESCAPES 0)
       (CL:LOOP
        (CL:LOOP WHILE
         (CL:AND (CL:>= CURSOR 0)
          (CL:EQL
           (CL:LET ((BUFFER BUFFER) (POSITION CURSOR))
            (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
            (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
             (CL:THE CL:FIXNUM POSITION)))
           #\\))
         DO (CL:SETQ NOFESCAPES (CL:1+ NOFESCAPES))
         (CL:SETQ CURSOR (CL:1- CURSOR)))
        (CL:IF
         (CL:AND (CL:< CURSOR 0)
          (CL:EQL
           (CL:LET ((BUFFER BUFFER) (POSITION 0))
            (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
            (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
             (CL:THE CL:FIXNUM POSITION)))
           #\\))
         (CL:SETQ CURSOR (CL:1- SIZE)) (CL:RETURN)))
       (CL:WHEN
        (CL:LET ((X NOFESCAPES)) (CL:DECLARE (CL:TYPE CL:FIXNUM X))
         (CL:NOT (CL:LOGBITP 0 X)))
        (CL:WHEN FULLYESCAPED?
         (CL:SETQ SEPARATORPOSITION (CL:1- SEPARATORPOSITION))
         (CL:WHEN (CL:< SEPARATORPOSITION 0)
          (CL:SETQ SEPARATORPOSITION (CL:+ SEPARATORPOSITION SIZE)))
         (CL:WHEN
          (CL:NOT
           (CL:EQL
            (CL:LET ((BUFFER BUFFER) (POSITION SEPARATORPOSITION))
             (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
             (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
              (CL:THE CL:FIXNUM POSITION)))
            MODULE-SEPARATOR-CHARACTER))
          (CL:SETQ SEPARATORPOSITION (CL:1- SEPARATORPOSITION))))
        (CL:SETQ SEPARATORPOSITION (CL:- SEPARATORPOSITION TOKENSTART))
        (CL:IF (CL:< SEPARATORPOSITION 0)
         (CL:RETURN-FROM
          GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
          (CL:+ SEPARATORPOSITION SIZE))
         (CL:RETURN-FROM
          GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
          SEPARATORPOSITION))))
      (CL:T (CL:SETQ CURSOR (CL:1- CURSOR)))))
    (CL:SETQ CURSOR (CL:1- SIZE)))))

;;; (DEFMACRO GET-TOKEN-INTEGER ...)

(CL:DEFUN GET-TOKEN-INTEGER ()
  "User-level macro to access the most recently parsed token as an integer.
This assumes correct signed integer syntax and only checks for overflows."
  (CL:WHEN (CL:NOT (INSIDE-WITH-TOKENIZER?))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
      " Encountered `get-token-integer' outside of `with-tokenizer' macro.."
      EOL)))
   (CL:RETURN-FROM GET-TOKEN-INTEGER
    (CONS SYM-READ-STELLA-GET-TOKEN-INTEGER NIL)))
  (CL:RETURN-FROM GET-TOKEN-INTEGER
   (LIST* SYM-READ-STELLA-GET-TOKEN-INTEGER-INTERNAL
    SYM-READ-STELLA-TOK_BUFFER_ SYM-READ-STELLA-TOK_TOKENSTART_
    SYM-READ-STELLA-TOK_CURSOR_ SYM-READ-STELLA-TOK_SIZE_ NIL)))

;;; (DEFGLOBAL *GET-TOKEN-INTEGER-CHECKPOINT* ...)

(CL:DEFVAR *GET-TOKEN-INTEGER-CHECKPOINT* NULL-INTEGER)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *GET-TOKEN-INTEGER-CHECKPOINT*))

;;; (DEFUN (GET-TOKEN-INTEGER-INTERNAL INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:FIXNUM CL:FIXNUM CL:FIXNUM) CL:FIXNUM)
  GET-TOKEN-INTEGER-INTERNAL))
(CL:DEFUN GET-TOKEN-INTEGER-INTERNAL (BUFFER START END SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM START END SIZE))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (CL:LET*
   ((RESULT (GET-TOKEN-LONG-INTEGER-INTERNAL BUFFER START END SIZE)))
   (CL:WHEN
    (CL:OR (CL:> RESULT MOST-POSITIVE-INTEGER)
     (CL:< RESULT MOST-NEGATIVE-INTEGER))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "get-token-integer: integer overflow: `" RESULT "'")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (CL:RETURN-FROM GET-TOKEN-INTEGER-INTERNAL (CL:TRUNCATE RESULT))))

;;; (DEFMACRO GET-TOKEN-LONG-INTEGER ...)

(CL:DEFUN GET-TOKEN-LONG-INTEGER ()
  "User-level macro to access the most recently parsed token as a long integer.
This assumes correct signed long-integer syntax and only checks for overflows."
  (CL:WHEN (CL:NOT (INSIDE-WITH-TOKENIZER?))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
      " Encountered `get-token-long-integer' outside of `with-tokenizer' macro.."
      EOL)))
   (CL:RETURN-FROM GET-TOKEN-LONG-INTEGER
    (CONS SYM-READ-STELLA-GET-TOKEN-LONG-INTEGER NIL)))
  (CL:RETURN-FROM GET-TOKEN-LONG-INTEGER
   (LIST* SYM-READ-STELLA-GET-TOKEN-LONG-INTEGER-INTERNAL
    SYM-READ-STELLA-TOK_BUFFER_ SYM-READ-STELLA-TOK_TOKENSTART_
    SYM-READ-STELLA-TOK_CURSOR_ SYM-READ-STELLA-TOK_SIZE_ NIL)))

;;; (DEFGLOBAL *GET-TOKEN-LONG-INTEGER-CHECKPOINT* ...)

(CL:DEFVAR *GET-TOKEN-LONG-INTEGER-CHECKPOINT* NULL-LONG-INTEGER)

;;; (DEFUN (GET-TOKEN-LONG-INTEGER-INTERNAL LONG-INTEGER) ...)

(CL:DEFUN GET-TOKEN-LONG-INTEGER-INTERNAL (BUFFER START END SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM START END SIZE))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (CL:LET*
   ((LENGTH (CL:- END START)) (AUXEND END) (RESULT 0)
    (NEGATIVE? CL:NIL) (DIGIT 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH AUXEND DIGIT))
   (CL:WHEN (CL:< LENGTH 0) (CL:SETQ LENGTH (CL:+ LENGTH SIZE))
    (CL:SETQ AUXEND SIZE))
   (CL:CASE
    (CL:LET ((BUFFER BUFFER) (POSITION START))
     (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
     (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
      (CL:THE CL:FIXNUM POSITION)))
    (#\+ (CL:SETQ START (CL:1+ START)))
    (#\- (CL:SETQ START (CL:1+ START)) (CL:SETQ NEGATIVE? CL:T))
    (CL:OTHERWISE))
   (CL:LOOP
    (CL:LOOP WHILE (CL:< START AUXEND) DO
     (CL:SETQ DIGIT
      (CL:TRUNCATE
       (CL:-
        (CL:THE CL:FIXNUM
         (CL:CHAR-CODE
          (CL:LET ((BUFFER BUFFER) (POSITION START))
           (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
            (CL:THE CL:FIXNUM POSITION)))))
        #.(CL:char-code #\0))))
     (CL:WHEN
      (CL:AND (CL:>= RESULT *GET-TOKEN-LONG-INTEGER-CHECKPOINT*)
       (CL:<
        (CL:LET ((X (CL:- MOST-POSITIVE-LONG-INTEGER DIGIT)) (Y 10))
         (CL:VALUES (CL:TRUNCATE X Y)))
        RESULT))
      (CL:ERROR
       (NEW-STELLA-EXCEPTION
        "get-token-long-integer: long-integer overflow")))
     (CL:SETQ RESULT (CL:+ (CL:* RESULT 10) DIGIT))
     (CL:SETQ START (CL:1+ START)))
    (CL:WHEN (CL:= AUXEND END) (CL:RETURN)) (CL:SETQ START 0)
    (CL:SETQ AUXEND END))
   (CL:IF NEGATIVE?
    (CL:RETURN-FROM GET-TOKEN-LONG-INTEGER-INTERNAL (CL:- 0 RESULT))
    (CL:RETURN-FROM GET-TOKEN-LONG-INTEGER-INTERNAL RESULT))))

;;; (DEFMACRO GET-TOKEN-FLOAT ...)

(CL:DEFUN GET-TOKEN-FLOAT ()
  "User-level macro to access the most recently parsed token as a float.
This assumes correct signed float syntax and only checks for overflows.
The main benefit for this is that it doesn't generate strings and wrappers.
Float parsing and conversion is generally hairy and we are probably not
covering all special cases here; but we are fast :-)"
  (CL:WHEN (CL:NOT (INSIDE-WITH-TOKENIZER?))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
      " Encountered `get-token-float' outside of `with-tokenizer' macro.."
      EOL)))
   (CL:RETURN-FROM GET-TOKEN-FLOAT
    (CONS SYM-READ-STELLA-GET-TOKEN-FLOAT NIL)))
  (CL:RETURN-FROM GET-TOKEN-FLOAT
   (LIST* SYM-READ-STELLA-GET-TOKEN-FLOAT-INTERNAL
    SYM-READ-STELLA-TOK_BUFFER_ SYM-READ-STELLA-TOK_TOKENSTART_
    SYM-READ-STELLA-TOK_CURSOR_ SYM-READ-STELLA-TOK_SIZE_ NIL)))

;;; (DEFUN (GET-TOKEN-FLOAT-INTERNAL FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:T CL:FIXNUM CL:FIXNUM CL:FIXNUM) CL:DOUBLE-FLOAT)
  GET-TOKEN-FLOAT-INTERNAL))
(CL:DEFUN GET-TOKEN-FLOAT-INTERNAL (BUFFER START END SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM START END SIZE))
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (CL:LET*
   ((LENGTH (CL:- END START)) (AUXEND END) (MANTISSA 0) (EXPONENT 0)
    (MANTISSASIGN 1.0d0) (EXPONENTSIGN 1.0d0) (EXPONENT? CL:NIL)
    (DECIMALS? CL:NIL) (DECIMALS 0) (CH NULL-CHARACTER) (DIGIT 0)
    (RESULT 0.0d0))
   (CL:DECLARE
    (CL:TYPE CL:FIXNUM LENGTH AUXEND EXPONENT DECIMALS DIGIT)
    (CL:TYPE CL:DOUBLE-FLOAT MANTISSASIGN EXPONENTSIGN RESULT))
   (CL:WHEN (CL:< LENGTH 0) (CL:SETQ LENGTH (CL:+ LENGTH SIZE))
    (CL:SETQ AUXEND SIZE))
   (CL:LOOP
    (CL:LOOP WHILE (CL:< START AUXEND) DO
     (CL:SETQ CH
      (CL:LET ((BUFFER BUFFER) (POSITION START))
       (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
        (CL:THE CL:FIXNUM POSITION))))
     (CL:CASE CH
      (#\-
       (CL:IF EXPONENT? (CL:SETQ EXPONENTSIGN -1.0d0)
        (CL:SETQ MANTISSASIGN -1.0d0)))
      (#\+) (#\. (CL:SETQ DECIMALS? CL:T))
      ((#\e #\E) (CL:SETQ EXPONENT? CL:T))
      (CL:OTHERWISE
       (CL:SETQ DIGIT
        (CL:TRUNCATE
         (CL:- (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))
          #.(CL:char-code #\0))))
       (CL:COND
        (EXPONENT? (CL:SETQ EXPONENT (CL:+ (CL:* EXPONENT 10) DIGIT)))
        (CL:T (CL:WHEN DECIMALS? (CL:SETQ DECIMALS (CL:1+ DECIMALS)))
         (CL:SETQ MANTISSA (CL:+ (CL:* MANTISSA 10) DIGIT))))))
     (CL:SETQ START (CL:1+ START)))
    (CL:WHEN (CL:= AUXEND END) (CL:RETURN)) (CL:SETQ START 0)
    (CL:SETQ AUXEND END))
   (CL:SETQ RESULT (CL:FLOAT MANTISSA 0.0d0))
   (CL:SETQ EXPONENT
    (CL:TRUNCATE (CL:- (CL:* EXPONENT EXPONENTSIGN) DECIMALS)))
   (CL:WHEN (CL:NOT (CL:= EXPONENT 0))
    (CL:SETQ RESULT
     (CL:* RESULT
      (CL:THE CL:DOUBLE-FLOAT
       (CL:EXPT 10.0d0
        (CL:THE CL:DOUBLE-FLOAT (CL:FLOAT EXPONENT 0.0d0)))))))
   (CL:RETURN-FROM GET-TOKEN-FLOAT-INTERNAL (CL:* RESULT MANTISSASIGN))))

;;; (DEFCLASS STELLA-TOKEN ...)

(CL:DEFCLASS STELLA-TOKEN (TOKENIZER-TOKEN)
  ((LOGICAL-TOKEN-TYPE :ALLOCATION :INSTANCE :ACCESSOR
    %LOGICAL-TOKEN-TYPE)
   (MODULE :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %MODULE)
   (ESCAPE-MODE :ALLOCATION :INSTANCE :ACCESSOR %ESCAPE-MODE)))

(CL:DEFUN NEW-STELLA-TOKEN ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STELLA-TOKEN)))
   (CL:SETF (%CONTENT SELF) STELLA::NULL-STRING)
   (CL:SETF (%TYPE SELF) NULL) (CL:SETF (%NEXT SELF) NULL)
   (CL:SETF (%ESCAPE-MODE SELF) NULL)
   (CL:SETF (%MODULE SELF) STELLA::NULL-STRING)
   (CL:SETF (%LOGICAL-TOKEN-TYPE SELF) NULL)
   (CL:RETURN-FROM NEW-STELLA-TOKEN SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STELLA-TOKEN))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-READ-STELLA-STELLA-TOKEN))

(CL:DEFUN ACCESS-STELLA-TOKEN-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-READ-STELLA-LOGICAL-TOKEN-TYPE)
    (CL:IF SETVALUE? (CL:SETF (%LOGICAL-TOKEN-TYPE SELF) VALUE)
     (CL:SETQ VALUE (%LOGICAL-TOKEN-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-MODULE)
    (CL:IF SETVALUE? (CL:SETF (%MODULE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%MODULE SELF)))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-ESCAPE-MODE)
    (CL:IF SETVALUE? (CL:SETF (%ESCAPE-MODE SELF) VALUE)
     (CL:SETQ VALUE (%ESCAPE-MODE SELF))))
   ((CL:EQ SLOTNAME SYM-READ-STELLA-NEXT)
    (CL:IF SETVALUE? (CL:SETF (%NEXT SELF) VALUE)
     (CL:SETQ VALUE (%NEXT SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-STELLA-TOKEN-SLOT-VALUE VALUE))

;;; (DEFUN (TOKENIZE-S-EXPRESSION STELLA-TOKEN) ...)

(CL:DEFUN TOKENIZE-S-EXPRESSION (STREAM TOKENLIST)
  (CL:LET*
   ((UPCASE? (CL:NOT (%CASE-SENSITIVE? *MODULE*))) (PARENBALANCE 0)
    (ENDOFFILE? CL:T) (SKIPCLOSINGQUOTE? CL:NIL)
    (TOKENCURSOR TOKENLIST))
   (CL:DECLARE (CL:TYPE CL:FIXNUM PARENBALANCE))
   (CL:WHEN (CL:EQ TOKENLIST NULL)
    (CL:SETQ TOKENLIST (NEW-STELLA-TOKEN))
    (CL:SETQ TOKENCURSOR TOKENLIST))
   (CL:LET*
    ((TOK_TABLE_ *STELLA-TOKENIZER-TABLE*)
     (TOK_TRANSITIONS_ (%TRANSITIONS TOK_TABLE_))
     (TOK_STATENAMES_ (%THE-ARRAY (%STATE-NAMES TOK_TABLE_)))
     (TOK_TOKENSTART_ -1) (TOK_ENDOFTOKENS?_ CL:NIL)
     (TOK_INPUTSTREAM_ STREAM)
     (TOK_ECHOSTREAM_ (%ECHO-STREAM TOK_INPUTSTREAM_))
     (TOK_STREAMSTATE_
      (CL:IF (CL:EQ (%TOKENIZER-STATE TOK_INPUTSTREAM_) NULL)
       (CL:SETF (%TOKENIZER-STATE TOK_INPUTSTREAM_)
        (NEW-TOKENIZER-STREAM-STATE))
       (%TOKENIZER-STATE TOK_INPUTSTREAM_)))
     (TOK_BUFFER_ (%BUFFER TOK_STREAMSTATE_))
     (TOK_SIZE_ (%BUFFER-SIZE TOK_STREAMSTATE_))
     (TOK_STATE_ (GET-SAVED-STATE TOK_STREAMSTATE_ TOK_TABLE_))
     (TOK_NEXTSTATE_ TOK_STATE_)
     (TOK_CURSOR_ (%CURSOR TOK_STREAMSTATE_))
     (TOK_END_ (%END TOK_STREAMSTATE_))
     (TOK_CHECKPOINT_
      (CL:IF (CL:<= TOK_CURSOR_ TOK_END_) TOK_END_ TOK_SIZE_)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOK_TRANSITIONS_)
     (CL:TYPE CL:SIMPLE-VECTOR TOK_STATENAMES_)
     (CL:TYPE CL:FIXNUM TOK_TOKENSTART_ TOK_SIZE_ TOK_STATE_
      TOK_NEXTSTATE_ TOK_CURSOR_ TOK_END_ TOK_CHECKPOINT_))
    (CL:PROGN (CL:SETQ TOK_STATENAMES_ TOK_STATENAMES_)
     (CL:SETQ TOK_ENDOFTOKENS?_ TOK_ENDOFTOKENS?_))
    (CL:LET*
     ((TOK_STELLALOGICALSTATENAMES_
       (%THE-ARRAY *STELLA-LOGICAL-STATE-NAMES*))
      (TOK_STELLALOGICALSTATENAME_ NULL))
     (CL:DECLARE
      (CL:TYPE CL:SIMPLE-VECTOR TOK_STELLALOGICALSTATENAMES_))
     (CL:LOOP
      (CL:TAGBODY
       (CL:PROGN
        (CL:PROGN (CL:SETQ TOK_TOKENSTART_ -1)
         (CL:LOOP
          (CL:WHEN (CL:= TOK_CURSOR_ TOK_CHECKPOINT_)
           (CL:COND
            ((CL:= TOK_CURSOR_ TOK_END_)
             (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
             (CL:SETQ TOK_ENDOFTOKENS?_
              (READ-INTO-TOKENIZER-BUFFER TOK_INPUTSTREAM_
               TOK_STREAMSTATE_ TOK_TOKENSTART_))
             (CL:SETQ TOK_BUFFER_ (%BUFFER TOK_STREAMSTATE_))
             (CL:SETQ TOK_SIZE_ (%BUFFER-SIZE TOK_STREAMSTATE_))
             (CL:SETQ TOK_CURSOR_
              (MOD (%CURSOR TOK_STREAMSTATE_) TOK_SIZE_))
             (CL:SETQ TOK_END_ (%END TOK_STREAMSTATE_))
             (CL:WHEN TOK_ENDOFTOKENS?_
              (CL:SETQ TOK_CHECKPOINT_ TOK_CURSOR_)
              (CL:COND ((CL:= TOK_NEXTSTATE_ -1))
               ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
                 (CL:AREF
                  (CL:THE CL:SIMPLE-VECTOR
                   (%THE-ARRAY (%LEGAL-EOF-STATES TOK_TABLE_)))
                  TOK_STATE_))
                (CL:SETQ TOK_NEXTSTATE_ -1)
                (CL:WHEN (CL:NOT (CL:= TOK_TOKENSTART_ -1))
                 (CL:SETQ TOK_ENDOFTOKENS?_ CL:NIL)))
               (CL:T (CL:SETQ TOK_ENDOFTOKENS?_ CL:NIL)
                (CL:SETQ TOK_STATE_ 0) (CL:SETQ TOK_NEXTSTATE_ -1)))
              (CL:RETURN))
             (CL:IF (CL:>= TOK_CURSOR_ TOK_END_)
              (CL:SETQ TOK_CHECKPOINT_ TOK_SIZE_)
              (CL:SETQ TOK_CHECKPOINT_ TOK_END_)))
            (CL:T (CL:SETQ TOK_CHECKPOINT_ TOK_END_)
             (CL:SETQ TOK_CURSOR_ 0))))
          (CL:SETQ TOK_NEXTSTATE_
           (CL:THE CL:FIXNUM
            (CL:CHAR-CODE
             (CL:LET
              ((SELF TOK_TRANSITIONS_)
               (POSITION
                (CL:THE CL:FIXNUM
                 (CL:LOGIOR (CL:THE CL:FIXNUM (CL:ASH TOK_STATE_ 8))
                  (CL:THE CL:FIXNUM
                   (CL:CHAR-CODE
                    (CL:LET
                     ((BUFFER TOK_BUFFER_) (POSITION TOK_CURSOR_))
                     (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
                     (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
                      (CL:THE CL:FIXNUM POSITION)))))))))
              (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
               (CL:TYPE CL:FIXNUM POSITION))
              (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
               (CL:THE CL:FIXNUM POSITION))))))
          (CL:COND
           ((CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 128)) 0)
            (CL:SETQ TOK_STATE_ TOK_NEXTSTATE_)
            (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
           ((CL:= TOK_TOKENSTART_ -1)
            (CL:WHEN
             (CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 64)) 0)
             (CL:SETQ TOK_TOKENSTART_ TOK_CURSOR_))
            (CL:SETQ TOK_STATE_
             (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 63)))
            (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
           (CL:T (CL:RETURN)))
          (CL:WHEN (CL:NOT (CL:EQ TOK_ECHOSTREAM_ NULL))
           (%%PRINT-STREAM (%NATIVE-STREAM TOK_ECHOSTREAM_)
            (CL:LET
             ((BUFFER TOK_BUFFER_) (POSITION (CL:1- TOK_CURSOR_)))
             (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
             (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
              (CL:THE CL:FIXNUM POSITION)))))))
        (CL:SETQ TOK_STELLALOGICALSTATENAME_
         (CL:AREF TOK_STELLALOGICALSTATENAMES_ TOK_STATE_)))
       (CL:WHEN TOK_ENDOFTOKENS?_
        (CL:WHEN (CL:= PARENBALANCE 0) (CL:RETURN))
        (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
         (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
         (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
         (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
        (CL:ERROR (NEW-READ-EXCEPTION "Expression ended prematurely")))
       (CL:SETQ ENDOFFILE? CL:NIL)
       (CL:WHEN (CL:NOT SKIPCLOSINGQUOTE?)
        (CL:SETF (%TYPE TOKENCURSOR)
         (CL:AREF TOK_STATENAMES_ TOK_STATE_))
        (CL:SETF (%LOGICAL-TOKEN-TYPE TOKENCURSOR)
         TOK_STELLALOGICALSTATENAME_)
        (CL:SETF (%MODULE TOKENCURSOR) STELLA::NULL-STRING)
        (CL:SETF (%ESCAPE-MODE TOKENCURSOR) NULL))
       (CL:SETQ SKIPCLOSINGQUOTE? CL:NIL)
       (CL:COND
        ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-OPEN-PAREN)
         (CL:SETQ PARENBALANCE (CL:1+ PARENBALANCE))
         (CL:SETF (%CONTENT TOKENCURSOR) "("))
        ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-CLOSE-PAREN)
         (CL:SETQ PARENBALANCE (CL:1- PARENBALANCE))
         (CL:SETF (%CONTENT TOKENCURSOR) ")")
         (CL:WHEN (CL:< PARENBALANCE 0)
          (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
           (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
           (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
           (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
          (CL:ERROR
           (NEW-READ-EXCEPTION
            "Extra right parenthesis encountered"))))
        ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-SYMBOL)
         (CL:LET*
          ((TEST-VALUE-000 (CL:AREF TOK_STATENAMES_ TOK_STATE_)))
          (CL:COND
           ((CL:EQ TEST-VALUE-000 KWD-READ-SYMBOL)
            (CL:SETF (%CONTENT TOKENCURSOR)
             (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
              TOK_CURSOR_ TOK_SIZE_ UPCASE?)))
           ((CL:EQ TEST-VALUE-000 KWD-READ-QUALIFIED-SYMBOL)
            (CL:LET*
             ((SEPARATORPOS
               (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
                TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
                KWD-READ-NONE)))
             (CL:DECLARE (CL:TYPE CL:FIXNUM SEPARATORPOS))
             (CL:SETF (%CONTENT TOKENCURSOR)
              (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
               (CL:+ TOK_TOKENSTART_ (CL:1+ SEPARATORPOS)) TOK_CURSOR_
               TOK_SIZE_ UPCASE?))
             (CL:SETF (%MODULE TOKENCURSOR)
              (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
               (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
                (CL:IF (CL:< SEPARATORPOS 0)
                 (CL:+ TOK_CURSOR_ SEPARATORPOS)
                 (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
                TOK_SIZE_ CL:T)))))
           ((CL:EQ TEST-VALUE-000 KWD-READ-FULLY-ESCAPED-SYMBOL)
            (CL:SETF (%CONTENT TOKENCURSOR)
             (UNESCAPE-TOKEN-STRING
              (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
               (CL:1+ TOK_TOKENSTART_) TOK_CURSOR_ TOK_SIZE_ CL:NIL)
              #\\ CL:NIL))
            (CL:SETF (%ESCAPE-MODE TOKENCURSOR) KWD-READ-FULL)
            (CL:SETQ SKIPCLOSINGQUOTE? CL:T))
           ((CL:EQ TEST-VALUE-000
             KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL)
            (CL:LET*
             ((SEPARATORPOS
               (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
                TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
                KWD-READ-FULLY-ESCAPED)))
             (CL:DECLARE (CL:TYPE CL:FIXNUM SEPARATORPOS))
             (CL:SETF (%CONTENT TOKENCURSOR)
              (UNESCAPE-TOKEN-STRING
               (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
                (CL:+ TOK_TOKENSTART_ (CL:+ SEPARATORPOS 2))
                TOK_CURSOR_ TOK_SIZE_ CL:NIL)
               #\\ CL:NIL))
             (CL:SETF (%MODULE TOKENCURSOR)
              (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
               (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
                (CL:IF (CL:< SEPARATORPOS 0)
                 (CL:+ TOK_CURSOR_ SEPARATORPOS)
                 (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
                TOK_SIZE_ CL:T)))
             (CL:SETF (%ESCAPE-MODE TOKENCURSOR) KWD-READ-FULL))
            (CL:SETQ SKIPCLOSINGQUOTE? CL:T))
           ((CL:EQ TEST-VALUE-000 KWD-READ-ESCAPED-SYMBOL)
            (CL:SETF (%CONTENT TOKENCURSOR)
             (UNESCAPE-TOKEN-STRING
              (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
               TOK_CURSOR_ TOK_SIZE_ CL:NIL)
              #\\ UPCASE?))
            (CL:SETF (%ESCAPE-MODE TOKENCURSOR) KWD-READ-PARTIAL))
           ((CL:EQ TEST-VALUE-000 KWD-READ-QUALIFIED-ESCAPED-SYMBOL)
            (CL:LET*
             ((SEPARATORPOS
               (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
                TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
                KWD-READ-ESCAPED)))
             (CL:DECLARE (CL:TYPE CL:FIXNUM SEPARATORPOS))
             (CL:SETF (%CONTENT TOKENCURSOR)
              (UNESCAPE-TOKEN-STRING
               (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
                (CL:+ TOK_TOKENSTART_ (CL:1+ SEPARATORPOS)) TOK_CURSOR_
                TOK_SIZE_ CL:NIL)
               #\\ UPCASE?))
             (CL:SETF (%MODULE TOKENCURSOR)
              (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
               (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
                (CL:IF (CL:< SEPARATORPOS 0)
                 (CL:+ TOK_CURSOR_ SEPARATORPOS)
                 (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
                TOK_SIZE_ CL:T)))
             (CL:SETF (%ESCAPE-MODE TOKENCURSOR) KWD-READ-PARTIAL)))
           ((CL:EQ TEST-VALUE-000 KWD-READ-CL-SYMBOL)
            (CL:SETF (%CONTENT TOKENCURSOR)
             (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
              (CL:+ TOK_TOKENSTART_ 3) TOK_CURSOR_ TOK_SIZE_ CL:T))
            (CL:SETF (%MODULE TOKENCURSOR) "/COMMON-LISP"))
           (CL:T
            (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
              TEST-VALUE-000 "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION
               (THE-STRING-READER STREAM-000))))))))
        ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-SURROGATE)
         (CL:LET*
          ((TEST-VALUE-001 (CL:AREF TOK_STATENAMES_ TOK_STATE_)))
          (CL:COND
           ((CL:EQ TEST-VALUE-001 KWD-READ-SURROGATE)
            (CL:SETF (%CONTENT TOKENCURSOR)
             (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
              (CL:1+ TOK_TOKENSTART_) TOK_CURSOR_ TOK_SIZE_ UPCASE?)))
           ((CL:EQ TEST-VALUE-001 KWD-READ-QUALIFIED-SURROGATE)
            (CL:LET*
             ((SEPARATORPOS
               (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
                TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
                KWD-READ-NONE)))
             (CL:DECLARE (CL:TYPE CL:FIXNUM SEPARATORPOS))
             (CL:SETF (%CONTENT TOKENCURSOR)
              (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
               (CL:+ TOK_TOKENSTART_ (CL:+ SEPARATORPOS 2)) TOK_CURSOR_
               TOK_SIZE_ UPCASE?))
             (CL:SETF (%MODULE TOKENCURSOR)
              (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
               (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
                (CL:IF (CL:< SEPARATORPOS 0)
                 (CL:+ TOK_CURSOR_ SEPARATORPOS)
                 (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
                TOK_SIZE_ CL:T)))))
           ((CL:EQ TEST-VALUE-001 KWD-READ-FULLY-ESCAPED-SURROGATE)
            (CL:SETF (%CONTENT TOKENCURSOR)
             (UNESCAPE-TOKEN-STRING
              (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
               (CL:+ TOK_TOKENSTART_ 2) TOK_CURSOR_ TOK_SIZE_ CL:NIL)
              #\\ CL:NIL))
            (CL:SETF (%ESCAPE-MODE TOKENCURSOR) KWD-READ-FULL)
            (CL:SETQ SKIPCLOSINGQUOTE? CL:T))
           ((CL:EQ TEST-VALUE-001
             KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE)
            (CL:LET*
             ((SEPARATORPOS
               (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
                TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
                KWD-READ-FULLY-ESCAPED)))
             (CL:DECLARE (CL:TYPE CL:FIXNUM SEPARATORPOS))
             (CL:SETF (%CONTENT TOKENCURSOR)
              (UNESCAPE-TOKEN-STRING
               (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
                (CL:+ TOK_TOKENSTART_ (CL:+ SEPARATORPOS 3))
                TOK_CURSOR_ TOK_SIZE_ CL:NIL)
               #\\ CL:NIL))
             (CL:SETF (%MODULE TOKENCURSOR)
              (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
               (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
                (CL:IF (CL:< SEPARATORPOS 0)
                 (CL:+ TOK_CURSOR_ SEPARATORPOS)
                 (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
                TOK_SIZE_ CL:T)))
             (CL:SETF (%ESCAPE-MODE TOKENCURSOR) KWD-READ-FULL))
            (CL:SETQ SKIPCLOSINGQUOTE? CL:T))
           ((CL:EQ TEST-VALUE-001 KWD-READ-ESCAPED-SURROGATE)
            (CL:SETF (%CONTENT TOKENCURSOR)
             (UNESCAPE-TOKEN-STRING
              (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
               (CL:1+ TOK_TOKENSTART_) TOK_CURSOR_ TOK_SIZE_ CL:NIL)
              #\\ UPCASE?))
            (CL:SETF (%ESCAPE-MODE TOKENCURSOR) KWD-READ-PARTIAL))
           ((CL:EQ TEST-VALUE-001 KWD-READ-QUALIFIED-ESCAPED-SURROGATE)
            (CL:LET*
             ((SEPARATORPOS
               (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
                TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
                KWD-READ-ESCAPED)))
             (CL:DECLARE (CL:TYPE CL:FIXNUM SEPARATORPOS))
             (CL:SETF (%CONTENT TOKENCURSOR)
              (UNESCAPE-TOKEN-STRING
               (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
                (CL:+ TOK_TOKENSTART_ (CL:+ SEPARATORPOS 2))
                TOK_CURSOR_ TOK_SIZE_ CL:NIL)
               #\\ UPCASE?))
             (CL:SETF (%MODULE TOKENCURSOR)
              (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
               (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
                (CL:IF (CL:< SEPARATORPOS 0)
                 (CL:+ TOK_CURSOR_ SEPARATORPOS)
                 (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
                TOK_SIZE_ CL:T)))
             (CL:SETF (%ESCAPE-MODE TOKENCURSOR) KWD-READ-PARTIAL)))
           (CL:T
            (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
              TEST-VALUE-001 "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION
               (THE-STRING-READER STREAM-001))))))))
        ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-KEYWORD)
         (CL:LET*
          ((TEST-VALUE-002 (CL:AREF TOK_STATENAMES_ TOK_STATE_)))
          (CL:COND
           ((CL:EQ TEST-VALUE-002 KWD-READ-KEYWORD)
            (CL:SETF (%CONTENT TOKENCURSOR)
             (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
              (CL:1+ TOK_TOKENSTART_) TOK_CURSOR_ TOK_SIZE_ CL:T)))
           ((CL:EQ TEST-VALUE-002 KWD-READ-FULLY-ESCAPED-KEYWORD)
            (CL:SETF (%CONTENT TOKENCURSOR)
             (UNESCAPE-TOKEN-STRING
              (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
               (CL:+ TOK_TOKENSTART_ 2) TOK_CURSOR_ TOK_SIZE_ CL:NIL)
              #\\ CL:NIL))
            (CL:SETF (%ESCAPE-MODE TOKENCURSOR) KWD-READ-FULL)
            (CL:SETQ SKIPCLOSINGQUOTE? CL:T))
           ((CL:EQ TEST-VALUE-002 KWD-READ-ESCAPED-KEYWORD)
            (CL:SETF (%CONTENT TOKENCURSOR)
             (UNESCAPE-TOKEN-STRING
              (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
               (CL:1+ TOK_TOKENSTART_) TOK_CURSOR_ TOK_SIZE_ CL:NIL)
              #\\ CL:T))
            (CL:SETF (%ESCAPE-MODE TOKENCURSOR) KWD-READ-PARTIAL))
           (CL:T
            (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`"
              TEST-VALUE-002 "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION
               (THE-STRING-READER STREAM-002))))))))
        ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-STRING)
         (CL:SETF (%CONTENT TOKENCURSOR)
          (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ (CL:1+ TOK_TOKENSTART_)
           TOK_CURSOR_ TOK_SIZE_ CL:NIL))
         (CL:LET*
          ((TEST-VALUE-003 (CL:AREF TOK_STATENAMES_ TOK_STATE_)))
          (CL:COND ((CL:EQ TEST-VALUE-003 KWD-READ-STRING))
           ((CL:EQ TEST-VALUE-003 KWD-READ-ESCAPED-STRING)
            (CL:SETF (%CONTENT TOKENCURSOR)
             (UNESCAPE-TOKEN-STRING (%CONTENT TOKENCURSOR) #\\ CL:NIL))
            (CL:SETF (%ESCAPE-MODE TOKENCURSOR) KWD-READ-PARTIAL))
           (CL:T
            (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM (%NATIVE-STREAM STREAM-003) "`"
              TEST-VALUE-003 "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION
               (THE-STRING-READER STREAM-003)))))))
         (CL:SETQ SKIPCLOSINGQUOTE? CL:T))
        ((CL:OR (CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-INTEGER)
          (CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-FLOAT))
         (CL:SETF (%CONTENT TOKENCURSOR)
          (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
           TOK_CURSOR_ TOK_SIZE_ CL:NIL)))
        ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-CHARACTER)
         (CL:LET*
          ((NAME
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
             TOK_CURSOR_ TOK_SIZE_ CL:NIL)))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
          (CL:WHEN (CL:> (CL:THE CL:FIXNUM (CL:LENGTH NAME)) 1)
           (CL:SETQ NAME (STRING-UPCASE NAME)))
          (CL:SETF (%CONTENT TOKENCURSOR) NAME)))
        ((CL:OR
          (CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-SINGLE-QUOTE)
          (CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-BACK-QUOTE)
          (CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-COMMA)
          (CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-COMMA-SPLICE))
         (CL:SETF (%CONTENT TOKENCURSOR)
          (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
           TOK_CURSOR_ TOK_SIZE_ CL:NIL))
         (CL:WHEN (CL:EQ (%NEXT TOKENCURSOR) NULL)
          (CL:SETF (%NEXT TOKENCURSOR) (NEW-STELLA-TOKEN)))
         (CL:SETQ TOKENCURSOR (%NEXT TOKENCURSOR)) (CL:GO :CONTINUE))
        ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-QUALIFIED-NAME)
         (CL:LET*
          ((TOKEN
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
             TOK_CURSOR_ TOK_SIZE_ CL:T))
           (LENGTH (CL:THE CL:FIXNUM (CL:LENGTH TOKEN))))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOKEN)
           (CL:TYPE CL:FIXNUM LENGTH))
          (CL:COND
           ((CL:AND (CL:>= LENGTH 1)
             (CL:EQL
              (CL:LET ((SELF TOKEN) (POSITION (CL:1- LENGTH)))
               (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
                (CL:TYPE CL:FIXNUM POSITION))
               (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                (CL:THE CL:FIXNUM POSITION)))
              #\/)
             (CL:OR (CL:= LENGTH 1)
              (CL:EQL
               (CL:LET ((SELF TOKEN) (POSITION (CL:- LENGTH 2)))
                (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
                 (CL:TYPE CL:FIXNUM POSITION))
                (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                 (CL:THE CL:FIXNUM POSITION)))
               #\/)))
            (CL:SETF (%CONTENT TOKENCURSOR) "/")
            (CL:SETF (%TYPE TOKENCURSOR) KWD-READ-SYMBOL)
            (CL:SETF (%LOGICAL-TOKEN-TYPE TOKENCURSOR) KWD-READ-SYMBOL)
            (CL:WHEN (CL:> LENGTH 1)
             (CL:SETF (%MODULE TOKENCURSOR)
              (SUBSEQUENCE TOKEN 0 (CL:- LENGTH 2)))
             (CL:SETF (%TYPE TOKENCURSOR) KWD-READ-QUALIFIED-SYMBOL)))
           (CL:T (CL:SETF (%CONTENT TOKENCURSOR) TOKEN)))))
        ((CL:EQ TOK_STELLALOGICALSTATENAME_
          KWD-READ-CLOSE-BALANCED-QUOTE))
        ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-ERROR)
         (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
          (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
          (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
          (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
         (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-004)
           "Illegal read syntax: `"
           (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
            TOK_CURSOR_ TOK_SIZE_ CL:NIL)
           "'")
          (CL:ERROR
           (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-004)))))
        (CL:T
         (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
          (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
          (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
          (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
         (CL:LET* ((STREAM-005 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-005)
           "Illegal read syntax: `"
           (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
            TOK_CURSOR_ TOK_SIZE_ CL:NIL)
           "' in state `" (CL:AREF TOK_STATENAMES_ TOK_STATE_) "'")
          (CL:ERROR
           (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-005))))))
       (CL:WHEN (CL:NOT SKIPCLOSINGQUOTE?)
        (CL:WHEN (CL:EQ (%NEXT TOKENCURSOR) NULL)
         (CL:SETF (%NEXT TOKENCURSOR) (NEW-STELLA-TOKEN)))
        (CL:SETQ TOKENCURSOR (%NEXT TOKENCURSOR))
        (CL:WHEN (CL:= PARENBALANCE 0) (CL:RETURN)))
       :CONTINUE))
     (CL:SETF (%TYPE TOKENCURSOR) NULL)
     (CL:SETF (%LOGICAL-TOKEN-TYPE TOKENCURSOR) NULL)
     (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
      (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
      (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
      (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
     (CL:IF ENDOFFILE? (CL:RETURN-FROM TOKENIZE-S-EXPRESSION NULL)
      (CL:RETURN-FROM TOKENIZE-S-EXPRESSION TOKENLIST))))))

;;; (DEFUN (PARSE-STELLA-NAME STRING STRING KEYWORD) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING CL:T)
   (CL:VALUES CL:SIMPLE-STRING CL:SIMPLE-STRING CL:T))
  PARSE-STELLA-NAME))
(CL:DEFUN PARSE-STELLA-NAME (NAME ENABLECASECONVERSION?)
  "Parse the printed representation `name' of a STELLA symbol, surrogate or
keyword and return its symbol name, module name and type (which is either
:SYMBOL, :SURROGATE or :KEYWORD).  `name' can be qualified and must use the
exact same syntax and escape characters that would be used if it were to be
read by `read-s-expression-from-string' (or `unstringify').  If
`enableCaseConversion?' is TRUE, the returned symbol name will be upcased if
the current module is case-insensitive; otherwise, it will be returned as is.
Raises a read exception if `name' does not represent a symbol.
This function is available primarily for efficiency, since it is about
10-15 times faster than `unstringify'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((SYMBOLNAME STELLA::NULL-STRING) (MODULENAME STELLA::NULL-STRING)
    (SYMBOLTYPE NULL) (SEPARATORPOS 0)
    (UPCASE?
     (CL:AND ENABLECASECONVERSION?
      (CL:NOT (%CASE-SENSITIVE? *MODULE*)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYMBOLNAME MODULENAME)
    (CL:TYPE CL:FIXNUM SEPARATORPOS))
   (CL:LET*
    ((TOK_TABLE_ *STELLA-TOKENIZER-TABLE*)
     (TOK_TRANSITIONS_ (%TRANSITIONS TOK_TABLE_))
     (TOK_STATENAMES_ (%THE-ARRAY (%STATE-NAMES TOK_TABLE_)))
     (TOK_TOKENSTART_ -1) (TOK_ENDOFTOKENS?_ CL:NIL)
     (TOK_STREAMSTATE_ NULL)
     (TOK_BUFFER_
      (CL:LET ((STRING NAME))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING)) STRING))
     (TOK_STATE_ 1) (TOK_NEXTSTATE_ TOK_STATE_) (TOK_CURSOR_ 0)
     (TOK_SIZE_ (CL:THE CL:FIXNUM (CL:LENGTH NAME)))
     (TOK_END_ TOK_SIZE_))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOK_TRANSITIONS_)
     (CL:TYPE CL:SIMPLE-VECTOR TOK_STATENAMES_)
     (CL:TYPE CL:FIXNUM TOK_TOKENSTART_ TOK_STATE_ TOK_NEXTSTATE_
      TOK_CURSOR_ TOK_SIZE_ TOK_END_))
    (CL:PROGN (CL:SETQ TOK_STATENAMES_ TOK_STATENAMES_)
     (CL:SETQ TOK_ENDOFTOKENS?_ TOK_ENDOFTOKENS?_))
    (CL:SETQ TOK_STREAMSTATE_ TOK_STREAMSTATE_)
    (CL:LET*
     ((TOK_STELLALOGICALSTATENAMES_
       (%THE-ARRAY *STELLA-LOGICAL-STATE-NAMES*))
      (TOK_STELLALOGICALSTATENAME_ NULL))
     (CL:DECLARE
      (CL:TYPE CL:SIMPLE-VECTOR TOK_STELLALOGICALSTATENAMES_))
     (CL:PROGN
      (CL:PROGN (CL:SETQ TOK_TOKENSTART_ -1)
       (CL:LOOP
        (CL:WHEN (CL:= TOK_CURSOR_ TOK_END_)
         (CL:COND
          ((CL:= TOK_NEXTSTATE_ -1) (CL:SETQ TOK_ENDOFTOKENS?_ CL:T))
          ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%THE-ARRAY (%LEGAL-EOF-STATES TOK_TABLE_)))
             TOK_STATE_))
           (CL:SETQ TOK_NEXTSTATE_ -1)
           (CL:WHEN (CL:= TOK_TOKENSTART_ -1)
            (CL:SETQ TOK_ENDOFTOKENS?_ CL:T)))
          (CL:T (CL:SETQ TOK_STATE_ 0) (CL:SETQ TOK_NEXTSTATE_ -1)))
         (CL:RETURN))
        (CL:SETQ TOK_NEXTSTATE_
         (CL:THE CL:FIXNUM
          (CL:CHAR-CODE
           (CL:LET
            ((SELF TOK_TRANSITIONS_)
             (POSITION
              (CL:THE CL:FIXNUM
               (CL:LOGIOR (CL:THE CL:FIXNUM (CL:ASH TOK_STATE_ 8))
                (CL:THE CL:FIXNUM
                 (CL:CHAR-CODE
                  (CL:LET ((BUFFER TOK_BUFFER_) (POSITION TOK_CURSOR_))
                   (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
                   (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
                    (CL:THE CL:FIXNUM POSITION)))))))))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
             (CL:THE CL:FIXNUM POSITION))))))
        (CL:COND
         ((CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 128)) 0)
          (CL:SETQ TOK_STATE_ TOK_NEXTSTATE_)
          (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
         ((CL:= TOK_TOKENSTART_ -1)
          (CL:WHEN
           (CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 64)) 0)
           (CL:SETQ TOK_TOKENSTART_ TOK_CURSOR_))
          (CL:SETQ TOK_STATE_
           (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 63)))
          (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
         (CL:T (CL:RETURN)))))
      (CL:SETQ TOK_STELLALOGICALSTATENAME_
       (CL:AREF TOK_STELLALOGICALSTATENAMES_ TOK_STATE_)))
     (CL:WHEN TOK_ENDOFTOKENS?_
      (CL:RETURN-FROM PARSE-STELLA-NAME
       (CL:VALUES STELLA::NULL-STRING STELLA::NULL-STRING NULL)))
     (CL:COND
      ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-SYMBOL)
       (CL:LET* ((TEST-VALUE-000 (CL:AREF TOK_STATENAMES_ TOK_STATE_)))
        (CL:COND
         ((CL:EQ TEST-VALUE-000 KWD-READ-SYMBOL)
          (CL:SETQ SYMBOLNAME
           (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
            TOK_CURSOR_ TOK_SIZE_ UPCASE?)))
         ((CL:EQ TEST-VALUE-000 KWD-READ-QUALIFIED-SYMBOL)
          (CL:SETQ SEPARATORPOS
           (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
            TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
            KWD-READ-NONE))
          (CL:SETQ SYMBOLNAME
           (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
            (CL:+ TOK_TOKENSTART_ (CL:1+ SEPARATORPOS)) TOK_CURSOR_
            TOK_SIZE_ UPCASE?))
          (CL:SETQ MODULENAME
           (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
             (CL:IF (CL:< SEPARATORPOS 0)
              (CL:+ TOK_CURSOR_ SEPARATORPOS)
              (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
             TOK_SIZE_ CL:T))))
         ((CL:EQ TEST-VALUE-000 KWD-READ-FULLY-ESCAPED-SYMBOL)
          (CL:SETQ SYMBOLNAME
           (UNESCAPE-TOKEN-STRING
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
             (CL:1+ TOK_TOKENSTART_) TOK_CURSOR_ TOK_SIZE_ CL:NIL)
            #\\ CL:NIL)))
         ((CL:EQ TEST-VALUE-000
           KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL)
          (CL:SETQ SEPARATORPOS
           (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
            TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
            KWD-READ-FULLY-ESCAPED))
          (CL:SETQ SYMBOLNAME
           (UNESCAPE-TOKEN-STRING
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
             (CL:+ TOK_TOKENSTART_ (CL:+ SEPARATORPOS 2)) TOK_CURSOR_
             TOK_SIZE_ CL:NIL)
            #\\ CL:NIL))
          (CL:SETQ MODULENAME
           (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
             (CL:IF (CL:< SEPARATORPOS 0)
              (CL:+ TOK_CURSOR_ SEPARATORPOS)
              (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
             TOK_SIZE_ CL:T))))
         ((CL:EQ TEST-VALUE-000 KWD-READ-ESCAPED-SYMBOL)
          (CL:SETQ SYMBOLNAME
           (UNESCAPE-TOKEN-STRING
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
             TOK_CURSOR_ TOK_SIZE_ CL:NIL)
            #\\ UPCASE?)))
         ((CL:EQ TEST-VALUE-000 KWD-READ-QUALIFIED-ESCAPED-SYMBOL)
          (CL:SETQ SEPARATORPOS
           (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
            TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
            KWD-READ-ESCAPED))
          (CL:SETQ SYMBOLNAME
           (UNESCAPE-TOKEN-STRING
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
             (CL:+ TOK_TOKENSTART_ (CL:1+ SEPARATORPOS)) TOK_CURSOR_
             TOK_SIZE_ CL:NIL)
            #\\ UPCASE?))
          (CL:SETQ MODULENAME
           (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
             (CL:IF (CL:< SEPARATORPOS 0)
              (CL:+ TOK_CURSOR_ SEPARATORPOS)
              (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
             TOK_SIZE_ CL:T))))
         ((CL:EQ TEST-VALUE-000 KWD-READ-CL-SYMBOL)
          (CL:SETQ SYMBOLNAME
           (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
            (CL:+ TOK_TOKENSTART_ 3) TOK_CURSOR_ TOK_SIZE_ CL:T))
          (CL:SETQ MODULENAME "/COMMON-LISP"))
         (CL:T
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
            TEST-VALUE-000 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
      ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-SURROGATE)
       (CL:LET* ((TEST-VALUE-001 (CL:AREF TOK_STATENAMES_ TOK_STATE_)))
        (CL:COND
         ((CL:EQ TEST-VALUE-001 KWD-READ-SURROGATE)
          (CL:SETQ SYMBOLNAME
           (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ (CL:1+ TOK_TOKENSTART_)
            TOK_CURSOR_ TOK_SIZE_ UPCASE?)))
         ((CL:EQ TEST-VALUE-001 KWD-READ-QUALIFIED-SURROGATE)
          (CL:SETQ SEPARATORPOS
           (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
            TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
            KWD-READ-NONE))
          (CL:SETQ SYMBOLNAME
           (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
            (CL:+ TOK_TOKENSTART_ (CL:+ SEPARATORPOS 2)) TOK_CURSOR_
            TOK_SIZE_ UPCASE?))
          (CL:SETQ MODULENAME
           (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
             (CL:IF (CL:< SEPARATORPOS 0)
              (CL:+ TOK_CURSOR_ SEPARATORPOS)
              (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
             TOK_SIZE_ CL:T))))
         ((CL:EQ TEST-VALUE-001 KWD-READ-FULLY-ESCAPED-SURROGATE)
          (CL:SETQ SYMBOLNAME
           (UNESCAPE-TOKEN-STRING
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
             (CL:+ TOK_TOKENSTART_ 2) TOK_CURSOR_ TOK_SIZE_ CL:NIL)
            #\\ CL:NIL)))
         ((CL:EQ TEST-VALUE-001
           KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE)
          (CL:SETQ SEPARATORPOS
           (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
            TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
            KWD-READ-FULLY-ESCAPED))
          (CL:SETQ SYMBOLNAME
           (UNESCAPE-TOKEN-STRING
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
             (CL:+ TOK_TOKENSTART_ (CL:+ SEPARATORPOS 3)) TOK_CURSOR_
             TOK_SIZE_ CL:NIL)
            #\\ CL:NIL))
          (CL:SETQ MODULENAME
           (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
             (CL:IF (CL:< SEPARATORPOS 0)
              (CL:+ TOK_CURSOR_ SEPARATORPOS)
              (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
             TOK_SIZE_ CL:T))))
         ((CL:EQ TEST-VALUE-001 KWD-READ-ESCAPED-SURROGATE)
          (CL:SETQ SYMBOLNAME
           (UNESCAPE-TOKEN-STRING
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
             (CL:1+ TOK_TOKENSTART_) TOK_CURSOR_ TOK_SIZE_ CL:NIL)
            #\\ UPCASE?)))
         ((CL:EQ TEST-VALUE-001 KWD-READ-QUALIFIED-ESCAPED-SURROGATE)
          (CL:SETQ SEPARATORPOS
           (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
            TOK_BUFFER_ TOK_TOKENSTART_ TOK_CURSOR_ TOK_SIZE_
            KWD-READ-ESCAPED))
          (CL:SETQ SYMBOLNAME
           (UNESCAPE-TOKEN-STRING
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
             (CL:+ TOK_TOKENSTART_ (CL:+ SEPARATORPOS 2)) TOK_CURSOR_
             TOK_SIZE_ CL:NIL)
            #\\ UPCASE?))
          (CL:SETQ MODULENAME
           (CL:IF (CL:= SEPARATORPOS 0) "ROOT-MODULE"
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
             (CL:IF (CL:< SEPARATORPOS 0)
              (CL:+ TOK_CURSOR_ SEPARATORPOS)
              (CL:+ TOK_TOKENSTART_ SEPARATORPOS))
             TOK_SIZE_ CL:T))))
         (CL:T
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
            TEST-VALUE-001 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
      ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-KEYWORD)
       (CL:LET* ((TEST-VALUE-002 (CL:AREF TOK_STATENAMES_ TOK_STATE_)))
        (CL:COND
         ((CL:EQ TEST-VALUE-002 KWD-READ-KEYWORD)
          (CL:SETQ SYMBOLNAME
           (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ (CL:1+ TOK_TOKENSTART_)
            TOK_CURSOR_ TOK_SIZE_ CL:T)))
         ((CL:EQ TEST-VALUE-002 KWD-READ-FULLY-ESCAPED-KEYWORD)
          (CL:SETQ SYMBOLNAME
           (UNESCAPE-TOKEN-STRING
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
             (CL:+ TOK_TOKENSTART_ 2) TOK_CURSOR_ TOK_SIZE_ CL:NIL)
            #\\ CL:NIL)))
         ((CL:EQ TEST-VALUE-002 KWD-READ-ESCAPED-KEYWORD)
          (CL:SETQ SYMBOLNAME
           (UNESCAPE-TOKEN-STRING
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_
             (CL:1+ TOK_TOKENSTART_) TOK_CURSOR_ TOK_SIZE_ CL:NIL)
            #\\ CL:T)))
         (CL:T
          (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`"
            TEST-VALUE-002 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002))))))))
      ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-QUALIFIED-NAME)
       (CL:LET*
        ((TOKEN
          (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
           TOK_CURSOR_ TOK_SIZE_ CL:T))
         (LENGTH (CL:THE CL:FIXNUM (CL:LENGTH TOKEN))))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOKEN)
         (CL:TYPE CL:FIXNUM LENGTH))
        (CL:COND
         ((CL:AND (CL:>= LENGTH 1)
           (CL:EQL
            (CL:LET ((SELF TOKEN) (POSITION (CL:1- LENGTH)))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
              (CL:TYPE CL:FIXNUM POSITION))
             (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
              (CL:THE CL:FIXNUM POSITION)))
            #\/)
           (CL:OR (CL:= LENGTH 1)
            (CL:EQL
             (CL:LET ((SELF TOKEN) (POSITION (CL:- LENGTH 2)))
              (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
               (CL:TYPE CL:FIXNUM POSITION))
              (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
               (CL:THE CL:FIXNUM POSITION)))
             #\/)))
          (CL:SETQ SYMBOLNAME "/")
          (CL:SETQ TOK_STELLALOGICALSTATENAME_ KWD-READ-SYMBOL)
          (CL:WHEN (CL:> LENGTH 1)
           (CL:SETQ MODULENAME (SUBSEQUENCE TOKEN 0 (CL:- LENGTH 2)))))
         (CL:T
          (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-003)
            "Illegal symbol syntax: `"
            (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
             TOK_CURSOR_ TOK_SIZE_ CL:NIL)
            "' in state `" (CL:AREF TOK_STATENAMES_ TOK_STATE_) "'")
           (CL:ERROR
            (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-003))))))))
      ((CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-READ-ERROR)
       (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-004)
         "Illegal read syntax: `"
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
          TOK_CURSOR_ TOK_SIZE_ CL:NIL)
         "'")
        (CL:ERROR
         (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-004)))))
      (CL:T
       (CL:LET* ((STREAM-005 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-005)
         "Illegal symbol syntax: `"
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
          TOK_CURSOR_ TOK_SIZE_ CL:NIL)
         "' in state `" (CL:AREF TOK_STATENAMES_ TOK_STATE_) "'")
        (CL:ERROR
         (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-005))))))
     (CL:SETQ SYMBOLTYPE TOK_STELLALOGICALSTATENAME_)
     (CL:PROGN
      (CL:PROGN (CL:SETQ TOK_TOKENSTART_ -1)
       (CL:LOOP
        (CL:WHEN (CL:= TOK_CURSOR_ TOK_END_)
         (CL:COND
          ((CL:= TOK_NEXTSTATE_ -1) (CL:SETQ TOK_ENDOFTOKENS?_ CL:T))
          ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR
              (%THE-ARRAY (%LEGAL-EOF-STATES TOK_TABLE_)))
             TOK_STATE_))
           (CL:SETQ TOK_NEXTSTATE_ -1)
           (CL:WHEN (CL:= TOK_TOKENSTART_ -1)
            (CL:SETQ TOK_ENDOFTOKENS?_ CL:T)))
          (CL:T (CL:SETQ TOK_STATE_ 0) (CL:SETQ TOK_NEXTSTATE_ -1)))
         (CL:RETURN))
        (CL:SETQ TOK_NEXTSTATE_
         (CL:THE CL:FIXNUM
          (CL:CHAR-CODE
           (CL:LET
            ((SELF TOK_TRANSITIONS_)
             (POSITION
              (CL:THE CL:FIXNUM
               (CL:LOGIOR (CL:THE CL:FIXNUM (CL:ASH TOK_STATE_ 8))
                (CL:THE CL:FIXNUM
                 (CL:CHAR-CODE
                  (CL:LET ((BUFFER TOK_BUFFER_) (POSITION TOK_CURSOR_))
                   (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
                   (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
                    (CL:THE CL:FIXNUM POSITION)))))))))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
             (CL:THE CL:FIXNUM POSITION))))))
        (CL:COND
         ((CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 128)) 0)
          (CL:SETQ TOK_STATE_ TOK_NEXTSTATE_)
          (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
         ((CL:= TOK_TOKENSTART_ -1)
          (CL:WHEN
           (CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 64)) 0)
           (CL:SETQ TOK_TOKENSTART_ TOK_CURSOR_))
          (CL:SETQ TOK_STATE_
           (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 63)))
          (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
         (CL:T (CL:RETURN)))))
      (CL:SETQ TOK_STELLALOGICALSTATENAME_
       (CL:AREF TOK_STELLALOGICALSTATENAMES_ TOK_STATE_)))
     (CL:IF
      (CL:OR TOK_ENDOFTOKENS?_
       (CL:EQ (CL:AREF TOK_STATENAMES_ TOK_STATE_)
        KWD-READ-CLOSE-FULLY-ESCAPED-NAME))
      (CL:RETURN-FROM PARSE-STELLA-NAME
       (CL:VALUES SYMBOLNAME MODULENAME SYMBOLTYPE))
      (CL:LET* ((STREAM-006 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-006)
        "Garbage found after `" NAME "'")
       (CL:ERROR
        (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-006)))))))))

;;; (DEFUN (QUALIFIED-STELLA-NAME? BOOLEAN) ...)

(CL:DEFUN QUALIFIED-STELLA-NAME? (NAME)
  "Return TRUE if `name' is a symbol or surrogate qualified with a module
pathname or a module pathname ending with a `/'.  Assumes that `name'
is the printed representation of a STELLA symbol (potentially containing
escape characters)."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((TOK_TABLE_ *STELLA-TOKENIZER-TABLE*)
    (TOK_TRANSITIONS_ (%TRANSITIONS TOK_TABLE_))
    (TOK_STATENAMES_ (%THE-ARRAY (%STATE-NAMES TOK_TABLE_)))
    (TOK_TOKENSTART_ -1) (TOK_ENDOFTOKENS?_ CL:NIL)
    (TOK_STREAMSTATE_ NULL)
    (TOK_BUFFER_
     (CL:LET ((STRING NAME))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING)) STRING))
    (TOK_STATE_ 1) (TOK_NEXTSTATE_ TOK_STATE_) (TOK_CURSOR_ 0)
    (TOK_SIZE_ (CL:THE CL:FIXNUM (CL:LENGTH NAME)))
    (TOK_END_ TOK_SIZE_))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOK_TRANSITIONS_)
    (CL:TYPE CL:SIMPLE-VECTOR TOK_STATENAMES_)
    (CL:TYPE CL:FIXNUM TOK_TOKENSTART_ TOK_STATE_ TOK_NEXTSTATE_
     TOK_CURSOR_ TOK_SIZE_ TOK_END_))
   (CL:PROGN (CL:SETQ TOK_STATENAMES_ TOK_STATENAMES_)
    (CL:SETQ TOK_ENDOFTOKENS?_ TOK_ENDOFTOKENS?_))
   (CL:SETQ TOK_STREAMSTATE_ TOK_STREAMSTATE_)
   (CL:LET*
    ((TOK_STELLALOGICALSTATENAMES_
      (%THE-ARRAY *STELLA-LOGICAL-STATE-NAMES*))
     (TOK_STELLALOGICALSTATENAME_ NULL))
    (CL:DECLARE
     (CL:TYPE CL:SIMPLE-VECTOR TOK_STELLALOGICALSTATENAMES_))
    (CL:PROGN
     (CL:PROGN (CL:SETQ TOK_TOKENSTART_ -1)
      (CL:LOOP
       (CL:WHEN (CL:= TOK_CURSOR_ TOK_END_)
        (CL:COND
         ((CL:= TOK_NEXTSTATE_ -1) (CL:SETQ TOK_ENDOFTOKENS?_ CL:T))
         ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%THE-ARRAY (%LEGAL-EOF-STATES TOK_TABLE_)))
            TOK_STATE_))
          (CL:SETQ TOK_NEXTSTATE_ -1)
          (CL:WHEN (CL:= TOK_TOKENSTART_ -1)
           (CL:SETQ TOK_ENDOFTOKENS?_ CL:T)))
         (CL:T (CL:SETQ TOK_STATE_ 0) (CL:SETQ TOK_NEXTSTATE_ -1)))
        (CL:RETURN))
       (CL:SETQ TOK_NEXTSTATE_
        (CL:THE CL:FIXNUM
         (CL:CHAR-CODE
          (CL:LET
           ((SELF TOK_TRANSITIONS_)
            (POSITION
             (CL:THE CL:FIXNUM
              (CL:LOGIOR (CL:THE CL:FIXNUM (CL:ASH TOK_STATE_ 8))
               (CL:THE CL:FIXNUM
                (CL:CHAR-CODE
                 (CL:LET ((BUFFER TOK_BUFFER_) (POSITION TOK_CURSOR_))
                  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
                  (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
                   (CL:THE CL:FIXNUM POSITION)))))))))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))))))
       (CL:COND
        ((CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 128)) 0)
         (CL:SETQ TOK_STATE_ TOK_NEXTSTATE_)
         (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
        ((CL:= TOK_TOKENSTART_ -1)
         (CL:WHEN
          (CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 64)) 0)
          (CL:SETQ TOK_TOKENSTART_ TOK_CURSOR_))
         (CL:SETQ TOK_STATE_
          (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 63)))
         (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
        (CL:T (CL:RETURN)))))
     (CL:SETQ TOK_STELLALOGICALSTATENAME_
      (CL:AREF TOK_STELLALOGICALSTATENAMES_ TOK_STATE_)))
    (CL:WHEN TOK_ENDOFTOKENS?_
     (CL:RETURN-FROM QUALIFIED-STELLA-NAME? CL:NIL))
    (CL:LET* ((TEST-VALUE-000 (CL:AREF TOK_STATENAMES_ TOK_STATE_)))
     (CL:COND
      ((CL:OR (CL:EQ TEST-VALUE-000 KWD-READ-QUALIFIED-SYMBOL)
        (CL:EQ TEST-VALUE-000 KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL)
        (CL:EQ TEST-VALUE-000 KWD-READ-QUALIFIED-ESCAPED-SYMBOL)
        (CL:EQ TEST-VALUE-000 KWD-READ-QUALIFIED-SURROGATE)
        (CL:EQ TEST-VALUE-000
         KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE)
        (CL:EQ TEST-VALUE-000 KWD-READ-QUALIFIED-ESCAPED-SURROGATE))
       (CL:RETURN-FROM QUALIFIED-STELLA-NAME? CL:T))
      ((CL:EQ TEST-VALUE-000 KWD-READ-QUALIFIED-NAME)
       (CL:RETURN-FROM QUALIFIED-STELLA-NAME?
        (CL:NOT (STRING-EQL? NAME "/"))))
      (CL:T (CL:RETURN-FROM QUALIFIED-STELLA-NAME? CL:NIL)))))))

;;; (DEFUN (STELLA-TOKEN-LIST-TO-S-EXPRESSION OBJECT) ...)

(CL:DEFUN STELLA-TOKEN-LIST-TO-S-EXPRESSION (TOKENLIST)
  (CL:LET*
   ((PARSEDTREE NULL) (PARSEDTREESTACK NIL) (PARSEDTOKEN NULL)
    (CONSCELL NULL) (TOKENTYPE NULL))
   (CL:LOOP
    (CL:TAGBODY (CL:SETQ TOKENTYPE (%LOGICAL-TOKEN-TYPE TOKENLIST))
     (CL:COND
      ((CL:EQ TOKENTYPE KWD-READ-OPEN-PAREN)
       (CL:WHEN (CL:NOT (CL:EQ PARSEDTREE NULL))
        (CL:SETQ PARSEDTREESTACK (CONS PARSEDTREE PARSEDTREESTACK)))
       (CL:SETQ PARSEDTREE NIL) (CL:SETQ TOKENLIST (%NEXT TOKENLIST))
       (CL:GO :CONTINUE))
      ((CL:EQ TOKENTYPE KWD-READ-CLOSE-PAREN)
       (CL:COND
        ((CL:EQ PARSEDTREESTACK NIL)
         (CL:SETQ PARSEDTREE (REVERSE PARSEDTREE)) (CL:RETURN))
        (CL:T
         (CL:LET* ((PARENTTREE PARSEDTREESTACK))
          (CL:SETQ PARSEDTREESTACK (%%REST PARSEDTREESTACK))
          (CL:SETF (%%REST PARENTTREE) (%%VALUE PARENTTREE))
          (FIRST-SETTER PARENTTREE (REVERSE PARSEDTREE))
          (CL:SETQ PARSEDTREE PARENTTREE)
          (CL:SETQ TOKENLIST (%NEXT TOKENLIST)) (CL:GO :CONTINUE)))))
      ((CL:OR (CL:EQ TOKENTYPE KWD-READ-SYMBOL)
        (CL:EQ TOKENTYPE KWD-READ-SURROGATE))
       (CL:LET*
        ((MODULENAME (%MODULE TOKENLIST)) (NAME (%CONTENT TOKENLIST))
         (MODULE
          (CL:IF (CL:NOT (CL:EQ MODULENAME STELLA::NULL-STRING))
           (GET-STELLA-MODULE MODULENAME CL:NIL) *MODULE*)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULENAME NAME))
        (CL:COND
         ((CL:EQ MODULE NULL)
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Module `"
            MODULENAME "' does not exist; current token=`" NAME "'")
           (CL:ERROR
            (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-000)))))
         ((CL:EQ TOKENTYPE KWD-READ-SURROGATE)
          (CL:SETQ PARSEDTOKEN
           (INTERN-SURROGATE-IN-MODULE NAME MODULE CL:NIL)))
         (CL:T
          (CL:SETQ PARSEDTOKEN
           (CL:IF
            (CL:AND *TRANSIENTOBJECTS?*
             (CL:EQ MODULENAME STELLA::NULL-STRING))
            (INTERN-TRANSIENT-SYMBOL NAME)
            (INTERN-SYMBOL-IN-MODULE NAME MODULE CL:NIL)))))))
      ((CL:EQ TOKENTYPE KWD-READ-KEYWORD)
       (CL:SETQ PARSEDTOKEN
        (INTERN-RIGID-SYMBOL-WRT-MODULE (%CONTENT TOKENLIST) NULL
         KEYWORD-SYM)))
      ((CL:EQ TOKENTYPE KWD-READ-STRING)
       (CL:SETQ PARSEDTOKEN
        (CL:MAKE-INSTANCE (CL:QUOTE STRING-WRAPPER)))
       (CL:SETF (%WRAPPER-VALUE PARSEDTOKEN) (%CONTENT TOKENLIST)))
      ((CL:EQ TOKENTYPE KWD-READ-INTEGER)
       (CL:SETQ PARSEDTOKEN
        (WRAP-INTEGER-VALUE (STRING-TO-INTEGER (%CONTENT TOKENLIST)))))
      ((CL:EQ TOKENTYPE KWD-READ-FLOAT)
       (CL:SETQ PARSEDTOKEN
        (CL:MAKE-INSTANCE (CL:QUOTE FLOAT-WRAPPER)))
       (CL:SETF (%WRAPPER-VALUE PARSEDTOKEN)
        (STRING-TO-FLOAT (%CONTENT TOKENLIST))))
      ((CL:EQ TOKENTYPE KWD-READ-CHARACTER)
       (CL:SETQ PARSEDTOKEN
        (CL:MAKE-INSTANCE (CL:QUOTE CHARACTER-WRAPPER)))
       (CL:SETF (%WRAPPER-VALUE PARSEDTOKEN)
        (STRING-TO-CHARACTER (%CONTENT TOKENLIST))))
      ((CL:EQ TOKENTYPE KWD-READ-COMMA)
       (CL:SETQ PARSEDTOKEN |SYM-READ-STELLA-&|))
      ((CL:EQ TOKENTYPE KWD-READ-COMMA-SPLICE)
       (CL:SETQ PARSEDTOKEN |SYM-READ-STELLA-&&|))
      ((CL:OR (CL:EQ TOKENTYPE KWD-READ-SINGLE-QUOTE)
        (CL:EQ TOKENTYPE KWD-READ-BACK-QUOTE))
       (EXPAND-QUOTE-MACRO-TOKEN TOKENLIST) (CL:GO :CONTINUE))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
         "Illegal read syntax: `" (%CONTENT TOKENLIST) "' of type `"
         TOKENTYPE "'")
        (CL:ERROR
         (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-001))))))
     (CL:COND
      ((CL:NOT (CL:EQ PARSEDTREE NULL))
       (CL:SETQ CONSCELL (CL:CONS CL:NIL CL:NIL))
       (CL:SETF (%%VALUE CONSCELL) PARSEDTOKEN)
       (CL:SETF (%%REST CONSCELL) PARSEDTREE)
       (CL:SETQ PARSEDTREE CONSCELL)
       (CL:SETQ TOKENLIST (%NEXT TOKENLIST)))
      (CL:T (CL:RETURN)))
     :CONTINUE))
   (CL:IF (CL:EQ PARSEDTREE NULL)
    (CL:RETURN-FROM STELLA-TOKEN-LIST-TO-S-EXPRESSION PARSEDTOKEN)
    (CL:RETURN-FROM STELLA-TOKEN-LIST-TO-S-EXPRESSION PARSEDTREE))))

;;; (DEFUN EXPAND-QUOTE-MACRO-TOKEN ...)

(CL:DEFUN EXPAND-QUOTE-MACRO-TOKEN (QUOTEDLIST)
  (CL:LET* ((QUOTESTRING (%CONTENT QUOTEDLIST)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUOTESTRING))
   (CL:LET* ((SELF-000 (NEW-STELLA-TOKEN)))
    (CL:SETF (%TYPE SELF-000) KWD-READ-SYMBOL)
    (CL:SETF (%LOGICAL-TOKEN-TYPE SELF-000) KWD-READ-SYMBOL)
    (CL:SETF (%CONTENT SELF-000)
     (CL:IF (STRING-EQL? QUOTESTRING "'") "QUOTE" "BQUOTE"))
    (CL:SETF (%MODULE SELF-000) "/STELLA")
    (CL:SETF (%NEXT SELF-000) (%NEXT QUOTEDLIST))
    (CL:LET* ((TOKEN SELF-000) (TOKENTYPE NULL) (BALANCE 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM BALANCE))
     (CL:SETF (%TYPE QUOTEDLIST) KWD-READ-OPEN-PAREN)
     (CL:SETF (%LOGICAL-TOKEN-TYPE QUOTEDLIST) KWD-READ-OPEN-PAREN)
     (CL:SETF (%CONTENT QUOTEDLIST) "(")
     (CL:SETF (%NEXT QUOTEDLIST) TOKEN)
     (CL:SETQ QUOTEDLIST (%NEXT TOKEN))
     (CL:LOOP (CL:SETQ TOKENTYPE (%LOGICAL-TOKEN-TYPE QUOTEDLIST))
      (CL:WHEN (CL:EQ TOKENTYPE NULL) (CL:RETURN))
      (CL:COND
       ((CL:EQ TOKENTYPE KWD-READ-OPEN-PAREN)
        (CL:SETQ BALANCE (CL:1+ BALANCE)))
       ((CL:EQ TOKENTYPE KWD-READ-CLOSE-PAREN)
        (CL:SETQ BALANCE (CL:1- BALANCE))
        (CL:COND ((CL:= BALANCE 0) (CL:RETURN))
         ((CL:< BALANCE 0)
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "Illegal `"
            QUOTESTRING "' syntax")
           (CL:ERROR
            (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-000)))))))
       (CL:T (CL:WHEN (CL:= BALANCE 0) (CL:RETURN))))
      (CL:SETQ QUOTEDLIST (%NEXT QUOTEDLIST)))
     (CL:WHEN (CL:EQ TOKENTYPE NULL)
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
        "EOF encountered while parsing `" QUOTESTRING "' syntax")
       (CL:ERROR (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-001)))))
     (CL:LET* ((SELF-005 (NEW-STELLA-TOKEN)))
      (CL:SETF (%TYPE SELF-005) KWD-READ-CLOSE-PAREN)
      (CL:SETF (%LOGICAL-TOKEN-TYPE SELF-005) KWD-READ-CLOSE-PAREN)
      (CL:SETF (%CONTENT SELF-005) ")")
      (CL:SETF (%NEXT SELF-005) (%NEXT QUOTEDLIST))
      (CL:SETQ TOKEN SELF-005))
     (CL:SETF (%NEXT QUOTEDLIST) TOKEN))))
  :VOID)

;;; (DEFUN (STRING-TO-CHARACTER CHARACTER) ...)

(CL:DEFUN STRING-TO-CHARACTER (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((CHAR
     (CL:LET ((SELF NAME) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION)))))
   (CL:WHEN (CL:> (CL:THE CL:FIXNUM (CL:LENGTH NAME)) 1)
    (CL:COND ((STRING-EQL? NAME "SPACE") (CL:SETQ CHAR #\ ))
     ((STRING-EQL? NAME "LINEFEED") (CL:SETQ CHAR #\Linefeed))
     ((STRING-EQL? NAME "NEWLINE") (CL:SETQ CHAR #\Linefeed))
     ((STRING-EQL? NAME "BACKSPACE") (CL:SETQ CHAR #\Backspace))
     ((STRING-EQL? NAME "TAB") (CL:SETQ CHAR #\Tab))
     ((STRING-EQL? NAME "RETURN") (CL:SETQ CHAR #\Return))
     ((STRING-EQL? NAME "PAGE") (CL:SETQ CHAR #\Page))
     ((STRING-EQL? NAME "NULL") (CL:SETQ CHAR NULL-CHARACTER))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
        "Illegal character constant: `" (CONCATENATE "#\\" NAME) "'")
       (CL:ERROR
        (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:RETURN-FROM STRING-TO-CHARACTER CHAR)))

;;; (DEFUN (CREATE-TOKENIZE-STRING-TABLE (VECTOR OF KEYWORD)) ...)

(CL:DEFUN CREATE-TOKENIZE-STRING-TABLE (PUNCTUATIONCHARS QUOTECHARS ESCAPECHARS)
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING PUNCTUATIONCHARS QUOTECHARS ESCAPECHARS))
  #+MCL
  (CL:CHECK-TYPE PUNCTUATIONCHARS CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE QUOTECHARS CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ESCAPECHARS CL:SIMPLE-STRING)
  (CL:LET* ((CHARTYPETABLE (NEW-VECTOR 256)))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH CHARTYPETABLE))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:IF
      (CL:EQ
       (CL:AREF *CHARACTER-TYPE-TABLE*
        (CL:THE CL:FIXNUM (CL:CHAR-CODE (CL:CODE-CHAR I))))
       KWD-READ-WHITE-SPACE)
      (CL:LET
       ((SELF (%THE-ARRAY CHARTYPETABLE)) (VALUE KWD-READ-WHITE-SPACE)
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET
       ((SELF (%THE-ARRAY CHARTYPETABLE)) (VALUE KWD-READ-TEXT)
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((CH NULL-CHARACTER) (VECTOR-000 PUNCTUATIONCHARS) (INDEX-000 0)
     (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ CH
      (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))))
     (CL:LET
      ((SELF (%THE-ARRAY CHARTYPETABLE)) (VALUE KWD-READ-PUNCTUATION)
       (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET*
    ((CH NULL-CHARACTER) (VECTOR-001 QUOTECHARS) (INDEX-001 0)
     (LENGTH-001 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-001))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-001)
     (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
    (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
     (CL:SETQ CH
      (CL:LET ((SELF VECTOR-001) (POSITION INDEX-001))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))))
     (CL:LET
      ((SELF (%THE-ARRAY CHARTYPETABLE)) (VALUE KWD-READ-QUOTE)
       (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
   (CL:LET*
    ((CH NULL-CHARACTER) (VECTOR-002 ESCAPECHARS) (INDEX-002 0)
     (LENGTH-002 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-002))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-002)
     (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
    (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
     (CL:SETQ CH
      (CL:LET ((SELF VECTOR-002) (POSITION INDEX-002))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))))
     (CL:LET
      ((SELF (%THE-ARRAY CHARTYPETABLE)) (VALUE KWD-READ-ESCAPE)
       (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
   (CL:RETURN-FROM CREATE-TOKENIZE-STRING-TABLE CHARTYPETABLE)))

;;; (DEFUN (TOKENIZE-STRING (CONS OF CONS)) ...)

(CL:DEFUN TOKENIZE-STRING (STRING PUNCTUATIONCHARS QUOTECHARS ESCAPECHARS)
  "Simple tokenizer that is somewhere between Java's StringTokenizer
and StreamTokenizer in functionality.  It doens't specially support number
tokens nor comment strings/sequences even though this could be added at
the expense of some extra complexity.
Returns a list of (<token-string> <token-type>) pairs, where the token
type is one of :TEXT, :PUNCTUATION or :QUOTE, i.e., all white space
is ignored and escape characters are handled and removed.  For example:
	 
  (tokenize-string \"for(i='fo^'o'; i>0; i++)\" \"()=<>+-;\" \"'\" \"^\")
  =>
  ((\"for\" :TEXT) (\"(\" :PUNCTUATION) (\"i\" :TEXT)
   (\"=\" :PUNCTUATION) (\"'\" :QUOTE) (\"fo'o\" :TEXT)
   (\"'\" :QUOTE) (\";\" :PUNCTUATION) (\"i\" :TEXT)
   (\">\" :PUNCTUATION) (\"0\" :TEXT) (\";\" :PUNCTUATION)
   (\"i\" :TEXT) (\"++)\" :PUNCTUATION))
	
NOTE: this aggregates multiple punctuation characters that immediately
follow each other into a single token which is (generally) useful to pickup
multi-character operators such as ++, >=, etc.  It's still easy to pick them
apart in a post-processing step if necessary (e.g., for the `++)' case above),
so we leave this for now as a feature."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING STRING PUNCTUATIONCHARS QUOTECHARS
    ESCAPECHARS))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PUNCTUATIONCHARS CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE QUOTECHARS CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ESCAPECHARS CL:SIMPLE-STRING)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-READ-STELLA-F-TOKENIZE-STRING-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-READ-STELLA-F-TOKENIZE-STRING-MEMO-TABLE-000
      "(:MAX-VALUES 10)")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE-VALUE
       SGT-READ-STELLA-F-TOKENIZE-STRING-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000
      (WRAP-STRING PUNCTUATIONCHARS) (WRAP-STRING QUOTECHARS)
      (WRAP-STRING ESCAPECHARS) MEMOIZED-NULL-VALUE 0))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (CREATE-TOKENIZE-STRING-TABLE PUNCTUATIONCHARS QUOTECHARS
       ESCAPECHARS))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET*
    ((CHARTYPETABLE MEMOIZED-VALUE-000) (I 0) (CH NULL-CHARACTER)
     (START 0) (END (CL:THE CL:FIXNUM (CL:LENGTH STRING)))
     (STATE KWD-READ-TEXT) (NEWSTATE KWD-READ-TEXT)
     (QUOTEDTOKEN? CL:NIL) (QUOTECHAR NULL-CHARACTER)
     (ENDOFTOKEN? CL:NIL) (ESCAPEPOSITIONS NIL)
     (TOKEN STELLA::NULL-STRING) (RESULT NIL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I START END)
     (CL:TYPE CL:SIMPLE-STRING TOKEN))
    (CL:LOOP
     (CL:TAGBODY (CL:SETQ ENDOFTOKEN? CL:NIL)
      (CL:WHEN (CL:< I END)
       (CL:SETQ CH
        (CL:LET ((SELF STRING) (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))
       (CL:SETQ NEWSTATE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY CHARTYPETABLE))
         (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))))
       (CL:COND
        ((CL:EQ NEWSTATE KWD-READ-TEXT)
         (CL:COND
          ((CL:OR (CL:EQ STATE KWD-READ-PUNCTUATION)
            (CL:EQ STATE KWD-READ-WHITE-SPACE)
            (CL:EQ STATE KWD-READ-QUOTE))
           (CL:SETQ ENDOFTOKEN? CL:T))
          (CL:T)))
        ((CL:EQ NEWSTATE KWD-READ-ESCAPE)
         (CL:COND
          ((CL:OR (CL:EQ STATE KWD-READ-PUNCTUATION)
            (CL:EQ STATE KWD-READ-WHITE-SPACE)
            (CL:EQ STATE KWD-READ-QUOTE))
           (CL:SETQ ENDOFTOKEN? CL:T))
          (CL:T))
         (CL:SETQ ESCAPEPOSITIONS
          (CONS (WRAP-INTEGER I) ESCAPEPOSITIONS))
         (CL:SETQ I (CL:+ I 2)) (CL:GO :CONTINUE))
        ((CL:EQ NEWSTATE KWD-READ-QUOTE)
         (CL:COND
          ((CL:AND QUOTEDTOKEN? (CL:EQL CH QUOTECHAR))
           (CL:SETQ ENDOFTOKEN? CL:T) (CL:SETQ QUOTEDTOKEN? CL:NIL))
          (QUOTEDTOKEN? (CL:SETQ NEWSTATE KWD-READ-TEXT))
          (CL:T (CL:SETQ ENDOFTOKEN? CL:T) (CL:SETQ QUOTEDTOKEN? CL:T)
           (CL:SETQ QUOTECHAR CH))))
        ((CL:EQ NEWSTATE KWD-READ-PUNCTUATION)
         (CL:COND
          ((CL:EQ STATE KWD-READ-TEXT)
           (CL:IF QUOTEDTOKEN? (CL:SETQ NEWSTATE KWD-READ-TEXT)
            (CL:SETQ ENDOFTOKEN? CL:T)))
          ((CL:OR (CL:EQ STATE KWD-READ-WHITE-SPACE)
            (CL:EQ STATE KWD-READ-QUOTE))
           (CL:SETQ ENDOFTOKEN? CL:T))
          (CL:T)))
        ((CL:EQ NEWSTATE KWD-READ-WHITE-SPACE)
         (CL:COND
          ((CL:EQ STATE KWD-READ-TEXT)
           (CL:IF QUOTEDTOKEN? (CL:SETQ NEWSTATE KWD-READ-TEXT)
            (CL:SETQ ENDOFTOKEN? CL:T)))
          ((CL:OR (CL:EQ STATE KWD-READ-PUNCTUATION)
            (CL:EQ STATE KWD-READ-QUOTE))
           (CL:SETQ ENDOFTOKEN? CL:T))
          (CL:T)))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" NEWSTATE
           "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
      (CL:WHEN (CL:OR (CL:AND ENDOFTOKEN? (CL:> I 0)) (CL:>= I END))
       (CL:WHEN (CL:NOT (CL:EQ STATE KWD-READ-WHITE-SPACE))
        (CL:COND
         ((CL:NOT (CL:EQ ESCAPEPOSITIONS NIL))
          (CL:LET* ((PARTS NIL) (S START))
           (CL:DECLARE (CL:TYPE CL:FIXNUM S))
           (CL:LET* ((E NULL) (ITER-000 (REVERSE ESCAPEPOSITIONS)))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
             (CL:SETQ E (%%VALUE ITER-000))
             (CL:SETQ PARTS
              (CONS
               (WRAP-STRING (SUBSEQUENCE STRING S (%WRAPPER-VALUE E)))
               PARTS))
             (CL:SETQ S (CL:1+ (%WRAPPER-VALUE E)))
             (CL:SETQ ITER-000 (%%REST ITER-000))))
           (CL:SETQ PARTS
            (CONS
             (WRAP-STRING (SUBSEQUENCE STRING (MIN S END) (MIN I END)))
             PARTS))
           (CL:SETQ PARTS (REVERSE PARTS))
           (CL:SETQ TOKEN
            (STRING-CONCATENATE (%WRAPPER-VALUE (%%VALUE PARTS))
             (%WRAPPER-VALUE (%%VALUE (%%REST PARTS)))))
           (CL:LET* ((PART NULL) (ITER-001 (%%REST (%%REST PARTS))))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
             (CL:SETQ PART (%%VALUE ITER-001))
             (CL:SETQ TOKEN
              (STRING-CONCATENATE TOKEN (%WRAPPER-VALUE PART)))
             (CL:SETQ ITER-001 (%%REST ITER-001)))))
          (CL:SETQ ESCAPEPOSITIONS NIL))
         (CL:T (CL:SETQ TOKEN (SUBSEQUENCE STRING START I))))
        (CL:SETQ RESULT
         (CONS (CONS (WRAP-STRING TOKEN) (CONS STATE NIL)) RESULT)))
       (CL:WHEN (CL:>= I END) (CL:RETURN)) (CL:SETQ START I))
      (CL:SETQ STATE NEWSTATE) (CL:SETQ I (CL:1+ I)) :CONTINUE))
    (CL:RETURN-FROM TOKENIZE-STRING (REVERSE RESULT)))))

;;; (DEFUN (READ-S-EXPRESSION OBJECT BOOLEAN) ...)

(CL:DEFUN READ-S-EXPRESSION (STREAM)
  "Read one STELLA s-expression from `stream' and return
the result.  Return `true' as the second value on EOF."
  (CL:LET*
   ((TOKENIZERSTATE (%TOKENIZER-STATE STREAM))
    (TOKENLIST
     (CL:IF (CL:NOT (CL:EQ TOKENIZERSTATE NULL))
      (%TOKEN-LIST TOKENIZERSTATE) NULL)))
   (CL:COND
    ((CL:NOT (CL:EQ TOKENLIST NULL))
     (CL:SETQ TOKENLIST (TOKENIZE-S-EXPRESSION STREAM TOKENLIST)))
    (CL:T (CL:SETQ TOKENLIST (TOKENIZE-S-EXPRESSION STREAM NULL))
     (CL:SETF (%TOKEN-LIST (%TOKENIZER-STATE STREAM)) TOKENLIST)))
   (CL:WHEN (CL:EQ TOKENLIST NULL)
    (CL:RETURN-FROM READ-S-EXPRESSION (CL:VALUES NULL CL:T)))
   (CL:WHEN
    (CL:OR (CL:EQ STREAM STANDARD-INPUT)
     (CL:NOT (CL:EQ (%ECHO-STREAM STREAM) NULL)))
    (EAT-NEXT-CHARACTER-IF-WHITESPACE STREAM))
   (CL:RETURN-FROM READ-S-EXPRESSION
    (CL:VALUES (STELLA-TOKEN-LIST-TO-S-EXPRESSION TOKENLIST) CL:NIL))))

;;; (DEFGLOBAL *STELLA-TOKENIZER-WHITE-SPACE-STATE* ...)

(CL:DEFVAR *STELLA-TOKENIZER-WHITE-SPACE-STATE* NULL-INTEGER)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *STELLA-TOKENIZER-WHITE-SPACE-STATE*))

;;; (DEFUN (EAT-NEXT-CHARACTER-IF-WHITESPACE BOOLEAN) ...)

(CL:DEFUN EAT-NEXT-CHARACTER-IF-WHITESPACE (STREAM)
  (CL:LET* ((CHAR NULL-CHARACTER) (EOF? CL:NIL))
   (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-CHARACTER STREAM))
   (CL:WHEN EOF?
    (CL:RETURN-FROM EAT-NEXT-CHARACTER-IF-WHITESPACE CL:T))
   (CL:COND
    ((CL:EQ
      (CL:AREF *CHARACTER-TYPE-TABLE*
       (CL:THE CL:FIXNUM (CL:CHAR-CODE CHAR)))
      KWD-READ-WHITE-SPACE)
     (CL:LET* ((STATE (%TOKENIZER-STATE STREAM)))
      (CL:WHEN (CL:NOT (CL:EQ STATE NULL))
       (CL:SETF (%STATE STATE) *STELLA-TOKENIZER-WHITE-SPACE-STATE*))))
    (CL:T (UNREAD-CHARACTER CHAR STREAM)))
   (CL:RETURN-FROM EAT-NEXT-CHARACTER-IF-WHITESPACE CL:NIL)))

;;; (DEFUN (CONSUME-WHITESPACE BOOLEAN) ...)

(CL:DEFUN CONSUME-WHITESPACE (STREAM)
  (CL:LOOP
   (CL:LET* ((CHAR NULL-CHARACTER) (EOF? CL:NIL))
    (CL:MULTIPLE-VALUE-SETQ (CHAR EOF?) (READ-CHARACTER STREAM))
    (CL:WHEN EOF? (CL:RETURN-FROM CONSUME-WHITESPACE CL:T))
    (CL:WHEN
     (CL:NOT
      (CL:EQ
       (CL:AREF *CHARACTER-TYPE-TABLE*
        (CL:THE CL:FIXNUM (CL:CHAR-CODE CHAR)))
       KWD-READ-WHITE-SPACE))
     (UNREAD-CHARACTER CHAR STREAM) (CL:RETURN))))
  (CL:RETURN-FROM CONSUME-WHITESPACE CL:NIL))

;;; (DEFUN (READ-S-EXPRESSION-FROM-STRING OBJECT) ...)

(CL:DEFUN READ-S-EXPRESSION-FROM-STRING (STRING)
  "Read one STELLA s-expression from `string' and
return the result."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:RETURN-FROM READ-S-EXPRESSION-FROM-STRING
   (READ-S-EXPRESSION (MAKE-TOKENIZER-STRING-STREAM STRING))))

;;; (DEFUN (MAKE-TOKENIZER-STRING-STREAM STRING-INPUT-STREAM) ...)

(CL:DEFUN MAKE-TOKENIZER-STRING-STREAM (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:LET*
   ((STREAM (NEW-INPUT-STRING-STREAM STRING))
    (STATE (CL:MAKE-INSTANCE (CL:QUOTE TOKENIZER-STREAM-STATE)))
    (LENGTH (CL:1+ (CL:THE CL:FIXNUM (CL:LENGTH STRING)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH))
   (CL:SETF (%BUFFER STATE) (CL:MAKE-STRING LENGTH))
   (CL:SETF (%BUFFER-SIZE STATE) LENGTH)
   (CL:SETF (%CURSOR STATE) LENGTH) (CL:SETF (%END STATE) LENGTH)
   (CL:SETF (%STATE STATE) 1) (CL:SETF (%TABLE STATE) NULL)
   (CL:SETF (%STATE-DICTIONARY STATE) NULL)
   (CL:SETF (%TOKEN-LIST STATE) (NEW-STELLA-TOKEN))
   (CL:SETF (%TOKENIZER-STATE STREAM) STATE)
   (CL:RETURN-FROM MAKE-TOKENIZER-STRING-STREAM STREAM)))

;;; (DEFUN (NATIVE-READ-LINE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) NATIVE-READ-LINE))
(CL:DEFUN NATIVE-READ-LINE (INPUTSTREAM)
  "Read one line from `inputStream' using the native language
readline algorithm and return the result.  On EOF return `null'"
  (CL:WHEN (CL:NOT (CL:EQ (%TOKENIZER-STATE INPUTSTREAM) NULL))
   (CL:RETURN-FROM NATIVE-READ-LINE
    (READ-LINE-FROM-TOKENIZER-BUFFER INPUTSTREAM)))
  (CL:LET*
   ((STREAM (%NATIVE-STREAM INPUTSTREAM))
    (ECHOSTREAM (%ECHO-STREAM INPUTSTREAM))
    (INPUT STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT)) 
   (setq input
         #+:stella-coerce-readline
         (CL:HANDLER-CASE
             (CL:COERCE (CL:read-line stream CL:T) 'CL:SIMPLE-STRING)
             (CL:END-OF-FILE ()  NULL-STRING))
         #-:stella-coerce-readline
         (CL:read-line stream CL-NIL NULL-STRING))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ ECHOSTREAM NULL))
     (CL:NOT (CL:EQ INPUT STELLA::NULL-STRING)))
    (%%PRINT-STREAM (%NATIVE-STREAM ECHOSTREAM) INPUT EOL))
   (CL:RETURN-FROM NATIVE-READ-LINE INPUT)))

;;; (DEFGLOBAL *READ-LINE-TOKENIZER-TABLE-DEFINITION* ...)

(CL:DEFVAR *READ-LINE-TOKENIZER-TABLE-DEFINITION* NULL)

;;; (DEFGLOBAL *READ-LINE2-TOKENIZER-TABLE-DEFINITION* ...)

(CL:DEFVAR *READ-LINE2-TOKENIZER-TABLE-DEFINITION* NULL)

;;; (DEFGLOBAL *READ-LINE-TOKENIZER-TABLE* ...)

(CL:DEFVAR *READ-LINE-TOKENIZER-TABLE* NULL)

;;; (DEFGLOBAL *READ-LINE2-TOKENIZER-TABLE* ...)

(CL:DEFVAR *READ-LINE2-TOKENIZER-TABLE* NULL)

;;; (DEFUN (READ-LINE STRING) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) READ-LINE))
(CL:DEFUN READ-LINE (STREAM)
  "Read one line from `stream' and return the result.
This differs from `native-read-line' in that it is not platform-dependent.
It recognizes any of the three common line ending formats: CR, LF, CR-LF
in any combination.  It is not as fast as `native-read-line', however."
  (CL:WHEN (CL:EQ STREAM STANDARD-INPUT)
   (CL:RETURN-FROM READ-LINE (NATIVE-READ-LINE STREAM)))
  (CL:LET*
   ((TOK_TABLE_ *READ-LINE-TOKENIZER-TABLE*)
    (TOK_TRANSITIONS_ (%TRANSITIONS TOK_TABLE_))
    (TOK_STATENAMES_ (%THE-ARRAY (%STATE-NAMES TOK_TABLE_)))
    (TOK_TOKENSTART_ -1) (TOK_ENDOFTOKENS?_ CL:NIL)
    (TOK_INPUTSTREAM_ STREAM)
    (TOK_ECHOSTREAM_ (%ECHO-STREAM TOK_INPUTSTREAM_))
    (TOK_STREAMSTATE_
     (CL:IF (CL:EQ (%TOKENIZER-STATE TOK_INPUTSTREAM_) NULL)
      (CL:SETF (%TOKENIZER-STATE TOK_INPUTSTREAM_)
       (NEW-TOKENIZER-STREAM-STATE))
      (%TOKENIZER-STATE TOK_INPUTSTREAM_)))
    (TOK_BUFFER_ (%BUFFER TOK_STREAMSTATE_))
    (TOK_SIZE_ (%BUFFER-SIZE TOK_STREAMSTATE_))
    (TOK_STATE_ (GET-SAVED-STATE TOK_STREAMSTATE_ TOK_TABLE_))
    (TOK_NEXTSTATE_ TOK_STATE_)
    (TOK_CURSOR_ (%CURSOR TOK_STREAMSTATE_))
    (TOK_END_ (%END TOK_STREAMSTATE_))
    (TOK_CHECKPOINT_
     (CL:IF (CL:<= TOK_CURSOR_ TOK_END_) TOK_END_ TOK_SIZE_)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOK_TRANSITIONS_)
    (CL:TYPE CL:SIMPLE-VECTOR TOK_STATENAMES_)
    (CL:TYPE CL:FIXNUM TOK_TOKENSTART_ TOK_SIZE_ TOK_STATE_
     TOK_NEXTSTATE_ TOK_CURSOR_ TOK_END_ TOK_CHECKPOINT_))
   (CL:PROGN (CL:SETQ TOK_STATENAMES_ TOK_STATENAMES_)
    (CL:SETQ TOK_ENDOFTOKENS?_ TOK_ENDOFTOKENS?_))
   (CL:LOOP
    (CL:PROGN (CL:SETQ TOK_TOKENSTART_ -1)
     (CL:LOOP
      (CL:WHEN (CL:= TOK_CURSOR_ TOK_CHECKPOINT_)
       (CL:COND
        ((CL:= TOK_CURSOR_ TOK_END_)
         (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
         (CL:SETQ TOK_ENDOFTOKENS?_
          (READ-INTO-TOKENIZER-BUFFER TOK_INPUTSTREAM_ TOK_STREAMSTATE_
           TOK_TOKENSTART_))
         (CL:SETQ TOK_BUFFER_ (%BUFFER TOK_STREAMSTATE_))
         (CL:SETQ TOK_SIZE_ (%BUFFER-SIZE TOK_STREAMSTATE_))
         (CL:SETQ TOK_CURSOR_
          (MOD (%CURSOR TOK_STREAMSTATE_) TOK_SIZE_))
         (CL:SETQ TOK_END_ (%END TOK_STREAMSTATE_))
         (CL:WHEN TOK_ENDOFTOKENS?_
          (CL:SETQ TOK_CHECKPOINT_ TOK_CURSOR_)
          (CL:COND ((CL:= TOK_NEXTSTATE_ -1))
           ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR
               (%THE-ARRAY (%LEGAL-EOF-STATES TOK_TABLE_)))
              TOK_STATE_))
            (CL:SETQ TOK_NEXTSTATE_ -1)
            (CL:WHEN (CL:NOT (CL:= TOK_TOKENSTART_ -1))
             (CL:SETQ TOK_ENDOFTOKENS?_ CL:NIL)))
           (CL:T (CL:SETQ TOK_ENDOFTOKENS?_ CL:NIL)
            (CL:SETQ TOK_STATE_ 0) (CL:SETQ TOK_NEXTSTATE_ -1)))
          (CL:RETURN))
         (CL:IF (CL:>= TOK_CURSOR_ TOK_END_)
          (CL:SETQ TOK_CHECKPOINT_ TOK_SIZE_)
          (CL:SETQ TOK_CHECKPOINT_ TOK_END_)))
        (CL:T (CL:SETQ TOK_CHECKPOINT_ TOK_END_)
         (CL:SETQ TOK_CURSOR_ 0))))
      (CL:SETQ TOK_NEXTSTATE_
       (CL:THE CL:FIXNUM
        (CL:CHAR-CODE
         (CL:LET
          ((SELF TOK_TRANSITIONS_)
           (POSITION
            (CL:THE CL:FIXNUM
             (CL:LOGIOR (CL:THE CL:FIXNUM (CL:ASH TOK_STATE_ 8))
              (CL:THE CL:FIXNUM
               (CL:CHAR-CODE
                (CL:LET ((BUFFER TOK_BUFFER_) (POSITION TOK_CURSOR_))
                 (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
                 (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
                  (CL:THE CL:FIXNUM POSITION)))))))))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))))
      (CL:COND
       ((CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 128)) 0)
        (CL:SETQ TOK_STATE_ TOK_NEXTSTATE_)
        (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
       ((CL:= TOK_TOKENSTART_ -1)
        (CL:WHEN
         (CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 64)) 0)
         (CL:SETQ TOK_TOKENSTART_ TOK_CURSOR_))
        (CL:SETQ TOK_STATE_
         (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 63)))
        (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
       (CL:T (CL:RETURN)))
      (CL:WHEN (CL:NOT (CL:EQ TOK_ECHOSTREAM_ NULL))
       (%%PRINT-STREAM (%NATIVE-STREAM TOK_ECHOSTREAM_)
        (CL:LET ((BUFFER TOK_BUFFER_) (POSITION (CL:1- TOK_CURSOR_)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
          (CL:THE CL:FIXNUM POSITION)))))))
    (CL:WHEN TOK_ENDOFTOKENS?_
     (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
      (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
      (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
      (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
     (CL:RETURN-FROM READ-LINE STELLA::NULL-STRING))
    (CL:LET* ((TEST-VALUE-000 (CL:AREF TOK_STATENAMES_ TOK_STATE_)))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 KWD-READ-LINE)
       (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
        (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
        (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
        (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
       (CL:RETURN-FROM READ-LINE
        (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
         TOK_CURSOR_ TOK_SIZE_ CL:NIL)))
      ((CL:OR (CL:EQ TEST-VALUE-000 KWD-READ-RETURN)
        (CL:EQ TEST-VALUE-000 KWD-READ-LINEFEED)))
      ((CL:OR (CL:EQ TEST-VALUE-000 KWD-READ-INITIAL-LINEFEED)
        (CL:EQ TEST-VALUE-000 KWD-READ-INITIAL-RETURN))
       (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
        (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
        (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
        (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
       (CL:RETURN-FROM READ-LINE ""))
      ((CL:EQ TEST-VALUE-000 KWD-READ-ERROR)
       (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
        (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
        (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
        (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
         "Illegal read syntax: `"
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
          TOK_CURSOR_ TOK_SIZE_ CL:NIL)
         "'")
        (CL:ERROR
         (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-000)))))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-000
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))))

;;; (DEFUN (READ-LINE2 STRING KEYWORD) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) (CL:VALUES CL:SIMPLE-STRING CL:T))
  READ-LINE2))
(CL:DEFUN READ-LINE2 (STREAM)
  "Read one line from `stream' and return the result and
a keyword that indicates the terminator for that line ending:
`:CR' `:LF' `:CRLF' or `:EOF'.   This is not platform-dependent
and differs from `read-line' by returning a second value.  It
may hang when used on interactive streams such as terminal or
network streams with only CR line endings.  It should only be
used on file or string input streams."
  (CL:LET* ((LINE "")) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LINE))
   (CL:LET*
    ((TOK_TABLE_ *READ-LINE-TOKENIZER-TABLE*)
     (TOK_TRANSITIONS_ (%TRANSITIONS TOK_TABLE_))
     (TOK_STATENAMES_ (%THE-ARRAY (%STATE-NAMES TOK_TABLE_)))
     (TOK_TOKENSTART_ -1) (TOK_ENDOFTOKENS?_ CL:NIL)
     (TOK_INPUTSTREAM_ STREAM)
     (TOK_ECHOSTREAM_ (%ECHO-STREAM TOK_INPUTSTREAM_))
     (TOK_STREAMSTATE_
      (CL:IF (CL:EQ (%TOKENIZER-STATE TOK_INPUTSTREAM_) NULL)
       (CL:SETF (%TOKENIZER-STATE TOK_INPUTSTREAM_)
        (NEW-TOKENIZER-STREAM-STATE))
       (%TOKENIZER-STATE TOK_INPUTSTREAM_)))
     (TOK_BUFFER_ (%BUFFER TOK_STREAMSTATE_))
     (TOK_SIZE_ (%BUFFER-SIZE TOK_STREAMSTATE_))
     (TOK_STATE_ (GET-SAVED-STATE TOK_STREAMSTATE_ TOK_TABLE_))
     (TOK_NEXTSTATE_ TOK_STATE_)
     (TOK_CURSOR_ (%CURSOR TOK_STREAMSTATE_))
     (TOK_END_ (%END TOK_STREAMSTATE_))
     (TOK_CHECKPOINT_
      (CL:IF (CL:<= TOK_CURSOR_ TOK_END_) TOK_END_ TOK_SIZE_)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOK_TRANSITIONS_)
     (CL:TYPE CL:SIMPLE-VECTOR TOK_STATENAMES_)
     (CL:TYPE CL:FIXNUM TOK_TOKENSTART_ TOK_SIZE_ TOK_STATE_
      TOK_NEXTSTATE_ TOK_CURSOR_ TOK_END_ TOK_CHECKPOINT_))
    (CL:PROGN (CL:SETQ TOK_STATENAMES_ TOK_STATENAMES_)
     (CL:SETQ TOK_ENDOFTOKENS?_ TOK_ENDOFTOKENS?_))
    (CL:LOOP
     (CL:PROGN (CL:SETQ TOK_TOKENSTART_ -1)
      (CL:LOOP
       (CL:WHEN (CL:= TOK_CURSOR_ TOK_CHECKPOINT_)
        (CL:COND
         ((CL:= TOK_CURSOR_ TOK_END_)
          (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
          (CL:SETQ TOK_ENDOFTOKENS?_
           (READ-INTO-TOKENIZER-BUFFER TOK_INPUTSTREAM_
            TOK_STREAMSTATE_ TOK_TOKENSTART_))
          (CL:SETQ TOK_BUFFER_ (%BUFFER TOK_STREAMSTATE_))
          (CL:SETQ TOK_SIZE_ (%BUFFER-SIZE TOK_STREAMSTATE_))
          (CL:SETQ TOK_CURSOR_
           (MOD (%CURSOR TOK_STREAMSTATE_) TOK_SIZE_))
          (CL:SETQ TOK_END_ (%END TOK_STREAMSTATE_))
          (CL:WHEN TOK_ENDOFTOKENS?_
           (CL:SETQ TOK_CHECKPOINT_ TOK_CURSOR_)
           (CL:COND ((CL:= TOK_NEXTSTATE_ -1))
            ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR
                (%THE-ARRAY (%LEGAL-EOF-STATES TOK_TABLE_)))
               TOK_STATE_))
             (CL:SETQ TOK_NEXTSTATE_ -1)
             (CL:WHEN (CL:NOT (CL:= TOK_TOKENSTART_ -1))
              (CL:SETQ TOK_ENDOFTOKENS?_ CL:NIL)))
            (CL:T (CL:SETQ TOK_ENDOFTOKENS?_ CL:NIL)
             (CL:SETQ TOK_STATE_ 0) (CL:SETQ TOK_NEXTSTATE_ -1)))
           (CL:RETURN))
          (CL:IF (CL:>= TOK_CURSOR_ TOK_END_)
           (CL:SETQ TOK_CHECKPOINT_ TOK_SIZE_)
           (CL:SETQ TOK_CHECKPOINT_ TOK_END_)))
         (CL:T (CL:SETQ TOK_CHECKPOINT_ TOK_END_)
          (CL:SETQ TOK_CURSOR_ 0))))
       (CL:SETQ TOK_NEXTSTATE_
        (CL:THE CL:FIXNUM
         (CL:CHAR-CODE
          (CL:LET
           ((SELF TOK_TRANSITIONS_)
            (POSITION
             (CL:THE CL:FIXNUM
              (CL:LOGIOR (CL:THE CL:FIXNUM (CL:ASH TOK_STATE_ 8))
               (CL:THE CL:FIXNUM
                (CL:CHAR-CODE
                 (CL:LET ((BUFFER TOK_BUFFER_) (POSITION TOK_CURSOR_))
                  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
                  (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
                   (CL:THE CL:FIXNUM POSITION)))))))))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))))))
       (CL:COND
        ((CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 128)) 0)
         (CL:SETQ TOK_STATE_ TOK_NEXTSTATE_)
         (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
        ((CL:= TOK_TOKENSTART_ -1)
         (CL:WHEN
          (CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 64)) 0)
          (CL:SETQ TOK_TOKENSTART_ TOK_CURSOR_))
         (CL:SETQ TOK_STATE_
          (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 63)))
         (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
        (CL:T (CL:RETURN)))
       (CL:WHEN (CL:NOT (CL:EQ TOK_ECHOSTREAM_ NULL))
        (%%PRINT-STREAM (%NATIVE-STREAM TOK_ECHOSTREAM_)
         (CL:LET ((BUFFER TOK_BUFFER_) (POSITION (CL:1- TOK_CURSOR_)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
           (CL:THE CL:FIXNUM POSITION)))))))
     (CL:WHEN TOK_ENDOFTOKENS?_
      (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
       (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
       (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
       (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
      (CL:IF (STRING-EQL? LINE "")
       (CL:RETURN-FROM READ-LINE2
        (CL:VALUES STELLA::NULL-STRING KWD-READ-EOF))
       (CL:RETURN-FROM READ-LINE2 (CL:VALUES LINE KWD-READ-EOF))))
     (CL:LET* ((TEST-VALUE-000 (CL:AREF TOK_STATENAMES_ TOK_STATE_)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-READ-LINE)
        (CL:SETQ LINE
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
          TOK_CURSOR_ TOK_SIZE_ CL:NIL)))
       ((CL:EQ TEST-VALUE-000 KWD-READ-LINEFEED)
        (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
         (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
         (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
         (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
        (CL:RETURN-FROM READ-LINE2 (CL:VALUES LINE KWD-READ-LF)))
       ((CL:EQ TEST-VALUE-000 KWD-READ-RETURN-LINEFEED)
        (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
         (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
         (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
         (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
        (CL:RETURN-FROM READ-LINE2 (CL:VALUES LINE KWD-READ-CRLF)))
       ((CL:EQ TEST-VALUE-000 KWD-READ-RETURN)
        (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
         (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
         (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
         (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
        (CL:RETURN-FROM READ-LINE2 (CL:VALUES LINE KWD-READ-CR)))
       ((CL:EQ TEST-VALUE-000 KWD-READ-ERROR)
        (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
         (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
         (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
         (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_))
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
          "Illegal read syntax: `"
          (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
           TOK_CURSOR_ TOK_SIZE_ CL:NIL)
          "'")
         (CL:ERROR
          (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-000)))))
       (CL:T
        (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-000
          "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))))))

;;; (DEFUN (READ-CHARACTER CHARACTER BOOLEAN) ...)

(CL:DEFUN READ-CHARACTER (INPUTSTREAM)
  "Read one character from `inputStream' and return the result.
Return `true' as the second value on EOF."
  (CL:WHEN (CL:NOT (CL:EQ (%TOKENIZER-STATE INPUTSTREAM) NULL))
   (CL:RETURN-FROM READ-CHARACTER
    (READ-CHARACTER-FROM-TOKENIZER-BUFFER INPUTSTREAM)))
  (CL:LET*
   ((STREAM (%NATIVE-STREAM INPUTSTREAM))
    (ECHOSTREAM (%ECHO-STREAM INPUTSTREAM)) (INPUT NULL-CHARACTER)
    (EOF CL:NIL))
   (CL:PROGN (SETQ INPUT (CL:READ-CHAR STREAM CL-NIL CL-NIL))
    (CL:WHEN (CL:NULL INPUT) (SETQ EOF TRUE)))
   (CL:WHEN (CL:AND (CL:NOT (CL:EQ ECHOSTREAM NULL)) (CL:NOT EOF))
    (%%PRINT-STREAM (%NATIVE-STREAM ECHOSTREAM) INPUT))
   (CL:RETURN-FROM READ-CHARACTER (CL:VALUES INPUT EOF))))

;;; (DEFUN UNREAD-CHARACTER ...)

(CL:DEFUN UNREAD-CHARACTER (CH INPUTSTREAM)
  "Unread `ch' from `inputStream'.  Signal an error if `ch'
was not the last character read."
  (CL:IF (CL:NOT (CL:EQ (%TOKENIZER-STATE INPUTSTREAM) NULL))
   (UNREAD-CHARACTER-FROM-TOKENIZER-BUFFER CH INPUTSTREAM)
   (CL:LET* ((STREAM (%NATIVE-STREAM INPUTSTREAM)))
    (CL:UNREAD-CHAR CH STREAM)))
  :VOID)

;;; (DEFSPECIAL *USER-QUERY-ACTION* ...)

(CL:DEFVAR *USER-QUERY-ACTION* NULL
  "Controls the behavior of interactive queries.  The default is :ASK
which asks the user.  Other options are :YES, :NO, :YES-VERBOSE, :NO-VERBOSE.  These
return the answer indicated, with the verbose versions printing the message and answer.")

;;; (DEFUN (YES-OR-NO? BOOLEAN) ...)

(CL:DEFUN YES-OR-NO? (MESSAGE)
  "Read a line of input from STANDARD-INPUT and return `true'
if the input was `yes' or `false' if the input was `no'.  Loop until either
`yes' or `no' was entered.  If 'message' is non-`null' prompt with it before
the input is read.  See also special variable `*USER-QUERY-ACTION*'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:COND
   ((CL:EQ *USER-QUERY-ACTION* KWD-READ-YES)
    (CL:RETURN-FROM YES-OR-NO? CL:T))
   ((CL:EQ *USER-QUERY-ACTION* KWD-READ-NO)
    (CL:RETURN-FROM YES-OR-NO? CL:NIL))
   ((CL:EQ *USER-QUERY-ACTION* KWD-READ-YES-VERBOSE)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) MESSAGE
     " [Auto => YES]" EOL)
    (CL:RETURN-FROM YES-OR-NO? CL:T))
   ((CL:EQ *USER-QUERY-ACTION* KWD-READ-NO-VERBOSE)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) MESSAGE
     " [Auto => NO]" EOL)
    (CL:RETURN-FROM YES-OR-NO? CL:NIL))
   ((CL:EQ *USER-QUERY-ACTION* KWD-READ-ASK)
    (CL:LET* ((INPUT STELLA::NULL-STRING) (START 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT)
      (CL:TYPE CL:FIXNUM START))
     (CL:LOOP
      (CL:WHEN (CL:NOT (CL:EQ MESSAGE STELLA::NULL-STRING))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) MESSAGE))
      (CL:SETQ INPUT (READ-LINE STANDARD-INPUT)) (CL:SETQ START 0)
      (CL:LET*
       ((CH NULL-CHARACTER) (VECTOR-000 INPUT) (INDEX-000 0)
        (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ CH
         (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))
        (CL:IF
         (CL:EQ
          (CL:AREF *CHARACTER-TYPE-TABLE*
           (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
          KWD-READ-WHITE-SPACE)
         (CL:SETQ START (CL:1+ START)) (CL:RETURN))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:WHEN (CL:> (CL:THE CL:FIXNUM (CL:LENGTH INPUT)) START)
       (CL:SETQ INPUT (SUBSEQUENCE INPUT START NULL-INTEGER))
       (CL:WHEN (STRING-EQUAL? INPUT "yes")
        (CL:RETURN-FROM YES-OR-NO? CL:T))
       (CL:WHEN (STRING-EQUAL? INPUT "no")
        (CL:RETURN-FROM YES-OR-NO? CL:NIL))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "Type `yes' for yes or `no' for no." EOL)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
      *USER-QUERY-ACTION* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (Y-OR-N? BOOLEAN) ...)

(CL:DEFUN Y-OR-N? (MESSAGE)
  "Read a line of input from STANDARD-INPUT and return `true'
if the input was `y' or `false' if the input was `n'.  Loop until either
`y' or `n' was entered.  If 'message' is non-`null' prompt with it before
the input is read.  See also special variable `*USER-QUERY-ACTION*'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:COND
   ((CL:EQ *USER-QUERY-ACTION* KWD-READ-YES)
    (CL:RETURN-FROM Y-OR-N? CL:T))
   ((CL:EQ *USER-QUERY-ACTION* KWD-READ-NO)
    (CL:RETURN-FROM Y-OR-N? CL:NIL))
   ((CL:EQ *USER-QUERY-ACTION* KWD-READ-YES-VERBOSE)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) MESSAGE
     " [Auto => Y]" EOL)
    (CL:RETURN-FROM Y-OR-N? CL:T))
   ((CL:EQ *USER-QUERY-ACTION* KWD-READ-NO-VERBOSE)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) MESSAGE
     " [Auto => N]" EOL)
    (CL:RETURN-FROM Y-OR-N? CL:NIL))
   ((CL:EQ *USER-QUERY-ACTION* KWD-READ-ASK)
    (CL:LET* ((INPUT STELLA::NULL-STRING) (START 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT)
      (CL:TYPE CL:FIXNUM START))
     (CL:LOOP
      (CL:WHEN (CL:NOT (CL:EQ MESSAGE STELLA::NULL-STRING))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) MESSAGE))
      (CL:SETQ INPUT (READ-LINE STANDARD-INPUT)) (CL:SETQ START 0)
      (CL:LET*
       ((CH NULL-CHARACTER) (VECTOR-000 INPUT) (INDEX-000 0)
        (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ CH
         (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))
        (CL:IF
         (CL:EQ
          (CL:AREF *CHARACTER-TYPE-TABLE*
           (CL:THE CL:FIXNUM (CL:CHAR-CODE CH)))
          KWD-READ-WHITE-SPACE)
         (CL:SETQ START (CL:1+ START)) (CL:RETURN))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:WHEN (CL:> (CL:THE CL:FIXNUM (CL:LENGTH INPUT)) START)
       (CL:CASE
        (CL:LET ((SELF INPUT) (POSITION START))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION)))
        ((#\y #\Y) (CL:RETURN-FROM Y-OR-N? CL:T))
        ((#\n #\N) (CL:RETURN-FROM Y-OR-N? CL:NIL)) (CL:OTHERWISE)))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "Type `y' for yes or `n' for no." EOL))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
      *USER-QUERY-ACTION* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD (STREAM-TO-STRING STRING) ...)

(CL:DEFMETHOD STREAM-TO-STRING ((FROM INPUT-STREAM))
  "Read all of the input from `stream' and return it as a string."
  (CL:LET*
   ((TO (NEW-OUTPUT-STRING-STREAM))
    (BUFFER (CL:MAKE-STRING *TOKENIZER-INITIAL-BUFFER-SIZE*))
    (BYTES-READ 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM BYTES-READ))
   (CL:LOOP
    (CL:SETQ BYTES-READ
     (BYTE-ARRAY-READ-SEQUENCE BUFFER FROM 0
      *TOKENIZER-INITIAL-BUFFER-SIZE*))
    (CL:IF (CL:> BYTES-READ 0)
     (BYTE-ARRAY-WRITE-SEQUENCE BUFFER (%NATIVE-STREAM TO) 0
      BYTES-READ)
     (CL:RETURN)))
   (CL:RETURN-FROM STREAM-TO-STRING (THE-STRING-READER TO))))

(CL:DEFUN HELP-STARTUP-READ1 ()
  (CL:PROGN
   (CL:SETQ SGT-READ-STELLA-TOKENIZER-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOKENIZER-TABLE" NULL 1))
   (CL:SETQ SYM-READ-STELLA-TRANSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSITIONS" NULL 0))
   (CL:SETQ SYM-READ-STELLA-UNIQUE-STATE-NAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNIQUE-STATE-NAMES" NULL 0))
   (CL:SETQ SYM-READ-STELLA-STATE-NAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STATE-NAMES" NULL 0))
   (CL:SETQ SYM-READ-STELLA-LEGAL-EOF-STATES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LEGAL-EOF-STATES" NULL 0))
   (CL:SETQ SYM-READ-STELLA-CHARACTER-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER-SET" NULL 0))
   (CL:SETQ KWD-READ-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ KWD-READ-START
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START" NULL 2))
   (CL:SETQ KWD-READ-EOF (INTERN-RIGID-SYMBOL-WRT-MODULE "EOF" NULL 2))
   (CL:SETQ SGT-READ-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 1))
   (CL:SETQ SGT-READ-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ KWD-READ-BLOCK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BLOCK" NULL 2))
   (CL:SETQ KWD-READ-LINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LINE" NULL 2))
   (CL:SETQ KWD-READ-CHARACTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER" NULL 2))
   (CL:SETQ SGT-READ-STELLA-TOKENIZER-TOKEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOKENIZER-TOKEN" NULL 1))
   (CL:SETQ SYM-READ-STELLA-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-CONTENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTENT" NULL 0))
   (CL:SETQ SYM-READ-STELLA-NEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEXT" NULL 0))
   (CL:SETQ SGT-READ-STELLA-TOKENIZER-STREAM-STATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOKENIZER-STREAM-STATE" NULL 1))
   (CL:SETQ SYM-READ-STELLA-BUFFER-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BUFFER-SIZE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURSOR" NULL 0))
   (CL:SETQ SYM-READ-STELLA-END
    (INTERN-RIGID-SYMBOL-WRT-MODULE "END" NULL 0))
   (CL:SETQ SYM-READ-STELLA-STATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STATE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-STATE-DICTIONARY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STATE-DICTIONARY" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOKEN-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOKEN-LIST" NULL 0))
   (CL:SETQ SGT-READ-STELLA-INPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STREAM" NULL 1))
   (CL:SETQ SGT-READ-STELLA-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
   (CL:SETQ SGT-READ-STELLA-VOID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
   (CL:SETQ SGT-READ-STELLA-MUTABLE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING" NULL 1))
   (CL:SETQ SYM-READ-STELLA-LET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_TABLE_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_TABLE_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_TRANSITIONS_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_TRANSITIONS_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_STATENAMES_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_STATENAMES_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-THE-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ARRAY" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_TOKENSTART_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_TOKENSTART_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_ENDOFTOKENS?_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_ENDOFTOKENS?_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-IGNORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IGNORE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_STREAMSTATE_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_STREAMSTATE_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOKENIZER-STREAM-STATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOKENIZER-STREAM-STATE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_BUFFER_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_BUFFER_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-STRING-TO-TOKENIZER-BYTE-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-TO-TOKENIZER-BYTE-ARRAY"
     NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_STATE_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_STATE_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_NEXTSTATE_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_NEXTSTATE_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_CURSOR_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_CURSOR_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_SIZE_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_SIZE_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-LENGTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LENGTH" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_END_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_END_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_INPUTSTREAM_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_INPUTSTREAM_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_ECHOSTREAM_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_ECHOSTREAM_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-ECHO-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ECHO-STREAM" NULL 0))
   (CL:SETQ SYM-READ-STELLA-CHOOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHOOSE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-NULL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL?" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOKENIZER-STATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOKENIZER-STATE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-SETF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETF" NULL 0))
   (CL:SETQ SYM-READ-STELLA-NEW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEW" NULL 0))
   (CL:SETQ SYM-READ-STELLA-BUFFER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BUFFER" NULL 0))
   (CL:SETQ SYM-READ-STELLA-GET-SAVED-STATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-SAVED-STATE" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-READ2 ()
  (CL:PROGN
   (CL:SETQ SYM-READ-STELLA-TOK_CHECKPOINT_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_CHECKPOINT_" NULL 0))
   (CL:SETQ SYM-READ-STELLA-<=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<=" NULL 0))
   (CL:SETQ SYM-READ-STELLA-END-OF-TOKENS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "END-OF-TOKENS?" NULL 0))
   (CL:SETQ SYM-READ-STELLA-GET-TOKEN-TEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-TOKEN-TEXT" NULL 0))
   (CL:SETQ SYM-READ-STELLA-GET-TOKEN-TEXT-INTERNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-TOKEN-TEXT-INTERNAL" NULL 0))
   (CL:SETQ SYM-READ-STELLA-+
    (INTERN-RIGID-SYMBOL-WRT-MODULE "+" NULL 0))
   (CL:SETQ SYM-READ-STELLA-<
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<" NULL 0))
   (CL:SETQ SYM-READ-STELLA-GET-TOKEN-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-TOKEN-TYPE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-NTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NTH" NULL 0))
   (CL:SETQ SYM-READ-STELLA-WHEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
   (CL:SETQ SYM-READ-STELLA-DEFINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
   (CL:SETQ SYM-READ-STELLA-GET-NEXT-TOKEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-NEXT-TOKEN" NULL 0))
   (CL:SETQ SYM-READ-STELLA-SAVE-TOKENIZER-STREAM-STATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVE-TOKENIZER-STREAM-STATE" NULL
     0))
   (CL:SETQ SYM-READ-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN" NULL 0))
   (CL:SETQ SYM-READ-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-READ-STELLA-LOOP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOP" NULL 0))
   (CL:SETQ SYM-READ-STELLA-CHARACTER-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER-CODE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-LOGOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGOR" NULL 0))
   (CL:SETQ SYM-READ-STELLA-SHIFT-LEFT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHIFT-LEFT" NULL 0))
   (CL:SETQ SYM-READ-STELLA-BYTE-ARRAY-NTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BYTE-ARRAY-NTH" NULL 0))
   (CL:SETQ SYM-READ-STELLA-COND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COND" NULL 0))
   (CL:SETQ SYM-READ-STELLA-=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=" NULL 0))
   (CL:SETQ SYM-READ-STELLA-LOGAND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGAND" NULL 0))
   (CL:SETQ SYM-READ-STELLA-++
    (INTERN-RIGID-SYMBOL-WRT-MODULE "++" NULL 0))
   (CL:SETQ SYM-READ-STELLA-OTHERWISE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-BREAK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BREAK" NULL 0))
   (CL:SETQ SYM-READ-STELLA-READ-INTO-TOKENIZER-BUFFER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "READ-INTO-TOKENIZER-BUFFER" NULL
     0))
   (CL:SETQ SYM-READ-STELLA-MOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MOD" NULL 0))
   (CL:SETQ SYM-READ-STELLA-UNLESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNLESS" NULL 0))
   (CL:SETQ SYM-READ-STELLA-IF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
   (CL:SETQ SYM-READ-STELLA->=
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">=" NULL 0))
   (CL:SETQ SYM-READ-STELLA-PRINT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-STREAM" NULL 0))
   (CL:SETQ SYM-READ-STELLA-1-
    (INTERN-RIGID-SYMBOL-WRT-MODULE "1-" NULL 0))
   (CL:SETQ SGT-READ-STELLA-STREAM-TOKENIZER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STREAM-TOKENIZER" NULL 1))
   (CL:SETQ SYM-READ-STELLA-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STREAM" NULL 0))
   (CL:SETQ KWD-READ-INCLUDE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCLUDE" NULL 2))
   (CL:SETQ KWD-READ-DELIMITER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELIMITER" NULL 2))
   (CL:SETQ KWD-READ-ATOM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ATOM" NULL 2))
   (CL:SETQ SYM-READ-STELLA-*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*" NULL 0))
   (CL:SETQ KWD-READ-OPEN-PAREN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-PAREN" NULL 2))
   (CL:SETQ KWD-READ-CLOSE-PAREN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSE-PAREN" NULL 2))
   (CL:SETQ KWD-READ-OPEN-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-STRING" NULL 2))
   (CL:SETQ KWD-READ-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 2))
   (CL:SETQ KWD-READ-SINGLE-QUOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLE-QUOTE" NULL 2))
   (CL:SETQ KWD-READ-BACK-QUOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACK-QUOTE" NULL 2))
   (CL:SETQ KWD-READ-COMMA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMA" NULL 2))
   (CL:SETQ SYM-READ-STELLA-!
    (INTERN-RIGID-SYMBOL-WRT-MODULE "!" NULL 0))
   (CL:SETQ KWD-READ-COMMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMENT" NULL 2))
   (CL:SETQ KWD-READ-HASH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HASH" NULL 2))
   (CL:SETQ KWD-READ-WHITE-SPACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHITE-SPACE" NULL 2))
   (CL:SETQ KWD-READ-OTHERWISE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 2))
   (CL:SETQ KWD-READ-PAREN-COMMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PAREN-COMMENT" NULL 2))
   (CL:SETQ KWD-READ-PAREN-COMMENT-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PAREN-COMMENT-ESCAPE" NULL 2))
   (CL:SETQ KWD-READ-PAREN-COMMENT-BAR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PAREN-COMMENT-BAR" NULL 2))
   (CL:SETQ KWD-READ-ANY (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY" NULL 2))
   (CL:SETQ KWD-READ-COMMA-SPLICE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMA-SPLICE" NULL 2))
   (CL:SETQ KWD-READ-SYMBOL-OR-SIGNED-NUMBER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OR-SIGNED-NUMBER" NULL 2))
   (CL:SETQ KWD-READ-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 2))
   (CL:SETQ KWD-READ-SYMBOL-OR-NUMBER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OR-NUMBER" NULL 2)))
  :VOID)

(CL:DEFUN HELP-STARTUP-READ3 ()
  (CL:PROGN
   (CL:SETQ KWD-READ-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 2))
   (CL:SETQ KWD-READ-SYMBOL-OR-CL-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OR-CL-SYMBOL" NULL 2))
   (CL:SETQ KWD-READ-OPEN-FULLY-ESCAPED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-FULLY-ESCAPED-SYMBOL" NULL
     2))
   (CL:SETQ KWD-READ-FULLY-ESCAPED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULLY-ESCAPED-SYMBOL" NULL 2))
   (CL:SETQ KWD-READ-ESCAPED-SYMBOL-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPED-SYMBOL-ESCAPE" NULL 2))
   (CL:SETQ KWD-READ-QUALIFIED-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUALIFIED-NAME" NULL 2))
   (CL:SETQ KWD-READ-OPEN-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-KEYWORD" NULL 2))
   (CL:SETQ KWD-READ-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" NULL 2))
   (CL:SETQ KWD-READ-OPEN-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-SURROGATE" NULL 2))
   (CL:SETQ KWD-READ-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE" NULL 2))
   (CL:SETQ KWD-READ-CLOSE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSE-STRING" NULL 2))
   (CL:SETQ KWD-READ-STRING-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-ESCAPE" NULL 2))
   (CL:SETQ KWD-READ-ESCAPED-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPED-STRING" NULL 2))
   (CL:SETQ KWD-READ-CHARACTER-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER-CONSTANT" NULL 2))
   (CL:SETQ KWD-READ-SYMBOL-OR-MANTISSA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OR-MANTISSA" NULL 2))
   (CL:SETQ KWD-READ-SYMBOL-OR-MANTISSA2
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OR-MANTISSA2" NULL 2))
   (CL:SETQ KWD-READ-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT" NULL 2))
   (CL:SETQ KWD-READ-SYMBOL-OR-EXPONENT-DELIMITER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OR-EXPONENT-DELIMITER" NULL
     2))
   (CL:SETQ KWD-READ-SYMBOL-OR-EXPONENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OR-EXPONENT" NULL 2))
   (CL:SETQ KWD-READ-SYMBOL-OR-EXPONENT2
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OR-EXPONENT2" NULL 2))
   (CL:SETQ KWD-READ-SYMBOL-OR-CL-SYMBOL2
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OR-CL-SYMBOL2" NULL 2))
   (CL:SETQ KWD-READ-SYMBOL-OR-CL-SYMBOL3
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OR-CL-SYMBOL3" NULL 2))
   (CL:SETQ KWD-READ-CL-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CL-SYMBOL" NULL 2))
   (CL:SETQ KWD-READ-ESCAPED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPED-SYMBOL" NULL 2))
   (CL:SETQ KWD-READ-CLOSE-FULLY-ESCAPED-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSE-FULLY-ESCAPED-NAME" NULL 2))
   (CL:SETQ KWD-READ-FULLY-ESCAPED-SYMBOL-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULLY-ESCAPED-SYMBOL-ESCAPE" NULL
     2))
   (CL:SETQ KWD-READ-FULLY-ESCAPED-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULLY-ESCAPED-KEYWORD" NULL 2))
   (CL:SETQ KWD-READ-ESCAPED-KEYWORD-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPED-KEYWORD-ESCAPE" NULL 2))
   (CL:SETQ KWD-READ-ESCAPED-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPED-KEYWORD" NULL 2))
   (CL:SETQ KWD-READ-FULLY-ESCAPED-KEYWORD-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULLY-ESCAPED-KEYWORD-ESCAPE" NULL
     2))
   (CL:SETQ KWD-READ-FULLY-ESCAPED-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULLY-ESCAPED-SURROGATE" NULL 2))
   (CL:SETQ KWD-READ-ESCAPED-SURROGATE-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPED-SURROGATE-ESCAPE" NULL 2))
   (CL:SETQ KWD-READ-ESCAPED-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPED-SURROGATE" NULL 2))
   (CL:SETQ KWD-READ-FULLY-ESCAPED-SURROGATE-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULLY-ESCAPED-SURROGATE-ESCAPE"
     NULL 2))
   (CL:SETQ KWD-READ-QUALIFIED-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUALIFIED-SURROGATE" NULL 2))
   (CL:SETQ KWD-READ-QUALIFIED-ESCAPED-SYMBOL-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUALIFIED-ESCAPED-SYMBOL-ESCAPE"
     NULL 2))
   (CL:SETQ KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUALIFIED-FULLY-ESCAPED-SYMBOL"
     NULL 2))
   (CL:SETQ KWD-READ-QUALIFIED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUALIFIED-SYMBOL" NULL 2))
   (CL:SETQ KWD-READ-QUALIFIED-ESCAPED-SURROGATE-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "QUALIFIED-ESCAPED-SURROGATE-ESCAPE" NULL 2))
   (CL:SETQ KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUALIFIED-FULLY-ESCAPED-SURROGATE"
     NULL 2))
   (CL:SETQ KWD-READ-QUALIFIED-ESCAPED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUALIFIED-ESCAPED-SYMBOL" NULL 2))
   (CL:SETQ KWD-READ-QUALIFIED-ESCAPED-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUALIFIED-ESCAPED-SURROGATE" NULL
     2))
   (CL:SETQ KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "QUALIFIED-FULLY-ESCAPED-SYMBOL-ESCAPE" NULL 2))
   (CL:SETQ KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "QUALIFIED-FULLY-ESCAPED-SURROGATE-ESCAPE" NULL 2))
   (CL:SETQ KWD-READ-CLOSE-BALANCED-QUOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSE-BALANCED-QUOTE" NULL 2))
   (CL:SETQ SYM-READ-STELLA-WITH-TOKENIZER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WITH-TOKENIZER" NULL 0))
   (CL:SETQ SYM-READ-STELLA-*STELLA-TOKENIZER-TABLE*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*STELLA-TOKENIZER-TABLE*" NULL 0))
   (CL:SETQ SYM-READ-STELLA-TOK_STELLALOGICALSTATENAMES_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_STELLALOGICALSTATENAMES_" NULL
     0))
   (CL:SETQ SYM-READ-STELLA-*STELLA-LOGICAL-STATE-NAMES*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*STELLA-LOGICAL-STATE-NAMES*" NULL
     0))
   (CL:SETQ SYM-READ-STELLA-TOK_STELLALOGICALSTATENAME_
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOK_STELLALOGICALSTATENAME_" NULL
     0))
   (CL:SETQ SYM-READ-STELLA-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" NULL 0))
   (CL:SETQ KWD-READ-NONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))
   (CL:SETQ
    SYM-READ-STELLA-GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL" NULL 0))
   (CL:SETQ KWD-READ-FULLY-ESCAPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULLY-ESCAPED" NULL 2))
   (CL:SETQ SYM-READ-STELLA-GET-TOKEN-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-TOKEN-INTEGER" NULL 0))
   (CL:SETQ SYM-READ-STELLA-GET-TOKEN-INTEGER-INTERNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-TOKEN-INTEGER-INTERNAL" NULL
     0))
   (CL:SETQ SYM-READ-STELLA-GET-TOKEN-LONG-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-TOKEN-LONG-INTEGER" NULL 0))
   (CL:SETQ SYM-READ-STELLA-GET-TOKEN-LONG-INTEGER-INTERNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-TOKEN-LONG-INTEGER-INTERNAL"
     NULL 0))
   (CL:SETQ SYM-READ-STELLA-GET-TOKEN-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-TOKEN-FLOAT" NULL 0))
   (CL:SETQ SYM-READ-STELLA-GET-TOKEN-FLOAT-INTERNAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GET-TOKEN-FLOAT-INTERNAL" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-READ4 ()
  (CL:PROGN
   (CL:SETQ SGT-READ-STELLA-STELLA-TOKEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STELLA-TOKEN" NULL 1))
   (CL:SETQ SYM-READ-STELLA-LOGICAL-TOKEN-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGICAL-TOKEN-TYPE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 0))
   (CL:SETQ SYM-READ-STELLA-ESCAPE-MODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPE-MODE" NULL 0))
   (CL:SETQ KWD-READ-FULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULL" NULL 2))
   (CL:SETQ KWD-READ-PARTIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL" NULL 2))
   (CL:SETQ KWD-READ-ESCAPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPED" NULL 2))
   (CL:SETQ |SYM-READ-STELLA-&|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "&" NULL 0))
   (CL:SETQ |SYM-READ-STELLA-&&|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "&&" NULL 0))
   (CL:SETQ KWD-READ-TEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TEXT" NULL 2))
   (CL:SETQ KWD-READ-PUNCTUATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUNCTUATION" NULL 2))
   (CL:SETQ KWD-READ-QUOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTE" NULL 2))
   (CL:SETQ KWD-READ-ESCAPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPE" NULL 2))
   (CL:SETQ SGT-READ-STELLA-F-TOKENIZE-STRING-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-TOKENIZE-STRING-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ KWD-READ-INITIAL-LINEFEED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-LINEFEED" NULL 2))
   (CL:SETQ KWD-READ-INITIAL-RETURN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-RETURN" NULL 2))
   (CL:SETQ KWD-READ-LINEFEED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LINEFEED" NULL 2))
   (CL:SETQ KWD-READ-RETURN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 2))
   (CL:SETQ KWD-READ-RETURN-LINEFEED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN-LINEFEED" NULL 2))
   (CL:SETQ KWD-READ-LF (INTERN-RIGID-SYMBOL-WRT-MODULE "LF" NULL 2))
   (CL:SETQ KWD-READ-CRLF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CRLF" NULL 2))
   (CL:SETQ KWD-READ-CR (INTERN-RIGID-SYMBOL-WRT-MODULE "CR" NULL 2))
   (CL:SETQ KWD-READ-ASK (INTERN-RIGID-SYMBOL-WRT-MODULE "ASK" NULL 2))
   (CL:SETQ KWD-READ-YES (INTERN-RIGID-SYMBOL-WRT-MODULE "YES" NULL 2))
   (CL:SETQ KWD-READ-NO (INTERN-RIGID-SYMBOL-WRT-MODULE "NO" NULL 2))
   (CL:SETQ KWD-READ-YES-VERBOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "YES-VERBOSE" NULL 2))
   (CL:SETQ KWD-READ-NO-VERBOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NO-VERBOSE" NULL 2))
   (CL:SETQ SYM-READ-STELLA-STARTUP-READ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-READ" NULL 0))
   (CL:SETQ SYM-READ-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-READ5 ()
  (CL:PROGN
   (CL:SETQ *STELLA-TOKENIZER-TABLE-DEFINITION*
    (LIST*
     (LIST* KWD-READ-START KWD-READ-INCLUDE KWD-READ-DELIMITER
      KWD-READ-INCLUDE KWD-READ-ATOM NIL)
     (LIST* KWD-READ-DELIMITER SYM-READ-STELLA-* (WRAP-STRING "(")
      KWD-READ-OPEN-PAREN SYM-READ-STELLA-* (WRAP-STRING ")")
      KWD-READ-CLOSE-PAREN SYM-READ-STELLA-* (WRAP-STRING "\"")
      (LIST* KWD-READ-OPEN-STRING KWD-READ-STRING NIL)
      SYM-READ-STELLA-* (WRAP-STRING "'") KWD-READ-SINGLE-QUOTE
      SYM-READ-STELLA-* (WRAP-STRING "`") KWD-READ-BACK-QUOTE
      SYM-READ-STELLA-* (WRAP-STRING ",") KWD-READ-COMMA
      SYM-READ-STELLA-! (WRAP-STRING ";") KWD-READ-COMMENT
      SYM-READ-STELLA-! (WRAP-STRING "#") KWD-READ-HASH
      SYM-READ-STELLA-!
      (LIST* (WRAP-CHARACTER #\ ) (WRAP-CHARACTER #\Tab)
       (WRAP-CHARACTER #\Linefeed) (WRAP-CHARACTER #\Return) NIL)
      KWD-READ-WHITE-SPACE KWD-READ-EOF KWD-READ-EOF NIL)
     (LIST* KWD-READ-WHITE-SPACE KWD-READ-INCLUDE KWD-READ-START NIL)
     (LIST* KWD-READ-COMMENT
      (LIST* (WRAP-CHARACTER #\Linefeed) (WRAP-CHARACTER #\Return) NIL)
      KWD-READ-START KWD-READ-EOF KWD-READ-EOF KWD-READ-OTHERWISE
      KWD-READ-COMMENT NIL)
     (LIST* KWD-READ-PAREN-COMMENT (WRAP-STRING "\\")
      KWD-READ-PAREN-COMMENT-ESCAPE (WRAP-STRING "|")
      KWD-READ-PAREN-COMMENT-BAR KWD-READ-OTHERWISE
      KWD-READ-PAREN-COMMENT NIL)
     (LIST* KWD-READ-PAREN-COMMENT-ESCAPE KWD-READ-ANY
      KWD-READ-PAREN-COMMENT NIL)
     (LIST* KWD-READ-PAREN-COMMENT-BAR (WRAP-STRING "#") KWD-READ-START
      (WRAP-STRING "\\") KWD-READ-PAREN-COMMENT-ESCAPE
      (WRAP-STRING "|") KWD-READ-PAREN-COMMENT-BAR KWD-READ-OTHERWISE
      KWD-READ-PAREN-COMMENT NIL)
     (LIST* KWD-READ-OPEN-PAREN KWD-READ-INCLUDE KWD-READ-START NIL)
     (LIST* KWD-READ-CLOSE-PAREN KWD-READ-INCLUDE KWD-READ-START NIL)
     (LIST* KWD-READ-SINGLE-QUOTE KWD-READ-INCLUDE KWD-READ-START NIL)
     (LIST* KWD-READ-BACK-QUOTE KWD-READ-INCLUDE KWD-READ-START NIL)
     (LIST* KWD-READ-COMMA (WRAP-STRING ".") KWD-READ-COMMA-SPLICE
      KWD-READ-INCLUDE KWD-READ-DELIMITER SYM-READ-STELLA-*
      (WRAP-STRING "-+")
      (LIST* KWD-READ-SYMBOL-OR-SIGNED-NUMBER KWD-READ-SYMBOL NIL)
      SYM-READ-STELLA-* (WRAP-STRING "0123456789")
      (LIST* KWD-READ-SYMBOL-OR-NUMBER KWD-READ-INTEGER NIL)
      SYM-READ-STELLA-* (WRAP-STRING "cC")
      (LIST* KWD-READ-SYMBOL-OR-CL-SYMBOL KWD-READ-SYMBOL NIL)
      SYM-READ-STELLA-* (WRAP-STRING "|")
      (LIST* KWD-READ-OPEN-FULLY-ESCAPED-SYMBOL
       KWD-READ-FULLY-ESCAPED-SYMBOL NIL)
      SYM-READ-STELLA-* (WRAP-STRING "\\")
      KWD-READ-ESCAPED-SYMBOL-ESCAPE SYM-READ-STELLA-*
      (WRAP-STRING "/") KWD-READ-QUALIFIED-NAME SYM-READ-STELLA-*
      (WRAP-STRING ":")
      (LIST* KWD-READ-OPEN-KEYWORD KWD-READ-KEYWORD NIL)
      SYM-READ-STELLA-* (WRAP-STRING "@")
      (LIST* KWD-READ-OPEN-SURROGATE KWD-READ-SURROGATE NIL)
      SYM-READ-STELLA-* KWD-READ-OTHERWISE KWD-READ-SYMBOL NIL)
     (LIST* KWD-READ-COMMA-SPLICE KWD-READ-INCLUDE KWD-READ-START NIL)
     (LIST* KWD-READ-OPEN-STRING SYM-READ-STELLA-* (WRAP-STRING "\"")
      KWD-READ-CLOSE-STRING (WRAP-STRING "\\") KWD-READ-STRING-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-STRING NIL)
     (LIST* KWD-READ-STRING SYM-READ-STELLA-* (WRAP-STRING "\"")
      KWD-READ-CLOSE-STRING (WRAP-STRING "\\") KWD-READ-STRING-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-STRING NIL)
     (LIST* KWD-READ-CLOSE-STRING KWD-READ-INCLUDE KWD-READ-START NIL)
     (LIST* KWD-READ-STRING-ESCAPE KWD-READ-ANY KWD-READ-ESCAPED-STRING
      NIL)
     (LIST* KWD-READ-ESCAPED-STRING SYM-READ-STELLA-*
      (WRAP-STRING "\"") KWD-READ-CLOSE-STRING (WRAP-STRING "\\")
      KWD-READ-STRING-ESCAPE KWD-READ-OTHERWISE KWD-READ-ESCAPED-STRING
      NIL)
     (LIST* KWD-READ-HASH (WRAP-STRING "\\")
      KWD-READ-CHARACTER-CONSTANT (WRAP-STRING "|")
      KWD-READ-PAREN-COMMENT NIL)
     (LIST* KWD-READ-CHARACTER-CONSTANT SYM-READ-STELLA-* KWD-READ-ANY
      KWD-READ-CHARACTER NIL)
     (LIST* KWD-READ-CHARACTER KWD-READ-INCLUDE KWD-READ-DELIMITER
      KWD-READ-OTHERWISE KWD-READ-CHARACTER NIL)
     (LIST* KWD-READ-ATOM SYM-READ-STELLA-* (WRAP-STRING "-+")
      (LIST* KWD-READ-SYMBOL-OR-SIGNED-NUMBER KWD-READ-SYMBOL NIL)
      SYM-READ-STELLA-* (WRAP-STRING "0123456789")
      (LIST* KWD-READ-SYMBOL-OR-NUMBER KWD-READ-INTEGER NIL)
      SYM-READ-STELLA-* (WRAP-STRING ".")
      (LIST* KWD-READ-SYMBOL-OR-MANTISSA KWD-READ-SYMBOL NIL)
      SYM-READ-STELLA-* (WRAP-STRING "cC")
      (LIST* KWD-READ-SYMBOL-OR-CL-SYMBOL KWD-READ-SYMBOL NIL)
      SYM-READ-STELLA-* (WRAP-STRING "|")
      (LIST* KWD-READ-OPEN-FULLY-ESCAPED-SYMBOL
       KWD-READ-FULLY-ESCAPED-SYMBOL NIL)
      SYM-READ-STELLA-* (WRAP-STRING "\\")
      KWD-READ-ESCAPED-SYMBOL-ESCAPE SYM-READ-STELLA-*
      (WRAP-STRING "/") KWD-READ-QUALIFIED-NAME SYM-READ-STELLA-*
      (WRAP-STRING ":")
      (LIST* KWD-READ-OPEN-KEYWORD KWD-READ-KEYWORD NIL)
      SYM-READ-STELLA-* (WRAP-STRING "@")
      (LIST* KWD-READ-OPEN-SURROGATE KWD-READ-SURROGATE NIL)
      SYM-READ-STELLA-* KWD-READ-OTHERWISE KWD-READ-SYMBOL NIL)
     (LIST* KWD-READ-SYMBOL-OR-SIGNED-NUMBER KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/") KWD-READ-QUALIFIED-NAME
      (WRAP-STRING "\\") KWD-READ-ESCAPED-SYMBOL-ESCAPE
      (WRAP-STRING "0123456789")
      (LIST* KWD-READ-SYMBOL-OR-NUMBER KWD-READ-INTEGER NIL)
      (WRAP-STRING ".")
      (LIST* KWD-READ-SYMBOL-OR-MANTISSA KWD-READ-SYMBOL NIL)
      (WRAP-STRING "|") KWD-READ-ERROR KWD-READ-OTHERWISE
      KWD-READ-SYMBOL NIL)
     (LIST* KWD-READ-SYMBOL-OR-NUMBER KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/") KWD-READ-QUALIFIED-NAME
      (WRAP-STRING "\\") KWD-READ-ESCAPED-SYMBOL-ESCAPE
      (WRAP-STRING "0123456789")
      (LIST* KWD-READ-SYMBOL-OR-NUMBER KWD-READ-INTEGER NIL)
      (WRAP-STRING ".")
      (LIST* KWD-READ-SYMBOL-OR-MANTISSA2 KWD-READ-FLOAT NIL)
      (WRAP-STRING "eE")
      (LIST* KWD-READ-SYMBOL-OR-EXPONENT-DELIMITER KWD-READ-SYMBOL NIL)
      (WRAP-STRING "|") KWD-READ-ERROR KWD-READ-OTHERWISE
      KWD-READ-SYMBOL NIL)
     (LIST* KWD-READ-SYMBOL-OR-MANTISSA KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/") KWD-READ-QUALIFIED-NAME
      (WRAP-STRING "\\") KWD-READ-ESCAPED-SYMBOL-ESCAPE
      (WRAP-STRING "0123456789")
      (LIST* KWD-READ-SYMBOL-OR-MANTISSA2 KWD-READ-FLOAT NIL)
      (WRAP-STRING "eE")
      (LIST* KWD-READ-SYMBOL-OR-EXPONENT-DELIMITER KWD-READ-SYMBOL NIL)
      (WRAP-STRING "|") KWD-READ-ERROR KWD-READ-OTHERWISE
      KWD-READ-SYMBOL NIL)
     (LIST* KWD-READ-SYMBOL-OR-MANTISSA2 KWD-READ-INCLUDE
      KWD-READ-SYMBOL-OR-MANTISSA NIL)
     (LIST* KWD-READ-SYMBOL-OR-EXPONENT-DELIMITER KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/") KWD-READ-QUALIFIED-NAME
      (WRAP-STRING "\\") KWD-READ-ESCAPED-SYMBOL-ESCAPE
      (WRAP-STRING "+-")
      (LIST* KWD-READ-SYMBOL-OR-EXPONENT KWD-READ-SYMBOL NIL)
      (WRAP-STRING "0123456789")
      (LIST* KWD-READ-SYMBOL-OR-EXPONENT2 KWD-READ-FLOAT NIL)
      (WRAP-STRING "|") KWD-READ-ERROR KWD-READ-OTHERWISE
      KWD-READ-SYMBOL NIL)
     (LIST* KWD-READ-SYMBOL-OR-EXPONENT KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/") KWD-READ-QUALIFIED-NAME
      (WRAP-STRING "\\") KWD-READ-ESCAPED-SYMBOL-ESCAPE
      (WRAP-STRING "0123456789")
      (LIST* KWD-READ-SYMBOL-OR-EXPONENT2 KWD-READ-FLOAT NIL)
      (WRAP-STRING "|") KWD-READ-ERROR KWD-READ-OTHERWISE
      KWD-READ-SYMBOL NIL)
     (LIST* KWD-READ-SYMBOL-OR-EXPONENT2 KWD-READ-INCLUDE
      KWD-READ-SYMBOL-OR-EXPONENT NIL)
     (LIST* KWD-READ-SYMBOL-OR-CL-SYMBOL KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/") KWD-READ-QUALIFIED-NAME
      (WRAP-STRING "\\") KWD-READ-ESCAPED-SYMBOL-ESCAPE
      (WRAP-STRING "lL")
      (LIST* KWD-READ-SYMBOL-OR-CL-SYMBOL2 KWD-READ-SYMBOL NIL)
      (WRAP-STRING "|") KWD-READ-ERROR KWD-READ-OTHERWISE
      KWD-READ-SYMBOL NIL)
     (LIST* KWD-READ-SYMBOL-OR-CL-SYMBOL2 KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/") KWD-READ-QUALIFIED-NAME
      (WRAP-STRING "\\") KWD-READ-ESCAPED-SYMBOL-ESCAPE
      (WRAP-STRING ":")
      (LIST* KWD-READ-SYMBOL-OR-CL-SYMBOL3 KWD-READ-SYMBOL NIL)
      (WRAP-STRING "|") KWD-READ-ERROR KWD-READ-OTHERWISE
      KWD-READ-SYMBOL NIL)
     (LIST* KWD-READ-SYMBOL-OR-CL-SYMBOL3 KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "|") KWD-READ-ERROR
      KWD-READ-OTHERWISE KWD-READ-CL-SYMBOL NIL)
     (LIST* KWD-READ-CL-SYMBOL KWD-READ-INCLUDE KWD-READ-DELIMITER
      (WRAP-STRING "|") KWD-READ-ERROR KWD-READ-OTHERWISE
      KWD-READ-CL-SYMBOL NIL)
     (LIST* KWD-READ-ESCAPED-SYMBOL-ESCAPE KWD-READ-ANY
      KWD-READ-ESCAPED-SYMBOL NIL)
     (LIST* KWD-READ-ESCAPED-SYMBOL KWD-READ-INCLUDE KWD-READ-DELIMITER
      (WRAP-STRING "/|") KWD-READ-ERROR (WRAP-STRING "\\")
      KWD-READ-ESCAPED-SYMBOL-ESCAPE KWD-READ-OTHERWISE
      KWD-READ-ESCAPED-SYMBOL NIL)
     (LIST* KWD-READ-OPEN-FULLY-ESCAPED-SYMBOL SYM-READ-STELLA-*
      (WRAP-STRING "|") KWD-READ-CLOSE-FULLY-ESCAPED-NAME
      (WRAP-STRING "\\") KWD-READ-FULLY-ESCAPED-SYMBOL-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-FULLY-ESCAPED-SYMBOL NIL)
     (LIST* KWD-READ-FULLY-ESCAPED-SYMBOL-ESCAPE KWD-READ-ANY
      KWD-READ-FULLY-ESCAPED-SYMBOL NIL)
     (LIST* KWD-READ-FULLY-ESCAPED-SYMBOL SYM-READ-STELLA-*
      (WRAP-STRING "|") KWD-READ-CLOSE-FULLY-ESCAPED-NAME
      (WRAP-STRING "\\") KWD-READ-FULLY-ESCAPED-SYMBOL-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-FULLY-ESCAPED-SYMBOL NIL)
     (LIST* KWD-READ-CLOSE-FULLY-ESCAPED-NAME KWD-READ-INCLUDE
      KWD-READ-START NIL)
     (LIST* KWD-READ-SYMBOL KWD-READ-INCLUDE KWD-READ-DELIMITER
      (WRAP-STRING "/") KWD-READ-QUALIFIED-NAME (WRAP-STRING "\\")
      KWD-READ-ESCAPED-SYMBOL-ESCAPE (WRAP-STRING "|") KWD-READ-ERROR
      KWD-READ-OTHERWISE KWD-READ-SYMBOL NIL)
     (LIST* KWD-READ-OPEN-KEYWORD KWD-READ-INCLUDE KWD-READ-DELIMITER
      (WRAP-STRING "|") KWD-READ-FULLY-ESCAPED-KEYWORD
      (WRAP-STRING "\\") KWD-READ-ESCAPED-KEYWORD-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-KEYWORD NIL)
     (LIST* KWD-READ-KEYWORD KWD-READ-INCLUDE KWD-READ-DELIMITER
      (WRAP-STRING "\\") KWD-READ-ESCAPED-KEYWORD-ESCAPE
      (WRAP-STRING "|") KWD-READ-ERROR KWD-READ-OTHERWISE
      KWD-READ-KEYWORD NIL)
     (LIST* KWD-READ-ESCAPED-KEYWORD-ESCAPE KWD-READ-ANY
      KWD-READ-ESCAPED-KEYWORD NIL)
     (LIST* KWD-READ-ESCAPED-KEYWORD KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "\\")
      KWD-READ-ESCAPED-KEYWORD-ESCAPE (WRAP-STRING "|") KWD-READ-ERROR
      KWD-READ-OTHERWISE KWD-READ-ESCAPED-KEYWORD NIL)
     (LIST* KWD-READ-FULLY-ESCAPED-KEYWORD SYM-READ-STELLA-*
      (WRAP-STRING "|") KWD-READ-CLOSE-FULLY-ESCAPED-NAME
      (WRAP-STRING "\\") KWD-READ-FULLY-ESCAPED-KEYWORD-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-FULLY-ESCAPED-KEYWORD NIL)
     (LIST* KWD-READ-FULLY-ESCAPED-KEYWORD-ESCAPE KWD-READ-ANY
      KWD-READ-FULLY-ESCAPED-KEYWORD NIL)
     (LIST* KWD-READ-OPEN-SURROGATE KWD-READ-INCLUDE KWD-READ-DELIMITER
      (WRAP-STRING "|") KWD-READ-FULLY-ESCAPED-SURROGATE
      (WRAP-STRING "\\") KWD-READ-ESCAPED-SURROGATE-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-SURROGATE NIL)
     (LIST* KWD-READ-SURROGATE KWD-READ-INCLUDE KWD-READ-DELIMITER
      (WRAP-STRING "/|") KWD-READ-ERROR (WRAP-STRING "\\")
      KWD-READ-ESCAPED-SURROGATE-ESCAPE KWD-READ-OTHERWISE
      KWD-READ-SURROGATE NIL)
     (LIST* KWD-READ-ESCAPED-SURROGATE KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/|") KWD-READ-ERROR
      (WRAP-STRING "\\") KWD-READ-ESCAPED-SURROGATE-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-ESCAPED-SURROGATE NIL)
     (LIST* KWD-READ-ESCAPED-SURROGATE-ESCAPE KWD-READ-ANY
      KWD-READ-ESCAPED-SURROGATE NIL)
     (LIST* KWD-READ-FULLY-ESCAPED-SURROGATE SYM-READ-STELLA-*
      (WRAP-STRING "|") KWD-READ-CLOSE-FULLY-ESCAPED-NAME
      (WRAP-STRING "\\") KWD-READ-FULLY-ESCAPED-SURROGATE-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-FULLY-ESCAPED-SURROGATE NIL)
     (LIST* KWD-READ-FULLY-ESCAPED-SURROGATE-ESCAPE KWD-READ-ANY
      KWD-READ-FULLY-ESCAPED-SURROGATE NIL)
     (LIST* KWD-READ-QUALIFIED-NAME KWD-READ-INCLUDE KWD-READ-DELIMITER
      (WRAP-STRING "@") KWD-READ-QUALIFIED-SURROGATE (WRAP-STRING ":")
      KWD-READ-ERROR (WRAP-STRING "\\")
      KWD-READ-QUALIFIED-ESCAPED-SYMBOL-ESCAPE (WRAP-STRING "|")
      KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL (WRAP-STRING "/")
      KWD-READ-QUALIFIED-NAME KWD-READ-OTHERWISE
      KWD-READ-QUALIFIED-SYMBOL NIL)
     (LIST* KWD-READ-QUALIFIED-SYMBOL KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/") KWD-READ-QUALIFIED-NAME
      (WRAP-STRING "\\") KWD-READ-QUALIFIED-ESCAPED-SYMBOL-ESCAPE
      (WRAP-STRING "|") KWD-READ-ERROR KWD-READ-OTHERWISE
      KWD-READ-QUALIFIED-SYMBOL NIL)
     (LIST* KWD-READ-QUALIFIED-SURROGATE KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/") KWD-READ-ERROR
      (WRAP-STRING "\\") KWD-READ-QUALIFIED-ESCAPED-SURROGATE-ESCAPE
      (WRAP-STRING "|") KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE
      KWD-READ-OTHERWISE KWD-READ-QUALIFIED-SURROGATE NIL)
     (LIST* KWD-READ-QUALIFIED-ESCAPED-SYMBOL KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/|") KWD-READ-ERROR
      (WRAP-STRING "\\") KWD-READ-QUALIFIED-ESCAPED-SYMBOL-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-QUALIFIED-ESCAPED-SYMBOL NIL)
     (LIST* KWD-READ-QUALIFIED-ESCAPED-SYMBOL-ESCAPE KWD-READ-ANY
      KWD-READ-QUALIFIED-ESCAPED-SYMBOL NIL)
     (LIST* KWD-READ-QUALIFIED-ESCAPED-SURROGATE KWD-READ-INCLUDE
      KWD-READ-DELIMITER (WRAP-STRING "/|") KWD-READ-ERROR
      (WRAP-STRING "\\") KWD-READ-QUALIFIED-ESCAPED-SURROGATE-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-QUALIFIED-ESCAPED-SURROGATE NIL)
     (LIST* KWD-READ-QUALIFIED-ESCAPED-SURROGATE-ESCAPE KWD-READ-ANY
      KWD-READ-QUALIFIED-ESCAPED-SURROGATE NIL)
     (LIST* KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL SYM-READ-STELLA-*
      (WRAP-STRING "|") KWD-READ-CLOSE-FULLY-ESCAPED-NAME
      (WRAP-STRING "\\") KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL NIL)
     (LIST* KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL-ESCAPE KWD-READ-ANY
      KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL NIL)
     (LIST* KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE
      SYM-READ-STELLA-* (WRAP-STRING "|")
      KWD-READ-CLOSE-FULLY-ESCAPED-NAME (WRAP-STRING "\\")
      KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE-ESCAPE
      KWD-READ-OTHERWISE KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE
      NIL)
     (LIST* KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE-ESCAPE
      KWD-READ-ANY KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE NIL)
     (LIST* KWD-READ-ERROR KWD-READ-INCLUDE KWD-READ-START NIL) NIL))
   (CL:SETQ *STELLA-TOKENIZER-TABLE*
    (UNSTRINGIFY-TOKENIZER-TABLE
     "32768|EJEJEJEJEJEJEJEJEJKMKMEJEJKMEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMEJEIJMEJEJEJFICIDIEJLIHILINIBJMIMIMIMIMIMIMIMIMIMICJIMEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJGIEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMKMEJEJKMEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMEJEIJMEJEJEJFICIDIEJLIHILINIBJMIMIMIMIMIMIMIMIMIMICJIMEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJGIEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMKMEJEJKMEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMEJEIJMEJEJEJFICIDIEJLIHILINIBJMIMIMIMIMIMIMIMIMIMICJIMEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJGIEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMKMEJEJKMEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMEJEIJMEJEJEJFICIDIEJLIHILINIBJMIMIMIMIMIMIMIMIMIMICJIMEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJGIEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBKJMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBLBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBEJEJEJEJEJEJEJEJEJKMKMEJEJKMEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMEJEIJMEJEJEJFICIDIEJLIHILINIBJMIMIMIMIMIMIMIMIMIMICJIMEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJGIEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMKMEJEJKMEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMEJEIJMEJEJEJFICIDIEJLIHILINIBJMIMIMIMIMIMIMIMIMIMICJIMEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJGIEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMKMEJEJKMEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMEJEIJMEJEJEJFICIDIEJLIHILIJBBJMIMIMIMIMIMIMIMIMIMICJIMEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJGIEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJIAIAIAIAIAIAIAIAIAIABAIAIABAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJEJEJEJEJEJEJEJEJKMKMEJEJKMEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMEJEIJMEJEJEJFICIDIEJLIHILINIBJMIMIMIMIMIMIMIMIMIMICJIMEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJGIEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEBEBEBEBEBEBEBEBEBKMKMEBEBKMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMEBEIJMEBEBEBFICIDIEBEBHIEBNABBMAMAMAMAMAMAMAMAMAMAEBIMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBABEBEBEBGIEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBAAEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMKMEBEBKMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMEBEIJMEBEBEBFICIDIEBEBHIEBBCBBMAMAMAMAMAMAMAMAMAMAEBIMEBEBEBEBEBEBEBEBEBCCEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBABEBEBEBGIEBEBEBEBCCEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBAAEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMKMEBEBKMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMEBEIJMEBEBEBFICIDIEBEBHIEBEBBBBCBCBCBCBCBCBCBCBCBCEBIMEBEBEBEBEBEBEBEBEBCCEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBABEBEBEBGIEBEBEBEBCCEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBAAEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMKMEBEBKMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMEBEIJMEBEBEBFICIDIEBEBHIEBEBBBEBEBEBEBEBEBEBEBEBEBEBIMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBFCEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBABEBEBEBGIEBEBEBEBEBEBEBEBEBEBEBFCEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBAAEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCKCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCJKLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICJDJDJDJDJDJDJDJDJDKMKMJDJDKMJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDKMJDEIJMJDJDJDFICIDIJDJDHIJDJDBBJDJDJDJDJDJDJDJDJDJDAAIMJDJDJDJDGDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDHDJDJDJDGIJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDIDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDOCOCOCOCOCOCOCOCOCKMKMOCOCKMOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCKMOCEIJMOCOCOCFICIDIOCOCHIOCOCOCOCOCOCOCOCOCOCOCOCOCOCIMOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCNCOCOCOCGIOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCMCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCDDDDDDDDDDDDDDDDDDKMKMDDDDKMDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDKMDDEIJMDDDDDDFICIDIDDDDHIDDDDDDDDDDDDDDDDDDDDDDDDDDDDIMDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDCDDDDDDDGIDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDBDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEBEBEBEBEBEBEBEBEBKMKMEBEBKMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMEBEIJMEBEBEBFICIDIEBEBHIEBEBBBEBEBEBEBEBEBEBEBEBEBEBIMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBABEBEBEBGIEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBAAEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBAAAAAAAAAAAAAAAAAAKMKMAAAAKMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKMAAEIJMAAAAAAFICIDIAAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAIMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBHBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBIBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBBAGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBHBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBIBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBGBEJEJEJEJEJEJEJEJEJKMKMEJEJKMEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMEJEIJMEJEJEJFICIDIEJLIHILINIBJMIMIMIMIMIMIMIMIMIMICJIMEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJGIEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMKMEJEJKMEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMEJEIJMEJEJEJFICIDIEJLIHILINIBJMIMIMIMIMIMIMIMIMIMICJIMEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJGIEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBKJMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBLBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBMBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBKJNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBLBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBNBPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPJPBPBPBPBPBPBPBPBPBKMKMPBPBKMPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBKMPBEIJMPBPBPBFICIDIPBPBHIPBPBPBPBPBPBPBPBPBPBPBPBPBPBIMPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBGIPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBPBEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJLIEJLINIBJMIMIMIMIMIMIMIMIMIMICJEJEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJEJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEBEBEBEBEBEBEBEBEBKMKMEBEBKMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMEBEIJMEBEBEBFICIDIEBEBHIEBEBBBBCBCBCBCBCBCBCBCBCBCEBIMEBEBEBEBEBEBEBEBEBCCEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBABEBEBEBGIEBEBEBEBCCEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBAAEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMKMEBEBKMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMEBEIJMEBEBEBFICIDIEBDCHIDCEBBBECECECECECECECECECECEBIMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBABEBEBEBGIEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBAAEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMKMEBEBKMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMEBEIJMEBEBEBFICIDIEBEBHIEBEBBBECECECECECECECECECECEBIMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBABEBEBEBGIEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBAAEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMKMEBEBKMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMEBEIJMEBEBEBFICIDIEBEBHIEBEBBBECECECECECECECECECECEBIMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBABEBEBEBGIEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBAAEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMKMEBEBKMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBKMEBEIJMEBEBEBFICIDIEBEBHIEBEBBBEBEBEBEBEBEBEBEBEBEBGCIMEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBABEBEBEBGIEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBAAEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBEBHCHCHCHCHCHCHCHCHCKMKMHCHCKMHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCKMHCEIJMHCHCHCFICIDIHCHCHIHCHCHCHCHCHCHCHCHCHCHCHCHCHCIMHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCGIHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCAAHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCKMKMHCHCKMHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCKMHCEIJMHCHCHCFICIDIHCHCHIHCHCHCHCHCHCHCHCHCHCHCHCHCHCIMHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCGIHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCAAHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCHCICICICICICICICICICKMKMICICKMICICICICICICICICICICICICICICICICICICKMICEIJMICICICFICIDIICICHIICICAAICICICICICICICICICICICIMICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICABICICICGIICICICICICICICICICICICICICICICICICICICICICICICICICICICAAICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICICEJEJEJEJEJEJEJEJEJKMKMEJEJKMEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJKMEJEIJMEJEJEJFICIDIEJLIHILINIBJMIMIMIMIMIMIMIMIMIMICJIMEJEJEJEJDJEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJAJEJEJEJGIEJEJOIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJPIEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJEJLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCKCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCJKLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCLCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCADMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCJKMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCOCOCOCOCOCOCOCOCOCKMKMOCOCKMOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCKMOCEIJMOCOCOCFICIDIOCOCHIOCOCOCOCOCOCOCOCOCOCOCOCOCOCIMOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCNCOCOCOCGIOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCAAOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCPCPCPCPCPCPCPCPCPCKMKMPCPCKMPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCKMPCEIJMPCPCPCFICIDIPCPCHIPCPCPCPCPCPCPCPCPCPCPCPCPCPCIMPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCNCPCPCPCGIPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCAAPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCPCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCMCBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDFDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDJKBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDDDDDDDDDDDDDDDDDDDKMKMDDDDKMDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDKMDDEIJMDDDDDDFICIDIDDDDHIDDDDAADDDDDDDDDDDDDDDDDDDDDDIMDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDCDDDDDDDGIDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDAADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEDEDEDEDEDEDEDEDEDKMKMEDEDKMEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDKMEDEIJMEDEDEDFICIDIEDEDHIEDEDAAEDEDEDEDEDEDEDEDEDEDEDIMEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDCDEDEDEDGIEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDAAEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDEDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDBDGDGDGDGDGDGDGDGDGDKMKMGDGDKMGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDKMGDEIJMGDGDGDFICIDIGDGDHIGDGDAAGDGDGDGDGDGDGDGDGDGDGDIMGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDKDGDGDGDGIGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDLDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDGDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDODIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDJKIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDJDJDJDJDJDJDJDJDJDKMKMJDJDKMJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDKMJDEIJMJDJDJDFICIDIJDJDHIJDJDBBJDJDJDJDJDJDJDJDJDJDJDIMJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDHDJDJDJDGIJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDAAJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDJDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDPDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDJKLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDMDMDMDMDMDMDMDMDMDKMKMMDMDKMMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDKMMDEIJMMDMDMDFICIDIMDMDHIMDMDAAMDMDMDMDMDMDMDMDMDMDMDIMMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDHDMDMDMDGIMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDAAMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDMDNDNDNDNDNDNDNDNDNDKMKMNDNDKMNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDKMNDEIJMNDNDNDFICIDINDNDHINDNDAANDNDNDNDNDNDNDNDNDNDNDIMNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDKDNDNDNDGINDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDAANDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDNDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDIDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLDLD|64|ERROR|START|OPEN-PAREN|CLOSE-PAREN|OPEN-STRING|SINGLE-QUOTE|BACK-QUOTE|COMMA|COMMENT|HASH|WHITE-SPACE|SYMBOL-OR-SIGNED-NUMBER|SYMBOL-OR-NUMBER|SYMBOL-OR-MANTISSA|SYMBOL-OR-CL-SYMBOL|OPEN-FULLY-ESCAPED-SYMBOL|ESCAPED-SYMBOL-ESCAPE|QUALIFIED-NAME|OPEN-KEYWORD|OPEN-SURROGATE|SYMBOL|DELIMITER|PAREN-COMMENT|PAREN-COMMENT-ESCAPE|PAREN-COMMENT-BAR|COMMA-SPLICE|CLOSE-STRING|STRING-ESCAPE|STRING|ESCAPED-STRING|CHARACTER-CONSTANT|CHARACTER|ATOM|SYMBOL-OR-MANTISSA2|SYMBOL-OR-EXPONENT-DELIMITER|SYMBOL-OR-EXPONENT|SYMBOL-OR-EXPONENT2|SYMBOL-OR-CL-SYMBOL2|SYMBOL-OR-CL-SYMBOL3|CL-SYMBOL|ESCAPED-SYMBOL|CLOSE-FULLY-ESCAPED-NAME|FULLY-ESCAPED-SYMBOL-ESCAPE|FULLY-ESCAPED-SYMBOL|FULLY-ESCAPED-KEYWORD|ESCAPED-KEYWORD-ESCAPE|KEYWORD|ESCAPED-KEYWORD|FULLY-ESCAPED-KEYWORD-ESCAPE|FULLY-ESCAPED-SURROGATE|ESCAPED-SURROGATE-ESCAPE|SURROGATE|ESCAPED-SURROGATE|FULLY-ESCAPED-SURROGATE-ESCAPE|QUALIFIED-SURROGATE|QUALIFIED-ESCAPED-SYMBOL-ESCAPE|QUALIFIED-FULLY-ESCAPED-SYMBOL|QUALIFIED-SYMBOL|QUALIFIED-ESCAPED-SURROGATE-ESCAPE|QUALIFIED-FULLY-ESCAPED-SURROGATE|QUALIFIED-ESCAPED-SYMBOL|QUALIFIED-ESCAPED-SURROGATE|QUALIFIED-FULLY-ESCAPED-SYMBOL-ESCAPE|QUALIFIED-FULLY-ESCAPED-SURROGATE-ESCAPE|64|ERROR|START|OPEN-PAREN|CLOSE-PAREN|STRING|SINGLE-QUOTE|BACK-QUOTE|COMMA|COMMENT|HASH|WHITE-SPACE|SYMBOL|INTEGER|SYMBOL|SYMBOL|FULLY-ESCAPED-SYMBOL|ESCAPED-SYMBOL-ESCAPE|QUALIFIED-NAME|KEYWORD|SURROGATE|SYMBOL|DELIMITER|PAREN-COMMENT|PAREN-COMMENT-ESCAPE|PAREN-COMMENT-BAR|COMMA-SPLICE|CLOSE-STRING|STRING-ESCAPE|STRING|ESCAPED-STRING|CHARACTER-CONSTANT|CHARACTER|ATOM|FLOAT|SYMBOL|SYMBOL|FLOAT|SYMBOL|SYMBOL|CL-SYMBOL|ESCAPED-SYMBOL|CLOSE-FULLY-ESCAPED-NAME|FULLY-ESCAPED-SYMBOL-ESCAPE|FULLY-ESCAPED-SYMBOL|FULLY-ESCAPED-KEYWORD|ESCAPED-KEYWORD-ESCAPE|KEYWORD|ESCAPED-KEYWORD|FULLY-ESCAPED-KEYWORD-ESCAPE|FULLY-ESCAPED-SURROGATE|ESCAPED-SURROGATE-ESCAPE|SURROGATE|ESCAPED-SURROGATE|FULLY-ESCAPED-SURROGATE-ESCAPE|QUALIFIED-SURROGATE|QUALIFIED-ESCAPED-SYMBOL-ESCAPE|QUALIFIED-FULLY-ESCAPED-SYMBOL|QUALIFIED-SYMBOL|QUALIFIED-ESCAPED-SURROGATE-ESCAPE|QUALIFIED-FULLY-ESCAPED-SURROGATE|QUALIFIED-ESCAPED-SYMBOL|QUALIFIED-ESCAPED-SURROGATE|QUALIFIED-FULLY-ESCAPED-SYMBOL-ESCAPE|QUALIFIED-FULLY-ESCAPED-SURROGATE-ESCAPE|64|TTTTFTTTTFTTTTTFFTTTTTFFFTTFFFFTFTTTTTTTTTFFFFTTFFFTTFTFFTFFTTFF|"))
   (CL:LET* ((SELF-061 (NEW-PROPERTY-LIST)))
    (CL:SETF (%THE-PLIST SELF-061)
     (LIST* KWD-READ-SYMBOL KWD-READ-SYMBOL KWD-READ-ESCAPED-SYMBOL
      KWD-READ-SYMBOL KWD-READ-FULLY-ESCAPED-SYMBOL KWD-READ-SYMBOL
      KWD-READ-QUALIFIED-SYMBOL KWD-READ-SYMBOL
      KWD-READ-QUALIFIED-ESCAPED-SYMBOL KWD-READ-SYMBOL
      KWD-READ-QUALIFIED-FULLY-ESCAPED-SYMBOL KWD-READ-SYMBOL
      KWD-READ-CL-SYMBOL KWD-READ-SYMBOL KWD-READ-SURROGATE
      KWD-READ-SURROGATE KWD-READ-ESCAPED-SURROGATE KWD-READ-SURROGATE
      KWD-READ-QUALIFIED-SURROGATE KWD-READ-SURROGATE
      KWD-READ-QUALIFIED-ESCAPED-SURROGATE KWD-READ-SURROGATE
      KWD-READ-FULLY-ESCAPED-SURROGATE KWD-READ-SURROGATE
      KWD-READ-QUALIFIED-FULLY-ESCAPED-SURROGATE KWD-READ-SURROGATE
      KWD-READ-KEYWORD KWD-READ-KEYWORD KWD-READ-ESCAPED-KEYWORD
      KWD-READ-KEYWORD KWD-READ-FULLY-ESCAPED-KEYWORD KWD-READ-KEYWORD
      KWD-READ-QUALIFIED-NAME KWD-READ-QUALIFIED-NAME KWD-READ-STRING
      KWD-READ-STRING KWD-READ-ESCAPED-STRING KWD-READ-STRING
      KWD-READ-INTEGER KWD-READ-INTEGER KWD-READ-FLOAT KWD-READ-FLOAT
      KWD-READ-CHARACTER KWD-READ-CHARACTER KWD-READ-OPEN-PAREN
      KWD-READ-OPEN-PAREN KWD-READ-CLOSE-PAREN KWD-READ-CLOSE-PAREN
      KWD-READ-SINGLE-QUOTE KWD-READ-SINGLE-QUOTE KWD-READ-BACK-QUOTE
      KWD-READ-BACK-QUOTE KWD-READ-COMMA KWD-READ-COMMA
      KWD-READ-COMMA-SPLICE KWD-READ-COMMA-SPLICE KWD-READ-CLOSE-STRING
      KWD-READ-CLOSE-BALANCED-QUOTE KWD-READ-CLOSE-FULLY-ESCAPED-NAME
      KWD-READ-CLOSE-BALANCED-QUOTE KWD-READ-ERROR KWD-READ-ERROR NIL))
    (CL:SETQ *STELLA-LOGICAL-STATE-NAMES-TABLE* SELF-061))
   (CL:SETQ *STELLA-LOGICAL-STATE-NAMES*
    (NEW-VECTOR (LENGTH (%STATE-NAMES *STELLA-TOKENIZER-TABLE*))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-063 0)
     (UPPER-BOUND-064 (CL:1- (LENGTH *STELLA-LOGICAL-STATE-NAMES*))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-063 UPPER-BOUND-064))
    (CL:LOOP WHILE (CL:<= ITER-063 UPPER-BOUND-064) DO
     (CL:SETQ I ITER-063)
     (CL:LET
      ((SELF (%THE-ARRAY *STELLA-LOGICAL-STATE-NAMES*))
       (VALUE
        (LOOKUP *STELLA-LOGICAL-STATE-NAMES-TABLE*
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR
           (%THE-ARRAY (%STATE-NAMES *STELLA-TOKENIZER-TABLE*)))
          I)))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:WHEN
      (CL:EQ
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%THE-ARRAY *STELLA-LOGICAL-STATE-NAMES*))
        I)
       NULL)
      (CL:LET
       ((SELF (%THE-ARRAY *STELLA-LOGICAL-STATE-NAMES*))
        (VALUE KWD-READ-ERROR) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))
     (CL:SETQ ITER-063 (CL:1+ ITER-063))))
   (CL:SETQ *GET-TOKEN-INTEGER-CHECKPOINT*
    (CL:LET ((X (CL:- MOST-POSITIVE-INTEGER 9)) (Y 10))
     (CL:DECLARE (CL:TYPE CL:FIXNUM X Y))
     (CL:THE CL:FIXNUM (CL:VALUES (CL:TRUNCATE X Y)))))
   (CL:SETQ *GET-TOKEN-LONG-INTEGER-CHECKPOINT*
    (CL:LET ((X (CL:- MOST-POSITIVE-LONG-INTEGER 9)) (Y 10))
     (CL:VALUES (CL:TRUNCATE X Y))))
   (CL:SETQ *STELLA-TOKENIZER-WHITE-SPACE-STATE*
    (POSITION (%STATE-NAMES *STELLA-TOKENIZER-TABLE*)
     KWD-READ-WHITE-SPACE 0))
   (CL:SETQ *READ-LINE-TOKENIZER-TABLE-DEFINITION*
    (LIST*
     (LIST* KWD-READ-START SYM-READ-STELLA-*
      (CONS (WRAP-CHARACTER #\Linefeed) NIL) KWD-READ-INITIAL-LINEFEED
      SYM-READ-STELLA-* (CONS (WRAP-CHARACTER #\Return) NIL)
      KWD-READ-INITIAL-RETURN KWD-READ-EOF KWD-READ-EOF
      SYM-READ-STELLA-* KWD-READ-OTHERWISE KWD-READ-LINE NIL)
     (LIST* KWD-READ-INITIAL-LINEFEED KWD-READ-INCLUDE
      KWD-READ-LINEFEED NIL)
     (LIST* KWD-READ-INITIAL-RETURN KWD-READ-INCLUDE KWD-READ-RETURN
      NIL)
     (LIST* KWD-READ-RETURN SYM-READ-STELLA-*
      (CONS (WRAP-CHARACTER #\Linefeed) NIL) KWD-READ-LINEFEED
      SYM-READ-STELLA-* (CONS (WRAP-CHARACTER #\Return) NIL)
      KWD-READ-INITIAL-RETURN KWD-READ-EOF KWD-READ-EOF
      SYM-READ-STELLA-* KWD-READ-OTHERWISE KWD-READ-LINE NIL)
     (LIST* KWD-READ-LINEFEED KWD-READ-EOF KWD-READ-EOF
      SYM-READ-STELLA-* (CONS (WRAP-CHARACTER #\Linefeed) NIL)
      KWD-READ-INITIAL-LINEFEED SYM-READ-STELLA-*
      (CONS (WRAP-CHARACTER #\Return) NIL) KWD-READ-INITIAL-RETURN
      SYM-READ-STELLA-* KWD-READ-OTHERWISE KWD-READ-LINE NIL)
     (LIST* KWD-READ-LINE SYM-READ-STELLA-*
      (CONS (WRAP-CHARACTER #\Linefeed) NIL) KWD-READ-LINEFEED
      SYM-READ-STELLA-* (CONS (WRAP-CHARACTER #\Return) NIL)
      KWD-READ-RETURN SYM-READ-STELLA-* KWD-READ-EOF KWD-READ-EOF
      KWD-READ-OTHERWISE KWD-READ-LINE NIL)
     (LIST* KWD-READ-ERROR KWD-READ-INCLUDE KWD-READ-START NIL) NIL))
   (CL:SETQ *READ-LINE2-TOKENIZER-TABLE-DEFINITION*
    (LIST*
     (LIST* KWD-READ-START SYM-READ-STELLA-*
      (CONS (WRAP-CHARACTER #\Linefeed) NIL) KWD-READ-LINEFEED
      SYM-READ-STELLA-* (CONS (WRAP-CHARACTER #\Return) NIL)
      KWD-READ-RETURN KWD-READ-EOF KWD-READ-EOF SYM-READ-STELLA-*
      KWD-READ-OTHERWISE KWD-READ-LINE NIL)
     (LIST* KWD-READ-LINE SYM-READ-STELLA-*
      (CONS (WRAP-CHARACTER #\Linefeed) NIL) KWD-READ-LINEFEED
      SYM-READ-STELLA-* (CONS (WRAP-CHARACTER #\Return) NIL)
      KWD-READ-RETURN SYM-READ-STELLA-* KWD-READ-EOF KWD-READ-EOF
      KWD-READ-OTHERWISE KWD-READ-LINE NIL)
     (LIST* KWD-READ-RETURN SYM-READ-STELLA-* KWD-READ-EOF KWD-READ-EOF
      (CONS (WRAP-CHARACTER #\Linefeed) NIL) KWD-READ-RETURN-LINEFEED
      SYM-READ-STELLA-* (CONS (WRAP-CHARACTER #\Return) NIL)
      KWD-READ-RETURN SYM-READ-STELLA-* KWD-READ-OTHERWISE
      KWD-READ-LINE NIL)
     (LIST* KWD-READ-LINEFEED KWD-READ-EOF KWD-READ-EOF
      SYM-READ-STELLA-* (CONS (WRAP-CHARACTER #\Linefeed) NIL)
      KWD-READ-LINEFEED SYM-READ-STELLA-*
      (CONS (WRAP-CHARACTER #\Return) NIL) KWD-READ-RETURN
      SYM-READ-STELLA-* KWD-READ-OTHERWISE KWD-READ-LINE NIL)
     (LIST* KWD-READ-RETURN-LINEFEED SYM-READ-STELLA-* KWD-READ-EOF
      KWD-READ-EOF SYM-READ-STELLA-*
      (CONS (WRAP-CHARACTER #\Linefeed) NIL) KWD-READ-LINEFEED
      SYM-READ-STELLA-* (CONS (WRAP-CHARACTER #\Return) NIL)
      KWD-READ-RETURN SYM-READ-STELLA-* KWD-READ-OTHERWISE
      KWD-READ-LINE NIL)
     (LIST* KWD-READ-ERROR KWD-READ-INCLUDE KWD-READ-START NIL) NIL))
   (CL:SETQ *USER-QUERY-ACTION* KWD-READ-ASK))
  :VOID)

(CL:DEFUN HELP-STARTUP-READ6 ()
  (CL:PROGN
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TOKENIZER-TABLE"
       "(DEFCLASS TOKENIZER-TABLE (STANDARD-OBJECT) :SLOTS ((TRANSITIONS :TYPE STRING) (UNIQUE-STATE-NAMES :TYPE (VECTOR OF GENERALIZED-SYMBOL)) (STATE-NAMES :TYPE (VECTOR OF GENERALIZED-SYMBOL)) (LEGAL-EOF-STATES :TYPE (VECTOR OF BOOLEAN-WRAPPER))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TOKENIZER-TABLE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TOKENIZER-TABLE-SLOT-VALUE)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE CHARACTER-SET (CONS OF CHARACTER-WRAPPER))")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TOKENIZER-BYTE"
    "(DEFCLASS TOKENIZER-BYTE () :CL-NATIVE-TYPE \"CHARACTER\" :CPP-NATIVE-TYPE \"char\" :JAVA-NATIVE-TYPE \"byte\")")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TOKENIZER-BYTE-ARRAY"
    "(DEFCLASS TOKENIZER-BYTE-ARRAY () :CL-NATIVE-TYPE \"STRING\" :CPP-NATIVE-TYPE \"char*\" :JAVA-NATIVE-TYPE \"byte[]\")")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TOKENIZER-TOKEN"
       "(DEFCLASS TOKENIZER-TOKEN (STANDARD-OBJECT) :SLOTS ((TYPE :TYPE KEYWORD) (CONTENT :TYPE STRING) (NEXT :TYPE TOKENIZER-TOKEN)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TOKENIZER-TOKEN))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TOKENIZER-TOKEN-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TOKENIZER-STREAM-STATE"
       "(DEFCLASS TOKENIZER-STREAM-STATE (STANDARD-OBJECT) :SLOTS ((BUFFER :TYPE TOKENIZER-BYTE-ARRAY :INITIALLY (MAKE-TOKENIZER-BYTE-ARRAY *TOKENIZER-INITIAL-BUFFER-SIZE*)) (BUFFER-SIZE :TYPE INTEGER :INITIALLY *TOKENIZER-INITIAL-BUFFER-SIZE*) (CURSOR :TYPE INTEGER :INITIALLY *TOKENIZER-INITIAL-BUFFER-SIZE*) (END :TYPE INTEGER :INITIALLY *TOKENIZER-INITIAL-BUFFER-SIZE*) (STATE :TYPE INTEGER :INITIALLY 1) (TABLE :TYPE TOKENIZER-TABLE) (STATE-DICTIONARY :TYPE (DICTIONARY OF TOKENIZER-TABLE INTEGER-WRAPPER)) (TOKEN-LIST :TYPE TOKENIZER-TOKEN)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TOKENIZER-STREAM-STATE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TOKENIZER-STREAM-STATE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STREAM-TOKENIZER"
       "(DEFCLASS STREAM-TOKENIZER (ITERATOR) :DOCUMENTATION \"Iterator that generates tokens by tokenizing a `stream'
according to a particular tokenization `table'.\" :PUBLIC? TRUE :PARAMETERS ((ANY-VALUE :TYPE TOKENIZER-TOKEN)) :SLOTS ((STREAM :TYPE INPUT-STREAM :REQUIRED? TRUE) (TABLE :TYPE TOKENIZER-TABLE :REQUIRED? TRUE) (TOKEN :RENAMES VALUE)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-STREAM-TOKENIZER))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-STREAM-TOKENIZER-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STELLA-TOKEN"
       "(DEFCLASS STELLA-TOKEN (TOKENIZER-TOKEN) :SLOTS ((LOGICAL-TOKEN-TYPE :TYPE KEYWORD) (MODULE :TYPE STRING) (ESCAPE-MODE :TYPE KEYWORD) (NEXT :TYPE STELLA-TOKEN)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-STELLA-TOKEN))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-STELLA-TOKEN-SLOT-VALUE))))
  :VOID)

(CL:DEFUN HELP-STARTUP-READ7 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "PARSE-TOKENIZER-DEFINITION"
    "(DEFUN (PARSE-TOKENIZER-DEFINITION TOKENIZER-TABLE) ((DEFINITION (CONS OF CONS))))"
    (CL:FUNCTION PARSE-TOKENIZER-DEFINITION) NULL)
   (DEFINE-FUNCTION-OBJECT "LEGAL-TOKENIZER-STATE?"
    "(DEFUN (LEGAL-TOKENIZER-STATE? BOOLEAN) ((X OBJECT)))"
    (CL:FUNCTION LEGAL-TOKENIZER-STATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "LEGAL-TOKENIZER-FROM-STATE?"
    "(DEFUN (LEGAL-TOKENIZER-FROM-STATE? BOOLEAN) ((X OBJECT)))"
    (CL:FUNCTION LEGAL-TOKENIZER-FROM-STATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "LEGAL-TOKENIZER-TO-STATE?"
    "(DEFUN (LEGAL-TOKENIZER-TO-STATE? BOOLEAN) ((X OBJECT)))"
    (CL:FUNCTION LEGAL-TOKENIZER-TO-STATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "TOKENIZER-TO-STATE-NAME"
    "(DEFUN (TOKENIZER-TO-STATE-NAME GENERALIZED-SYMBOL) ((STATE OBJECT)))"
    (CL:FUNCTION TOKENIZER-TO-STATE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "TOKENIZER-TO-STATE-ALIAS"
    "(DEFUN (TOKENIZER-TO-STATE-ALIAS GENERALIZED-SYMBOL) ((STATE OBJECT)))"
    (CL:FUNCTION TOKENIZER-TO-STATE-ALIAS) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-TOKENIZER-STATE-MODIFIERS"
    "(DEFUN (PARSE-TOKENIZER-STATE-MODIFIERS INTEGER) ((MODIFIER OBJECT)))"
    (CL:FUNCTION PARSE-TOKENIZER-STATE-MODIFIERS) NULL)
   (DEFINE-FUNCTION-OBJECT "TOKENIZER-INCLUDE-SPEC?"
    "(DEFUN (TOKENIZER-INCLUDE-SPEC? BOOLEAN) ((X OBJECT)))"
    (CL:FUNCTION TOKENIZER-INCLUDE-SPEC?) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-TOKENIZER-CHARACTER-SPEC"
    "(DEFUN (PARSE-TOKENIZER-CHARACTER-SPEC CHARACTER-SET) ((CHARACTERSPEC OBJECT) (ALLCHARACTERSETS (LIST OF CHARACTER-SET))))"
    (CL:FUNCTION PARSE-TOKENIZER-CHARACTER-SPEC) NULL)
   (DEFINE-FUNCTION-OBJECT "STRINGIFY-TOKENIZER-TABLE"
    "(DEFUN (STRINGIFY-TOKENIZER-TABLE STRING) ((TABLE TOKENIZER-TABLE)))"
    (CL:FUNCTION STRINGIFY-TOKENIZER-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNSTRINGIFY-TOKENIZER-TABLE"
    "(DEFUN (UNSTRINGIFY-TOKENIZER-TABLE TOKENIZER-TABLE) ((TABLE STRING)))"
    (CL:FUNCTION UNSTRINGIFY-TOKENIZER-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-TOKENIZER-BYTE-ARRAY"
    "(DEFUN (MAKE-TOKENIZER-BYTE-ARRAY TOKENIZER-BYTE-ARRAY) ((SIZE INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:MAKE-STRING SIZE) :CPP \"new (PointerFreeGC) char[size]\" :JAVA \"new byte[size]\")))"
    (CL:FUNCTION MAKE-TOKENIZER-BYTE-ARRAY) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-TOKENIZER-BYTE-ARRAY"
    "(DEFUN (STRING-TO-TOKENIZER-BYTE-ARRAY TOKENIZER-BYTE-ARRAY) ((STRING STRING)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP STRING :CPP \"string\" :JAVA \"string.getBytes()\")))"
    (CL:FUNCTION STRING-TO-TOKENIZER-BYTE-ARRAY) NULL)
   (DEFINE-FUNCTION-OBJECT "TOKENIZER-BYTE-ARRAY-TO-STRING"
    "(DEFUN (TOKENIZER-BYTE-ARRAY-TO-STRING STRING) ((BYTES TOKENIZER-BYTE-ARRAY)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP BYTES :CPP \"bytes\" :JAVA \"new String(bytes)\")))"
    (CL:FUNCTION TOKENIZER-BYTE-ARRAY-TO-STRING) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (BYTE-ARRAY-NTH CHARACTER) ((BUFFER TOKENIZER-BYTE-ARRAY) (POSITION INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER) (CL:THE CL:FIXNUM POSITION)) :CPP \"buffer[position]\" :JAVA \"((char) (0x00ff & buffer[position]))\")))"
    (CL:FUNCTION BYTE-ARRAY-NTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (BYTE-ARRAY-NTH-SETTER TOKENIZER-BYTE) ((BUFFER TOKENIZER-BYTE-ARRAY) (CH CHARACTER) (POSITION INTEGER)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (VERBATIM :COMMON-LISP (CL:SETF (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER) (CL:THE CL:FIXNUM POSITION)) (CL:THE CL:CHARACTER CH)) :CPP \"buffer[position] = ch\" :JAVA \"buffer[position] = (byte)ch\")))"
    (CL:FUNCTION BYTE-ARRAY-NTH-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-BYTE-ARRAY-READ-SEQUENCE"
    "(DEFUN (NATIVE-BYTE-ARRAY-READ-SEQUENCE INTEGER) ((BUFFER TOKENIZER-BYTE-ARRAY) (STREAM NATIVE-INPUT-STREAM) (START INTEGER) (END INTEGER)))"
    (CL:FUNCTION NATIVE-BYTE-ARRAY-READ-SEQUENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "TOKENIZER-BYTE-ARRAY-READ-SEQUENCE"
    "(DEFUN (TOKENIZER-BYTE-ARRAY-READ-SEQUENCE INTEGER) ((BUFFER TOKENIZER-BYTE-ARRAY) (STREAM INPUT-STREAM) (START INTEGER) (END INTEGER)))"
    (CL:FUNCTION TOKENIZER-BYTE-ARRAY-READ-SEQUENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "BYTE-ARRAY-READ-SEQUENCE"
    "(DEFUN (BYTE-ARRAY-READ-SEQUENCE INTEGER) ((BUFFER TOKENIZER-BYTE-ARRAY) (STREAM INPUT-STREAM) (START INTEGER) (END INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Read from `stream' filling `buffer' between `start' and `end' (depending
on how many characters are available).
Return the actual end pointer to the input read into `buffer'.  EOF is
indicated by the return value being equal to start.\")"
    (CL:FUNCTION BYTE-ARRAY-READ-SEQUENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-BYTE-ARRAY-WRITE-SEQUENCE"
    "(DEFUN NATIVE-BYTE-ARRAY-WRITE-SEQUENCE ((BUFFER TOKENIZER-BYTE-ARRAY) (STREAM NATIVE-OUTPUT-STREAM) (START INTEGER) (END INTEGER)))"
    (CL:FUNCTION NATIVE-BYTE-ARRAY-WRITE-SEQUENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "BYTE-ARRAY-WRITE-SEQUENCE"
    "(DEFUN BYTE-ARRAY-WRITE-SEQUENCE ((BUFFER TOKENIZER-BYTE-ARRAY) (STREAM NATIVE-OUTPUT-STREAM) (START INTEGER) (END INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Write from `buffer' to `stream', using data in the buffer starting at position
`start' stopping just before `end'.\")"
    (CL:FUNCTION BYTE-ARRAY-WRITE-SEQUENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "ENSURE-TOKENIZER-BUFFER-SIZE"
    "(DEFUN ENSURE-TOKENIZER-BUFFER-SIZE ((STATE TOKENIZER-STREAM-STATE) (CURRENTTOKENSTART INTEGER) (REQUIREDSPACE INTEGER)))"
    (CL:FUNCTION ENSURE-TOKENIZER-BUFFER-SIZE) NULL)
   (DEFINE-FUNCTION-OBJECT "READ-INTO-TOKENIZER-BUFFER"
    "(DEFUN (READ-INTO-TOKENIZER-BUFFER BOOLEAN) ((STREAM INPUT-STREAM) (STATE TOKENIZER-STREAM-STATE) (CURRENTTOKENSTART INTEGER)))"
    (CL:FUNCTION READ-INTO-TOKENIZER-BUFFER) NULL)
   (DEFINE-FUNCTION-OBJECT "READ-CHARACTER-FROM-TOKENIZER-BUFFER"
    "(DEFUN (READ-CHARACTER-FROM-TOKENIZER-BUFFER CHARACTER BOOLEAN) ((STREAM INPUT-STREAM)))"
    (CL:FUNCTION READ-CHARACTER-FROM-TOKENIZER-BUFFER) NULL)
   (DEFINE-FUNCTION-OBJECT "UNREAD-CHARACTER-FROM-TOKENIZER-BUFFER"
    "(DEFUN UNREAD-CHARACTER-FROM-TOKENIZER-BUFFER ((CHAR CHARACTER) (STREAM INPUT-STREAM)))"
    (CL:FUNCTION UNREAD-CHARACTER-FROM-TOKENIZER-BUFFER) NULL)
   (DEFINE-FUNCTION-OBJECT "READ-LINE-FROM-TOKENIZER-BUFFER"
    "(DEFUN (READ-LINE-FROM-TOKENIZER-BUFFER STRING) ((STREAM INPUT-STREAM)))"
    (CL:FUNCTION READ-LINE-FROM-TOKENIZER-BUFFER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (BUFFERED-INPUT-LENGTH INTEGER) ((STATE TOKENIZER-STREAM-STATE)))"
    (CL:FUNCTION BUFFERED-INPUT-LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR ((STATE TOKENIZER-STREAM-STATE)))"
    (CL:FUNCTION CLEAR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD RESET ((STATE TOKENIZER-STREAM-STATE)))"
    (CL:FUNCTION RESET) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-SAVED-STATE INTEGER) ((STATE-OBJECT TOKENIZER-STREAM-STATE) (TABLE TOKENIZER-TABLE)))"
    (CL:FUNCTION GET-SAVED-STATE) NULL)
   (DEFINE-FUNCTION-OBJECT "WITH-TOKENIZER"
    "(DEFUN WITH-TOKENIZER ((TABLE OBJECT) (INPUT OBJECT) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION WITH-TOKENIZER) NULL)
   (DEFINE-FUNCTION-OBJECT "WITH-TOKENIZER-STRING-INPUT?"
    "(DEFUN (WITH-TOKENIZER-STRING-INPUT? BOOLEAN) ())"
    (CL:FUNCTION WITH-TOKENIZER-STRING-INPUT?) NULL)
   (DEFINE-FUNCTION-OBJECT "INSIDE-WITH-TOKENIZER?"
    "(DEFUN (INSIDE-WITH-TOKENIZER? BOOLEAN) ())"
    (CL:FUNCTION INSIDE-WITH-TOKENIZER?) NULL)
   (DEFINE-FUNCTION-OBJECT "END-OF-TOKENS?"
    "(DEFUN END-OF-TOKENS? () :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION END-OF-TOKENS?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-TOKEN-TEXT"
    "(DEFUN GET-TOKEN-TEXT (|&BODY| (OPTIONS CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION GET-TOKEN-TEXT) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-TOKEN-TEXT-INTERNAL"
    "(DEFUN (GET-TOKEN-TEXT-INTERNAL STRING) ((BUFFER TOKENIZER-BYTE-ARRAY) (START INTEGER) (END INTEGER) (SIZE INTEGER) (UPCASE? BOOLEAN)))"
    (CL:FUNCTION GET-TOKEN-TEXT-INTERNAL) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-TOKEN-TYPE"
    "(DEFUN GET-TOKEN-TYPE () :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION GET-TOKEN-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "SAVE-TOKENIZER-STREAM-STATE"
    "(DEFUN SAVE-TOKENIZER-STREAM-STATE () :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION SAVE-TOKENIZER-STREAM-STATE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-NEXT-TOKEN"
    "(DEFUN GET-NEXT-TOKEN (|&BODY| (OPTIONS CONS)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION GET-NEXT-TOKEN) NULL)
   (DEFINE-FUNCTION-OBJECT "UNESCAPE-TOKEN-STRING"
    "(DEFUN (UNESCAPE-TOKEN-STRING STRING) ((TOKEN STRING) (ESCAPECHAR CHARACTER) (UPCASE? BOOLEAN)))"
    (CL:FUNCTION UNESCAPE-TOKEN-STRING) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF STREAM-TOKENIZER)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "WITH-STELLA-TOKENIZER"
    "(DEFUN WITH-STELLA-TOKENIZER ((INPUT OBJECT) |&BODY| (BODY CONS)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION WITH-STELLA-TOKENIZER) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-NEXT-STELLA-TOKEN"
    "(DEFUN GET-NEXT-STELLA-TOKEN (|&BODY| (OPTIONS CONS)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION GET-NEXT-STELLA-TOKEN) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-STELLA-TOKEN-TYPE"
    "(DEFUN GET-STELLA-TOKEN-TYPE () :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION GET-STELLA-TOKEN-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION"
    "(DEFUN GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION (|&BODY| (ESCAPEMODE CONS)) :TYPE OBJECT :MACRO? TRUE)"
    (CL:FUNCTION GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION) NULL)
   (DEFINE-FUNCTION-OBJECT
    "GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL"
    "(DEFUN (GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL INTEGER) ((BUFFER TOKENIZER-BYTE-ARRAY) (TOKENSTART INTEGER) (TOKENEND INTEGER) (SIZE INTEGER) (ESCAPEMODE KEYWORD)))"
    (CL:FUNCTION GET-QUALIFIED-SYMBOL-SEPARATOR-POSITION-INTERNAL)
    NULL)
   (DEFINE-FUNCTION-OBJECT "GET-TOKEN-INTEGER"
    "(DEFUN GET-TOKEN-INTEGER () :TYPE OBJECT :MACRO? TRUE :DOCUMENTATION \"User-level macro to access the most recently parsed token as an integer.
This assumes correct signed integer syntax and only checks for overflows.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-TOKEN-INTEGER) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-TOKEN-INTEGER-INTERNAL"
    "(DEFUN (GET-TOKEN-INTEGER-INTERNAL INTEGER) ((BUFFER TOKENIZER-BYTE-ARRAY) (START INTEGER) (END INTEGER) (SIZE INTEGER)))"
    (CL:FUNCTION GET-TOKEN-INTEGER-INTERNAL) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-TOKEN-LONG-INTEGER"
    "(DEFUN GET-TOKEN-LONG-INTEGER () :TYPE OBJECT :MACRO? TRUE :DOCUMENTATION \"User-level macro to access the most recently parsed token as a long integer.
This assumes correct signed long-integer syntax and only checks for overflows.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-TOKEN-LONG-INTEGER) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-TOKEN-LONG-INTEGER-INTERNAL"
    "(DEFUN (GET-TOKEN-LONG-INTEGER-INTERNAL LONG-INTEGER) ((BUFFER TOKENIZER-BYTE-ARRAY) (START INTEGER) (END INTEGER) (SIZE INTEGER)))"
    (CL:FUNCTION GET-TOKEN-LONG-INTEGER-INTERNAL) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-TOKEN-FLOAT"
    "(DEFUN GET-TOKEN-FLOAT () :TYPE OBJECT :MACRO? TRUE :DOCUMENTATION \"User-level macro to access the most recently parsed token as a float.
This assumes correct signed float syntax and only checks for overflows.
The main benefit for this is that it doesn't generate strings and wrappers.
Float parsing and conversion is generally hairy and we are probably not
covering all special cases here; but we are fast :-)\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-TOKEN-FLOAT) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-TOKEN-FLOAT-INTERNAL"
    "(DEFUN (GET-TOKEN-FLOAT-INTERNAL FLOAT) ((BUFFER TOKENIZER-BYTE-ARRAY) (START INTEGER) (END INTEGER) (SIZE INTEGER)))"
    (CL:FUNCTION GET-TOKEN-FLOAT-INTERNAL) NULL)
   (DEFINE-FUNCTION-OBJECT "TOKENIZE-S-EXPRESSION"
    "(DEFUN (TOKENIZE-S-EXPRESSION STELLA-TOKEN) ((STREAM INPUT-STREAM) (TOKENLIST STELLA-TOKEN)))"
    (CL:FUNCTION TOKENIZE-S-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-STELLA-NAME"
    "(DEFUN (PARSE-STELLA-NAME STRING STRING KEYWORD) ((NAME STRING) (ENABLECASECONVERSION? BOOLEAN)) :DOCUMENTATION \"Parse the printed representation `name' of a STELLA symbol, surrogate or
keyword and return its symbol name, module name and type (which is either
:SYMBOL, :SURROGATE or :KEYWORD).  `name' can be qualified and must use the
exact same syntax and escape characters that would be used if it were to be
read by `read-s-expression-from-string' (or `unstringify').  If
`enableCaseConversion?' is TRUE, the returned symbol name will be upcased if
the current module is case-insensitive; otherwise, it will be returned as is.
Raises a read exception if `name' does not represent a symbol.
This function is available primarily for efficiency, since it is about
10-15 times faster than `unstringify'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PARSE-STELLA-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "QUALIFIED-STELLA-NAME?"
    "(DEFUN (QUALIFIED-STELLA-NAME? BOOLEAN) ((NAME STRING)) :DOCUMENTATION \"Return TRUE if `name' is a symbol or surrogate qualified with a module
pathname or a module pathname ending with a `/'.  Assumes that `name'
is the printed representation of a STELLA symbol (potentially containing
escape characters).\" :PUBLIC? TRUE)"
    (CL:FUNCTION QUALIFIED-STELLA-NAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "STELLA-TOKEN-LIST-TO-S-EXPRESSION"
    "(DEFUN (STELLA-TOKEN-LIST-TO-S-EXPRESSION OBJECT) ((TOKENLIST STELLA-TOKEN)))"
    (CL:FUNCTION STELLA-TOKEN-LIST-TO-S-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPAND-QUOTE-MACRO-TOKEN"
    "(DEFUN EXPAND-QUOTE-MACRO-TOKEN ((QUOTEDLIST STELLA-TOKEN)))"
    (CL:FUNCTION EXPAND-QUOTE-MACRO-TOKEN) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-CHARACTER"
    "(DEFUN (STRING-TO-CHARACTER CHARACTER) ((NAME STRING)))"
    (CL:FUNCTION STRING-TO-CHARACTER) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-TOKENIZE-STRING-TABLE"
    "(DEFUN (CREATE-TOKENIZE-STRING-TABLE (VECTOR OF KEYWORD)) ((PUNCTUATIONCHARS STRING) (QUOTECHARS STRING) (ESCAPECHARS STRING)))"
    (CL:FUNCTION CREATE-TOKENIZE-STRING-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "TOKENIZE-STRING"
    "(DEFUN (TOKENIZE-STRING (CONS OF CONS)) ((STRING STRING) (PUNCTUATIONCHARS STRING) (QUOTECHARS STRING) (ESCAPECHARS STRING)) :DOCUMENTATION \"Simple tokenizer that is somewhere between Java's StringTokenizer
and StreamTokenizer in functionality.  It doens't specially support number
tokens nor comment strings/sequences even though this could be added at
the expense of some extra complexity.
Returns a list of (<token-string> <token-type>) pairs, where the token
type is one of :TEXT, :PUNCTUATION or :QUOTE, i.e., all white space
is ignored and escape characters are handled and removed.  For example:
	 
  (tokenize-string \\\"for(i='fo^'o'; i>0; i++)\\\" \\\"()=<>+-;\\\" \\\"'\\\" \\\"^\\\")
  =>
  ((\\\"for\\\" :TEXT) (\\\"(\\\" :PUNCTUATION) (\\\"i\\\" :TEXT)
   (\\\"=\\\" :PUNCTUATION) (\\\"'\\\" :QUOTE) (\\\"fo'o\\\" :TEXT)
   (\\\"'\\\" :QUOTE) (\\\";\\\" :PUNCTUATION) (\\\"i\\\" :TEXT)
   (\\\">\\\" :PUNCTUATION) (\\\"0\\\" :TEXT) (\\\";\\\" :PUNCTUATION)
   (\\\"i\\\" :TEXT) (\\\"++)\\\" :PUNCTUATION))
	
NOTE: this aggregates multiple punctuation characters that immediately
follow each other into a single token which is (generally) useful to pickup
multi-character operators such as ++, >=, etc.  It's still easy to pick them
apart in a post-processing step if necessary (e.g., for the `++)' case above),
so we leave this for now as a feature.\" :PUBLIC? TRUE)"
    (CL:FUNCTION TOKENIZE-STRING) NULL))
  :VOID)

(CL:DEFUN STARTUP-READ ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-READ1)
    (HELP-STARTUP-READ2) (HELP-STARTUP-READ3) (HELP-STARTUP-READ4))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-READ5))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5) (HELP-STARTUP-READ6))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-READ7)
    (DEFINE-FUNCTION-OBJECT "READ-S-EXPRESSION"
     "(DEFUN (READ-S-EXPRESSION OBJECT BOOLEAN) ((STREAM INPUT-STREAM)) :DOCUMENTATION \"Read one STELLA s-expression from `stream' and return
the result.  Return `true' as the second value on EOF.\" :PUBLIC? TRUE)"
     (CL:FUNCTION READ-S-EXPRESSION) NULL)
    (DEFINE-FUNCTION-OBJECT "EAT-NEXT-CHARACTER-IF-WHITESPACE"
     "(DEFUN (EAT-NEXT-CHARACTER-IF-WHITESPACE BOOLEAN) ((STREAM INPUT-STREAM)))"
     (CL:FUNCTION EAT-NEXT-CHARACTER-IF-WHITESPACE) NULL)
    (DEFINE-FUNCTION-OBJECT "CONSUME-WHITESPACE"
     "(DEFUN (CONSUME-WHITESPACE BOOLEAN) ((STREAM INPUT-STREAM)))"
     (CL:FUNCTION CONSUME-WHITESPACE) NULL)
    (DEFINE-FUNCTION-OBJECT "READ-S-EXPRESSION-FROM-STRING"
     "(DEFUN (READ-S-EXPRESSION-FROM-STRING OBJECT) ((STRING STRING)) :DOCUMENTATION \"Read one STELLA s-expression from `string' and
return the result.\" :PUBLIC? TRUE)"
     (CL:FUNCTION READ-S-EXPRESSION-FROM-STRING) NULL)
    (DEFINE-FUNCTION-OBJECT "MAKE-TOKENIZER-STRING-STREAM"
     "(DEFUN (MAKE-TOKENIZER-STRING-STREAM STRING-INPUT-STREAM) ((STRING STRING)))"
     (CL:FUNCTION MAKE-TOKENIZER-STRING-STREAM) NULL)
    (DEFINE-FUNCTION-OBJECT "NATIVE-READ-LINE"
     "(DEFUN (NATIVE-READ-LINE STRING) ((INPUTSTREAM INPUT-STREAM)) :DOCUMENTATION \"Read one line from `inputStream' using the native language
readline algorithm and return the result.  On EOF return `null'\" :PUBLIC? TRUE)"
     (CL:FUNCTION NATIVE-READ-LINE) NULL)
    (DEFINE-FUNCTION-OBJECT "READ-LINE"
     "(DEFUN (READ-LINE STRING) ((STREAM INPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Read one line from `stream' and return the result.
This differs from `native-read-line' in that it is not platform-dependent.
It recognizes any of the three common line ending formats: CR, LF, CR-LF
in any combination.  It is not as fast as `native-read-line', however.\")"
     (CL:FUNCTION READ-LINE) NULL)
    (DEFINE-FUNCTION-OBJECT "READ-LINE2"
     "(DEFUN (READ-LINE2 STRING KEYWORD) ((STREAM INPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Read one line from `stream' and return the result and
a keyword that indicates the terminator for that line ending:
`:CR' `:LF' `:CRLF' or `:EOF'.   This is not platform-dependent
and differs from `read-line' by returning a second value.  It
may hang when used on interactive streams such as terminal or
network streams with only CR line endings.  It should only be
used on file or string input streams.\")" (CL:FUNCTION READ-LINE2)
     NULL)
    (DEFINE-FUNCTION-OBJECT "READ-CHARACTER"
     "(DEFUN (READ-CHARACTER CHARACTER BOOLEAN) ((INPUTSTREAM INPUT-STREAM)) :DOCUMENTATION \"Read one character from `inputStream' and return the result.
Return `true' as the second value on EOF.\" :PUBLIC? TRUE)"
     (CL:FUNCTION READ-CHARACTER) NULL)
    (DEFINE-FUNCTION-OBJECT "UNREAD-CHARACTER"
     "(DEFUN UNREAD-CHARACTER ((CH CHARACTER) (INPUTSTREAM INPUT-STREAM)) :DOCUMENTATION \"Unread `ch' from `inputStream'.  Signal an error if `ch'
was not the last character read.\" :PUBLIC? TRUE)"
     (CL:FUNCTION UNREAD-CHARACTER) NULL)
    (DEFINE-FUNCTION-OBJECT "YES-OR-NO?"
     "(DEFUN (YES-OR-NO? BOOLEAN) ((MESSAGE STRING)) :DOCUMENTATION \"Read a line of input from STANDARD-INPUT and return `true'
if the input was `yes' or `false' if the input was `no'.  Loop until either
`yes' or `no' was entered.  If 'message' is non-`null' prompt with it before
the input is read.  See also special variable `*USER-QUERY-ACTION*'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION YES-OR-NO?) NULL)
    (DEFINE-FUNCTION-OBJECT "Y-OR-N?"
     "(DEFUN (Y-OR-N? BOOLEAN) ((MESSAGE STRING)) :DOCUMENTATION \"Read a line of input from STANDARD-INPUT and return `true'
if the input was `y' or `false' if the input was `n'.  Loop until either
`y' or `n' was entered.  If 'message' is non-`null' prompt with it before
the input is read.  See also special variable `*USER-QUERY-ACTION*'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION Y-OR-N?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (STREAM-TO-STRING STRING) ((FROM INPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Read all of the input from `stream' and return it as a string.\")"
     (CL:FUNCTION STREAM-TO-STRING) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-READ"
     "(DEFUN STARTUP-READ () :PUBLIC? TRUE)" (CL:FUNCTION STARTUP-READ)
     NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-READ-STELLA-STARTUP-READ)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-READ-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupRead") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAX-TOKENIZER-STATES* INTEGER 64)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAX-TOKENIZER-CHARACTERS* INTEGER 256)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TOKENIZER-INITIAL-BUFFER-SIZE* INTEGER 2048)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *WITHTOKENIZERINPUTTYPE* TYPE NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STELLA-TOKENIZER-TABLE-DEFINITION* CONS (BQUOTE ((:START :INCLUDE :DELIMITER :INCLUDE :ATOM) (:DELIMITER * \"(\" :OPEN-PAREN * \")\" :CLOSE-PAREN * \"\\\"\" (:OPEN-STRING :STRING) * \"'\" :SINGLE-QUOTE * \"`\" :BACK-QUOTE * \",\" :COMMA ! \";\" :COMMENT ! \"#\" :HASH ! (#\\  #\\Tab #\\Linefeed #\\Return) :WHITE-SPACE :EOF :EOF) (:WHITE-SPACE :INCLUDE :START) (:COMMENT (#\\Linefeed #\\Return) :START :EOF :EOF :OTHERWISE :COMMENT) (:PAREN-COMMENT \"\\\\\" :PAREN-COMMENT-ESCAPE \"|\" :PAREN-COMMENT-BAR :OTHERWISE :PAREN-COMMENT) (:PAREN-COMMENT-ESCAPE :ANY :PAREN-COMMENT) (:PAREN-COMMENT-BAR \"#\" :START \"\\\\\" :PAREN-COMMENT-ESCAPE \"|\" :PAREN-COMMENT-BAR :OTHERWISE :PAREN-COMMENT) (:OPEN-PAREN :INCLUDE :START) (:CLOSE-PAREN :INCLUDE :START) (:SINGLE-QUOTE :INCLUDE :START) (:BACK-QUOTE :INCLUDE :START) (:COMMA \".\" :COMMA-SPLICE :INCLUDE :DELIMITER * \"-+\" (:SYMBOL-OR-SIGNED-NUMBER :SYMBOL) * \"0123456789\" (:SYMBOL-OR-NUMBER :INTEGER) * \"cC\" (:SYMBOL-OR-CL-SYMBOL :SYMBOL) * \"|\" (:OPEN-FULLY-ESCAPED-SYMBOL :FULLY-ESCAPED-SYMBOL) * \"\\\\\" :ESCAPED-SYMBOL-ESCAPE * \"/\" :QUALIFIED-NAME * \":\" (:OPEN-KEYWORD :KEYWORD) * \"@\" (:OPEN-SURROGATE :SURROGATE) * :OTHERWISE :SYMBOL) (:COMMA-SPLICE :INCLUDE :START) (:OPEN-STRING * \"\\\"\" :CLOSE-STRING \"\\\\\" :STRING-ESCAPE :OTHERWISE :STRING) (:STRING * \"\\\"\" :CLOSE-STRING \"\\\\\" :STRING-ESCAPE :OTHERWISE :STRING) (:CLOSE-STRING :INCLUDE :START) (:STRING-ESCAPE :ANY :ESCAPED-STRING) (:ESCAPED-STRING * \"\\\"\" :CLOSE-STRING \"\\\\\" :STRING-ESCAPE :OTHERWISE :ESCAPED-STRING) (:HASH \"\\\\\" :CHARACTER-CONSTANT \"|\" :PAREN-COMMENT) (:CHARACTER-CONSTANT * :ANY :CHARACTER) (:CHARACTER :INCLUDE :DELIMITER :OTHERWISE :CHARACTER) (:ATOM * \"-+\" (:SYMBOL-OR-SIGNED-NUMBER :SYMBOL) * \"0123456789\" (:SYMBOL-OR-NUMBER :INTEGER) * \".\" (:SYMBOL-OR-MANTISSA :SYMBOL) * \"cC\" (:SYMBOL-OR-CL-SYMBOL :SYMBOL) * \"|\" (:OPEN-FULLY-ESCAPED-SYMBOL :FULLY-ESCAPED-SYMBOL) * \"\\\\\" :ESCAPED-SYMBOL-ESCAPE * \"/\" :QUALIFIED-NAME * \":\" (:OPEN-KEYWORD :KEYWORD) * \"@\" (:OPEN-SURROGATE :SURROGATE) * :OTHERWISE :SYMBOL) (:SYMBOL-OR-SIGNED-NUMBER :INCLUDE :DELIMITER \"/\" :QUALIFIED-NAME \"\\\\\" :ESCAPED-SYMBOL-ESCAPE \"0123456789\" (:SYMBOL-OR-NUMBER :INTEGER) \".\" (:SYMBOL-OR-MANTISSA :SYMBOL) \"|\" :ERROR :OTHERWISE :SYMBOL) (:SYMBOL-OR-NUMBER :INCLUDE :DELIMITER \"/\" :QUALIFIED-NAME \"\\\\\" :ESCAPED-SYMBOL-ESCAPE \"0123456789\" (:SYMBOL-OR-NUMBER :INTEGER) \".\" (:SYMBOL-OR-MANTISSA2 :FLOAT) \"eE\" (:SYMBOL-OR-EXPONENT-DELIMITER :SYMBOL) \"|\" :ERROR :OTHERWISE :SYMBOL) (:SYMBOL-OR-MANTISSA :INCLUDE :DELIMITER \"/\" :QUALIFIED-NAME \"\\\\\" :ESCAPED-SYMBOL-ESCAPE \"0123456789\" (:SYMBOL-OR-MANTISSA2 :FLOAT) \"eE\" (:SYMBOL-OR-EXPONENT-DELIMITER :SYMBOL) \"|\" :ERROR :OTHERWISE :SYMBOL) (:SYMBOL-OR-MANTISSA2 :INCLUDE :SYMBOL-OR-MANTISSA) (:SYMBOL-OR-EXPONENT-DELIMITER :INCLUDE :DELIMITER \"/\" :QUALIFIED-NAME \"\\\\\" :ESCAPED-SYMBOL-ESCAPE \"+-\" (:SYMBOL-OR-EXPONENT :SYMBOL) \"0123456789\" (:SYMBOL-OR-EXPONENT2 :FLOAT) \"|\" :ERROR :OTHERWISE :SYMBOL) (:SYMBOL-OR-EXPONENT :INCLUDE :DELIMITER \"/\" :QUALIFIED-NAME \"\\\\\" :ESCAPED-SYMBOL-ESCAPE \"0123456789\" (:SYMBOL-OR-EXPONENT2 :FLOAT) \"|\" :ERROR :OTHERWISE :SYMBOL) (:SYMBOL-OR-EXPONENT2 :INCLUDE :SYMBOL-OR-EXPONENT) (:SYMBOL-OR-CL-SYMBOL :INCLUDE :DELIMITER \"/\" :QUALIFIED-NAME \"\\\\\" :ESCAPED-SYMBOL-ESCAPE \"lL\" (:SYMBOL-OR-CL-SYMBOL2 :SYMBOL) \"|\" :ERROR :OTHERWISE :SYMBOL) (:SYMBOL-OR-CL-SYMBOL2 :INCLUDE :DELIMITER \"/\" :QUALIFIED-NAME \"\\\\\" :ESCAPED-SYMBOL-ESCAPE \":\" (:SYMBOL-OR-CL-SYMBOL3 :SYMBOL) \"|\" :ERROR :OTHERWISE :SYMBOL) (:SYMBOL-OR-CL-SYMBOL3 :INCLUDE :DELIMITER \"|\" :ERROR :OTHERWISE :CL-SYMBOL) (:CL-SYMBOL :INCLUDE :DELIMITER \"|\" :ERROR :OTHERWISE :CL-SYMBOL) (:ESCAPED-SYMBOL-ESCAPE :ANY :ESCAPED-SYMBOL) (:ESCAPED-SYMBOL :INCLUDE :DELIMITER \"/|\" :ERROR \"\\\\\" :ESCAPED-SYMBOL-ESCAPE :OTHERWISE :ESCAPED-SYMBOL) (:OPEN-FULLY-ESCAPED-SYMBOL * \"|\" :CLOSE-FULLY-ESCAPED-NAME \"\\\\\" :FULLY-ESCAPED-SYMBOL-ESCAPE :OTHERWISE :FULLY-ESCAPED-SYMBOL) (:FULLY-ESCAPED-SYMBOL-ESCAPE :ANY :FULLY-ESCAPED-SYMBOL) (:FULLY-ESCAPED-SYMBOL * \"|\" :CLOSE-FULLY-ESCAPED-NAME \"\\\\\" :FULLY-ESCAPED-SYMBOL-ESCAPE :OTHERWISE :FULLY-ESCAPED-SYMBOL) (:CLOSE-FULLY-ESCAPED-NAME :INCLUDE :START) (:SYMBOL :INCLUDE :DELIMITER \"/\" :QUALIFIED-NAME \"\\\\\" :ESCAPED-SYMBOL-ESCAPE \"|\" :ERROR :OTHERWISE :SYMBOL) (:OPEN-KEYWORD :INCLUDE :DELIMITER \"|\" :FULLY-ESCAPED-KEYWORD \"\\\\\" :ESCAPED-KEYWORD-ESCAPE :OTHERWISE :KEYWORD) (:KEYWORD :INCLUDE :DELIMITER \"\\\\\" :ESCAPED-KEYWORD-ESCAPE \"|\" :ERROR :OTHERWISE :KEYWORD) (:ESCAPED-KEYWORD-ESCAPE :ANY :ESCAPED-KEYWORD) (:ESCAPED-KEYWORD :INCLUDE :DELIMITER \"\\\\\" :ESCAPED-KEYWORD-ESCAPE \"|\" :ERROR :OTHERWISE :ESCAPED-KEYWORD) (:FULLY-ESCAPED-KEYWORD * \"|\" :CLOSE-FULLY-ESCAPED-NAME \"\\\\\" :FULLY-ESCAPED-KEYWORD-ESCAPE :OTHERWISE :FULLY-ESCAPED-KEYWORD) (:FULLY-ESCAPED-KEYWORD-ESCAPE :ANY :FULLY-ESCAPED-KEYWORD) (:OPEN-SURROGATE :INCLUDE :DELIMITER \"|\" :FULLY-ESCAPED-SURROGATE \"\\\\\" :ESCAPED-SURROGATE-ESCAPE :OTHERWISE :SURROGATE) (:SURROGATE :INCLUDE :DELIMITER \"/|\" :ERROR \"\\\\\" :ESCAPED-SURROGATE-ESCAPE :OTHERWISE :SURROGATE) (:ESCAPED-SURROGATE :INCLUDE :DELIMITER \"/|\" :ERROR \"\\\\\" :ESCAPED-SURROGATE-ESCAPE :OTHERWISE :ESCAPED-SURROGATE) (:ESCAPED-SURROGATE-ESCAPE :ANY :ESCAPED-SURROGATE) (:FULLY-ESCAPED-SURROGATE * \"|\" :CLOSE-FULLY-ESCAPED-NAME \"\\\\\" :FULLY-ESCAPED-SURROGATE-ESCAPE :OTHERWISE :FULLY-ESCAPED-SURROGATE) (:FULLY-ESCAPED-SURROGATE-ESCAPE :ANY :FULLY-ESCAPED-SURROGATE) (:QUALIFIED-NAME :INCLUDE :DELIMITER \"@\" :QUALIFIED-SURROGATE \":\" :ERROR \"\\\\\" :QUALIFIED-ESCAPED-SYMBOL-ESCAPE \"|\" :QUALIFIED-FULLY-ESCAPED-SYMBOL \"/\" :QUALIFIED-NAME :OTHERWISE :QUALIFIED-SYMBOL) (:QUALIFIED-SYMBOL :INCLUDE :DELIMITER \"/\" :QUALIFIED-NAME \"\\\\\" :QUALIFIED-ESCAPED-SYMBOL-ESCAPE \"|\" :ERROR :OTHERWISE :QUALIFIED-SYMBOL) (:QUALIFIED-SURROGATE :INCLUDE :DELIMITER \"/\" :ERROR \"\\\\\" :QUALIFIED-ESCAPED-SURROGATE-ESCAPE \"|\" :QUALIFIED-FULLY-ESCAPED-SURROGATE :OTHERWISE :QUALIFIED-SURROGATE) (:QUALIFIED-ESCAPED-SYMBOL :INCLUDE :DELIMITER \"/|\" :ERROR \"\\\\\" :QUALIFIED-ESCAPED-SYMBOL-ESCAPE :OTHERWISE :QUALIFIED-ESCAPED-SYMBOL) (:QUALIFIED-ESCAPED-SYMBOL-ESCAPE :ANY :QUALIFIED-ESCAPED-SYMBOL) (:QUALIFIED-ESCAPED-SURROGATE :INCLUDE :DELIMITER \"/|\" :ERROR \"\\\\\" :QUALIFIED-ESCAPED-SURROGATE-ESCAPE :OTHERWISE :QUALIFIED-ESCAPED-SURROGATE) (:QUALIFIED-ESCAPED-SURROGATE-ESCAPE :ANY :QUALIFIED-ESCAPED-SURROGATE) (:QUALIFIED-FULLY-ESCAPED-SYMBOL * \"|\" :CLOSE-FULLY-ESCAPED-NAME \"\\\\\" :QUALIFIED-FULLY-ESCAPED-SYMBOL-ESCAPE :OTHERWISE :QUALIFIED-FULLY-ESCAPED-SYMBOL) (:QUALIFIED-FULLY-ESCAPED-SYMBOL-ESCAPE :ANY :QUALIFIED-FULLY-ESCAPED-SYMBOL) (:QUALIFIED-FULLY-ESCAPED-SURROGATE * \"|\" :CLOSE-FULLY-ESCAPED-NAME \"\\\\\" :QUALIFIED-FULLY-ESCAPED-SURROGATE-ESCAPE :OTHERWISE :QUALIFIED-FULLY-ESCAPED-SURROGATE) (:QUALIFIED-FULLY-ESCAPED-SURROGATE-ESCAPE :ANY :QUALIFIED-FULLY-ESCAPED-SURROGATE) (:ERROR :INCLUDE :START))))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STELLA-TOKENIZER-TABLE* TOKENIZER-TABLE NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STELLA-LOGICAL-STATE-NAMES* (VECTOR OF KEYWORD) NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STELLA-LOGICAL-STATE-NAMES-TABLE* (PROPERTY-LIST OF KEYWORD KEYWORD) (NEW (PROPERTY-LIST OF KEYWORD KEYWORD) :THE-PLIST (BQUOTE (:SYMBOL :SYMBOL :ESCAPED-SYMBOL :SYMBOL :FULLY-ESCAPED-SYMBOL :SYMBOL :QUALIFIED-SYMBOL :SYMBOL :QUALIFIED-ESCAPED-SYMBOL :SYMBOL :QUALIFIED-FULLY-ESCAPED-SYMBOL :SYMBOL :CL-SYMBOL :SYMBOL :SURROGATE :SURROGATE :ESCAPED-SURROGATE :SURROGATE :QUALIFIED-SURROGATE :SURROGATE :QUALIFIED-ESCAPED-SURROGATE :SURROGATE :FULLY-ESCAPED-SURROGATE :SURROGATE :QUALIFIED-FULLY-ESCAPED-SURROGATE :SURROGATE :KEYWORD :KEYWORD :ESCAPED-KEYWORD :KEYWORD :FULLY-ESCAPED-KEYWORD :KEYWORD :QUALIFIED-NAME :QUALIFIED-NAME :STRING :STRING :ESCAPED-STRING :STRING :INTEGER :INTEGER :FLOAT :FLOAT :CHARACTER :CHARACTER :OPEN-PAREN :OPEN-PAREN :CLOSE-PAREN :CLOSE-PAREN :SINGLE-QUOTE :SINGLE-QUOTE :BACK-QUOTE :BACK-QUOTE :COMMA :COMMA :COMMA-SPLICE :COMMA-SPLICE :CLOSE-STRING :CLOSE-BALANCED-QUOTE :CLOSE-FULLY-ESCAPED-NAME :CLOSE-BALANCED-QUOTE :ERROR :ERROR))))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GET-TOKEN-INTEGER-CHECKPOINT* INTEGER (DIV (- MOST-POSITIVE-INTEGER 9) 10))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GET-TOKEN-LONG-INTEGER-CHECKPOINT* LONG-INTEGER (DIV (- MOST-POSITIVE-LONG-INTEGER 9) 10))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STELLA-TOKENIZER-WHITE-SPACE-STATE* INTEGER (POSITION (STATE-NAMES *STELLA-TOKENIZER-TABLE*) :WHITE-SPACE 0))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *READ-LINE-TOKENIZER-TABLE-DEFINITION* CONS (BQUOTE ((:START * (#\\Linefeed) :INITIAL-LINEFEED * (#\\Return) :INITIAL-RETURN :EOF :EOF * :OTHERWISE :LINE) (:INITIAL-LINEFEED :INCLUDE :LINEFEED) (:INITIAL-RETURN :INCLUDE :RETURN) (:RETURN * (#\\Linefeed) :LINEFEED * (#\\Return) :INITIAL-RETURN :EOF :EOF * :OTHERWISE :LINE) (:LINEFEED :EOF :EOF * (#\\Linefeed) :INITIAL-LINEFEED * (#\\Return) :INITIAL-RETURN * :OTHERWISE :LINE) (:LINE * (#\\Linefeed) :LINEFEED * (#\\Return) :RETURN * :EOF :EOF :OTHERWISE :LINE) (:ERROR :INCLUDE :START))) :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *READ-LINE2-TOKENIZER-TABLE-DEFINITION* CONS (BQUOTE ((:START * (#\\Linefeed) :LINEFEED * (#\\Return) :RETURN :EOF :EOF * :OTHERWISE :LINE) (:LINE * (#\\Linefeed) :LINEFEED * (#\\Return) :RETURN * :EOF :EOF :OTHERWISE :LINE) (:RETURN * :EOF :EOF (#\\Linefeed) :RETURN-LINEFEED * (#\\Return) :RETURN * :OTHERWISE :LINE) (:LINEFEED :EOF :EOF * (#\\Linefeed) :LINEFEED * (#\\Return) :RETURN * :OTHERWISE :LINE) (:RETURN-LINEFEED * :EOF :EOF * (#\\Linefeed) :LINEFEED * (#\\Return) :RETURN * :OTHERWISE :LINE) (:ERROR :INCLUDE :START))) :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *READ-LINE-TOKENIZER-TABLE* TOKENIZER-TABLE NULL :PUBLIC? FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *READ-LINE2-TOKENIZER-TABLE* TOKENIZER-TABLE NULL :PUBLIC? FALSE)")
    (CL:SETQ *READ-LINE-TOKENIZER-TABLE*
     (PARSE-TOKENIZER-DEFINITION
      *READ-LINE-TOKENIZER-TABLE-DEFINITION*))
    (CL:SETQ *READ-LINE2-TOKENIZER-TABLE*
     (PARSE-TOKENIZER-DEFINITION
      *READ-LINE2-TOKENIZER-TABLE-DEFINITION*))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *USER-QUERY-ACTION* KEYWORD :ASK :PUBLIC? TRUE :DOCUMENTATION \"Controls the behavior of interactive queries.  The default is :ASK
which asks the user.  Other options are :YES, :NO, :YES-VERBOSE, :NO-VERBOSE.  These
return the answer indicated, with the verbose versions printing the message and answer.\")")))
  :VOID)
