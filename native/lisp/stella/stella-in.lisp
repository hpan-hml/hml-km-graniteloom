;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; stella-in.lisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2014      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-STELLA-IN-STELLA-TRUE NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-FALSE NULL)
(CL:DEFVAR SGT-STELLA-IN-STELLA-CONS NULL)
(CL:DEFVAR SGT-STELLA-IN-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-DEFMETHOD NULL)
(CL:DEFVAR KWD-STELLA-IN-PUBLIC-SLOTS NULL)
(CL:DEFVAR KWD-STELLA-IN-SLOTS NULL)
(CL:DEFVAR KWD-STELLA-IN-PUBLIC-METHODS NULL)
(CL:DEFVAR KWD-STELLA-IN-METHODS NULL)
(CL:DEFVAR KWD-STELLA-IN-PARAMETERS NULL)
(CL:DEFVAR KWD-STELLA-IN-KEY NULL)
(CL:DEFVAR KWD-STELLA-IN-SYNONYMS NULL)
(CL:DEFVAR KWD-STELLA-IN-DOCUMENTATION NULL)
(CL:DEFVAR KWD-STELLA-IN-CL-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-STELLA-IN-CPP-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-STELLA-IN-JAVA-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-STELLA-IN-IDL-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-STELLA-IN-ABSTRACT? NULL)
(CL:DEFVAR KWD-STELLA-IN-ACTIVE? NULL)
(CL:DEFVAR KWD-STELLA-IN-PUBLIC? NULL)
(CL:DEFVAR KWD-STELLA-IN-CL-STRUCT? NULL)
(CL:DEFVAR KWD-STELLA-IN-MIXIN? NULL)
(CL:DEFVAR KWD-STELLA-IN-RECYCLE-METHOD NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-NEXT-SWEEP-LIST-OBJECT NULL)
(CL:DEFVAR KWD-STELLA-IN-TYPE NULL)
(CL:DEFVAR KWD-STELLA-IN-EXTENSION NULL)
(CL:DEFVAR KWD-STELLA-IN-CREATOR NULL)
(CL:DEFVAR KWD-STELLA-IN-DESTRUCTOR NULL)
(CL:DEFVAR KWD-STELLA-IN-INITIALIZER NULL)
(CL:DEFVAR KWD-STELLA-IN-TERMINATOR NULL)
(CL:DEFVAR KWD-STELLA-IN-EQUALITY-TEST NULL)
(CL:DEFVAR KWD-STELLA-IN-INITIAL-VALUE NULL)
(CL:DEFVAR KWD-STELLA-IN-PRINT-FORM NULL)
(CL:DEFVAR KWD-STELLA-IN-PROPERTIES NULL)
(CL:DEFVAR KWD-STELLA-IN-META-ATTRIBUTES NULL)
(CL:DEFVAR KWD-STELLA-IN-CHILDREN NULL)
(CL:DEFVAR KWD-STELLA-IN-INITIALLY NULL)
(CL:DEFVAR KWD-STELLA-IN-DEFAULT NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-LIKE NULL)
(CL:DEFVAR KWD-STELLA-IN-ALLOCATION NULL)
(CL:DEFVAR KWD-STELLA-IN-READER NULL)
(CL:DEFVAR KWD-STELLA-IN-WRITER NULL)
(CL:DEFVAR KWD-STELLA-IN-INVERSE NULL)
(CL:DEFVAR KWD-STELLA-IN-RENAMES NULL)
(CL:DEFVAR KWD-STELLA-IN-REQUIRED? NULL)
(CL:DEFVAR KWD-STELLA-IN-COMPONENT? NULL)
(CL:DEFVAR KWD-STELLA-IN-READ-ONLY? NULL)
(CL:DEFVAR KWD-STELLA-IN-CONTEXT-SENSITIVE? NULL)
(CL:DEFVAR KWD-STELLA-IN-HARDWIRED? NULL)
(CL:DEFVAR KWD-STELLA-IN-OPTION-KEYWORD NULL)
(CL:DEFVAR KWD-STELLA-IN-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-SLOT-HOME-MODULE NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-SETTER NULL)
(CL:DEFVAR KWD-STELLA-IN-RETURN-TYPES NULL)
(CL:DEFVAR KWD-STELLA-IN-STORAGE-SLOT NULL)
(CL:DEFVAR KWD-STELLA-IN-INHERITS-THROUGH NULL)
(CL:DEFVAR KWD-STELLA-IN-SETTER? NULL)
(CL:DEFVAR KWD-STELLA-IN-NATIVE? NULL)
(CL:DEFVAR KWD-STELLA-IN-CONSTRUCTOR? NULL)
(CL:DEFVAR KWD-STELLA-IN-AUXILIARY? NULL)
(CL:DEFVAR KWD-STELLA-IN-GLOBALLY-INLINE? NULL)
(CL:DEFVAR KWD-STELLA-IN-COMMAND? NULL)
(CL:DEFVAR KWD-STELLA-IN-LISP-MACRO? NULL)
(CL:DEFVAR KWD-STELLA-IN-EVALUATE-ARGUMENTS? NULL)
(CL:DEFVAR KWD-STELLA-IN-INLINE NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-DEFUN NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-SLOT-AUXILIARY? NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-METHOD-GLOBALLY-INLINE? NULL)
(CL:DEFVAR KWD-STELLA-IN-DYNAMIC NULL)
(CL:DEFVAR SGT-STELLA-IN-STELLA-DYNAMIC-SLOTS-MIXIN NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-SLOT-OPTION-KEYWORD NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-DEFAULT-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-SLOT-OPTION-HANDLER NULL)
(CL:DEFVAR SGT-STELLA-IN-STELLA-BOOLEAN NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-STARTUP-STELLA-IN NULL)
(CL:DEFVAR SYM-STELLA-IN-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *SAFETY* *STELLA-MODULE* STANDARD-WARNING FALSE-WRAPPER
  NULL-INTEGER STANDARD-OUTPUT NIL STANDARD-ERROR EOL *MODULE*))

;;; (DEFGLOBAL *REDEFINE-IDENTICAL-CLASSES?* ...)

(CL:DEFVAR *REDEFINE-IDENTICAL-CLASSES?* CL:NIL
  "If `true', always redefine classes, even if an
                  identical class exists")

;;; (DEFUN (PERMANENTIFY-FORM OBJECT) ...)

(CL:DEFUN PERMANENTIFY-FORM (FORM)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE FORM)))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:COND
       ((CL:EQ FORM SYM-STELLA-IN-STELLA-TRUE)
        (CL:RETURN-FROM PERMANENTIFY-FORM FORM))
       ((CL:EQ FORM SYM-STELLA-IN-STELLA-FALSE)
        (CL:RETURN-FROM PERMANENTIFY-FORM FORM))
       (CL:T (CL:RETURN-FROM PERMANENTIFY-FORM (PERMANENTIFY FORM))))))
    ((CL:EQ TEST-VALUE-000 SGT-STELLA-IN-STELLA-CONS)
     (CL:PROGN
      (CL:RETURN-FROM PERMANENTIFY-FORM (PERMANENT-COPY FORM))))
    (CL:T (CL:RETURN-FROM PERMANENTIFY-FORM (PERMANENTIFY FORM))))))

;;; (DEFUN (TRANSIENTIFY-FORM OBJECT) ...)

(CL:DEFUN TRANSIENTIFY-FORM (FORM)
  (CL:RETURN-FROM TRANSIENTIFY-FORM (COPY-CONS-TREE FORM)))

;;; (DEFUN (STRINGIFY-IN-MODULE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:SIMPLE-STRING)
  STRINGIFY-IN-MODULE))
(CL:DEFUN STRINGIFY-IN-MODULE (TREE MODULE)
  "Stringify a parse `tree' relative to `module', or
`*module*' if no module is specified."
  (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
  (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:RETURN-FROM STRINGIFY-IN-MODULE (STRINGIFY TREE))))

;;; (DEFUN (UNSTRINGIFY-IN-MODULE OBJECT) ...)

(CL:DEFUN UNSTRINGIFY-IN-MODULE (STRING MODULE)
  "Unstringify relative to `module', or `*MODULE*' if no
module is specified."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
  (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:RETURN-FROM UNSTRINGIFY-IN-MODULE
    (READ-S-EXPRESSION-FROM-STRING STRING))))

;;; (DEFUN (UNSTRINGIFY-STELLA-SOURCE OBJECT) ...)

(CL:DEFUN UNSTRINGIFY-STELLA-SOURCE (SOURCE MODULE)
  "Unstringify a STELLA `source' string relative to `module',
or `*MODULE*' if no module is specified.  This function allocates transient
objects as opposed to `unstringify-in-module' or the regular `unstringify'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SOURCE))
  #+MCL
  (CL:CHECK-TYPE SOURCE CL:SIMPLE-STRING)
  (CL:LET* ((RESULT NULL))
   (CL:LET* ((*TRANSIENTOBJECTS?* CL:T))
    (CL:DECLARE (CL:SPECIAL *TRANSIENTOBJECTS?*))
    (CL:SETQ RESULT (UNSTRINGIFY-IN-MODULE SOURCE MODULE)))
   (CL:RETURN-FROM UNSTRINGIFY-STELLA-SOURCE RESULT)))

;;; (DEFUN (COLLECT-FEATURE-LIST (LIST OF GENERALIZED-SYMBOL)) ...)

(CL:DEFUN COLLECT-FEATURE-LIST (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-STELLA-IN-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((RESULT NULL))
      (CL:WHEN (CL:> (LENGTH TREE) 0) (CL:SETQ RESULT (NEW-LIST)))
      (CL:LET* ((FEATURE NULL) (ITER-000 TREE) (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ FEATURE (%%VALUE ITER-000))
        (CL:TAGBODY
         (CL:WHEN
          (CL:NOT
           (ISA? FEATURE SGT-STELLA-IN-STELLA-GENERALIZED-SYMBOL))
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
            (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
             " Ignoring illegal feature `"
             (DE-UGLIFY-PARSE-TREE FEATURE) "' in feature list: `"
             (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
          (CL:GO :CONTINUE))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-000 (CONS (PERMANENTIFY FEATURE) NIL))
           (CL:IF (CL:EQ (%THE-CONS-LIST RESULT) NIL)
            (CL:SETF (%THE-CONS-LIST RESULT) COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST RESULT)
             COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000)
            (CONS (PERMANENTIFY FEATURE) NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         :CONTINUE)
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:RETURN-FROM COLLECT-FEATURE-LIST RESULT))))
   (CL:T
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal atomic feature list: `" (DE-UGLIFY-PARSE-TREE TREE)
       "'." EOL)))
    (CL:RETURN-FROM COLLECT-FEATURE-LIST NULL))))

;;; (DEFUN (COLLECT-KEY-VALUE-LIST (KEY-VALUE-LIST OF GENERALIZED-SYMBOL OBJECT)) ...)

(CL:DEFUN COLLECT-KEY-VALUE-LIST (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-STELLA-IN-STELLA-CONS)
    (CL:PROGN
     (CL:LET*
      ((LENGTH (LENGTH TREE)) (CURSOR TREE) (KEY NULL) (VALUE NULL)
       (RESULT NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH))
      (CL:WHEN (CL:= LENGTH 0)
       (CL:RETURN-FROM COLLECT-KEY-VALUE-LIST NULL))
      (CL:WHEN (CL:LOGBITP 0 LENGTH)
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
          " Unbalanced keys and values in key-value list: `"
          (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
       (CL:RETURN-FROM COLLECT-KEY-VALUE-LIST NULL))
      (CL:SETQ RESULT (NEW-KEY-VALUE-LIST))
      (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
       (CL:TAGBODY (CL:SETQ KEY (%%VALUE CURSOR))
        (CL:SETQ VALUE (%%VALUE (%%REST CURSOR)))
        (CL:SETQ CURSOR (%%REST (%%REST CURSOR)))
        (CL:WHEN
         (CL:NOT (ISA? KEY SGT-STELLA-IN-STELLA-GENERALIZED-SYMBOL))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
            " Ignoring illegal key `" (DE-UGLIFY-PARSE-TREE KEY)
            "' in key-value list: `" (DE-UGLIFY-PARSE-TREE TREE) "'."
            EOL)))
         (CL:GO :CONTINUE))
        (CL:IF
         (CL:OR (CL:EQ VALUE SYM-STELLA-IN-STELLA-TRUE)
          (CL:EQ VALUE SYM-STELLA-IN-STELLA-FALSE))
         (CL:SETQ VALUE (COERCE-TO-BOOLEAN VALUE))
         (CL:SETQ VALUE (PERMANENT-COPY VALUE)))
        (INSERT-AT RESULT (PERMANENTIFY KEY) VALUE) :CONTINUE))
      (CL:RETURN-FROM COLLECT-KEY-VALUE-LIST RESULT))))
   (CL:T
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal atomic key-value list: `" (DE-UGLIFY-PARSE-TREE TREE)
       "'." EOL)))
    (CL:RETURN-FROM COLLECT-KEY-VALUE-LIST NULL))))

;;; (DEFUN (DEFINE-INLINE-METHOD METHOD-SLOT) ...)

(CL:DEFUN DEFINE-INLINE-METHOD (NAME PARAMETERSANDBODY)
  (CL:LET* ((PARSETREE NULL) (METHOD NULL))
   (CL:SETQ PARSETREE
    (LIST* SYM-STELLA-IN-STELLA-DEFMETHOD NAME
     (CONCATENATE PARAMETERSANDBODY NIL)))
   (CL:SETQ METHOD
    (HELP-DEFINE-METHOD-FROM-PARSE-TREE PARSETREE
     (STRINGIFY PARSETREE)))
   (CL:RETURN-FROM DEFINE-INLINE-METHOD METHOD)))

;;; (DEFUN (HELP-DEFINE-CLASS-FROM-PARSE-TREE CLASS) ...)

(CL:DEFUN HELP-DEFINE-CLASS-FROM-PARSE-TREE (PARSETREE STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (CL:LET*
   ((TREEDEFINITION (%%REST PARSETREE))
    (THESUPERS (%%VALUE (%%REST TREEDEFINITION)))
    (THEOPTIONS (NEW-PROPERTY-LIST))
    (CLASSTYPE (TYPIFY (%%VALUE TREEDEFINITION)))
    (DIRECTSUPERS (NEW-LIST)) (SLOTS (NEW-LIST))
    (CLASSOPTIONS (NEW-KEYWORD-KEY-VALUE-LIST)) (KEY NULL)
    (PARAMETERS NULL) (SLOTTREE NULL))
   (CL:SETF (%THE-PLIST THEOPTIONS) (%%REST (%%REST TREEDEFINITION)))
   (CL:LET* ((S NULL) (ITER-000 THESUPERS) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ S (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (TYPIFY S) NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST DIRECTSUPERS) NIL)
        (CL:SETF (%THE-CONS-LIST DIRECTSUPERS) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST DIRECTSUPERS)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS (TYPIFY S) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((THEKEY NULL) (THEVALUE NULL) (ITER-001 (%THE-PLIST THEOPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ THEKEY (%%VALUE ITER-001))
     (CL:SETQ THEVALUE (%%VALUE (%%REST ITER-001)))
     (CL:SETQ KEY (PERMANENTIFY THEKEY))
     (CL:COND
      ((CL:OR (CL:EQ KEY KWD-STELLA-IN-PUBLIC-SLOTS)
        (CL:EQ KEY KWD-STELLA-IN-SLOTS))
       (CL:LET* ((LOCALSLOT NULL))
        (CL:LET*
         ((SLOTDEF NULL) (ITER-002 THEVALUE) (COLLECT-001 NULL))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
          (CL:SETQ SLOTDEF (%%VALUE ITER-002))
          (CL:TAGBODY
           (CL:WHEN (CL:NOT (CONS? SLOTDEF))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-NOTE)
             (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
              (PRINT-ERROR-CONTEXT ">> NOTE: " STANDARD-OUTPUT)
              (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
               " Illegal slot definition:" EOL "   `"
               (DE-UGLIFY-PARSE-TREE SLOTDEF) "'" EOL "." EOL)))
            (CL:GO :CONTINUE))
           (CL:SETQ LOCALSLOT
            (DEFINE-STORAGE-SLOT-FROM-PARSE-TREE SLOTDEF CLASSTYPE))
           (CL:WHEN (CL:EQ KEY KWD-STELLA-IN-PUBLIC-SLOTS)
            (CL:SETF (%SLOT-PUBLIC? LOCALSLOT) CL:T))
           (CL:IF (CL:EQ COLLECT-001 NULL)
            (CL:PROGN (CL:SETQ COLLECT-001 (CONS LOCALSLOT NIL))
             (CL:IF (CL:EQ (%THE-CONS-LIST SLOTS) NIL)
              (CL:SETF (%THE-CONS-LIST SLOTS) COLLECT-001)
              (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST SLOTS)
               COLLECT-001)))
            (CL:PROGN
             (CL:SETF (%%REST COLLECT-001) (CONS LOCALSLOT NIL))
             (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
           :CONTINUE)
          (CL:SETQ ITER-002 (%%REST ITER-002))))))
      ((CL:OR (CL:EQ KEY KWD-STELLA-IN-PUBLIC-METHODS)
        (CL:EQ KEY KWD-STELLA-IN-METHODS))
       (CL:LET* ((LOCALSLOT NULL))
        (CL:LET*
         ((METHODDEF NULL) (ITER-003 THEVALUE) (COLLECT-002 NULL))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
          (CL:SETQ METHODDEF (%%VALUE ITER-003))
          (CL:TAGBODY
           (CL:WHEN (CL:NOT (CONS? METHODDEF))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-NOTE)
             (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
              (PRINT-ERROR-CONTEXT ">> NOTE: " STANDARD-OUTPUT)
              (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
               " Illegal inline method definition:" EOL "   `"
               (DE-UGLIFY-PARSE-TREE METHODDEF) "'" EOL "." EOL)))
            (CL:GO :CONTINUE))
           (CL:SETQ LOCALSLOT
            (DEFINE-INLINE-METHOD (%%VALUE METHODDEF)
             (%%REST METHODDEF)))
           (CL:WHEN (CL:EQ KEY KWD-STELLA-IN-PUBLIC-METHODS)
            (CL:SETF (%SLOT-PUBLIC? LOCALSLOT) CL:T))
           (CL:WHEN (CL:NOT (CL:EQ (%SLOT-OWNER LOCALSLOT) CLASSTYPE))
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
              (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
               " Defining a method for the class `"
               (%SLOT-OWNER LOCALSLOT) "' inside of the class `"
               (DE-UGLIFY-PARSE-TREE CLASSTYPE) "'." EOL))))
           (CL:IF (CL:EQ COLLECT-002 NULL)
            (CL:PROGN (CL:SETQ COLLECT-002 (CONS LOCALSLOT NIL))
             (CL:IF (CL:EQ (%THE-CONS-LIST SLOTS) NIL)
              (CL:SETF (%THE-CONS-LIST SLOTS) COLLECT-002)
              (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST SLOTS)
               COLLECT-002)))
            (CL:PROGN
             (CL:SETF (%%REST COLLECT-002) (CONS LOCALSLOT NIL))
             (CL:SETQ COLLECT-002 (%%REST COLLECT-002))))
           :CONTINUE)
          (CL:SETQ ITER-003 (%%REST ITER-003))))))
      ((CL:EQ KEY KWD-STELLA-IN-PARAMETERS)
       (CL:SETQ PARAMETERS (NEW-LIST))
       (CL:LET* ((SLOTDEF NULL) (ITER-004 THEVALUE) (COLLECT-003 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
         (CL:SETQ SLOTDEF (%%VALUE ITER-004))
         (CL:IF (CL:EQ COLLECT-003 NULL)
          (CL:PROGN
           (CL:SETQ COLLECT-003
            (CONS
             (DEFINE-STORAGE-SLOT-FROM-PARSE-TREE SLOTDEF CLASSTYPE)
             NIL))
           (CL:IF (CL:EQ (%THE-CONS-LIST PARAMETERS) NIL)
            (CL:SETF (%THE-CONS-LIST PARAMETERS) COLLECT-003)
            (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST PARAMETERS)
             COLLECT-003)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-003)
            (CONS
             (DEFINE-STORAGE-SLOT-FROM-PARSE-TREE SLOTDEF CLASSTYPE)
             NIL))
           (CL:SETQ COLLECT-003 (%%REST COLLECT-003))))
         (CL:SETQ ITER-004 (%%REST ITER-004))))
       (INSERT-AT CLASSOPTIONS KEY PARAMETERS))
      ((CL:EQ KEY KWD-STELLA-IN-KEY)
       (CL:WHEN (CL:NOT (CONS? THEVALUE))
        (CL:SETQ THEVALUE (CONS THEKEY NIL)))
       (IN-PLACE-OBJECTS-TO-SYMBOLS THEVALUE)
       (INSERT-AT CLASSOPTIONS KEY THEVALUE))
      ((CL:EQ KEY KWD-STELLA-IN-SYNONYMS)
       (CL:WHEN (CL:NOT (CONS? THEVALUE))
        (CL:SETQ THEVALUE (CONS THEKEY NIL)))
       (IN-PLACE-OBJECTS-TO-TYPES THEVALUE)
       (INSERT-AT CLASSOPTIONS KEY THEVALUE))
      ((CL:OR (CL:EQ KEY KWD-STELLA-IN-DOCUMENTATION)
        (CL:EQ KEY KWD-STELLA-IN-CL-NATIVE-TYPE)
        (CL:EQ KEY KWD-STELLA-IN-CPP-NATIVE-TYPE)
        (CL:EQ KEY KWD-STELLA-IN-JAVA-NATIVE-TYPE)
        (CL:EQ KEY KWD-STELLA-IN-IDL-NATIVE-TYPE))
       (INSERT-AT CLASSOPTIONS KEY THEVALUE))
      ((CL:OR (CL:EQ KEY KWD-STELLA-IN-ABSTRACT?)
        (CL:EQ KEY KWD-STELLA-IN-ACTIVE?)
        (CL:EQ KEY KWD-STELLA-IN-PUBLIC?)
        (CL:EQ KEY KWD-STELLA-IN-CL-STRUCT?)
        (CL:EQ KEY KWD-STELLA-IN-MIXIN?))
       (INSERT-AT CLASSOPTIONS KEY (COERCE-TO-BOOLEAN THEVALUE)))
      ((CL:EQ KEY KWD-STELLA-IN-RECYCLE-METHOD)
       (CL:SETQ THEVALUE (PERMANENTIFY THEVALUE))
       (INSERT-AT CLASSOPTIONS KEY THEVALUE)
       (CL:WHEN
        (MEMBER?
         (GET-QUOTED-TREE
          "((:SWEEP-LIST :FREE-AND-SWEEP-LIST) \"/STELLA\")" "/STELLA")
         THEVALUE)
        (CL:SETQ SLOTTREE
         (LIST* SYM-STELLA-IN-STELLA-NEXT-SWEEP-LIST-OBJECT
          KWD-STELLA-IN-TYPE (%%VALUE TREEDEFINITION) NIL))
        (PUSH SLOTS
         (DEFINE-STORAGE-SLOT-FROM-PARSE-TREE SLOTTREE CLASSTYPE))))
      ((CL:OR (CL:EQ KEY KWD-STELLA-IN-EXTENSION)
        (CL:EQ KEY KWD-STELLA-IN-CREATOR)
        (CL:EQ KEY KWD-STELLA-IN-DESTRUCTOR)
        (CL:EQ KEY KWD-STELLA-IN-INITIALIZER)
        (CL:EQ KEY KWD-STELLA-IN-TERMINATOR)
        (CL:EQ KEY KWD-STELLA-IN-EQUALITY-TEST))
       (INSERT-AT CLASSOPTIONS KEY (PERMANENTIFY THEVALUE)))
      ((CL:OR (CL:EQ KEY KWD-STELLA-IN-INITIAL-VALUE)
        (CL:EQ KEY KWD-STELLA-IN-PRINT-FORM))
       (INSERT-AT CLASSOPTIONS KEY (PERMANENTIFY-FORM THEVALUE)))
      ((CL:EQ KEY KWD-STELLA-IN-PROPERTIES)
       (INSERT-AT CLASSOPTIONS KEY (COLLECT-FEATURE-LIST THEVALUE)))
      ((CL:EQ KEY KWD-STELLA-IN-META-ATTRIBUTES)
       (INSERT-AT CLASSOPTIONS KEY (COLLECT-KEY-VALUE-LIST THEVALUE)))
      ((CL:EQ KEY KWD-STELLA-IN-CHILDREN)
       (CL:COND
        ((CL:EQ (SAFE-PRIMARY-TYPE THEVALUE) SGT-STELLA-IN-STELLA-CONS)
         (CL:PROGN
          (CL:LET* ((CHILDREN (NEW-LIST)))
           (CL:LET*
            ((CHILD NULL) (ITER-005 THEVALUE) (COLLECT-004 NULL))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
             (CL:SETQ CHILD (%%VALUE ITER-005))
             (CL:WHEN (SYMBOL? CHILD)
              (CL:IF (CL:EQ COLLECT-004 NULL)
               (CL:PROGN
                (CL:SETQ COLLECT-004 (CONS (TYPIFY CHILD) NIL))
                (CL:IF (CL:EQ (%THE-CONS-LIST CHILDREN) NIL)
                 (CL:SETF (%THE-CONS-LIST CHILDREN) COLLECT-004)
                 (ADD-CONS-TO-END-OF-CONS-LIST
                  (%THE-CONS-LIST CHILDREN) COLLECT-004)))
               (CL:PROGN
                (CL:SETF (%%REST COLLECT-004)
                 (CONS (TYPIFY CHILD) NIL))
                (CL:SETQ COLLECT-004 (%%REST COLLECT-004)))))
             (CL:SETQ ITER-005 (%%REST ITER-005))))
           (INSERT-AT CLASSOPTIONS KEY CHILDREN))))
        (CL:T
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
            " Illegal :children specification: `"
            (DE-UGLIFY-PARSE-TREE THEVALUE) "'." EOL))))))
      (CL:T (INSERT-AT CLASSOPTIONS KEY THEVALUE)))
     (CL:SETQ ITER-001 (%%REST (%%REST ITER-001)))))
   (CL:SETF (%THE-PLIST THEOPTIONS) NULL)
   (CL:LET*
    ((CLASS
      (DEFINE-STELLA-CLASS CLASSTYPE DIRECTSUPERS SLOTS
       (REVERSE CLASSOPTIONS))))
    (CL:WHEN (CL:NOT (CL:EQ CLASS NULL))
     (CL:SETF (%CLASS-STRINGIFIED-SOURCE CLASS) STRINGIFIEDSOURCE))
    (CL:RETURN-FROM HELP-DEFINE-CLASS-FROM-PARSE-TREE CLASS))))

;;; (DEFUN (DEFINE-STORAGE-SLOT-FROM-PARSE-TREE STORAGE-SLOT) ...)

(CL:DEFUN DEFINE-STORAGE-SLOT-FROM-PARSE-TREE (SLOTDEF OWNER)
  (CL:LET*
   ((NAME (PERMANENTIFY (%%VALUE SLOTDEF))) (BASETYPE NULL)
    (TYPEEXPRESSION NIL) (THEOPTIONS (NEW-PROPERTY-LIST))
    (SLOTOPTIONS (NEW-KEYWORD-KEY-VALUE-LIST)) (KEY NULL) (SLOT NULL))
   (CL:SETF (%THE-PLIST THEOPTIONS) (%%REST SLOTDEF))
   (CL:LET*
    ((THEKEY NULL) (THEVALUE NULL) (ITER-000 (%THE-PLIST THEOPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ THEKEY (%%VALUE ITER-000))
     (CL:SETQ THEVALUE (%%VALUE (%%REST ITER-000)))
     (CL:SETQ KEY (PERMANENTIFY THEKEY))
     (CL:COND
      ((CL:OR (CL:EQ KEY KWD-STELLA-IN-INITIALLY)
        (CL:EQ KEY KWD-STELLA-IN-DEFAULT))
       (INSERT-AT SLOTOPTIONS KEY (PERMANENTIFY-FORM THEVALUE)))
      ((CL:EQ KEY KWD-STELLA-IN-TYPE)
       (CL:COND
        ((CL:EQ (SAFE-PRIMARY-TYPE THEVALUE) SGT-STELLA-IN-STELLA-CONS)
         (CL:PROGN (CL:SETQ TYPEEXPRESSION THEVALUE)
          (CL:IF (CL:EQ (%%VALUE THEVALUE) SYM-STELLA-IN-STELLA-LIKE)
           (CL:SETQ BASETYPE NULL)
           (CL:SETQ BASETYPE (TYPIFY (%%VALUE THEVALUE))))))
        (CL:T (CL:SETQ BASETYPE (TYPIFY THEVALUE))
         (CL:WHEN (DEFINED-TYPE? BASETYPE)
          (CL:LET* ((REALTYPE (YIELD-TYPE-SPECIFIER THEVALUE)))
           (CL:SETQ BASETYPE (TYPE-SPEC-TO-BASE-TYPE REALTYPE))
           (CL:WHEN (CL:NOT (TYPE? REALTYPE))
            (CL:SETQ TYPEEXPRESSION
             (YIELD-TYPE-SPEC-TREE REALTYPE))))))))
      ((CL:EQ KEY KWD-STELLA-IN-ALLOCATION)
       (INSERT-AT SLOTOPTIONS KEY (PERMANENTIFY THEVALUE)))
      ((CL:EQ KEY KWD-STELLA-IN-READER)
       (INSERT-AT SLOTOPTIONS KEY (PERMANENTIFY THEVALUE)))
      ((CL:EQ KEY KWD-STELLA-IN-WRITER)
       (INSERT-AT SLOTOPTIONS KEY (PERMANENTIFY THEVALUE)))
      ((CL:OR (CL:EQ KEY KWD-STELLA-IN-INVERSE)
        (CL:EQ KEY KWD-STELLA-IN-RENAMES))
       (INSERT-AT SLOTOPTIONS KEY (PERMANENTIFY THEVALUE)))
      ((CL:OR (CL:EQ KEY KWD-STELLA-IN-PUBLIC?)
        (CL:EQ KEY KWD-STELLA-IN-REQUIRED?)
        (CL:EQ KEY KWD-STELLA-IN-COMPONENT?)
        (CL:EQ KEY KWD-STELLA-IN-READ-ONLY?)
        (CL:EQ KEY KWD-STELLA-IN-ACTIVE?)
        (CL:EQ KEY KWD-STELLA-IN-CONTEXT-SENSITIVE?)
        (CL:EQ KEY KWD-STELLA-IN-HARDWIRED?)
        (CL:EQ KEY KWD-STELLA-IN-ABSTRACT?))
       (INSERT-AT SLOTOPTIONS KEY (COERCE-TO-BOOLEAN THEVALUE)))
      ((CL:EQ KEY KWD-STELLA-IN-DOCUMENTATION)
       (INSERT-AT SLOTOPTIONS KEY THEVALUE))
      ((CL:EQ KEY KWD-STELLA-IN-PROPERTIES)
       (INSERT-AT SLOTOPTIONS KEY (COLLECT-FEATURE-LIST THEVALUE)))
      ((CL:EQ KEY KWD-STELLA-IN-META-ATTRIBUTES)
       (INSERT-AT SLOTOPTIONS KEY (COLLECT-KEY-VALUE-LIST THEVALUE)))
      ((CL:OR (CL:EQ KEY KWD-STELLA-IN-OPTION-KEYWORD)
        (CL:EQ KEY KWD-STELLA-IN-OPTION-HANDLER))
       (INSERT-AT SLOTOPTIONS KEY (PERMANENTIFY THEVALUE)))
      (CL:T (INSERT-AT SLOTOPTIONS KEY THEVALUE)))
     (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
   (CL:SETF (%THE-PLIST THEOPTIONS) NULL)
   (CL:SETQ SLOT
    (DEFINE-STELLA-SLOT NAME OWNER BASETYPE TYPEEXPRESSION
     (REVERSE SLOTOPTIONS)))
   (RECORD-SLOT-HOME-MODULE SLOT)
   (CL:RETURN-FROM DEFINE-STORAGE-SLOT-FROM-PARSE-TREE SLOT)))

;;; (DEFUN (RECORD-SLOT-HOME-MODULE MODULE) ...)

(CL:DEFUN RECORD-SLOT-HOME-MODULE (SELF)
  (CL:LET*
   ((NAME (%SLOT-NAME SELF)) (NAMEMODULE (%HOME-CONTEXT NAME))
    (DEFINITIONMODULE *MODULE*) (HOMEMODULE NAMEMODULE))
   (CL:IF (EXPLICITLY-QUALIFIED-NAME? NAME DEFINITIONMODULE)
    (CL:SETQ HOMEMODULE NAMEMODULE)
    (CL:SETQ HOMEMODULE DEFINITIONMODULE))
   (CL:WHEN (CL:NOT (CL:EQ HOMEMODULE NAMEMODULE))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-STELLA-IN-STELLA-SLOT-HOME-MODULE HOMEMODULE NULL))
   (CL:RETURN-FROM RECORD-SLOT-HOME-MODULE HOMEMODULE)))

;;; (DEFUN (EXPLICITLY-QUALIFIED-NAME? BOOLEAN) ...)

(CL:DEFUN EXPLICITLY-QUALIFIED-NAME? (NAME DEFINITIONMODULE)
  (CL:LET* ((NAMEMODULE (%HOME-CONTEXT NAME)) (SHADOW NULL))
   (CL:IF (CL:EQ NAMEMODULE DEFINITIONMODULE)
    (CL:PROGN (CL:RETURN-FROM EXPLICITLY-QUALIFIED-NAME? CL:NIL))
    (CL:IF (CL:NOT (VISIBLE-FROM? NAMEMODULE DEFINITIONMODULE))
     (CL:PROGN (CL:RETURN-FROM EXPLICITLY-QUALIFIED-NAME? CL:T))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:LET* ()
       (CL:SETQ SHADOW
        (LOOKUP-SYMBOL-IN-MODULE (%SYMBOL-NAME NAME) DEFINITIONMODULE
         CL:T))
       (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ SHADOW NULL))))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ SHADOW NAME))))
      (CL:IF TEST-VALUE-000
       (CL:PROGN (CL:RETURN-FROM EXPLICITLY-QUALIFIED-NAME? CL:T))
       (CL:PROGN
        (CL:RETURN-FROM EXPLICITLY-QUALIFIED-NAME? CL:NIL))))))))

;;; (DEFUN (GET-IDENTICAL-CLASS CLASS) ...)

(CL:DEFUN GET-IDENTICAL-CLASS (CLASSNAME STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CLASSNAME STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE CLASSNAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (CL:LET*
   ((SURROGATE (LOOKUP-SURROGATE CLASSNAME))
    (OLDVALUE
     (CL:IF (CL:NOT (CL:EQ SURROGATE NULL))
      (%SURROGATE-VALUE SURROGATE) NULL)))
   (CL:WHEN (CL:NOT (CL:EQ OLDVALUE NULL))
    (CL:COND
     ((SUBTYPE-OF-CLASS? (SAFE-PRIMARY-TYPE OLDVALUE))
      (CL:PROGN
       (CL:WHEN
        (CL:AND
         (CL:NOT
          (CL:EQ (%CLASS-STRINGIFIED-SOURCE OLDVALUE)
           STELLA::NULL-STRING))
         (STRING-EQL? (%CLASS-STRINGIFIED-SOURCE OLDVALUE)
          STRINGIFIEDSOURCE)
         (CL:EQ (%HOME-CONTEXT SURROGATE) *MODULE*))
        (CL:RETURN-FROM GET-IDENTICAL-CLASS OLDVALUE))))
     (CL:T)))
   (CL:RETURN-FROM GET-IDENTICAL-CLASS NULL)))

;;; (DEFUN (DEFINE-CLASS-FROM-PARSE-TREE CLASS) ...)

(CL:DEFUN DEFINE-CLASS-FROM-PARSE-TREE (PARSETREE)
  (CL:WHEN (BAD-ARGUMENT-RANGE? PARSETREE 2 NULL-INTEGER)
   (CL:RETURN-FROM DEFINE-CLASS-FROM-PARSE-TREE NULL))
  (CL:WHEN
   (CL:NOT
    (CL:AND (SYMBOL? (%%VALUE (%%REST PARSETREE)))
     (CONS? (%%VALUE (%%REST (%%REST PARSETREE))))))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
      " Illegal class definition: `" (DE-UGLIFY-PARSE-TREE PARSETREE)
      "'." EOL)))
   (CL:RETURN-FROM DEFINE-CLASS-FROM-PARSE-TREE NULL))
  (CL:LET*
   ((CLASSNAME (%%VALUE (%%REST PARSETREE)))
    (STRINGIFIEDSOURCE (STRINGIFY PARSETREE))
    (OLDCLASS
     (GET-IDENTICAL-CLASS (%SYMBOL-NAME CLASSNAME) STRINGIFIEDSOURCE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ OLDCLASS NULL))
     (CL:NOT *REDEFINE-IDENTICAL-CLASSES?*))
    (CL:RETURN-FROM DEFINE-CLASS-FROM-PARSE-TREE OLDCLASS))
   (CL:RETURN-FROM DEFINE-CLASS-FROM-PARSE-TREE
    (HELP-DEFINE-CLASS-FROM-PARSE-TREE PARSETREE STRINGIFIEDSOURCE))))

;;; (DEFUN (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE CLASS) ...)

(CL:DEFUN DEFINE-CLASS-FROM-STRINGIFIED-SOURCE (CLASSNAME STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CLASSNAME STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE CLASSNAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (CL:LET*
   ((OLDCLASS (GET-IDENTICAL-CLASS CLASSNAME STRINGIFIEDSOURCE))
    (NEWCLASS NULL))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ OLDCLASS NULL))
     (CL:NOT *REDEFINE-IDENTICAL-CLASSES?*))
    (CL:RETURN-FROM DEFINE-CLASS-FROM-STRINGIFIED-SOURCE OLDCLASS))
   (CL:SETQ NEWCLASS
    (HELP-DEFINE-CLASS-FROM-PARSE-TREE
     (UNSTRINGIFY-STELLA-SOURCE STRINGIFIEDSOURCE NULL)
     STRINGIFIEDSOURCE))
   (CL:RETURN-FROM DEFINE-CLASS-FROM-STRINGIFIED-SOURCE NEWCLASS)))

;;; (DEFUN (EXTRACT-OPTIONS CONS) ...)

(CL:DEFUN EXTRACT-OPTIONS (TREE OPTIONSTABLE)
  (CL:LET* ((OPTIONS NULL) (TAIL NULL))
   (CL:LOOP WHILE
    (CL:AND (CL:NOT (CL:EQ (%%REST TREE) NIL))
     (CL:NOT (KEYWORD? (%%VALUE (%%REST TREE)))))
    DO (CL:SETQ TREE (%%REST TREE)))
   (CL:WHEN
    (CL:OR (CL:EQ (%%REST TREE) NIL)
     (CL:EQ (%%REST (%%REST TREE)) NIL))
    (CL:RETURN-FROM EXTRACT-OPTIONS NIL))
   (CL:WHEN (CL:NOT (CL:EQ OPTIONSTABLE NULL))
    (INSERT-AT OPTIONSTABLE (%%VALUE (%%REST TREE))
     (%%VALUE (%%REST (%%REST TREE)))))
   (CL:SETQ OPTIONS (%%REST TREE))
   (CL:SETQ TAIL (%%REST (%%REST TREE)))
   (CL:LOOP WHILE
    (CL:AND (CL:NOT (CL:EQ (%%REST (%%REST TAIL)) NIL))
     (KEYWORD? (%%VALUE (%%REST TAIL))))
    DO
    (CL:WHEN (CL:NOT (CL:EQ OPTIONSTABLE NULL))
     (INSERT-AT OPTIONSTABLE (%%VALUE (%%REST TAIL))
      (%%VALUE (%%REST (%%REST TAIL)))))
    (CL:SETQ TAIL (%%REST (%%REST TAIL))))
   (CL:SETF (%%REST TREE) (%%REST TAIL)) (CL:SETF (%%REST TAIL) NIL)
   (CL:RETURN-FROM EXTRACT-OPTIONS OPTIONS)))

;;; (DEFUN (DESTRUCTURE-DEFMETHOD-TREE OBJECT CONS CONS) ...)

(CL:DEFUN DESTRUCTURE-DEFMETHOD-TREE (METHOD-TREE OPTIONS-TABLE)
  "Return three parse trees representing the name,
parameters, and code body of the parse tree `method-tree'.  Fill
`options-table' with a dictionary of method options.
Storage note:  Options are treated specially because the other return
values are subtrees of `method-tree', while `options-table' is a newly-created
cons tree.  Note also, the parameter and body trees are destructively
removed from `method-tree'."
  (CL:LET*
   ((NAMETREE (%%VALUE (%%REST METHOD-TREE)))
    (PARAMETERSTREE (%%VALUE (%%REST (%%REST METHOD-TREE)))))
   (CL:WHEN (CL:NOT (CONS? PARAMETERSTREE))
    (CL:IF (CL:EQ PARAMETERSTREE NULL)
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
        " Missing parameter list." EOL)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
        " Illegal parameter list: `"
        (DE-UGLIFY-PARSE-TREE PARAMETERSTREE) "'." EOL))))
    (CL:SETQ PARAMETERSTREE NIL))
   (EXTRACT-OPTIONS METHOD-TREE OPTIONS-TABLE)
   (CL:RETURN-FROM DESTRUCTURE-DEFMETHOD-TREE
    (CL:VALUES NAMETREE PARAMETERSTREE (NTH-REST METHOD-TREE 3)))))

;;; (DEFUN (YIELD-SETTER-METHOD-NAME SYMBOL) ...)

(CL:DEFUN YIELD-SETTER-METHOD-NAME (METHODNAME)
  (CL:LET*
   ((BASE-NAME (%SYMBOL-NAME METHODNAME))
    (SUFFIX
     (CL:IF (ALL-UPPER-CASE-STRING? BASE-NAME) "-SETTER" "-Setter")))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BASE-NAME SUFFIX))
   (CL:RETURN-FROM YIELD-SETTER-METHOD-NAME
    (INTERN-DERIVED-SYMBOL METHODNAME (CONCATENATE BASE-NAME SUFFIX)))))

;;; (DEFUN (DESTRUCTURE-METHOD-NAME-TREE SYMBOL CONS) ...)

(CL:DEFUN DESTRUCTURE-METHOD-NAME-TREE (NAMETREE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NAMETREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SGT-STELLA-IN-STELLA-CONS)
     (CL:PROGN
      (CL:WHEN (CL:NOT (SYMBOL? (%%VALUE NAMETREE)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
          " Illegal method name: `" (DE-UGLIFY-PARSE-TREE NAMETREE)
          "'." EOL)))
       (CL:RETURN-FROM DESTRUCTURE-METHOD-NAME-TREE
        (CL:VALUES NULL NULL)))
      (CL:IF
       (CL:EQ (%%VALUE (%%REST NAMETREE)) SYM-STELLA-IN-STELLA-SETTER)
       (CL:RETURN-FROM DESTRUCTURE-METHOD-NAME-TREE
        (CL:VALUES (YIELD-SETTER-METHOD-NAME (%%VALUE NAMETREE)) NIL))
       (CL:RETURN-FROM DESTRUCTURE-METHOD-NAME-TREE
        (CL:VALUES (%%VALUE NAMETREE) (%%REST NAMETREE))))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM DESTRUCTURE-METHOD-NAME-TREE
       (CL:VALUES NAMETREE NIL))))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
        " Illegal method name: `" (DE-UGLIFY-PARSE-TREE NAMETREE) "'."
        EOL)))
     (CL:RETURN-FROM DESTRUCTURE-METHOD-NAME-TREE
      (CL:VALUES NULL NULL))))))

;;; (DEFUN IN-PLACE-NORMALIZE-METHOD-OPTIONS ...)

(CL:DEFUN IN-PLACE-NORMALIZE-METHOD-OPTIONS (METHODOPTIONS METHODNAME)
  (CL:SETQ METHODNAME METHODNAME)
  (CL:LET*
   ((KEY NULL) (VALUE NULL)
    (ITER-000 (ALLOCATE-ITERATOR METHODOPTIONS)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ KEY (%KEY ITER-000))
    (CL:SETQ VALUE (%VALUE ITER-000))
    (CL:COND
     ((CL:OR (CL:EQ KEY KWD-STELLA-IN-TYPE)
       (CL:EQ KEY KWD-STELLA-IN-RETURN-TYPES)))
     ((CL:OR (CL:EQ KEY KWD-STELLA-IN-RENAMES)
       (CL:EQ KEY KWD-STELLA-IN-STORAGE-SLOT)
       (CL:EQ KEY KWD-STELLA-IN-INHERITS-THROUGH))
      (INSERT-AT METHODOPTIONS KEY (PERMANENTIFY VALUE)))
     ((CL:OR (CL:EQ KEY KWD-STELLA-IN-PUBLIC?)
       (CL:EQ KEY KWD-STELLA-IN-ABSTRACT?)
       (CL:EQ KEY KWD-STELLA-IN-SETTER?)
       (CL:EQ KEY KWD-STELLA-IN-NATIVE?)
       (CL:EQ KEY KWD-STELLA-IN-CONSTRUCTOR?)
       (CL:EQ KEY KWD-STELLA-IN-AUXILIARY?)
       (CL:EQ KEY KWD-STELLA-IN-GLOBALLY-INLINE?)
       (CL:EQ KEY KWD-STELLA-IN-COMMAND?)
       (CL:EQ KEY KWD-STELLA-IN-LISP-MACRO?)
       (CL:EQ KEY KWD-STELLA-IN-EVALUATE-ARGUMENTS?))
      (INSERT-AT METHODOPTIONS KEY (COERCE-TO-BOOLEAN VALUE)))
     ((CL:EQ KEY KWD-STELLA-IN-DOCUMENTATION)
      (INSERT-AT METHODOPTIONS KEY VALUE))
     ((CL:EQ KEY KWD-STELLA-IN-INLINE)
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE VALUE)))
       (CL:COND
        ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
         (CL:PROGN (INSERT-AT METHODOPTIONS KEY (PERMANENTIFY VALUE))))
        ((CL:EQ TEST-VALUE-000 SGT-STELLA-IN-STELLA-CONS)
         (CL:PROGN
          (CL:LET* ((SYMBOLSLIST NIL))
           (CL:LET* ((SYMBOL NULL) (ITER-001 VALUE) (COLLECT-000 NULL))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
             (CL:SETQ SYMBOL (%%VALUE ITER-001))
             (CL:IF (CL:EQ COLLECT-000 NULL)
              (CL:PROGN
               (CL:SETQ COLLECT-000 (CONS (PERMANENTIFY SYMBOL) NIL))
               (CL:IF (CL:EQ SYMBOLSLIST NIL)
                (CL:SETQ SYMBOLSLIST COLLECT-000)
                (ADD-CONS-TO-END-OF-CONS-LIST SYMBOLSLIST
                 COLLECT-000)))
              (CL:PROGN
               (CL:SETF (%%REST COLLECT-000)
                (CONS (PERMANENTIFY SYMBOL) NIL))
               (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
             (CL:SETQ ITER-001 (%%REST ITER-001))))
           (INSERT-AT METHODOPTIONS KEY SYMBOLSLIST))))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
           TEST-VALUE-000 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
     ((CL:EQ KEY KWD-STELLA-IN-PROPERTIES)
      (INSERT-AT METHODOPTIONS KEY (COLLECT-FEATURE-LIST VALUE)))
     ((CL:EQ KEY KWD-STELLA-IN-META-ATTRIBUTES)
      (INSERT-AT METHODOPTIONS KEY (COLLECT-KEY-VALUE-LIST VALUE)))
     (CL:T (INSERT-AT METHODOPTIONS KEY (PERMANENTIFY VALUE))))))
  (REVERSE METHODOPTIONS)
  :VOID)

;;; (DEFUN (GET-FUNCTION-WITH-IDENTICAL-SIGNATURE METHOD-SLOT) ...)

(CL:DEFUN GET-FUNCTION-WITH-IDENTICAL-SIGNATURE (NAME STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (CL:LET* ((OLDMETHOD (LOOKUP-FUNCTION NAME)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ OLDMETHOD NULL))
     (STRING-EQL? (%METHOD-STRINGIFIED-SOURCE OLDMETHOD)
      STRINGIFIEDSOURCE))
    (CL:RETURN-FROM GET-FUNCTION-WITH-IDENTICAL-SIGNATURE OLDMETHOD))
   (CL:RETURN-FROM GET-FUNCTION-WITH-IDENTICAL-SIGNATURE NULL)))

;;; (DEFUN (GET-METHOD-WITH-IDENTICAL-SIGNATURE METHOD-SLOT) ...)

(CL:DEFUN GET-METHOD-WITH-IDENTICAL-SIGNATURE (NAME PARAMETERSTREE STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (CL:LET* ((EXISTINGSLOT NULL))
   (CL:WHEN (CONS? (%%VALUE PARAMETERSTREE))
    (CL:SETQ PARAMETERSTREE (%%VALUE PARAMETERSTREE))
    (CL:WHEN (SYMBOL? (LAST PARAMETERSTREE))
     (CL:SETQ EXISTINGSLOT
      (LOOKUP-SLOT
       (TYPE-SPEC-TO-CLASS
        (YIELD-TYPE-SPECIFIER (LAST PARAMETERSTREE)))
       NAME))
     (CL:WHEN (CL:NOT (CL:EQ EXISTINGSLOT NULL))
      (CL:COND
       ((SUBTYPE-OF-METHOD-SLOT? (SAFE-PRIMARY-TYPE EXISTINGSLOT))
        (CL:PROGN
         (CL:WHEN
          (STRING-EQL? (%METHOD-STRINGIFIED-SOURCE EXISTINGSLOT)
           STRINGIFIEDSOURCE)
          (CL:RETURN-FROM GET-METHOD-WITH-IDENTICAL-SIGNATURE
           EXISTINGSLOT))))
       (CL:T)))))
   (CL:RETURN-FROM GET-METHOD-WITH-IDENTICAL-SIGNATURE NULL)))

;;; (DEFUN (HELP-DEFINE-METHOD-FROM-PARSE-TREE METHOD-SLOT BOOLEAN) ...)

(CL:DEFUN HELP-DEFINE-METHOD-FROM-PARSE-TREE (INPUTTREE STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (CL:LET*
   ((NAMETREE NULL) (PARAMETERSTREE NULL)
    (METHODOPTIONS (NEW-KEYWORD-KEY-VALUE-LIST)) (BODYTREE NULL)
    (NAME NULL) (RETURNTYPESTREE NULL)
    (FUNCTION? (CL:EQ (%%VALUE INPUTTREE) SYM-STELLA-IN-STELLA-DEFUN))
    (OLDMETHOD NULL)
    (SIGNATURESTRING
     (CL:IF (CL:EQ STRINGIFIEDSOURCE STELLA::NULL-STRING)
      (STRINGIFY-METHOD-SIGNATURE INPUTTREE) STRINGIFIEDSOURCE)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SIGNATURESTRING))
   (CL:MULTIPLE-VALUE-SETQ (NAMETREE PARAMETERSTREE BODYTREE)
    (DESTRUCTURE-DEFMETHOD-TREE INPUTTREE METHODOPTIONS))
   (CL:MULTIPLE-VALUE-SETQ (NAME RETURNTYPESTREE)
    (DESTRUCTURE-METHOD-NAME-TREE NAMETREE))
   (CL:WHEN (CL:EQ NAME NULL)
    (CL:RETURN-FROM HELP-DEFINE-METHOD-FROM-PARSE-TREE
     (CL:VALUES NULL CL:NIL)))
   (CL:SETQ OLDMETHOD
    (CL:IF FUNCTION?
     (GET-FUNCTION-WITH-IDENTICAL-SIGNATURE NAME SIGNATURESTRING)
     (GET-METHOD-WITH-IDENTICAL-SIGNATURE NAME PARAMETERSTREE
      SIGNATURESTRING)))
   (CL:WHEN (CL:NOT (CL:EQ OLDMETHOD NULL))
    (CL:RETURN-FROM HELP-DEFINE-METHOD-FROM-PARSE-TREE
     (CL:VALUES OLDMETHOD CL:T)))
   (IN-PLACE-NORMALIZE-METHOD-OPTIONS METHODOPTIONS NAME)
   (CL:LET*
    ((METHOD
      (DEFINE-STELLA-METHOD-SLOT NAME RETURNTYPESTREE FUNCTION?
       PARAMETERSTREE METHODOPTIONS)))
    (CL:WHEN (CL:EQ STRINGIFIEDSOURCE STELLA::NULL-STRING)
     (CL:SETQ STRINGIFIEDSOURCE
      (CL:IF (STRINGIFY-METHOD-BODY? METHOD)
       (STRINGIFY
        (CONCATENATE (READ-S-EXPRESSION-FROM-STRING SIGNATURESTRING)
         BODYTREE))
       SIGNATURESTRING)))
    (CL:SETF (%METHOD-STRINGIFIED-SOURCE METHOD) STRINGIFIEDSOURCE)
    (RECORD-SLOT-HOME-MODULE METHOD)
    (CL:RETURN-FROM HELP-DEFINE-METHOD-FROM-PARSE-TREE
     (CL:VALUES METHOD CL:NIL)))))

;;; (DEFUN (DEFINE-METHOD-FROM-PARSE-TREE METHOD-SLOT) ...)

(CL:DEFUN DEFINE-METHOD-FROM-PARSE-TREE (PARSETREE)
  (CL:WHEN (BAD-ARGUMENT-RANGE? PARSETREE 2 NULL-INTEGER)
   (CL:RETURN-FROM DEFINE-METHOD-FROM-PARSE-TREE NULL))
  (CL:LET* ((METHOD NULL) (IDENTICALMETHOD? CL:NIL))
   (CL:MULTIPLE-VALUE-SETQ (METHOD IDENTICALMETHOD?)
    (HELP-DEFINE-METHOD-FROM-PARSE-TREE PARSETREE STELLA::NULL-STRING))
   (CL:WHEN (CL:NOT (CL:OR IDENTICALMETHOD? (CL:EQ METHOD NULL)))
    (CL:IF
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS METHOD)
       SYM-STELLA-IN-STELLA-SLOT-AUXILIARY? FALSE-WRAPPER))
     (CL:SETF (%SLOT-EXTERNAL? METHOD) CL:T)
     (ATTACH-METHOD-SLOT-TO-OWNER METHOD)))
   (CL:RETURN-FROM DEFINE-METHOD-FROM-PARSE-TREE METHOD)))

;;; (DEFUN (STRINGIFY-METHOD-SIGNATURE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  STRINGIFY-METHOD-SIGNATURE))
(CL:DEFUN STRINGIFY-METHOD-SIGNATURE (PARSETREE)
  (CL:LET*
   ((SIGNATURE NIL) (SIGNATURESTRING STELLA::NULL-STRING)
    (OPTIONSTREE (NTH-REST PARSETREE 3)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SIGNATURESTRING))
   (CL:SETQ SIGNATURE (CONS (%%VALUE PARSETREE) SIGNATURE))
   (CL:SETQ SIGNATURE (CONS (%%VALUE (%%REST PARSETREE)) SIGNATURE))
   (CL:SETQ SIGNATURE
    (CONS (%%VALUE (%%REST (%%REST PARSETREE))) SIGNATURE))
   (CL:LOOP WHILE (KEYWORD? (%%VALUE OPTIONSTREE)) DO
    (CL:SETQ SIGNATURE (CONS (%%VALUE OPTIONSTREE) SIGNATURE))
    (CL:SETQ SIGNATURE (CONS (%%VALUE (%%REST OPTIONSTREE)) SIGNATURE))
    (CL:SETQ OPTIONSTREE (%%REST (%%REST OPTIONSTREE))))
   (CL:SETQ SIGNATURESTRING (STRINGIFY (REVERSE SIGNATURE)))
   (CL:RETURN-FROM STRINGIFY-METHOD-SIGNATURE SIGNATURESTRING)))

;;; (DEFUN (STRINGIFY-METHOD-BODY? BOOLEAN) ...)

(CL:DEFUN STRINGIFY-METHOD-BODY? (METHOD)
  (CL:RETURN-FROM STRINGIFY-METHOD-BODY?
   (CL:OR
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS METHOD)
      SYM-STELLA-IN-STELLA-METHOD-GLOBALLY-INLINE? FALSE-WRAPPER))
    (CL:AND (CL:NOT (%METHOD-FUNCTION? METHOD))
     (CL:OR (CL:EQ (%SURROGATE-VALUE (%SLOT-OWNER METHOD)) NULL)
      (%MIXIN? (%SURROGATE-VALUE (%SLOT-OWNER METHOD))))))))

;;; (DEFUN (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE METHOD-SLOT) ...)

(CL:DEFUN DEFINE-METHOD-FROM-STRINGIFIED-SOURCE (METHODNAME CLASSNAME STRINGIFIEDSOURCE)
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING METHODNAME CLASSNAME STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE METHODNAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE CLASSNAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (CL:PROGN (CL:SETQ METHODNAME METHODNAME)
   (CL:SETQ CLASSNAME CLASSNAME))
  (CL:LET* ((METHOD NULL) (IDENTICALMETHOD? CL:NIL))
   (CL:MULTIPLE-VALUE-SETQ (METHOD IDENTICALMETHOD?)
    (HELP-DEFINE-METHOD-FROM-PARSE-TREE
     (UNSTRINGIFY-STELLA-SOURCE STRINGIFIEDSOURCE NULL)
     STRINGIFIEDSOURCE))
   (CL:WHEN
    (CL:NOT
     (CL:OR IDENTICALMETHOD?
      (%WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS METHOD)
        SYM-STELLA-IN-STELLA-SLOT-AUXILIARY? FALSE-WRAPPER))))
    (ATTACH-METHOD-SLOT-TO-OWNER METHOD))
   (CL:RETURN-FROM DEFINE-METHOD-FROM-STRINGIFIED-SOURCE METHOD)))

;;; (DEFUN DEFINE-METHOD-OBJECT ...)

(CL:DEFUN DEFINE-METHOD-OBJECT (DEFINITION CODE WRAPPERCODE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DEFINITION))
  #+MCL
  (CL:CHECK-TYPE DEFINITION CL:SIMPLE-STRING)
  (CL:SETQ WRAPPERCODE WRAPPERCODE)
  (CL:LET*
   ((METHOD
     (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE STELLA::NULL-STRING
      STELLA::NULL-STRING DEFINITION)))
   (CL:WHEN (CL:NOT (CL:EQ METHOD NULL))
    (CL:WHEN (CL:NOT (CL:EQ CODE NULL))
     (CL:SETF (%METHOD-CODE METHOD) CODE))))
  :VOID)

;;; (DEFGLOBAL *UNSUPPORTED-EXTERNAL-SLOT-OPTIONS* ...)

(CL:DEFVAR *UNSUPPORTED-EXTERNAL-SLOT-OPTIONS* NULL)

;;; (DEFUN (DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE STORAGE-SLOT) ...)

(CL:DEFUN DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE (PARSETREE)
  (CL:WHEN (BAD-ARGUMENT-RANGE? PARSETREE 2 NULL-INTEGER)
   (CL:RETURN-FROM DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE NULL))
  (CL:WHEN
   (CL:OR (CL:NOT (SYMBOL? (%%VALUE (%%REST PARSETREE))))
    (CL:NOT (SYMBOL? (%%VALUE (%%REST (%%REST PARSETREE)))))
    (CL:NOT
     (CL:LET ((X (LENGTH (NTH-REST PARSETREE 3))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM X)) (CL:NOT (CL:LOGBITP 0 X)))))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
      " Illegal external slot definition: `"
      (DE-UGLIFY-PARSE-TREE PARSETREE) "'." EOL)))
   (CL:RETURN-FROM DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE NULL))
  (CL:LET*
   ((CLASSNAME (%%VALUE (%%REST PARSETREE))) (OWNER (TYPIFY CLASSNAME))
    (OWNERCLASS (%SURROGATE-VALUE OWNER)) (SLOT NULL)
    (OPTIONS (NTH-REST PARSETREE 3)) (MARKER *STELLA-MODULE*)
    (ABSTRACT? CL:NIL))
   (CL:WHEN (CL:EQ OWNERCLASS NULL)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
       " Can't define a slot on the non-existent class `"
       (DE-UGLIFY-PARSE-TREE CLASSNAME) "'." EOL)))
    (CL:RETURN-FROM DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ OPTIONS NIL)) DO
    (CL:LET*
     ((OPTION (%%VALUE OPTIONS)) (VALUE (%%VALUE (%%REST OPTIONS))))
     (CL:WHEN (MEMBER? *UNSUPPORTED-EXTERNAL-SLOT-OPTIONS* OPTION)
      (CL:WHEN
       (CL:OR (CL:NOT (CL:EQ OPTION KWD-STELLA-IN-ALLOCATION))
        (CL:NOT (CL:EQ VALUE KWD-STELLA-IN-DYNAMIC)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-WARNING)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING) EOL
          " Skipping slot option `" (DE-UGLIFY-PARSE-TREE OPTION)
          "' which is unsupported on external slots." EOL))))
      (FIRST-SETTER OPTIONS MARKER)
      (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
       (SECOND-SETTER OPTIONS MARKER)))
     (CL:WHEN
      (CL:OR
       (CL:AND (CL:EQ OPTION KWD-STELLA-IN-ABSTRACT?)
        (CL:EQ VALUE SYM-STELLA-IN-STELLA-TRUE))
       (CL:EQ OPTION KWD-STELLA-IN-RENAMES))
      (CL:SETQ ABSTRACT? CL:T)))
    (CL:SETQ OPTIONS (%%REST (%%REST OPTIONS))))
   (CL:WHEN
    (CL:AND (CL:NOT ABSTRACT?) (%CLASS-FINALIZED? OWNERCLASS)
     (CL:NOT
      (SUBTYPE-OF? OWNER SGT-STELLA-IN-STELLA-DYNAMIC-SLOTS-MIXIN)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
       " Can't define a non-abstract external slot on class `"
       (DE-UGLIFY-PARSE-TREE CLASSNAME) "'," EOL
       " since it does not inherit DYNAMIC-SLOTS-MIXIN." EOL)))
    (CL:RETURN-FROM DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE NULL))
   (CL:SETQ PARSETREE (REMOVE PARSETREE MARKER))
   (CL:WHEN (CL:NOT ABSTRACT?)
    (CL:SETQ PARSETREE
     (CONCATENATE PARSETREE
      (LIST* KWD-STELLA-IN-ALLOCATION KWD-STELLA-IN-DYNAMIC NIL))))
   (CL:SETQ SLOT
    (DEFINE-STORAGE-SLOT-FROM-PARSE-TREE (%%REST (%%REST PARSETREE))
     OWNER))
   (CL:WHEN (CL:NOT (CL:EQ SLOT NULL)) (ATTACH-SLOT-TO-OWNER SLOT))
   (CL:RETURN-FROM DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE SLOT)))

;;; (DEFUN (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE STORAGE-SLOT) ...)

(CL:DEFUN DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE (STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (CL:RETURN-FROM DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
   (DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE
    (READ-S-EXPRESSION-FROM-STRING STRINGIFIEDSOURCE))))

;;; (DEFUN (LOOKUP-SLOT-FROM-OPTION-KEYWORD STORAGE-SLOT) ...)

(CL:DEFUN LOOKUP-SLOT-FROM-OPTION-KEYWORD (OWNER KEYWORD)
  (CL:LET* ((OWNERCLASS (%SURROGATE-VALUE OWNER)))
   (CL:WHEN (CL:NOT (CL:EQ OWNERCLASS NULL))
    (CL:LET* ((SLOT NULL) (ITER-000 (CLASS-SLOTS OWNERCLASS)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ SLOT (%VALUE ITER-000))
      (CL:WHEN
       (CL:AND (STORAGE-SLOT? SLOT)
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SLOT)
          SYM-STELLA-IN-STELLA-SLOT-OPTION-KEYWORD NULL)
         KEYWORD))
       (CL:RETURN-FROM LOOKUP-SLOT-FROM-OPTION-KEYWORD SLOT)))))
   (CL:RETURN-FROM LOOKUP-SLOT-FROM-OPTION-KEYWORD NULL)))

;;; (DEFGLOBAL *DEFAULT-OPTION-HANDLER* ...)

(CL:DEFVAR *DEFAULT-OPTION-HANDLER* NULL)

;;; (DEFUN (LOOKUP-OPTION-HANDLER METHOD-SLOT) ...)

(CL:DEFUN LOOKUP-OPTION-HANDLER (SLOT)
  (CL:LET*
   ((HANDLERNAME
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SLOT)
      SYM-STELLA-IN-STELLA-SLOT-OPTION-HANDLER NULL))
    (HANDLER NULL))
   (CL:WHEN (CL:EQ HANDLERNAME NULL)
    (CL:IF (CL:NOT (CL:EQ *DEFAULT-OPTION-HANDLER* NULL))
     (CL:RETURN-FROM LOOKUP-OPTION-HANDLER *DEFAULT-OPTION-HANDLER*)
     (CL:RETURN-FROM LOOKUP-OPTION-HANDLER
      (LOOKUP-FUNCTION SYM-STELLA-IN-STELLA-DEFAULT-OPTION-HANDLER))))
   (CL:SETQ HANDLER (LOOKUP-FUNCTION HANDLERNAME))
   (CL:WHEN
    (CL:AND (CL:>= *SAFETY* 2) (CL:NOT (CL:EQ HANDLER NULL))
     (CL:NOT
      (CL:EQ HANDLERNAME SYM-STELLA-IN-STELLA-DEFAULT-OPTION-HANDLER))
     (CL:NOT
      (CONFORMING-SIGNATURES? HANDLER *DEFAULT-OPTION-HANDLER*)))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "The signature of slot option handler `" HANDLERNAME
      "' does not conform to that of 'default-option-handler'.")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (CL:RETURN-FROM LOOKUP-OPTION-HANDLER HANDLER)))

;;; (DEFUN (RUN-OPTION-HANDLER? BOOLEAN) ...)

(CL:DEFUN RUN-OPTION-HANDLER? (OBJECT OPTION VALUETREE)
  (CL:LET*
   ((SLOT
     (LOOKUP-SLOT-FROM-OPTION-KEYWORD (PRIMARY-TYPE OBJECT) OPTION))
    (HANDLER
     (CL:IF (CL:NOT (CL:EQ SLOT NULL)) (LOOKUP-OPTION-HANDLER SLOT)
      NULL)))
   (CL:WHEN (CL:NOT (CL:EQ HANDLER NULL))
    (CL:FUNCALL (%FUNCTION-CODE HANDLER) OBJECT SLOT VALUETREE)
    (CL:RETURN-FROM RUN-OPTION-HANDLER? CL:T))
   (CL:RETURN-FROM RUN-OPTION-HANDLER? CL:NIL)))

;;; (DEFUN DEFAULT-OPTION-HANDLER ...)

(CL:DEFUN DEFAULT-OPTION-HANDLER (SELF SLOT TREE)
  (CL:LET* ((PARSEDVALUE NULL))
   (CL:COND
    ((CL:EQ (TYPE SLOT) SGT-STELLA-IN-STELLA-BOOLEAN)
     (CL:SETQ PARSEDVALUE (COERCE-TO-BOOLEAN TREE)))
    (CL:T
     (CL:WHEN (CL:NOT (CL:EQ TREE NULL))
      (CL:SETQ PARSEDVALUE (PERMANENT-COPY TREE)))))
   (CL:WHEN
    (CL:AND (CL:>= *SAFETY* 2) (CL:NOT (CL:EQ PARSEDVALUE NULL)))
    (CL:WHEN
     (CL:NOT (ISA? PARSEDVALUE (TYPE-TO-WRAPPED-TYPE (TYPE SLOT))))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
        " Illegal value for `"
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SLOT)
         SYM-STELLA-IN-STELLA-SLOT-OPTION-KEYWORD NULL)
        "' option: `" (DE-UGLIFY-PARSE-TREE TREE) "'." EOL)))
     (CL:RETURN-FROM DEFAULT-OPTION-HANDLER)))
   (WRITE-SLOT-VALUE SELF SLOT PARSEDVALUE))
  :VOID)

(CL:DEFUN HELP-STARTUP-STELLA-IN1 ()
  (CL:PROGN
   (CL:SETQ SYM-STELLA-IN-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-STELLA-IN-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ SGT-STELLA-IN-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SGT-STELLA-IN-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 1))
   (CL:SETQ SYM-STELLA-IN-STELLA-DEFMETHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFMETHOD" NULL 0))
   (CL:SETQ KWD-STELLA-IN-PUBLIC-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC-SLOTS" NULL 2))
   (CL:SETQ KWD-STELLA-IN-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTS" NULL 2))
   (CL:SETQ KWD-STELLA-IN-PUBLIC-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC-METHODS" NULL 2))
   (CL:SETQ KWD-STELLA-IN-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHODS" NULL 2))
   (CL:SETQ KWD-STELLA-IN-PARAMETERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETERS" NULL 2))
   (CL:SETQ KWD-STELLA-IN-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 2))
   (CL:SETQ KWD-STELLA-IN-SYNONYMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYNONYMS" NULL 2))
   (CL:SETQ KWD-STELLA-IN-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ KWD-STELLA-IN-CL-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CL-NATIVE-TYPE" NULL 2))
   (CL:SETQ KWD-STELLA-IN-CPP-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-NATIVE-TYPE" NULL 2))
   (CL:SETQ KWD-STELLA-IN-JAVA-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-NATIVE-TYPE" NULL 2))
   (CL:SETQ KWD-STELLA-IN-IDL-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IDL-NATIVE-TYPE" NULL 2))
   (CL:SETQ KWD-STELLA-IN-ABSTRACT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-ACTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-CL-STRUCT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CL-STRUCT?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-MIXIN?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MIXIN?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-RECYCLE-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RECYCLE-METHOD" NULL 2))
   (CL:SETQ SYM-STELLA-IN-STELLA-NEXT-SWEEP-LIST-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEXT-SWEEP-LIST-OBJECT" NULL 0))
   (CL:SETQ KWD-STELLA-IN-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 2))
   (CL:SETQ KWD-STELLA-IN-EXTENSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSION" NULL 2))
   (CL:SETQ KWD-STELLA-IN-CREATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATOR" NULL 2))
   (CL:SETQ KWD-STELLA-IN-DESTRUCTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESTRUCTOR" NULL 2))
   (CL:SETQ KWD-STELLA-IN-INITIALIZER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIALIZER" NULL 2))
   (CL:SETQ KWD-STELLA-IN-TERMINATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TERMINATOR" NULL 2))
   (CL:SETQ KWD-STELLA-IN-EQUALITY-TEST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUALITY-TEST" NULL 2))
   (CL:SETQ KWD-STELLA-IN-INITIAL-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-VALUE" NULL 2))
   (CL:SETQ KWD-STELLA-IN-PRINT-FORM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-FORM" NULL 2))
   (CL:SETQ KWD-STELLA-IN-PROPERTIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 2))
   (CL:SETQ KWD-STELLA-IN-META-ATTRIBUTES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 2))
   (CL:SETQ KWD-STELLA-IN-CHILDREN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILDREN" NULL 2))
   (CL:SETQ KWD-STELLA-IN-INITIALLY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIALLY" NULL 2))
   (CL:SETQ KWD-STELLA-IN-DEFAULT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT" NULL 2))
   (CL:SETQ SYM-STELLA-IN-STELLA-LIKE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIKE" NULL 0))
   (CL:SETQ KWD-STELLA-IN-ALLOCATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATION" NULL 2))
   (CL:SETQ KWD-STELLA-IN-READER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "READER" NULL 2))
   (CL:SETQ KWD-STELLA-IN-WRITER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRITER" NULL 2))
   (CL:SETQ KWD-STELLA-IN-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE" NULL 2))
   (CL:SETQ KWD-STELLA-IN-RENAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RENAMES" NULL 2))
   (CL:SETQ KWD-STELLA-IN-REQUIRED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REQUIRED?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-COMPONENT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPONENT?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-READ-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "READ-ONLY?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-CONTEXT-SENSITIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-SENSITIVE?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-HARDWIRED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HARDWIRED?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-OPTION-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTION-KEYWORD" NULL 2))
   (CL:SETQ KWD-STELLA-IN-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTION-HANDLER" NULL 2))
   (CL:SETQ SYM-STELLA-IN-STELLA-SLOT-HOME-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-HOME-MODULE" NULL 0))
   (CL:SETQ SYM-STELLA-IN-STELLA-SETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETTER" NULL 0))
   (CL:SETQ KWD-STELLA-IN-RETURN-TYPES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN-TYPES" NULL 2))
   (CL:SETQ KWD-STELLA-IN-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 2))
   (CL:SETQ KWD-STELLA-IN-INHERITS-THROUGH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INHERITS-THROUGH" NULL 2))
   (CL:SETQ KWD-STELLA-IN-SETTER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETTER?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-NATIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-CONSTRUCTOR?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTRUCTOR?" NULL 2))
   (CL:SETQ KWD-STELLA-IN-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY?" NULL 2)))
  :VOID)

(CL:DEFUN STARTUP-STELLA-IN ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-STELLA-IN1)
    (CL:SETQ KWD-STELLA-IN-GLOBALLY-INLINE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBALLY-INLINE?" NULL 2))
    (CL:SETQ KWD-STELLA-IN-COMMAND?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMAND?" NULL 2))
    (CL:SETQ KWD-STELLA-IN-LISP-MACRO?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-MACRO?" NULL 2))
    (CL:SETQ KWD-STELLA-IN-EVALUATE-ARGUMENTS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATE-ARGUMENTS?" NULL 2))
    (CL:SETQ KWD-STELLA-IN-INLINE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE" NULL 2))
    (CL:SETQ SYM-STELLA-IN-STELLA-DEFUN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFUN" NULL 0))
    (CL:SETQ SYM-STELLA-IN-STELLA-SLOT-AUXILIARY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-AUXILIARY?" NULL 0))
    (CL:SETQ SYM-STELLA-IN-STELLA-METHOD-GLOBALLY-INLINE?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-GLOBALLY-INLINE?" NULL 0))
    (CL:SETQ KWD-STELLA-IN-DYNAMIC
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC" NULL 2))
    (CL:SETQ SGT-STELLA-IN-STELLA-DYNAMIC-SLOTS-MIXIN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC-SLOTS-MIXIN" NULL 1))
    (CL:SETQ SYM-STELLA-IN-STELLA-SLOT-OPTION-KEYWORD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-OPTION-KEYWORD" NULL 0))
    (CL:SETQ SYM-STELLA-IN-STELLA-DEFAULT-OPTION-HANDLER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT-OPTION-HANDLER" NULL 0))
    (CL:SETQ SYM-STELLA-IN-STELLA-SLOT-OPTION-HANDLER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-OPTION-HANDLER" NULL 0))
    (CL:SETQ SGT-STELLA-IN-STELLA-BOOLEAN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
    (CL:SETQ SYM-STELLA-IN-STELLA-STARTUP-STELLA-IN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-STELLA-IN" NULL 0))
    (CL:SETQ SYM-STELLA-IN-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL
      0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *UNSUPPORTED-EXTERNAL-SLOT-OPTIONS*
     (LIST KWD-STELLA-IN-ALLOCATION KWD-STELLA-IN-INITIALLY
      KWD-STELLA-IN-CONTEXT-SENSITIVE? KWD-STELLA-IN-HARDWIRED?)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "PERMANENTIFY-FORM"
     "(DEFUN (PERMANENTIFY-FORM OBJECT) ((FORM OBJECT)) :PUBLIC? TRUE)"
     (CL:FUNCTION PERMANENTIFY-FORM) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSIENTIFY-FORM"
     "(DEFUN (TRANSIENTIFY-FORM OBJECT) ((FORM OBJECT)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (COPY-CONS-TREE FORM)))"
     (CL:FUNCTION TRANSIENTIFY-FORM) NULL)
    (DEFINE-FUNCTION-OBJECT "STRINGIFY-IN-MODULE"
     "(DEFUN (STRINGIFY-IN-MODULE STRING) ((TREE OBJECT) (MODULE MODULE)) :DOCUMENTATION \"Stringify a parse `tree' relative to `module', or
`*module*' if no module is specified.\" :PUBLIC? TRUE)"
     (CL:FUNCTION STRINGIFY-IN-MODULE) NULL)
    (DEFINE-FUNCTION-OBJECT "UNSTRINGIFY-IN-MODULE"
     "(DEFUN (UNSTRINGIFY-IN-MODULE OBJECT) ((STRING STRING) (MODULE MODULE)) :DOCUMENTATION \"Unstringify relative to `module', or `*MODULE*' if no
module is specified.\" :PUBLIC? TRUE)"
     (CL:FUNCTION UNSTRINGIFY-IN-MODULE) NULL)
    (DEFINE-FUNCTION-OBJECT "UNSTRINGIFY-STELLA-SOURCE"
     "(DEFUN (UNSTRINGIFY-STELLA-SOURCE OBJECT) ((SOURCE STRING) (MODULE MODULE)) :DOCUMENTATION \"Unstringify a STELLA `source' string relative to `module',
or `*MODULE*' if no module is specified.  This function allocates transient
objects as opposed to `unstringify-in-module' or the regular `unstringify'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION UNSTRINGIFY-STELLA-SOURCE) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-FEATURE-LIST"
     "(DEFUN (COLLECT-FEATURE-LIST (LIST OF GENERALIZED-SYMBOL)) ((TREE OBJECT)))"
     (CL:FUNCTION COLLECT-FEATURE-LIST) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-KEY-VALUE-LIST"
     "(DEFUN (COLLECT-KEY-VALUE-LIST (KEY-VALUE-LIST OF GENERALIZED-SYMBOL OBJECT)) ((TREE OBJECT)))"
     (CL:FUNCTION COLLECT-KEY-VALUE-LIST) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-INLINE-METHOD"
     "(DEFUN (DEFINE-INLINE-METHOD METHOD-SLOT) ((NAME SYMBOL) (PARAMETERSANDBODY CONS)))"
     (CL:FUNCTION DEFINE-INLINE-METHOD) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-DEFINE-CLASS-FROM-PARSE-TREE"
     "(DEFUN (HELP-DEFINE-CLASS-FROM-PARSE-TREE CLASS) ((PARSETREE CONS) (STRINGIFIEDSOURCE STRING)))"
     (CL:FUNCTION HELP-DEFINE-CLASS-FROM-PARSE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-STORAGE-SLOT-FROM-PARSE-TREE"
     "(DEFUN (DEFINE-STORAGE-SLOT-FROM-PARSE-TREE STORAGE-SLOT) ((SLOTDEF CONS) (OWNER TYPE)))"
     (CL:FUNCTION DEFINE-STORAGE-SLOT-FROM-PARSE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-SLOT-HOME-MODULE"
     "(DEFUN (RECORD-SLOT-HOME-MODULE MODULE) ((SELF SLOT)))"
     (CL:FUNCTION RECORD-SLOT-HOME-MODULE) NULL)
    (DEFINE-FUNCTION-OBJECT "EXPLICITLY-QUALIFIED-NAME?"
     "(DEFUN (EXPLICITLY-QUALIFIED-NAME? BOOLEAN) ((NAME GENERALIZED-SYMBOL) (DEFINITIONMODULE MODULE)))"
     (CL:FUNCTION EXPLICITLY-QUALIFIED-NAME?) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-IDENTICAL-CLASS"
     "(DEFUN (GET-IDENTICAL-CLASS CLASS) ((CLASSNAME STRING) (STRINGIFIEDSOURCE STRING)) :PUBLIC? TRUE)"
     (CL:FUNCTION GET-IDENTICAL-CLASS) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-CLASS-FROM-PARSE-TREE"
     "(DEFUN (DEFINE-CLASS-FROM-PARSE-TREE CLASS) ((PARSETREE CONS)) :PUBLIC? TRUE)"
     (CL:FUNCTION DEFINE-CLASS-FROM-PARSE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-CLASS-FROM-STRINGIFIED-SOURCE"
     "(DEFUN (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE CLASS) ((CLASSNAME STRING) (STRINGIFIEDSOURCE STRING)) :PUBLIC? TRUE)"
     (CL:FUNCTION DEFINE-CLASS-FROM-STRINGIFIED-SOURCE) NULL)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-OPTIONS"
     "(DEFUN (EXTRACT-OPTIONS CONS) ((TREE CONS) (OPTIONSTABLE KEY-VALUE-LIST)) :PUBLIC? TRUE)"
     (CL:FUNCTION EXTRACT-OPTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTRUCTURE-DEFMETHOD-TREE"
     "(DEFUN (DESTRUCTURE-DEFMETHOD-TREE OBJECT CONS CONS) ((METHOD-TREE CONS) (OPTIONS-TABLE KEY-VALUE-LIST)) :PUBLIC? TRUE :DOCUMENTATION \"Return three parse trees representing the name,
parameters, and code body of the parse tree `method-tree'.  Fill
`options-table' with a dictionary of method options.
Storage note:  Options are treated specially because the other return
values are subtrees of `method-tree', while `options-table' is a newly-created
cons tree.  Note also, the parameter and body trees are destructively
removed from `method-tree'.\")"
     (CL:FUNCTION DESTRUCTURE-DEFMETHOD-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-SETTER-METHOD-NAME"
     "(DEFUN (YIELD-SETTER-METHOD-NAME SYMBOL) ((METHODNAME SYMBOL)))"
     (CL:FUNCTION YIELD-SETTER-METHOD-NAME) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTRUCTURE-METHOD-NAME-TREE"
     "(DEFUN (DESTRUCTURE-METHOD-NAME-TREE SYMBOL CONS) ((NAMETREE OBJECT)))"
     (CL:FUNCTION DESTRUCTURE-METHOD-NAME-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "IN-PLACE-NORMALIZE-METHOD-OPTIONS"
     "(DEFUN IN-PLACE-NORMALIZE-METHOD-OPTIONS ((METHODOPTIONS KEYWORD-KEY-VALUE-LIST) (METHODNAME SYMBOL)))"
     (CL:FUNCTION IN-PLACE-NORMALIZE-METHOD-OPTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-FUNCTION-WITH-IDENTICAL-SIGNATURE"
     "(DEFUN (GET-FUNCTION-WITH-IDENTICAL-SIGNATURE METHOD-SLOT) ((NAME SYMBOL) (STRINGIFIEDSOURCE STRING)))"
     (CL:FUNCTION GET-FUNCTION-WITH-IDENTICAL-SIGNATURE) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-METHOD-WITH-IDENTICAL-SIGNATURE"
     "(DEFUN (GET-METHOD-WITH-IDENTICAL-SIGNATURE METHOD-SLOT) ((NAME SYMBOL) (PARAMETERSTREE CONS) (STRINGIFIEDSOURCE STRING)))"
     (CL:FUNCTION GET-METHOD-WITH-IDENTICAL-SIGNATURE) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-DEFINE-METHOD-FROM-PARSE-TREE"
     "(DEFUN (HELP-DEFINE-METHOD-FROM-PARSE-TREE METHOD-SLOT BOOLEAN) ((INPUTTREE CONS) (STRINGIFIEDSOURCE STRING)))"
     (CL:FUNCTION HELP-DEFINE-METHOD-FROM-PARSE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-METHOD-FROM-PARSE-TREE"
     "(DEFUN (DEFINE-METHOD-FROM-PARSE-TREE METHOD-SLOT) ((PARSETREE CONS)))"
     (CL:FUNCTION DEFINE-METHOD-FROM-PARSE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "STRINGIFY-METHOD-SIGNATURE"
     "(DEFUN (STRINGIFY-METHOD-SIGNATURE STRING) ((PARSETREE CONS)))"
     (CL:FUNCTION STRINGIFY-METHOD-SIGNATURE) NULL)
    (DEFINE-FUNCTION-OBJECT "STRINGIFY-METHOD-BODY?"
     "(DEFUN (STRINGIFY-METHOD-BODY? BOOLEAN) ((METHOD METHOD-SLOT)))"
     (CL:FUNCTION STRINGIFY-METHOD-BODY?) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-METHOD-FROM-STRINGIFIED-SOURCE"
     "(DEFUN (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE METHOD-SLOT) ((METHODNAME STRING) (CLASSNAME STRING) (STRINGIFIEDSOURCE STRING)) :PUBLIC? TRUE)"
     (CL:FUNCTION DEFINE-METHOD-FROM-STRINGIFIED-SOURCE) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-METHOD-OBJECT"
     "(DEFUN DEFINE-METHOD-OBJECT ((DEFINITION STRING) (CODE METHOD-CODE) (WRAPPERCODE METHOD-CODE)))"
     (CL:FUNCTION DEFINE-METHOD-OBJECT) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE"
     "(DEFUN (DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE STORAGE-SLOT) ((PARSETREE CONS)))"
     (CL:FUNCTION DEFINE-EXTERNAL-SLOT-FROM-PARSE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT
     "DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE"
     "(DEFUN (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE STORAGE-SLOT) ((STRINGIFIEDSOURCE STRING)) :PUBLIC? TRUE)"
     (CL:FUNCTION DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-SLOT-FROM-OPTION-KEYWORD"
     "(DEFUN (LOOKUP-SLOT-FROM-OPTION-KEYWORD STORAGE-SLOT) ((OWNER TYPE) (KEYWORD KEYWORD)))"
     (CL:FUNCTION LOOKUP-SLOT-FROM-OPTION-KEYWORD) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-OPTION-HANDLER"
     "(DEFUN (LOOKUP-OPTION-HANDLER METHOD-SLOT) ((SLOT STORAGE-SLOT)) :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-OPTION-HANDLER) NULL)
    (DEFINE-FUNCTION-OBJECT "RUN-OPTION-HANDLER?"
     "(DEFUN (RUN-OPTION-HANDLER? BOOLEAN) ((OBJECT OBJECT) (OPTION KEYWORD) (VALUETREE OBJECT)) :PUBLIC? TRUE)"
     (CL:FUNCTION RUN-OPTION-HANDLER?) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFAULT-OPTION-HANDLER"
     "(DEFUN DEFAULT-OPTION-HANDLER ((SELF OBJECT) (SLOT STORAGE-SLOT) (TREE OBJECT)))"
     (CL:FUNCTION DEFAULT-OPTION-HANDLER) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-STELLA-IN"
     "(DEFUN STARTUP-STELLA-IN () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-STELLA-IN) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-STELLA-IN-STELLA-STARTUP-STELLA-IN)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-STELLA-IN-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupStellaIn") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *REDEFINE-IDENTICAL-CLASSES?* BOOLEAN FALSE :DOCUMENTATION \"If `true', always redefine classes, even if an
                  identical class exists\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *UNSUPPORTED-EXTERNAL-SLOT-OPTIONS* (LIST OF KEYWORD) (LIST :ALLOCATION :INITIALLY :CONTEXT-SENSITIVE? :HARDWIRED?))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEFAULT-OPTION-HANDLER* METHOD-SLOT NULL)")
    (CL:SETQ *DEFAULT-OPTION-HANDLER*
     (LOOKUP-FUNCTION SYM-STELLA-IN-STELLA-DEFAULT-OPTION-HANDLER))))
  :VOID)
