;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; symbols.lisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2014      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-SYMBOLS-STELLA-MODULE-LISP-PACKAGE NULL)
(CL:DEFVAR SYM-SYMBOLS-STELLA-JAVA-PACKAGE NULL)
(CL:DEFVAR SYM-SYMBOLS-STELLA-MODULE-CPP-PACKAGE NULL)
(CL:DEFVAR SYM-SYMBOLS-STELLA-CODE-ONLY? NULL)
(CL:DEFVAR KWD-SYMBOLS-SYMBOL NULL)
(CL:DEFVAR KWD-SYMBOLS-SURROGATE NULL)
(CL:DEFVAR KWD-SYMBOLS-KEYWORD NULL)
(CL:DEFVAR KWD-SYMBOLS-LETTER NULL)
(CL:DEFVAR KWD-SYMBOLS-DIGIT NULL)
(CL:DEFVAR KWD-SYMBOLS-SYMBOL-CONSTITUENT NULL)
(CL:DEFVAR KWD-SYMBOLS-ESCAPED NULL)
(CL:DEFVAR KWD-SYMBOLS-UNESCAPED NULL)
(CL:DEFVAR KWD-SYMBOLS-COMPLEX-ESCAPED NULL)
(CL:DEFVAR SYM-SYMBOLS-STELLA-STARTUP-SYMBOLS NULL)
(CL:DEFVAR SYM-SYMBOLS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *PRINTREADABLY?* *STELLA-TOKENIZER-TABLE*
  *STELLA-LOGICAL-STATE-NAMES* NULL-CHARACTER *CHARACTER-TYPE-TABLE*
  NULL-STRING-WRAPPER *TRANSIENTOBJECTS?* NIL NULL-INTEGER))

;;; (DEFUN (NEXT-FREE-OFFSET INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) NEXT-FREE-OFFSET))
(CL:DEFUN NEXT-FREE-OFFSET (SELF)
  (CL:LET*
   ((TOPOFFSET (%TOP-SYMBOL-OFFSET SELF))
    (FREEOFFSET (CL:1+ TOPOFFSET)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM TOPOFFSET FREEOFFSET))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 (%POTENTIAL-FREE-SYMBOL-OFFSET SELF))
     (UPPER-BOUND-000 TOPOFFSET)
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:WHEN
      (CL:EQ (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) I)
       NULL)
      (CL:SETQ FREEOFFSET I) (CL:RETURN))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETF (%POTENTIAL-FREE-SYMBOL-OFFSET SELF) (CL:1+ FREEOFFSET))
   (CL:RETURN-FROM NEXT-FREE-OFFSET FREEOFFSET)))

;;; (DEFUN FREE-SYMBOL-OFFSET ...)

(CL:DEFUN FREE-SYMBOL-OFFSET (SELF OFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:LET ((SELF (%THE-ARRAY SELF)) (VALUE NULL) (POSITION OFFSET))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
    (CL:TYPE CL:FIXNUM POSITION))
   (CL:SETF (CL:AREF SELF POSITION) VALUE))
  (CL:WHEN (CL:< OFFSET (%POTENTIAL-FREE-SYMBOL-OFFSET SELF))
   (CL:SETF (%POTENTIAL-FREE-SYMBOL-OFFSET SELF) OFFSET))
  :VOID)

;;; (DEFUN ADD-TO-SYMBOL-ARRAY-AT ...)

(CL:DEFUN ADD-TO-SYMBOL-ARRAY-AT (ARRAY OFFSET SYMBOL)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (INSERT-AT ARRAY OFFSET SYMBOL)
  (CL:SETF (%SYMBOL-ID SYMBOL) OFFSET)
  :VOID)

;;; (DEFUN (ADD-TO-SYMBOL-ARRAY INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM) ADD-TO-SYMBOL-ARRAY))
(CL:DEFUN ADD-TO-SYMBOL-ARRAY (ARRAY SYMBOL)
  (CL:LET* ((OFFSET (NEXT-FREE-OFFSET ARRAY)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (ADD-TO-SYMBOL-ARRAY-AT ARRAY OFFSET SYMBOL)
   (CL:RETURN-FROM ADD-TO-SYMBOL-ARRAY OFFSET)))

;;; (DEFUN (LEGAL-SYMBOL-ARRAY-OFFSET? BOOLEAN) ...)

(CL:DEFUN LEGAL-SYMBOL-ARRAY-OFFSET? (ARRAY OFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:RETURN-FROM LEGAL-SYMBOL-ARRAY-OFFSET?
   (<= OFFSET (%TOP-SYMBOL-OFFSET ARRAY))))

;;; (DEFGLOBAL *SYMBOL-ARRAY* ...)

(CL:DEFVAR *SYMBOL-ARRAY* NULL)

;;; (DEFGLOBAL *SURROGATE-ARRAY* ...)

(CL:DEFVAR *SURROGATE-ARRAY* NULL)

;;; (DEFGLOBAL *KEYWORD-ARRAY* ...)

(CL:DEFVAR *KEYWORD-ARRAY* NULL)

;;; (DEFGLOBAL *KEYWORD-OFFSET-TABLE* ...)

(CL:DEFVAR *KEYWORD-OFFSET-TABLE* NULL)

;;; (DEFGLOBAL *FIXED-SYMBOL-ARRAY* ...)

(CL:DEFVAR *FIXED-SYMBOL-ARRAY* NULL)

;;; (DEFGLOBAL *FIXED-SURROGATE-ARRAY* ...)

(CL:DEFVAR *FIXED-SURROGATE-ARRAY* NULL)

;;; (DEFGLOBAL *FIXED-KEYWORD-ARRAY* ...)

(CL:DEFVAR *FIXED-KEYWORD-ARRAY* NULL)

;;; (DEFGLOBAL *TRANSIENT-SYMBOL-LOOKUP-TABLE* ...)

(CL:DEFVAR *TRANSIENT-SYMBOL-LOOKUP-TABLE* NULL)

;;; (DEFGLOBAL *COMMON-LISP-SYMBOL-LOOKUP-TABLE* ...)

(CL:DEFVAR *COMMON-LISP-SYMBOL-LOOKUP-TABLE* NULL)

;;; (DEFCONSTANT SYMBOL-SYM ...)

(CL:DEFVAR SYMBOL-SYM 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM SYMBOL-SYM))

;;; (DEFCONSTANT SURROGATE-SYM ...)

(CL:DEFVAR SURROGATE-SYM 1)
(CL:DECLAIM (CL:TYPE CL:FIXNUM SURROGATE-SYM))

;;; (DEFCONSTANT KEYWORD-SYM ...)

(CL:DEFVAR KEYWORD-SYM 2)
(CL:DECLAIM (CL:TYPE CL:FIXNUM KEYWORD-SYM))

;;; (DEFGLOBAL *ROOT-MODULE* ...)

(CL:DEFVAR *ROOT-MODULE* NULL
  "Pointer to the top-most module ROOT-MODULE.")

;;; (DEFGLOBAL *STELLA-MODULE* ...)

(CL:DEFVAR *STELLA-MODULE* NULL
  "Pointer to the module STELLA containing definitions of 
STELLA classes and methods.")

;;; (DEFGLOBAL *COMMON-LISP-MODULE* ...)

(CL:DEFVAR *COMMON-LISP-MODULE* NULL
  "Pointer to the module COMMON-LISP containing Common
Lisp symbols (and maybe other things).")

;;; (DEFGLOBAL *ALTERNATE-STELLA-MODULE* ...)

(CL:DEFVAR *ALTERNATE-STELLA-MODULE* NULL
  "Pointer to the module ALTERNATE-STELLA containing
definitions of STELLA classes and methods generated during the
translation of STELLA files.")

;;; (DEFSPECIAL *CONTEXT* ...)

(CL:DEFVAR *CONTEXT*)

;;; (DEFSPECIAL *MODULE* ...)

(CL:DEFVAR *MODULE*)

;;; (DEFCONSTANT SURROGATE-PREFIX-CHARACTER ...)

(CL:DEFVAR SURROGATE-PREFIX-CHARACTER #\@
  "Character used to prefix the name of a surrogate.")

;;; (DEFCONSTANT MODULE-SEPARATOR-CHARACTER ...)

(CL:DEFVAR MODULE-SEPARATOR-CHARACTER #\/
  "Character used to concatenate a module name
to a symbol or surrogate name to form a qualified name.")

;;; (DEFCONSTANT MODULE-SEPARATOR-STRING ...)

(CL:DEFVAR MODULE-SEPARATOR-STRING "/"
  "String containing character used to concatenate a module name
to a symbol or surrogate name to form a qualified name.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING MODULE-SEPARATOR-STRING))

;;; (DEFUN (GET-SYM SYMBOL) ...)

(CL:DEFUN GET-SYM (OFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:RETURN-FROM GET-SYM
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY *FIXED-SYMBOL-ARRAY*))
    OFFSET)))

;;; (DEFUN (GET-SGT SURROGATE) ...)

(CL:DEFUN GET-SGT (OFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:RETURN-FROM GET-SGT
   (CL:AREF
    (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY *FIXED-SURROGATE-ARRAY*))
    OFFSET)))

;;; (DEFUN (GET-KWD KEYWORD) ...)

(CL:DEFUN GET-KWD (OFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:RETURN-FROM GET-KWD
   (CL:AREF
    (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY *FIXED-KEYWORD-ARRAY*))
    OFFSET)))

;;; (DEFUN (GET-GENERALIZED-SYMBOL-FROM-OFFSET GENERALIZED-SYMBOL) ...)

(CL:DEFUN GET-GENERALIZED-SYMBOL-FROM-OFFSET (SYMBOLARRAY OFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:RETURN-FROM GET-GENERALIZED-SYMBOL-FROM-OFFSET
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SYMBOLARRAY)) OFFSET)))

;;; (DEFUN (GET-SYM-FROM-OFFSET SYMBOL) ...)

(CL:DEFUN GET-SYM-FROM-OFFSET (OFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:RETURN-FROM GET-SYM-FROM-OFFSET
   (GET-GENERALIZED-SYMBOL-FROM-OFFSET *SYMBOL-ARRAY* OFFSET)))

;;; (DEFUN (GET-SGT-FROM-OFFSET SURROGATE) ...)

(CL:DEFUN GET-SGT-FROM-OFFSET (OFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:RETURN-FROM GET-SGT-FROM-OFFSET
   (GET-GENERALIZED-SYMBOL-FROM-OFFSET *SURROGATE-ARRAY* OFFSET)))

;;; (DEFUN (GET-KWD-FROM-OFFSET KEYWORD) ...)

(CL:DEFUN GET-KWD-FROM-OFFSET (OFFSET)
  (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:RETURN-FROM GET-KWD-FROM-OFFSET
   (GET-GENERALIZED-SYMBOL-FROM-OFFSET *KEYWORD-ARRAY* OFFSET)))

;;; (DEFUN (SELECT-SYMBOL-OFFSET-TABLE STRING-TO-INTEGER-HASH-TABLE) ...)

(CL:DEFUN SELECT-SYMBOL-OFFSET-TABLE (MODULE KINDOFSYM)
  (CL:DECLARE (CL:TYPE CL:FIXNUM KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:ECASE KINDOFSYM
   (0
    (CL:RETURN-FROM SELECT-SYMBOL-OFFSET-TABLE
     (%SYMBOL-OFFSET-TABLE MODULE)))
   (1
    (CL:RETURN-FROM SELECT-SYMBOL-OFFSET-TABLE
     (%SURROGATE-OFFSET-TABLE MODULE)))
   (2
    (CL:RETURN-FROM SELECT-SYMBOL-OFFSET-TABLE *KEYWORD-OFFSET-TABLE*))))

;;; (DEFUN (SELECT-SYMBOL-ARRAY EXTENSIBLE-SYMBOL-ARRAY) ...)

(CL:DEFUN SELECT-SYMBOL-ARRAY (KINDOFSYM)
  (CL:DECLARE (CL:TYPE CL:FIXNUM KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:ECASE KINDOFSYM
   (0 (CL:RETURN-FROM SELECT-SYMBOL-ARRAY *SYMBOL-ARRAY*))
   (1 (CL:RETURN-FROM SELECT-SYMBOL-ARRAY *SURROGATE-ARRAY*))
   (2 (CL:RETURN-FROM SELECT-SYMBOL-ARRAY *KEYWORD-ARRAY*))))

;;; (DEFUN (LOOKUP-RIGID-SYMBOL-LOCALLY GENERALIZED-SYMBOL) ...)

(CL:DEFUN LOOKUP-RIGID-SYMBOL-LOCALLY (NAME MODULE KINDOFSYM)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:LET*
   ((OFFSETTABLE (SELECT-SYMBOL-OFFSET-TABLE MODULE KINDOFSYM))
    (OFFSET (LOOKUP OFFSETTABLE NAME)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:WHEN (CL:NOT (CL:= OFFSET NULL-INTEGER))
    (CL:ECASE KINDOFSYM
     (0
      (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL-LOCALLY
       (GET-SYM-FROM-OFFSET OFFSET)))
     (1
      (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL-LOCALLY
       (GET-SGT-FROM-OFFSET OFFSET)))
     (2
      (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL-LOCALLY
       (GET-KWD-FROM-OFFSET OFFSET)))))
   (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL-LOCALLY NULL)))

;;; (DEFUN (YIELD-VISIBLE-RIGID-SYMBOLS-WRT-MODULE (CONS OF GENERALIZED-SYMBOL)) ...)

(CL:DEFUN YIELD-VISIBLE-RIGID-SYMBOLS-WRT-MODULE (NAME MODULE KINDOFSYM)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:LET* ((LISTOFSYMBOLS NIL) (SYMBOL NULL))
   (CL:LET* ((VISIBLEMODULE NULL) (ITER-000 (VISIBLE-MODULES MODULE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ VISIBLEMODULE (%%VALUE ITER-000))
     (CL:LET* ()
      (CL:SETQ SYMBOL
       (LOOKUP-RIGID-SYMBOL-LOCALLY NAME VISIBLEMODULE KINDOFSYM))
      (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
       (CL:SETQ LISTOFSYMBOLS (CONS SYMBOL LISTOFSYMBOLS))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM YIELD-VISIBLE-RIGID-SYMBOLS-WRT-MODULE
    (REVERSE LISTOFSYMBOLS))))

;;; (DEFUN (VISIBLE-RIGID-SYMBOLS-WRT-MODULE (ITERATOR OF GENERALIZED-SYMBOL)) ...)

(CL:DEFUN VISIBLE-RIGID-SYMBOLS-WRT-MODULE (NAME MODULE KINDOFSYM)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:RETURN-FROM VISIBLE-RIGID-SYMBOLS-WRT-MODULE
   (ALLOCATE-DESTRUCTIVE-LIST-ITERATOR
    (YIELD-VISIBLE-RIGID-SYMBOLS-WRT-MODULE NAME MODULE KINDOFSYM))))

;;; (DEFUN (REMOVE-SHADOWED-SYMBOLS (CONS OF GENERALIZED-SYMBOL)) ...)

(CL:DEFUN REMOVE-SHADOWED-SYMBOLS (VISIBLESYMBOLS)
  (CL:WHEN (CL:EQ (%%REST VISIBLESYMBOLS) NIL)
   (CL:RETURN-FROM REMOVE-SHADOWED-SYMBOLS VISIBLESYMBOLS))
  (CL:LET* ((SHADOWINGMODULES NIL))
   (CL:LET*
    ((SYMBOL NULL) (ITER-000 VISIBLESYMBOLS) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SYMBOL (%%VALUE ITER-000))
     (CL:WHEN (SHADOWED-SYMBOL? SYMBOL)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000 (CONS (%HOME-CONTEXT SYMBOL) NIL))
        (CL:IF (CL:EQ SHADOWINGMODULES NIL)
         (CL:SETQ SHADOWINGMODULES COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST SHADOWINGMODULES COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (%HOME-CONTEXT SYMBOL) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:NOT (CL:EQ SHADOWINGMODULES NIL))
    (CL:LET* ((UNSHADOWEDSYMBOLS NIL))
     (CL:LET*
      ((SYMBOL NULL) (ITER-001 VISIBLESYMBOLS) (COLLECT-001 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ SYMBOL (%%VALUE ITER-001))
       (CL:LET* ((TEST-VALUE-000 CL:NIL))
        (CL:LET* ((FOUND?-000 CL:NIL))
         (CL:LET* ((MODULE NULL) (ITER-002 SHADOWINGMODULES))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
           (CL:SETQ MODULE (%%VALUE ITER-002))
           (CL:WHEN
            (CL:AND (CL:NOT (CL:EQ MODULE (%HOME-CONTEXT SYMBOL)))
             (VISIBLE-FROM? (%HOME-CONTEXT SYMBOL) MODULE))
            (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
           (CL:SETQ ITER-002 (%%REST ITER-002))))
         (CL:SETQ TEST-VALUE-000 FOUND?-000))
        (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
        (CL:WHEN TEST-VALUE-000
         (CL:IF (CL:EQ COLLECT-001 NULL)
          (CL:PROGN (CL:SETQ COLLECT-001 (CONS SYMBOL NIL))
           (CL:IF (CL:EQ UNSHADOWEDSYMBOLS NIL)
            (CL:SETQ UNSHADOWEDSYMBOLS COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST UNSHADOWEDSYMBOLS
             COLLECT-001)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS SYMBOL NIL))
           (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETQ VISIBLESYMBOLS UNSHADOWEDSYMBOLS)))
   (CL:RETURN-FROM REMOVE-SHADOWED-SYMBOLS VISIBLESYMBOLS)))

;;; (DEFUN (LOOKUP-RIGID-SYMBOL-OFFSET-WRT-MODULE INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING CL:T CL:FIXNUM) CL:FIXNUM)
  LOOKUP-RIGID-SYMBOL-OFFSET-WRT-MODULE))
(CL:DEFUN LOOKUP-RIGID-SYMBOL-OFFSET-WRT-MODULE (NAME MODULE KINDOFSYM)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:LET*
   ((OFFSETTABLE (SELECT-SYMBOL-OFFSET-TABLE MODULE KINDOFSYM))
    (OFFSET (LOOKUP OFFSETTABLE NAME)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:WHEN (CL:NOT (CL:= OFFSET NULL-INTEGER))
    (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL-OFFSET-WRT-MODULE OFFSET))
   (CL:LET* ((SUPER NULL) (ITER-000 (%%REST (VISIBLE-MODULES MODULE))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPER (%%VALUE ITER-000))
     (CL:SETQ OFFSET
      (LOOKUP (SELECT-SYMBOL-OFFSET-TABLE SUPER KINDOFSYM) NAME))
     (CL:WHEN (CL:NOT (CL:= OFFSET NULL-INTEGER))
      (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL-OFFSET-WRT-MODULE OFFSET))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL-OFFSET-WRT-MODULE NULL-INTEGER)))

;;; (DEFUN (LOOKUP-RIGID-SYMBOL-WRT-MODULE GENERALIZED-SYMBOL) ...)

(CL:DEFUN LOOKUP-RIGID-SYMBOL-WRT-MODULE (NAME MODULE KINDOFSYM)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:LET*
   ((OFFSET
     (LOOKUP-RIGID-SYMBOL-OFFSET-WRT-MODULE NAME MODULE KINDOFSYM)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:IF (CL:NOT (CL:= OFFSET NULL-INTEGER))
    (CL:ECASE KINDOFSYM
     (0
      (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL-WRT-MODULE
       (GET-SYM-FROM-OFFSET OFFSET)))
     (1
      (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL-WRT-MODULE
       (GET-SGT-FROM-OFFSET OFFSET)))
     (2
      (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL-WRT-MODULE
       (GET-KWD-FROM-OFFSET OFFSET))))
    (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL-WRT-MODULE NULL))))

;;; (DEFUN (LOOKUP-RIGID-SYMBOL GENERALIZED-SYMBOL) ...)

(CL:DEFUN LOOKUP-RIGID-SYMBOL (NAME KINDOFSYM)
  "Return the permanent symbol with name 'name' and type
`kindOfSym' visible from the current module (case-sensitive)."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:RETURN-FROM LOOKUP-RIGID-SYMBOL
   (LOOKUP-RIGID-SYMBOL-WRT-MODULE NAME *MODULE* KINDOFSYM)))

;;; (DEFUN (LOOKUP-SYMBOL SYMBOL) ...)

(CL:DEFUN LOOKUP-SYMBOL (NAME)
  "Return the first symbol with `name' visible from the current module."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM LOOKUP-SYMBOL
   (LOOKUP-RIGID-SYMBOL-WRT-MODULE NAME *MODULE* SYMBOL-SYM)))

;;; (DEFUN (LOOKUP-SYMBOL-IN-MODULE SYMBOL) ...)

(CL:DEFUN LOOKUP-SYMBOL-IN-MODULE (NAME MODULE LOCAL?)
  "Return the first symbol with `name' visible from `module'.
If `local?' only consider symbols directly interned in `module'.
If `module' is `null', use `*MODULE*' instead."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
  (CL:IF LOCAL?
   (CL:RETURN-FROM LOOKUP-SYMBOL-IN-MODULE
    (LOOKUP-RIGID-SYMBOL-LOCALLY NAME MODULE SYMBOL-SYM))
   (CL:RETURN-FROM LOOKUP-SYMBOL-IN-MODULE
    (LOOKUP-RIGID-SYMBOL-WRT-MODULE NAME MODULE SYMBOL-SYM))))

;;; (DEFUN (LOOKUP-VISIBLE-SYMBOLS-IN-MODULE (CONS OF SYMBOL)) ...)

(CL:DEFUN LOOKUP-VISIBLE-SYMBOLS-IN-MODULE (NAME MODULE ENFORCESHADOWING?)
  "Return the list of symbols with `name' visible from `module'.
More specific symbols (relative to the module precedence order defined by
`visible-modules') come earlier in the list.  If `module' is `null', start
from `*MODULE*' instead.  If `enforceShadowing?' is true, do not return any
symbols that are shadowed due to some :SHADOW declaration."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((VISIBLESYMBOLS
     (YIELD-VISIBLE-RIGID-SYMBOLS-WRT-MODULE NAME MODULE SYMBOL-SYM)))
   (CL:IF
    (CL:AND ENFORCESHADOWING?
     (CL:NOT (CL:EQ (%%REST VISIBLESYMBOLS) NIL)))
    (CL:RETURN-FROM LOOKUP-VISIBLE-SYMBOLS-IN-MODULE
     (REMOVE-SHADOWED-SYMBOLS VISIBLESYMBOLS))
    (CL:RETURN-FROM LOOKUP-VISIBLE-SYMBOLS-IN-MODULE VISIBLESYMBOLS))))

;;; (DEFUN (LOOKUP-SURROGATE SURROGATE) ...)

(CL:DEFUN LOOKUP-SURROGATE (NAME)
  "Return the first surrogate with `name' visible from the current module."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM LOOKUP-SURROGATE
   (LOOKUP-RIGID-SYMBOL-WRT-MODULE NAME *MODULE* SURROGATE-SYM)))

;;; (DEFUN (LOOKUP-SURROGATE-IN-MODULE SURROGATE) ...)

(CL:DEFUN LOOKUP-SURROGATE-IN-MODULE (NAME MODULE LOCAL?)
  "Return the first surrogate with `name' visible from `module'.
If `local?' only consider surrogates directly interned in `module'.
If `module' is `null', use `*MODULE*' instead."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
  (CL:IF LOCAL?
   (CL:RETURN-FROM LOOKUP-SURROGATE-IN-MODULE
    (LOOKUP-RIGID-SYMBOL-LOCALLY NAME MODULE SURROGATE-SYM))
   (CL:RETURN-FROM LOOKUP-SURROGATE-IN-MODULE
    (LOOKUP-RIGID-SYMBOL-WRT-MODULE NAME MODULE SURROGATE-SYM))))

;;; (DEFUN (LOOKUP-VISIBLE-SURROGATES-IN-MODULE (CONS OF SURROGATE)) ...)

(CL:DEFUN LOOKUP-VISIBLE-SURROGATES-IN-MODULE (NAME MODULE ENFORCESHADOWING?)
  "Return the list of surrogates with `name' visible from `module'.
More specific surrogates (relative to the module precedence order defined by
`visible-modules') come earlier in the list.  If `module' is `null', start
from `*MODULE*' instead.  If `enforceShadowing?' is true, do not return any
surrogates that are shadowed due to some :SHADOW declaration."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((VISIBLESURROGATES
     (YIELD-VISIBLE-RIGID-SYMBOLS-WRT-MODULE NAME MODULE
      SURROGATE-SYM)))
   (CL:IF
    (CL:AND ENFORCESHADOWING?
     (CL:NOT (CL:EQ (%%REST VISIBLESURROGATES) NIL)))
    (CL:RETURN-FROM LOOKUP-VISIBLE-SURROGATES-IN-MODULE
     (REMOVE-SHADOWED-SYMBOLS VISIBLESURROGATES))
    (CL:RETURN-FROM LOOKUP-VISIBLE-SURROGATES-IN-MODULE
     VISIBLESURROGATES))))

;;; (DEFUN (LOOKUP-KEYWORD KEYWORD) ...)

(CL:DEFUN LOOKUP-KEYWORD (NAME)
  "Return the keyword with `name' if it exists."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM LOOKUP-KEYWORD (LOOKUP-RIGID-SYMBOL NAME KEYWORD-SYM)))

;;; (DEFUN (HELP-INTERN-GENERALIZED-SYMBOL GENERALIZED-SYMBOL) ...)

(CL:DEFUN HELP-INTERN-GENERALIZED-SYMBOL (NAME KINDOFSYM ARRAY OFFSET MODULE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM KINDOFSYM OFFSET))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:LET*
   ((SYMBOL NULL)
    (TABLE (SELECT-SYMBOL-OFFSET-TABLE MODULE KINDOFSYM)))
   (CL:ECASE KINDOFSYM
    (0 (CL:SETQ SYMBOL (NEW-SYMBOL NAME)) (INSERT-AT TABLE NAME OFFSET)
     (CL:SETF (%HOME-CONTEXT SYMBOL) MODULE))
    (1 (CL:SETQ SYMBOL (NEW-SURROGATE NAME))
     (INSERT-AT TABLE NAME OFFSET)
     (CL:SETF (%HOME-CONTEXT SYMBOL) MODULE))
    (2 (CL:SETQ SYMBOL (NEW-KEYWORD NAME))
     (INSERT-AT TABLE NAME OFFSET)
     (CL:SETF (%HOME-CONTEXT SYMBOL) NULL)))
   (ADD-TO-SYMBOL-ARRAY-AT ARRAY OFFSET SYMBOL)
   (CL:RETURN-FROM HELP-INTERN-GENERALIZED-SYMBOL SYMBOL)))

;;; (DEFUN (INTERN-RIGID-SYMBOL-WRT-MODULE GENERALIZED-SYMBOL) ...)

(CL:DEFUN INTERN-RIGID-SYMBOL-WRT-MODULE (NAME MODULE KINDOFSYM)
  "Return a newly-created or existing rigid symbol with
name `name'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
  (CL:LET*
   ((OFFSET
     (LOOKUP-RIGID-SYMBOL-OFFSET-WRT-MODULE NAME MODULE KINDOFSYM)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:WHEN (CL:NOT (CL:= OFFSET NULL-INTEGER))
    (CL:ECASE KINDOFSYM
     (0
      (CL:RETURN-FROM INTERN-RIGID-SYMBOL-WRT-MODULE
       (GET-SYM-FROM-OFFSET OFFSET)))
     (1
      (CL:RETURN-FROM INTERN-RIGID-SYMBOL-WRT-MODULE
       (GET-SGT-FROM-OFFSET OFFSET)))
     (2
      (CL:RETURN-FROM INTERN-RIGID-SYMBOL-WRT-MODULE
       (GET-KWD-FROM-OFFSET OFFSET)))))
   (CL:LET* ((ARRAY (SELECT-SYMBOL-ARRAY KINDOFSYM)))
    (CL:SETQ OFFSET (NEXT-FREE-OFFSET ARRAY))
    (CL:RETURN-FROM INTERN-RIGID-SYMBOL-WRT-MODULE
     (HELP-INTERN-GENERALIZED-SYMBOL NAME KINDOFSYM ARRAY OFFSET
      MODULE)))))

;;; (DEFUN (INTERN-RIGID-SYMBOL-LOCALLY GENERALIZED-SYMBOL) ...)

(CL:DEFUN INTERN-RIGID-SYMBOL-LOCALLY (NAME MODULE KINDOFSYM)
  "Return a newly-created or existing rigid symbol
interned into the module `module' with name `name'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
  (CL:LET*
   ((SYMBOL (LOOKUP-RIGID-SYMBOL-LOCALLY NAME MODULE KINDOFSYM)))
   (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM INTERN-RIGID-SYMBOL-LOCALLY SYMBOL))
   (CL:LET* ((ARRAY (SELECT-SYMBOL-ARRAY KINDOFSYM)))
    (CL:RETURN-FROM INTERN-RIGID-SYMBOL-LOCALLY
     (HELP-INTERN-GENERALIZED-SYMBOL NAME KINDOFSYM ARRAY
      (NEXT-FREE-OFFSET ARRAY) MODULE)))))

;;; (DEFUN (INTERN-RIGID-SYMBOL-CASE-SENSITIVELY GENERALIZED-SYMBOL) ...)

(CL:DEFUN INTERN-RIGID-SYMBOL-CASE-SENSITIVELY (NAME KINDOFSYM TRYUPCASING?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:LET* ((SYMBOL NULL))
   (CL:SETQ SYMBOL (LOOKUP-RIGID-SYMBOL NAME KINDOFSYM))
   (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM INTERN-RIGID-SYMBOL-CASE-SENSITIVELY SYMBOL))
   (CL:WHEN (CL:AND *TRANSIENTOBJECTS?* (CL:= KINDOFSYM SYMBOL-SYM))
    (CL:SETQ SYMBOL (LOOKUP-TRANSIENT-SYMBOL NAME))
    (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
     (CL:RETURN-FROM INTERN-RIGID-SYMBOL-CASE-SENSITIVELY SYMBOL)))
   (CL:WHEN TRYUPCASING?
    (CL:SETQ SYMBOL
     (LOOKUP-RIGID-SYMBOL (STRING-UPCASE NAME) KINDOFSYM))
    (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
     (CL:RETURN-FROM INTERN-RIGID-SYMBOL-CASE-SENSITIVELY SYMBOL)))
   (CL:ECASE KINDOFSYM
    (0
     (CL:IF *TRANSIENTOBJECTS?*
      (CL:RETURN-FROM INTERN-RIGID-SYMBOL-CASE-SENSITIVELY
       (INTERN-TRANSIENT-SYMBOL NAME))
      (CL:RETURN-FROM INTERN-RIGID-SYMBOL-CASE-SENSITIVELY
       (INTERN-PERMANENT-SYMBOL NAME))))
    (1
     (CL:RETURN-FROM INTERN-RIGID-SYMBOL-CASE-SENSITIVELY
      (INTERN-RIGID-SYMBOL-WRT-MODULE NAME *MODULE* SURROGATE-SYM))))))

;;; (DEFUN (INTERN-PERMANENT-SYMBOL SYMBOL) ...)

(CL:DEFUN INTERN-PERMANENT-SYMBOL (NAME)
  "Return a newly-created or existing permanent symbol with
name `name'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM INTERN-PERMANENT-SYMBOL
   (INTERN-RIGID-SYMBOL-WRT-MODULE NAME *MODULE* SYMBOL-SYM)))

;;; (DEFUN (INTERN-SYMBOL SYMBOL) ...)

(CL:DEFUN INTERN-SYMBOL (NAME)
  "Return a newly-created or existing symbol with name `name'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:IF (%CASE-SENSITIVE? *MODULE*)
   (CL:RETURN-FROM INTERN-SYMBOL
    (INTERN-RIGID-SYMBOL-CASE-SENSITIVELY NAME SYMBOL-SYM CL:NIL))
   (CL:IF *TRANSIENTOBJECTS?*
    (CL:RETURN-FROM INTERN-SYMBOL
     (INTERN-TRANSIENT-SYMBOL (STRING-UPCASE NAME)))
    (CL:RETURN-FROM INTERN-SYMBOL
     (INTERN-PERMANENT-SYMBOL (STRING-UPCASE NAME))))))

;;; (DEFUN (INTERN-SYMBOL-IN-MODULE SYMBOL) ...)

(CL:DEFUN INTERN-SYMBOL-IN-MODULE (NAME MODULE LOCAL?)
  "Look for a symbol named `name' in `module' (if `local?' do
not consider inherited modules).  If none exists, intern it locally in
`module'.  Return the existing or newly-created symbol."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
  (CL:IF LOCAL?
   (CL:RETURN-FROM INTERN-SYMBOL-IN-MODULE
    (INTERN-RIGID-SYMBOL-LOCALLY NAME MODULE SYMBOL-SYM))
   (CL:RETURN-FROM INTERN-SYMBOL-IN-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE NAME MODULE SYMBOL-SYM))))

;;; (DEFUN (INTERN-DERIVED-SYMBOL SYMBOL) ...)

(CL:DEFUN INTERN-DERIVED-SYMBOL (BASESYMBOL NEWNAME)
  "Return a newly-created or existing symbol with name
`newName' which is interned in the same module as `baseSymbol'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NEWNAME))
  #+MCL
  (CL:CHECK-TYPE NEWNAME CL:SIMPLE-STRING)
  (CL:LET* ((CURRENTMODULE *MODULE*))
   (CL:LET* ((*MODULE* (%HOME-CONTEXT BASESYMBOL)))
    (CL:DECLARE (CL:SPECIAL *MODULE*))
    (CL:WHEN (CL:NOT (CL:EQ *MODULE* NULL))
     (CL:RETURN-FROM INTERN-DERIVED-SYMBOL
      (INTERN-RIGID-SYMBOL-LOCALLY NEWNAME *MODULE* SYMBOL-SYM)))
    (CL:SETQ *MODULE* CURRENTMODULE)
    (CL:RETURN-FROM INTERN-DERIVED-SYMBOL
     (INTERN-RIGID-SYMBOL-CASE-SENSITIVELY NEWNAME SYMBOL-SYM CL:NIL)))))

;;; (DEFUN (INTERN-SURROGATE SURROGATE) ...)

(CL:DEFUN INTERN-SURROGATE (NAME)
  "Return a newly-created or existing surrogate with name `name'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:IF (%CASE-SENSITIVE? *MODULE*)
   (CL:RETURN-FROM INTERN-SURROGATE
    (INTERN-RIGID-SYMBOL-CASE-SENSITIVELY NAME SURROGATE-SYM CL:NIL))
   (CL:RETURN-FROM INTERN-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE (STRING-UPCASE NAME) *MODULE*
     SURROGATE-SYM))))

;;; (DEFUN (INTERN-SURROGATE-IN-MODULE SURROGATE) ...)

(CL:DEFUN INTERN-SURROGATE-IN-MODULE (NAME MODULE LOCAL?)
  "Look for a symbol named `name' in `module' (if `local?' do
not consider inherited modules).  If none exists, intern it locally in
`module'.  Return the existing or newly-created symbol."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
  (CL:IF LOCAL?
   (CL:RETURN-FROM INTERN-SURROGATE-IN-MODULE
    (INTERN-RIGID-SYMBOL-LOCALLY NAME MODULE SURROGATE-SYM))
   (CL:RETURN-FROM INTERN-SURROGATE-IN-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE NAME MODULE SURROGATE-SYM))))

;;; (DEFUN (INTERN-DERIVED-SURROGATE SURROGATE) ...)

(CL:DEFUN INTERN-DERIVED-SURROGATE (BASESYMBOL NEWNAME)
  "Return a newly-created or existing surrogate with name
`newName' which is interned in the same module as `baseSymbol'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NEWNAME))
  #+MCL
  (CL:CHECK-TYPE NEWNAME CL:SIMPLE-STRING)
  (CL:LET* ((CURRENTMODULE *MODULE*))
   (CL:LET* ((*MODULE* (%HOME-CONTEXT BASESYMBOL)))
    (CL:DECLARE (CL:SPECIAL *MODULE*))
    (CL:WHEN (CL:NOT (CL:EQ *MODULE* NULL))
     (CL:RETURN-FROM INTERN-DERIVED-SURROGATE
      (INTERN-RIGID-SYMBOL-LOCALLY
       (CL:IF (%CASE-SENSITIVE? *MODULE*) NEWNAME
        (STRING-UPCASE NEWNAME))
       *MODULE* SURROGATE-SYM)))
    (CL:SETQ *MODULE* CURRENTMODULE)
    (CL:RETURN-FROM INTERN-DERIVED-SURROGATE
     (INTERN-SURROGATE NEWNAME)))))

;;; (DEFUN (INTERN-KEYWORD KEYWORD) ...)

(CL:DEFUN INTERN-KEYWORD (NAME)
  "Return a newly-created or existing keyword with name
`name'.  Storage note: a COPY of `name' is stored in the keyword"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM INTERN-KEYWORD
   (INTERN-RIGID-SYMBOL-WRT-MODULE (STRING-UPCASE NAME) *MODULE*
    KEYWORD-SYM)))

;;; (DEFUN (IMPORT-SYMBOL SYMBOL) ...)

(CL:DEFUN IMPORT-SYMBOL (SYMBOL MODULE)
  "Import `symbol' into `module' and return the imported `symbol'.
Signal an error if a different symbol with the same name already exists
locally in `module'.  Any symbol with the same name visible in `module' by
inheritance will be shadowed by the newly imported `symbol'."
  (CL:LET*
   ((NAME (%SYMBOL-NAME SYMBOL))
    (MODULESYMBOL (LOOKUP-SYMBOL-IN-MODULE NAME MODULE CL:T)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
   (CL:WHEN (CL:EQ (%HOME-CONTEXT SYMBOL) NULL)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "Can't import the TRANSIENT symbol `" NAME "' into `" MODULE "'")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (CL:WHEN (CL:NOT (CL:EQ MODULESYMBOL SYMBOL))
    (CL:WHEN (CL:NOT (CL:EQ MODULESYMBOL NULL))
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
       "Can't import, a symbol with name `" NAME
       "' already exists in `" MODULE "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))
    (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
     (INSERT-AT (SELECT-SYMBOL-OFFSET-TABLE MODULE SYMBOL-SYM) NAME
      (%SYMBOL-ID SYMBOL))))
   (CL:RETURN-FROM IMPORT-SYMBOL SYMBOL)))

;;; (DEFUN (IMPORT-SURROGATE SURROGATE) ...)

(CL:DEFUN IMPORT-SURROGATE (SURROGATE MODULE)
  "Import `surrogate' into `module' and return the imported `surrogate'.
Signal an error if a different surrogate with the same name already exists
locally in `module'.  Any surrogate with the same name visible in `module' by
inheritance will be shadowed by the newly imported `surrogate'."
  (CL:LET*
   ((NAME (%SYMBOL-NAME SURROGATE))
    (MODULESURROGATE (LOOKUP-SURROGATE-IN-MODULE NAME MODULE CL:T)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
   (CL:WHEN (CL:NOT (CL:EQ MODULESURROGATE SURROGATE))
    (CL:WHEN (CL:NOT (CL:EQ MODULESURROGATE NULL))
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "Can't import, a surrogate with name `" NAME
       "' already exists in `" MODULE "'")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
    (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
     (INSERT-AT (SELECT-SYMBOL-OFFSET-TABLE MODULE SURROGATE-SYM) NAME
      (%SYMBOL-ID SURROGATE))))
   (CL:RETURN-FROM IMPORT-SURROGATE SURROGATE)))

;;; (DEFUN (SAFE-IMPORT-SYMBOL SYMBOL) ...)

(CL:DEFUN SAFE-IMPORT-SYMBOL (SYMBOL MODULE)
  "Safe version of `import-symbol' (which see).  Only imports `symbol' if
no symbol with that name is currently interned or visible in `module'.
Returns `symbol' if it was imported or the conflicting symbol in `module'
otherwise."
  (CL:LET*
   ((NAME (%SYMBOL-NAME SYMBOL))
    (MODULESYMBOL (LOOKUP-SYMBOL-IN-MODULE NAME MODULE CL:NIL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
   (CL:IF
    (CL:OR (CL:NOT (CL:EQ MODULESYMBOL NULL))
     (CL:EQ (%HOME-CONTEXT SYMBOL) NULL))
    (CL:RETURN-FROM SAFE-IMPORT-SYMBOL MODULESYMBOL)
    (CL:RETURN-FROM SAFE-IMPORT-SYMBOL (IMPORT-SYMBOL SYMBOL MODULE)))))

;;; (DEFUN (SAFE-IMPORT-SURROGATE SURROGATE) ...)

(CL:DEFUN SAFE-IMPORT-SURROGATE (SURROGATE MODULE)
  "Safe version of `import-surrogate' (which see).  Only imports `surrogate' if
no surrogate with that name is currently interned or visible in `module'.
Returns `surrogate' if it was imported or the conflicting surrogate in `module'
otherwise."
  (CL:LET*
   ((NAME (%SYMBOL-NAME SURROGATE))
    (MODULESURROGATE (LOOKUP-SURROGATE-IN-MODULE NAME MODULE CL:NIL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
   (CL:IF (CL:NOT (CL:EQ MODULESURROGATE NULL))
    (CL:RETURN-FROM SAFE-IMPORT-SURROGATE MODULESURROGATE)
    (CL:RETURN-FROM SAFE-IMPORT-SURROGATE
     (IMPORT-SURROGATE SURROGATE MODULE)))))

;;; (DEFUN UNINTERN-SYMBOL ...)

(CL:DEFUN UNINTERN-SYMBOL (SELF)
  "Remove `self' from its home module and the symbol table."
  (CL:LET*
   ((SYMBOLARRAY (SELECT-SYMBOL-ARRAY SYMBOL-SYM))
    (OFFSETTABLE
     (CL:IF (CL:NOT (CL:EQ (%HOME-CONTEXT SELF) NULL))
      (SELECT-SYMBOL-OFFSET-TABLE (%HOME-CONTEXT SELF) SYMBOL-SYM)
      NULL))
    (SYMBOLID (%SYMBOL-ID SELF))
    (REALSYMBOL (GET-SYM-FROM-OFFSET SYMBOLID)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SYMBOLID))
   (CL:WHEN (CL:EQ SELF REALSYMBOL)
    (FREE-SYMBOL-OFFSET SYMBOLARRAY SYMBOLID))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ OFFSETTABLE NULL))
     (CL:= SYMBOLID (LOOKUP OFFSETTABLE (%SYMBOL-NAME SELF))))
    (REMOVE-AT OFFSETTABLE (%SYMBOL-NAME SELF)))
   (CL:SETF (%SYMBOL-ID SELF) -1)
   (CL:SETF (%SYMBOL-VALUE-AND-PLIST SELF) NULL))
  :VOID)

;;; (DEFUN UNINTERN-SURROGATE ...)

(CL:DEFUN UNINTERN-SURROGATE (SELF)
  "Remove `self' from its home module and the surrogate table."
  (CL:LET*
   ((SURROGATEARRAY (SELECT-SYMBOL-ARRAY SURROGATE-SYM))
    (OFFSETTABLE
     (CL:IF (CL:NOT (CL:EQ (%HOME-CONTEXT SELF) NULL))
      (SELECT-SYMBOL-OFFSET-TABLE (%HOME-CONTEXT SELF) SURROGATE-SYM)
      NULL))
    (SURROGATEID (%SYMBOL-ID SELF))
    (REALSURROGATE (GET-SGT-FROM-OFFSET SURROGATEID)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SURROGATEID))
   (CL:WHEN (CL:EQ SELF REALSURROGATE)
    (FREE-SYMBOL-OFFSET SURROGATEARRAY SURROGATEID))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ OFFSETTABLE NULL))
     (CL:= SURROGATEID (LOOKUP OFFSETTABLE (%SYMBOL-NAME SELF))))
    (REMOVE-AT OFFSETTABLE (%SYMBOL-NAME SELF)))
   (CL:SETF (%SYMBOL-ID SELF) -1)
   (CL:SETF (%SURROGATE-VALUE SELF) NULL))
  :VOID)

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF GENERALIZED-SYMBOL))
  (CL:RETURN-FROM DELETED? (CL:= (%SYMBOL-ID SELF) -1)))

;;; (DEFUN (INTERN-BOOTSTRAP-SYMBOL-AT GENERALIZED-SYMBOL) ...)

(CL:DEFUN INTERN-BOOTSTRAP-SYMBOL-AT (NAME OFFSET KINDOFSYM)
  "Interns a symbol, or keyword with
`name' and symbol-id `offset'.
If a symbol with that ID already existed, an error is signaled.  This
function is used to recreate the symbol table in a way where symbol IDs
which got hardwired into translated code will refer to the correct objects."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM OFFSET KINDOFSYM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE KINDOFSYM CL:FIXNUM)
  (CL:LET* ((SYMBOLARRAY NULL) (SYMBOL NULL))
   (CL:ECASE KINDOFSYM (0 (CL:SETQ SYMBOL (LOOKUP-SYMBOL NAME)))
    (1 (CL:SETQ SYMBOL (LOOKUP-SURROGATE NAME)))
    (2 (CL:SETQ SYMBOL (LOOKUP-KEYWORD NAME))))
   (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:WHEN (CL:NOT (CL:= (%SYMBOL-ID SYMBOL) OFFSET))
     (CL:WARN
      "intern-bootstrap-symbol-at: `~A' is already interned at offset `~A'"
      SYMBOL (%SYMBOL-ID SYMBOL)))
    (CL:RETURN-FROM INTERN-BOOTSTRAP-SYMBOL-AT SYMBOL))
   (CL:SETQ SYMBOLARRAY (SELECT-SYMBOL-ARRAY KINDOFSYM))
   (CL:WHEN
    (CL:AND (LEGAL-SYMBOL-ARRAY-OFFSET? SYMBOLARRAY OFFSET)
     (CL:NOT
      (CL:EQ (GET-GENERALIZED-SYMBOL-FROM-OFFSET SYMBOLARRAY OFFSET)
       NULL)))
    (CL:SETQ SYMBOL
     (GET-GENERALIZED-SYMBOL-FROM-OFFSET SYMBOLARRAY OFFSET))
    (CL:WARN
     "intern-bootstrap-symbol-at: `~A' is already interned at offset `~A'"
     SYMBOL OFFSET)
    (CL:RETURN-FROM INTERN-BOOTSTRAP-SYMBOL-AT SYMBOL))
   (CL:LET* ((ARRAY (SELECT-SYMBOL-ARRAY KINDOFSYM)))
    (CL:RETURN-FROM INTERN-BOOTSTRAP-SYMBOL-AT
     (HELP-INTERN-GENERALIZED-SYMBOL NAME KINDOFSYM ARRAY OFFSET
      *MODULE*)))))

;;; (DEFUN (INTERN-SYMBOL-AT SYMBOL) ...)

(CL:DEFUN INTERN-SYMBOL-AT (NAME OFFSET)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:RETURN-FROM INTERN-SYMBOL-AT
   (INTERN-BOOTSTRAP-SYMBOL-AT NAME OFFSET SYMBOL-SYM)))

;;; (DEFUN (INTERN-SURROGATE-AT SURROGATE) ...)

(CL:DEFUN INTERN-SURROGATE-AT (NAME OFFSET)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:RETURN-FROM INTERN-SURROGATE-AT
   (INTERN-BOOTSTRAP-SYMBOL-AT NAME OFFSET SURROGATE-SYM)))

;;; (DEFUN (INTERN-KEYWORD-AT KEYWORD) ...)

(CL:DEFUN INTERN-KEYWORD-AT (NAME OFFSET)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
   (CL:TYPE CL:FIXNUM OFFSET))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE OFFSET CL:FIXNUM)
  (CL:RETURN-FROM INTERN-KEYWORD-AT
   (INTERN-BOOTSTRAP-SYMBOL-AT NAME OFFSET KEYWORD-SYM)))

;;; (DEFGLOBAL *CONTEXT-NUMBER-COUNTER* ...)

(CL:DEFVAR *CONTEXT-NUMBER-COUNTER* -2
  "Contains the number of the last-created
context (all 'live' contexts are even-numbered).")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *CONTEXT-NUMBER-COUNTER*))

;;; (DEFUN INITIALIZE-KERNEL-MODULE ...)

(CL:DEFUN INITIALIZE-KERNEL-MODULE (MODULE NAME FULLNAME PARENT)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME FULLNAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE FULLNAME CL:SIMPLE-STRING)
  (CL:SETF (%MODULE-NAME MODULE) NAME)
  (CL:SETF (%MODULE-FULL-NAME MODULE) FULLNAME)
  (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
   (INSERT (%CHILD-CONTEXTS PARENT) MODULE)
   (CL:SETF (%CARDINAL-MODULE MODULE) MODULE))
  (CL:SETF (%SYMBOL-OFFSET-TABLE MODULE)
   (NEW-STRING-TO-INTEGER-HASH-TABLE))
  (CL:SETF (%SURROGATE-OFFSET-TABLE MODULE)
   (NEW-STRING-TO-INTEGER-HASH-TABLE))
  (CL:SETF (%ALL-SUPER-CONTEXTS MODULE) NIL)
  (CL:SETF (%BASE-MODULE MODULE) MODULE)
  (CL:SETQ *CONTEXT-NUMBER-COUNTER* (CL:+ *CONTEXT-NUMBER-COUNTER* 2))
  (CL:SETF (%CONTEXT-NUMBER MODULE) *CONTEXT-NUMBER-COUNTER*)
  (CL:SETF (%STRINGIFIED-OPTIONS MODULE) "")
  :VOID)

;;; (DEFUN INITIALIZE-KERNEL-MODULES ...)

(CL:DEFUN INITIALIZE-KERNEL-MODULES ()
  (CL:SETQ *ROOT-MODULE* (NEW-MODULE))
  (INITIALIZE-KERNEL-MODULE *ROOT-MODULE* "ROOT-MODULE" "/" NULL)
  (CL:SETQ *STELLA-MODULE* (NEW-MODULE))
  (INITIALIZE-KERNEL-MODULE *STELLA-MODULE* "STELLA" "/STELLA"
   *ROOT-MODULE*)
  (CL:SETQ *COMMON-LISP-MODULE* (NEW-MODULE))
  (INITIALIZE-KERNEL-MODULE *COMMON-LISP-MODULE* "COMMON-LISP"
   "/COMMON-LISP" *ROOT-MODULE*)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *COMMON-LISP-MODULE*)
   SYM-SYMBOLS-STELLA-MODULE-LISP-PACKAGE (WRAP-STRING "CL")
   NULL-STRING-WRAPPER)
  (CL:SETF (%CARDINAL-MODULE *ROOT-MODULE*) *STELLA-MODULE*)
  (CL:SETQ *MODULE* *STELLA-MODULE*)
  (CL:SETQ *CONTEXT* *MODULE*)
  :VOID)

;;; (DEFUN INITIALIZE-SYMBOLS-AND-KERNEL-MODULES ...)

(CL:DEFUN INITIALIZE-SYMBOLS-AND-KERNEL-MODULES ()
  (CL:SETQ *FIXED-SYMBOL-ARRAY* (NEW-EXTENSIBLE-SYMBOL-ARRAY 100))
  (CL:SETQ *FIXED-SURROGATE-ARRAY* (NEW-EXTENSIBLE-SYMBOL-ARRAY 100))
  (CL:SETQ *FIXED-KEYWORD-ARRAY* (NEW-EXTENSIBLE-SYMBOL-ARRAY 100))
  (CL:SETQ *KEYWORD-OFFSET-TABLE* (NEW-STRING-TO-INTEGER-HASH-TABLE))
  (CL:SETQ *SYMBOL-ARRAY* *FIXED-SYMBOL-ARRAY*)
  (CL:SETQ *SURROGATE-ARRAY* *FIXED-SURROGATE-ARRAY*)
  (CL:SETQ *KEYWORD-ARRAY* *FIXED-KEYWORD-ARRAY*)
  (INITIALIZE-KERNEL-MODULES)
  :VOID)

;;; (DEFUN (LOOKUP-TRANSIENT-SYMBOL SYMBOL) ...)

(CL:DEFUN LOOKUP-TRANSIENT-SYMBOL (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:IF (CL:NOT (CL:EQ *TRANSIENT-SYMBOL-LOOKUP-TABLE* NULL))
   (CL:RETURN-FROM LOOKUP-TRANSIENT-SYMBOL
    (LOOKUP *TRANSIENT-SYMBOL-LOOKUP-TABLE* NAME))
   (CL:PROGN
    (CL:WARN
     "Looking for a transient symbol when the parsing tables have
not been initialized.")
    (CL:RETURN-FROM LOOKUP-TRANSIENT-SYMBOL NULL))))

;;; (DEFUN (INTERN-TRANSIENT-SYMBOL SYMBOL) ...)

(CL:DEFUN INTERN-TRANSIENT-SYMBOL (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((SYMBOL (LOOKUP-SYMBOL-IN-MODULE NAME *MODULE* CL:NIL)))
   (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM INTERN-TRANSIENT-SYMBOL SYMBOL))
   (CL:SETQ SYMBOL (LOOKUP-TRANSIENT-SYMBOL NAME))
   (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM INTERN-TRANSIENT-SYMBOL SYMBOL))
   (CL:SETQ SYMBOL (NEW-TRANSIENT-SYMBOL NAME))
   (CL:SETF (%HOME-CONTEXT SYMBOL) NULL)
   (INSERT-AT *TRANSIENT-SYMBOL-LOOKUP-TABLE* NAME SYMBOL)
   (CL:RETURN-FROM INTERN-TRANSIENT-SYMBOL SYMBOL)))

;;; (DEFUN FREE-TRANSIENT-SYMBOLS ...)

(CL:DEFUN FREE-TRANSIENT-SYMBOLS ()
  (INITIALIZE-HASH-TABLE *TRANSIENT-SYMBOL-LOOKUP-TABLE*)
  :VOID)

;;; (DEFUN (INTERN-COMMON-LISP-SYMBOL SYMBOL) ...)

(CL:DEFUN INTERN-COMMON-LISP-SYMBOL (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((SYMBOL
     (LOOKUP-RIGID-SYMBOL-WRT-MODULE NAME *COMMON-LISP-MODULE*
      SYMBOL-SYM)))
   (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM INTERN-COMMON-LISP-SYMBOL SYMBOL))
   (CL:SETQ NAME (STRING-UPCASE NAME))
   (CL:SETQ SYMBOL
    (LOOKUP-RIGID-SYMBOL-WRT-MODULE NAME *COMMON-LISP-MODULE*
     SYMBOL-SYM))
   (CL:WHEN (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM INTERN-COMMON-LISP-SYMBOL SYMBOL))
   (CL:SETQ SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE NAME *COMMON-LISP-MODULE*
     SYMBOL-SYM))
   (CL:RETURN-FROM INTERN-COMMON-LISP-SYMBOL SYMBOL)))

;;; (DEFUN (SYMBOL-COMMON-LISP? BOOLEAN) ...)

(CL:DEFUN SYMBOL-COMMON-LISP? (SELF)
  (CL:RETURN-FROM SYMBOL-COMMON-LISP?
   (CL:EQ (%HOME-CONTEXT SELF) *COMMON-LISP-MODULE*)))

;;; (DEFUN (COMMON-LISP-SYMBOL? BOOLEAN) ...)

(CL:DEFUN COMMON-LISP-SYMBOL? (SELF)
  (CL:RETURN-FROM COMMON-LISP-SYMBOL?
   (CL:AND (SYMBOL? SELF) (SYMBOL-COMMON-LISP? SELF))))

;;; (DEFUN INITIALIZE-PARSING-TABLES ...)

(CL:DEFUN INITIALIZE-PARSING-TABLES ()
  "Create indices for recording transient symbols and
Common Lisp symbols while parsing."
  (CL:SETQ *TRANSIENT-SYMBOL-LOOKUP-TABLE* (NEW-STRING-HASH-TABLE))
  (CL:SETQ *COMMON-LISP-SYMBOL-LOOKUP-TABLE* (NEW-STRING-HASH-TABLE))
  :VOID)

;;; (DEFGLOBAL *GENSYM-COUNTER* ...)

(CL:DEFVAR *GENSYM-COUNTER* 0
  "Incremented once for each gensym call.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *GENSYM-COUNTER*))

;;; (DEFGLOBAL *GENSYM-MASK* ...)

(CL:DEFVAR *GENSYM-MASK* "-000"
  "Defines the separator character for gensyms,
and the fill digits.")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *GENSYM-MASK*))

;;; (DEFUN (YIELD-GENSYM-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING CL:FIXNUM) CL:SIMPLE-STRING)
  YIELD-GENSYM-NAME))
(CL:DEFUN YIELD-GENSYM-NAME (PREFIX COUNTER)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PREFIX)
   (CL:TYPE CL:FIXNUM COUNTER))
  #+MCL
  (CL:CHECK-TYPE PREFIX CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE COUNTER CL:FIXNUM)
  (CL:LET*
   ((SUFFIX (INTEGER-TO-STRING (CL:TRUNCATE COUNTER)))
    (MASKEND (CL:- 4 (CL:THE CL:FIXNUM (CL:LENGTH SUFFIX)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SUFFIX)
    (CL:TYPE CL:FIXNUM MASKEND))
   (CL:WHEN (CL:< MASKEND 1) (CL:SETQ MASKEND 1))
   (CL:RETURN-FROM YIELD-GENSYM-NAME
    (CONCATENATE PREFIX (SUBSEQUENCE *GENSYM-MASK* 0 MASKEND) SUFFIX))))

;;; (DEFUN (YIELD-UNIQUE-GENSYM-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING CL:T) CL:SIMPLE-STRING)
  YIELD-UNIQUE-GENSYM-NAME))
(CL:DEFUN YIELD-UNIQUE-GENSYM-NAME (PREFIX MODULE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PREFIX))
  #+MCL
  (CL:CHECK-TYPE PREFIX CL:SIMPLE-STRING)
  (CL:LET*
   ((GENSYM-NAME
     (YIELD-GENSYM-NAME PREFIX
      (CL:SETQ *GENSYM-COUNTER* (CL:1+ *GENSYM-COUNTER*)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING GENSYM-NAME))
   (CL:LOOP WHILE
    (CL:NOT
     (CL:EQ (LOOKUP-SYMBOL-IN-MODULE GENSYM-NAME MODULE CL:NIL) NULL))
    DO
    (CL:SETQ GENSYM-NAME
     (YIELD-GENSYM-NAME PREFIX
      (CL:SETQ *GENSYM-COUNTER* (CL:1+ *GENSYM-COUNTER*)))))
   (CL:RETURN-FROM YIELD-UNIQUE-GENSYM-NAME GENSYM-NAME)))

;;; (DEFUN (GENSYM SYMBOL) ...)

(CL:DEFUN GENSYM (PREFIX)
  "Return a transient symbol with a name beginning with
`prefix' and ending with a globally gensym'd integer."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PREFIX))
  #+MCL
  (CL:CHECK-TYPE PREFIX CL:SIMPLE-STRING)
  (CL:RETURN-FROM GENSYM
   (INTERN-TRANSIENT-SYMBOL (YIELD-UNIQUE-GENSYM-NAME PREFIX *MODULE*))))

;;; (DEFUN (SURROGATE-TO-SYMBOL SYMBOL) ...)

(CL:DEFUN SURROGATE-TO-SYMBOL (SELF)
  (CL:RETURN-FROM SURROGATE-TO-SYMBOL
   (INTERN-SYMBOL-IN-MODULE (%SYMBOL-NAME SELF) *MODULE* CL:NIL)))

;;; (DEFUN (TYPE-TO-SYMBOL SYMBOL) ...)

(CL:DEFUN TYPE-TO-SYMBOL (TYPE)
  "Convert `type' into a symbol with the same name and module."
  (CL:RETURN-FROM TYPE-TO-SYMBOL
   (INTERN-SYMBOL-IN-MODULE (%SYMBOL-NAME TYPE) (%HOME-CONTEXT TYPE)
    CL:T)))

;;; (DEFUN (SYMBOLIZE SYMBOL) ...)

(CL:DEFUN SYMBOLIZE (SURROGATE)
  "Convert `surrogate' into a symbol with the same name and module."
  (CL:RETURN-FROM SYMBOLIZE
   (INTERN-SYMBOL-IN-MODULE (%SYMBOL-NAME SURROGATE)
    (%HOME-CONTEXT SURROGATE) CL:NIL)))

;;; (DEFUN (SYMBOL-TO-TYPE SURROGATE) ...)

(CL:DEFUN SYMBOL-TO-TYPE (SELF)
  "Convert `self' into a surrogate with the same name and module."
  (CL:RETURN-FROM SYMBOL-TO-TYPE
   (INTERN-SURROGATE-IN-MODULE (%SYMBOL-NAME SELF) (%HOME-CONTEXT SELF)
    CL:T)))

;;; (DEFUN (STRING-TO-SURROGATE SURROGATE) ...)

(CL:DEFUN STRING-TO-SURROGATE (SELF)
  "Return a surrogate with the name 'self' visible
in the current module.  Very tricky: The logic is designed to avoid
returning an inherited surrogate that has no value.  In that case,
a new local surrogate is created that shadows the inherited surrogate."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (CL:LET*
   ((SURROGATE (INTERN-SURROGATE-IN-MODULE SELF *MODULE* CL:NIL)))
   (CL:WHEN
    (CL:OR (CL:EQ (%HOME-CONTEXT SURROGATE) *MODULE*)
     (CL:NOT (CL:EQ (%SURROGATE-VALUE SURROGATE) NULL)))
    (CL:RETURN-FROM STRING-TO-SURROGATE SURROGATE))
   (CL:RETURN-FROM STRING-TO-SURROGATE
    (INTERN-SURROGATE-IN-MODULE SELF *MODULE* CL:T))))

;;; (DEFUN (SYMBOL-TO-SURROGATE SURROGATE) ...)

(CL:DEFUN SYMBOL-TO-SURROGATE (SELF)
  "Return a surrogate with the same name as 'self'.
Very tricky: The logic is designed to avoid returning an inherited surrogate
that has no value.  In that case, a new local surrogate is created that shadows
the inherited surrogate.  Unlike 'string-to-surrogate', the search starts first
from the home context of 'self', and if that fails, then it restarts in
*module*."
  (CL:LET*
   ((SURROGATE
     (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL-NAME SELF)
      (%HOME-CONTEXT SELF) CL:NIL)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ SURROGATE NULL))
     (CL:NOT (CL:EQ (%SURROGATE-VALUE SURROGATE) NULL)))
    (CL:RETURN-FROM SYMBOL-TO-SURROGATE SURROGATE))
   (CL:RETURN-FROM SYMBOL-TO-SURROGATE
    (STRING-TO-SURROGATE (%SYMBOL-NAME SELF)))))

;;; (DEFMETHOD (SURROGATIFY SURROGATE) ...)

(CL:DEFMETHOD SURROGATIFY ((SELF SURROGATE))
  "Converts 'self' into a surrogate."
  (CL:RETURN-FROM SURROGATIFY SELF))

;;; (DEFMETHOD (SURROGATIFY SURROGATE) ...)

(CL:DEFMETHOD SURROGATIFY ((SELF SYMBOL))
  "Converts 'self' into a surrogate (same semantics
as `symbol-to-surrogate' which see)."
  (CL:RETURN-FROM SURROGATIFY (SYMBOL-TO-SURROGATE SELF)))

;;; (DEFMETHOD (SURROGATIFY SURROGATE) ...)

(CL:DEFMETHOD SURROGATIFY ((SELF CL:STRING))
  "Converts 'self' into a surrogate."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (CL:RETURN-FROM SURROGATIFY (INTERN-SURROGATE SELF)))

;;; (DEFMETHOD (SURROGATIFY SURROGATE) ...)

(%%DEFCONSMETHOD SURROGATIFY ((SELF OBJECT))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
    "Don't know how to 'surrogatify' `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFUN (TYPIFY TYPE) ...)

(CL:DEFUN TYPIFY (SELF)
  (CL:RETURN-FROM TYPIFY (SURROGATIFY SELF)))

;;; (DEFMETHOD (KEYWORDIFY KEYWORD) ...)

(CL:DEFMETHOD KEYWORDIFY ((SELF KEYWORD))
  (CL:RETURN-FROM KEYWORDIFY SELF))

;;; (DEFMETHOD (KEYWORDIFY KEYWORD) ...)

(CL:DEFMETHOD KEYWORDIFY ((SELF GENERALIZED-SYMBOL))
  (CL:RETURN-FROM KEYWORDIFY (INTERN-KEYWORD (%SYMBOL-NAME SELF))))

;;; (DEFMETHOD (KEYWORDIFY KEYWORD) ...)

(CL:DEFMETHOD KEYWORDIFY ((SELF STRING-WRAPPER))
  (CL:RETURN-FROM KEYWORDIFY (INTERN-KEYWORD (%WRAPPER-VALUE SELF))))

;;; (DEFMETHOD (KEYWORDIFY KEYWORD) ...)

(CL:DEFMETHOD KEYWORDIFY ((SELF CL:STRING))
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (CL:RETURN-FROM KEYWORDIFY (INTERN-KEYWORD SELF)))

;;; (DEFUN IN-PLACE-OBJECTS-TO-SYMBOLS ...)

(CL:DEFUN IN-PLACE-OBJECTS-TO-SYMBOLS (CONSLIST)
  (CL:LET* ((CURSOR CONSLIST))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:SETF (%%VALUE CURSOR) (PERMANENTIFY (%%VALUE CURSOR)))
    (CL:SETQ CURSOR (%%REST CURSOR))))
  :VOID)

;;; (DEFUN IN-PLACE-OBJECTS-TO-TYPES ...)

(CL:DEFUN IN-PLACE-OBJECTS-TO-TYPES (CONSLIST)
  (CL:LET* ((CURSOR CONSLIST))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:SETF (%%VALUE CURSOR) (TYPIFY (%%VALUE CURSOR)))
    (CL:SETQ CURSOR (%%REST CURSOR))))
  :VOID)

;;; (DEFUN (SURROGATE-NAME? BOOLEAN) ...)

(CL:DEFUN SURROGATE-NAME? (NAME)
  "Return TRUE if name is prefixed by 'SURROGATE-PREFIX-CHARACTER'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM SURROGATE-NAME?
   (CL:AND (CL:> (CL:THE CL:FIXNUM (CL:LENGTH NAME)) 0)
    (CL:EQL
     (CL:LET ((SELF NAME) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION)))
     SURROGATE-PREFIX-CHARACTER))))

;;; (DEFUN (KEYWORD-NAME? BOOLEAN) ...)

(CL:DEFUN KEYWORD-NAME? (NAME)
  "Return TRUE if name is prefixed by ':'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM KEYWORD-NAME?
   (CL:AND (CL:> (CL:THE CL:FIXNUM (CL:LENGTH NAME)) 0)
    (CL:EQL
     (CL:LET ((SELF NAME) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION)))
     #\:))))

;;; (DEFUN (INTERN-STELLA-NAME GENERALIZED-SYMBOL) ...)

(CL:DEFUN INTERN-STELLA-NAME (NAME)
  "Parse `name' which is assumed to be the printed
representation of a STELLA symbol, surrogate or keyword, intern
it into the current or specified module and return the result.
This is identical to calling `unstringify' on `name' but 10-15
times faster."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((MODULE *MODULE*))
   (CL:LET*
    ((BARENAME STELLA::NULL-STRING) (MODULENAME STELLA::NULL-STRING)
     (KIND NULL))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BARENAME MODULENAME))
    (CL:MULTIPLE-VALUE-SETQ (BARENAME MODULENAME KIND)
     (PARSE-STELLA-NAME NAME CL:T))
    (CL:WHEN (CL:NOT (CL:EQ MODULENAME STELLA::NULL-STRING))
     (CL:SETQ MODULE (GET-STELLA-MODULE MODULENAME CL:T)))
    (CL:COND
     ((CL:EQ KIND KWD-SYMBOLS-SYMBOL)
      (CL:IF
       (CL:AND *TRANSIENTOBJECTS?*
        (CL:EQ MODULENAME STELLA::NULL-STRING))
       (CL:RETURN-FROM INTERN-STELLA-NAME
        (INTERN-TRANSIENT-SYMBOL BARENAME))
       (CL:RETURN-FROM INTERN-STELLA-NAME
        (INTERN-SYMBOL-IN-MODULE BARENAME MODULE CL:NIL))))
     ((CL:EQ KIND KWD-SYMBOLS-SURROGATE)
      (CL:RETURN-FROM INTERN-STELLA-NAME
       (INTERN-SURROGATE-IN-MODULE BARENAME MODULE CL:NIL)))
     ((CL:EQ KIND KWD-SYMBOLS-KEYWORD)
      (CL:RETURN-FROM INTERN-STELLA-NAME
       (INTERN-RIGID-SYMBOL-WRT-MODULE BARENAME NULL KEYWORD-SYM)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN (COMPUTE-FULL-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING CL:T) CL:SIMPLE-STRING)
  COMPUTE-FULL-NAME))
(CL:DEFUN COMPUTE-FULL-NAME (NAME MODULE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:COND
   ((CL:EQ MODULE NULL) (CL:RETURN-FROM COMPUTE-FULL-NAME NAME))
   ((STRING-EQL? NAME "")
    (CL:LET* ((PATHNAME ""))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PATHNAME))
     (CL:LOOP WHILE (CL:NOT (CL:EQ MODULE NULL)) DO
      (CL:SETQ PATHNAME
       (CONCATENATE MODULE-SEPARATOR-STRING (%MODULE-NAME MODULE)
        PATHNAME))
      (CL:SETQ MODULE (FIRST (%PARENT-MODULES MODULE))))
     (CL:RETURN-FROM COMPUTE-FULL-NAME PATHNAME)))
   (CL:T
    (CL:LET* ((MODULEFULLNAME (%MODULE-FULL-NAME MODULE)))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MODULEFULLNAME))
     (CL:WHEN (CL:EQ MODULEFULLNAME STELLA::NULL-STRING)
      (CL:SETQ MODULEFULLNAME (COMPUTE-FULL-NAME "" MODULE)))
     (CL:RETURN-FROM COMPUTE-FULL-NAME
      (CONCATENATE MODULEFULLNAME MODULE-SEPARATOR-STRING NAME))))))

;;; (DEFMETHOD (LOCAL-PRINT-NAME STRING) ...)

(CL:DEFMETHOD LOCAL-PRINT-NAME ((SELF GENERALIZED-SYMBOL) READABLE?)
  (CL:IF READABLE?
   (CL:RETURN-FROM LOCAL-PRINT-NAME
    (READABLE-SYMBOL-NAME (%SYMBOL-NAME SELF)
     (%CASE-SENSITIVE? *MODULE*)))
   (CL:RETURN-FROM LOCAL-PRINT-NAME (%SYMBOL-NAME SELF))))

;;; (DEFMETHOD (LOCAL-PRINT-NAME STRING) ...)

(CL:DEFMETHOD LOCAL-PRINT-NAME ((SELF SURROGATE) READABLE?)
  (CL:LET*
   ((LOCAL-NAME
     (CL:IF READABLE?
      (READABLE-SYMBOL-NAME (%SYMBOL-NAME SELF)
       (%CASE-SENSITIVE? *MODULE*))
      (%SYMBOL-NAME SELF))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LOCAL-NAME))
   (CL:RETURN-FROM LOCAL-PRINT-NAME (CONCATENATE "@" LOCAL-NAME))))

;;; (DEFMETHOD (RELATIVE-NAME STRING) ...)

(CL:DEFMETHOD RELATIVE-NAME ((SELF GENERALIZED-SYMBOL) READABLE?)
  (CL:LET* ((STRING STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
   (CL:IF (CL:EQ (%HOME-CONTEXT SELF) *MODULE*)
    (CL:SETQ STRING (LOCAL-PRINT-NAME SELF READABLE?))
    (CL:SETQ STRING
     (COMPUTE-FULL-NAME (LOCAL-PRINT-NAME SELF READABLE?)
      (%HOME-CONTEXT SELF))))
   (CL:WHEN (CL:= (%SYMBOL-ID SELF) -1)
    (CL:SETQ STRING (CONCATENATE "<<UNINTERNED>>/" STRING)))
   (CL:RETURN-FROM RELATIVE-NAME STRING)))

;;; (DEFUN (VISIBLE-SYMBOL? BOOLEAN) ...)

(CL:DEFUN VISIBLE-SYMBOL? (SELF)
  "Return `true' if `self' is visible from the current module."
  (CL:RETURN-FROM VISIBLE-SYMBOL?
   (CL:EQ SELF
    (LOOKUP-SYMBOL-IN-MODULE (%SYMBOL-NAME SELF) *MODULE* CL:NIL))))

;;; (DEFUN (VISIBLE-SURROGATE? BOOLEAN) ...)

(CL:DEFUN VISIBLE-SURROGATE? (SELF)
  "Return `true' if `self' is visible from the current module."
  (CL:RETURN-FROM VISIBLE-SURROGATE?
   (CL:EQ SELF
    (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL-NAME SELF) *MODULE* CL:NIL))))

;;; (DEFMETHOD (VISIBLE-NAME STRING) ...)

(CL:DEFMETHOD VISIBLE-NAME ((SELF GENERALIZED-SYMBOL) READABLE?)
  (CL:LET* ((VISIBLE? CL:NIL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ VISIBLE?
        (CL:EQ SELF
         (LOOKUP-SYMBOL-IN-MODULE (%SYMBOL-NAME SELF) *MODULE*
          CL:NIL)))))
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ VISIBLE?
        (CL:EQ SELF
         (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL-NAME SELF) *MODULE*
          CL:NIL)))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:IF VISIBLE?
    (CL:RETURN-FROM VISIBLE-NAME (LOCAL-PRINT-NAME SELF READABLE?))
    (CL:RETURN-FROM VISIBLE-NAME
     (COMPUTE-FULL-NAME (LOCAL-PRINT-NAME SELF READABLE?)
      (%HOME-CONTEXT SELF))))))

;;; (DEFUN (SYMBOL-VALUE OBJECT) ...)

(CL:DEFUN SYMBOL-VALUE (SYMBOL)
  "Return the value of `symbol'.  Note, that this value is not
visible to code that references a variable with the same name as `symbol'.
The `symbol-value' is simply a special property that can always be accessed
in constant time.  The `symbol-value' of a symbol can be changed with `setf'."
  (CL:RETURN-FROM SYMBOL-VALUE
   (%%VALUE (%SYMBOL-VALUE-AND-PLIST SYMBOL))))

;;; (DEFUN (SYMBOL-VALUE-SETTER OBJECT) ...)

(CL:DEFUN SYMBOL-VALUE-SETTER (SYMBOL VALUE)
  (CL:LET* ((VPLIST (%SYMBOL-VALUE-AND-PLIST SYMBOL)))
   (CL:WHEN (CL:EQ VPLIST NIL) (CL:SETQ VPLIST (CONS NULL NIL))
    (CL:SETF (%SYMBOL-VALUE-AND-PLIST SYMBOL) VPLIST))
   (CL:RETURN-FROM SYMBOL-VALUE-SETTER
    (CL:SETF (%%VALUE VPLIST) VALUE))))

;;; (DEFUN (SYMBOL-PLIST CONS) ...)

(CL:DEFUN SYMBOL-PLIST (SYMBOL)
  "Return the property list of `symbol'.  The `symbol-plist'
of a symbol can be set with `setf'.  IMPORTANT: Property list are modified 
destructively, hence, if you supply it as a whole make sure to always supply
a modfiable copy, e.g., by using `bquote'."
  (CL:RETURN-FROM SYMBOL-PLIST
   (%%REST (%SYMBOL-VALUE-AND-PLIST SYMBOL))))

;;; (DEFUN (SYMBOL-PLIST-SETTER CONS) ...)

(CL:DEFUN SYMBOL-PLIST-SETTER (SYMBOL PLIST)
  (CL:LET* ((VPLIST (%SYMBOL-VALUE-AND-PLIST SYMBOL)))
   (CL:WHEN (CL:EQ VPLIST NIL) (CL:SETQ VPLIST (CONS NULL NIL))
    (CL:SETF (%SYMBOL-VALUE-AND-PLIST SYMBOL) VPLIST))
   (CL:RETURN-FROM SYMBOL-PLIST-SETTER (CL:SETF (%%REST VPLIST) PLIST))))

;;; (DEFUN (SYMBOL-PROPERTY OBJECT) ...)

(CL:DEFUN SYMBOL-PROPERTY (SYMBOL KEY)
  "Return the property of `symbol' whose key is `eq?' to `key'.
Symbol properties can be set with `setf'."
  (CL:LET* ((PLIST (%%REST (%SYMBOL-VALUE-AND-PLIST SYMBOL))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ PLIST NIL)) DO
    (CL:WHEN (CL:EQ (%%VALUE PLIST) KEY)
     (CL:RETURN-FROM SYMBOL-PROPERTY (%%VALUE (%%REST PLIST))))
    (CL:SETQ PLIST (%%REST (%%REST PLIST))))
   (CL:RETURN-FROM SYMBOL-PROPERTY NULL)))

;;; (DEFUN (SYMBOL-PROPERTY-SETTER OBJECT) ...)

(CL:DEFUN SYMBOL-PROPERTY-SETTER (SYMBOL VALUE KEY)
  (CL:LET*
   ((VPLIST (%SYMBOL-VALUE-AND-PLIST SYMBOL)) (PLIST (%%REST VPLIST)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ PLIST NIL)) DO
    (CL:WHEN (CL:EQ (%%VALUE PLIST) KEY)
     (CL:COND
      ((CL:NOT (CL:EQ VALUE NULL))
       (CL:SETF (%%VALUE (%%REST PLIST)) VALUE))
      ((CL:NOT (CL:EQ (%%REST (%%REST PLIST)) NIL))
       (CL:LET* ((RESTPLIST (%%REST PLIST)))
        (CL:SETF (%%VALUE PLIST) (%%VALUE (%%REST RESTPLIST)))
        (CL:SETF (%%REST PLIST) (%%REST (%%REST RESTPLIST)))))
      ((CL:EQ PLIST (%%REST VPLIST)) (CL:SETF (%%REST VPLIST) NIL))
      (CL:T (CL:SETF (%%VALUE (%%REST PLIST)) VALUE)))
     (CL:RETURN-FROM SYMBOL-PROPERTY-SETTER VALUE))
    (CL:SETQ PLIST (%%REST (%%REST PLIST))))
   (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
    (CL:WHEN (CL:EQ VPLIST NIL) (CL:SETQ VPLIST (CONS NULL NIL))
     (CL:SETF (%SYMBOL-VALUE-AND-PLIST SYMBOL) VPLIST))
    (CL:SETF (%%REST VPLIST) (CONS KEY (CONS VALUE (%%REST VPLIST)))))
   (CL:RETURN-FROM SYMBOL-PROPERTY-SETTER VALUE)))

;;; (DEFUN (SYMBOL-CONSTITUENT-CHARACTER? BOOLEAN) ...)

(CL:DEFUN SYMBOL-CONSTITUENT-CHARACTER? (CHARACTER)
  (CL:LET*
   ((TEST-VALUE-000
     (CL:AREF *CHARACTER-TYPE-TABLE*
      (CL:THE CL:FIXNUM (CL:CHAR-CODE CHARACTER)))))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-SYMBOLS-LETTER)
      (CL:EQ TEST-VALUE-000 KWD-SYMBOLS-DIGIT)
      (CL:EQ TEST-VALUE-000 KWD-SYMBOLS-SYMBOL-CONSTITUENT))
     (CL:RETURN-FROM SYMBOL-CONSTITUENT-CHARACTER? CL:T))
    (CL:T (CL:RETURN-FROM SYMBOL-CONSTITUENT-CHARACTER? CL:NIL)))))

;;; (DEFGLOBAL *SYMBOL-ESCAPE-CODE-TABLE* ...)

(CL:DEFVAR *SYMBOL-ESCAPE-CODE-TABLE* STELLA::NULL-STRING)
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *SYMBOL-ESCAPE-CODE-TABLE*))

;;; (DEFGLOBAL *CASE-SENSITIVE-SYMBOL-ESCAPE-CODE-TABLE* ...)

(CL:DEFVAR *CASE-SENSITIVE-SYMBOL-ESCAPE-CODE-TABLE* STELLA::NULL-STRING)
(CL:DECLAIM
 (CL:TYPE CL:SIMPLE-STRING *CASE-SENSITIVE-SYMBOL-ESCAPE-CODE-TABLE*))

;;; (DEFUN (INITIALIZE-SYMBOL-ESCAPE-CODE-TABLE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  INITIALIZE-SYMBOL-ESCAPE-CODE-TABLE))
(CL:DEFUN INITIALIZE-SYMBOL-ESCAPE-CODE-TABLE (CASESENSITIVE?)
  (CL:LET*
   ((BUFFER
     (CL:THE CL:SIMPLE-STRING
      (CL:MAKE-STRING 256 :INITIAL-ELEMENT NULL-CHARACTER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BUFFER))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 255))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:LET* ((TEST-VALUE-000 (CL:AREF *CHARACTER-TYPE-TABLE* I)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-SYMBOLS-DIGIT)
        (CL:LET ((SELF BUFFER) (CH (CL:CODE-CHAR 1)) (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (SETF
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))
          (CL:THE CL:CHARACTER CH))))
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-SYMBOLS-LETTER)
         (CL:EQ TEST-VALUE-000 KWD-SYMBOLS-SYMBOL-CONSTITUENT))
        (CL:IF
         (CL:AND (CL:NOT CASESENSITIVE?)
          (LOWER-CASE-CHARACTER? (CL:CODE-CHAR I)))
         (CL:LET ((SELF BUFFER) (CH (CL:CODE-CHAR 2)) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (SETF
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))
           (CL:THE CL:CHARACTER CH)))
         (CL:LET ((SELF BUFFER) (CH (CL:CODE-CHAR 0)) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (SETF
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
            (CL:THE CL:FIXNUM POSITION))
           (CL:THE CL:CHARACTER CH)))))
       (CL:T
        (CL:LET ((SELF BUFFER) (CH (CL:CODE-CHAR 2)) (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (SETF
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))
          (CL:THE CL:CHARACTER CH))))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((CH NULL-CHARACTER) (VECTOR-000 ".+-") (INDEX-000 0)
     (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ CH
      (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))))
     (CL:LET
      ((SELF BUFFER) (CH (CL:CODE-CHAR 1))
       (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (SETF
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))
       (CL:THE CL:CHARACTER CH)))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET
    ((SELF BUFFER) (CH (CL:CODE-CHAR 3))
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\\))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (SETF
     (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
      (CL:THE CL:FIXNUM POSITION))
     (CL:THE CL:CHARACTER CH)))
   (CL:LET
    ((SELF BUFFER) (CH (CL:CODE-CHAR 3))
     (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE #\|))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
     (CL:TYPE CL:FIXNUM POSITION))
    (SETF
     (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
      (CL:THE CL:FIXNUM POSITION))
     (CL:THE CL:CHARACTER CH)))
   (CL:RETURN-FROM INITIALIZE-SYMBOL-ESCAPE-CODE-TABLE
    (CL:LET ((S BUFFER)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
     (CL:THE CL:SIMPLE-STRING S)))))

;;; (DEFUN (COMPUTE-SYMBOL-ESCAPE-CODE KEYWORD) ...)

(CL:DEFUN COMPUTE-SYMBOL-ESCAPE-CODE (NAME CASESENSITIVE?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((TABLE
     (CL:IF CASESENSITIVE? *CASE-SENSITIVE-SYMBOL-ESCAPE-CODE-TABLE*
      *SYMBOL-ESCAPE-CODE-TABLE*))
    (ESCAPECODE 0) (MAXESCAPECODE 0) (FIRSTCHAR? CL:T)
    (COULDBENUMBER? CL:T))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TABLE)
    (CL:TYPE CL:FIXNUM ESCAPECODE MAXESCAPECODE))
   (CL:LET*
    ((CH NULL-CHARACTER) (VECTOR-000 NAME) (INDEX-000 0)
     (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ CH
      (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
        (CL:THE CL:FIXNUM POSITION))))
     (CL:SETQ ESCAPECODE
      (CL:THE CL:FIXNUM
       (CL:CHAR-CODE
        (CL:LET
         ((SELF TABLE) (POSITION (CL:THE CL:FIXNUM (CL:CHAR-CODE CH))))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))))
     (CL:COND
      ((CL:= ESCAPECODE 0)
       (CL:WHEN
        (CL:AND COULDBENUMBER? (CL:NOT (CL:EQL CH #\E))
         (CL:NOT (CL:EQL CH #\e)))
        (CL:SETQ COULDBENUMBER? CL:NIL)))
      (FIRSTCHAR? (CL:SETQ MAXESCAPECODE ESCAPECODE)
       (CL:SETQ COULDBENUMBER? (CL:= ESCAPECODE 1)))
      (CL:T
       (CL:WHEN
        (CL:AND (CL:> ESCAPECODE 1) (CL:> ESCAPECODE MAXESCAPECODE))
        (CL:SETQ MAXESCAPECODE ESCAPECODE))))
     (CL:SETQ FIRSTCHAR? CL:NIL)
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:IF FIRSTCHAR?
    (CL:RETURN-FROM COMPUTE-SYMBOL-ESCAPE-CODE KWD-SYMBOLS-ESCAPED)
    (CL:ECASE MAXESCAPECODE
     (0
      (CL:RETURN-FROM COMPUTE-SYMBOL-ESCAPE-CODE
       KWD-SYMBOLS-UNESCAPED))
     (1
      (CL:WHEN COULDBENUMBER?
       (CL:LET*
        ((TOK_TABLE_ *STELLA-TOKENIZER-TABLE*)
         (TOK_TRANSITIONS_ (%TRANSITIONS TOK_TABLE_))
         (TOK_STATENAMES_ (%THE-ARRAY (%STATE-NAMES TOK_TABLE_)))
         (TOK_TOKENSTART_ -1) (TOK_ENDOFTOKENS?_ CL:NIL)
         (TOK_STREAMSTATE_ NULL)
         (TOK_BUFFER_
          (CL:LET ((STRING NAME))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING)) STRING))
         (TOK_STATE_ 1) (TOK_NEXTSTATE_ TOK_STATE_) (TOK_CURSOR_ 0)
         (TOK_SIZE_ (CL:THE CL:FIXNUM (CL:LENGTH NAME)))
         (TOK_END_ TOK_SIZE_))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOK_TRANSITIONS_)
         (CL:TYPE CL:SIMPLE-VECTOR TOK_STATENAMES_)
         (CL:TYPE CL:FIXNUM TOK_TOKENSTART_ TOK_STATE_ TOK_NEXTSTATE_
          TOK_CURSOR_ TOK_SIZE_ TOK_END_))
        (CL:PROGN (CL:SETQ TOK_STATENAMES_ TOK_STATENAMES_)
         (CL:SETQ TOK_ENDOFTOKENS?_ TOK_ENDOFTOKENS?_))
        (CL:SETQ TOK_STREAMSTATE_ TOK_STREAMSTATE_)
        (CL:LET*
         ((TOK_STELLALOGICALSTATENAMES_
           (%THE-ARRAY *STELLA-LOGICAL-STATE-NAMES*))
          (TOK_STELLALOGICALSTATENAME_ NULL))
         (CL:DECLARE
          (CL:TYPE CL:SIMPLE-VECTOR TOK_STELLALOGICALSTATENAMES_))
         (CL:PROGN
          (CL:PROGN (CL:SETQ TOK_TOKENSTART_ -1)
           (CL:LOOP
            (CL:WHEN (CL:= TOK_CURSOR_ TOK_END_)
             (CL:COND
              ((CL:= TOK_NEXTSTATE_ -1)
               (CL:SETQ TOK_ENDOFTOKENS?_ CL:T))
              ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
                (CL:AREF
                 (CL:THE CL:SIMPLE-VECTOR
                  (%THE-ARRAY (%LEGAL-EOF-STATES TOK_TABLE_)))
                 TOK_STATE_))
               (CL:SETQ TOK_NEXTSTATE_ -1)
               (CL:WHEN (CL:= TOK_TOKENSTART_ -1)
                (CL:SETQ TOK_ENDOFTOKENS?_ CL:T)))
              (CL:T (CL:SETQ TOK_STATE_ 0)
               (CL:SETQ TOK_NEXTSTATE_ -1)))
             (CL:RETURN))
            (CL:SETQ TOK_NEXTSTATE_
             (CL:THE CL:FIXNUM
              (CL:CHAR-CODE
               (CL:LET ((BUFFER TOK_BUFFER_) (POSITION TOK_CURSOR_))
                (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
                (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
                 (CL:THE CL:FIXNUM POSITION))))))
            (CL:WHEN (CL:> TOK_NEXTSTATE_ 255)
             (CL:SETQ TOK_NEXTSTATE_ 255))
            (CL:SETQ TOK_NEXTSTATE_
             (CL:THE CL:FIXNUM
              (CL:CHAR-CODE
               (CL:LET
                ((SELF TOK_TRANSITIONS_)
                 (POSITION
                  (CL:THE CL:FIXNUM
                   (CL:LOGIOR (CL:THE CL:FIXNUM (CL:ASH TOK_STATE_ 8))
                    TOK_NEXTSTATE_))))
                (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
                 (CL:TYPE CL:FIXNUM POSITION))
                (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                 (CL:THE CL:FIXNUM POSITION))))))
            (CL:COND
             ((CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 128))
               0)
              (CL:SETQ TOK_STATE_ TOK_NEXTSTATE_)
              (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
             ((CL:= TOK_TOKENSTART_ -1)
              (CL:WHEN
               (CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 64))
                0)
               (CL:SETQ TOK_TOKENSTART_ TOK_CURSOR_))
              (CL:SETQ TOK_STATE_
               (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 63)))
              (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
             (CL:T (CL:RETURN))))
           (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
            (CL:SETF (%CURSOR TOK_STREAMSTATE_) TOK_CURSOR_)
            (CL:SETF (%TABLE TOK_STREAMSTATE_) TOK_TABLE_)
            (CL:SETF (%STATE TOK_STREAMSTATE_) TOK_STATE_)))
          (CL:SETQ TOK_STELLALOGICALSTATENAME_
           (CL:AREF TOK_STELLALOGICALSTATENAMES_ TOK_STATE_)))
         (CL:WHEN
          (CL:EQ TOK_STELLALOGICALSTATENAME_ KWD-SYMBOLS-SYMBOL)
          (CL:SETQ COULDBENUMBER? CL:NIL)))))
      (CL:IF COULDBENUMBER?
       (CL:RETURN-FROM COMPUTE-SYMBOL-ESCAPE-CODE KWD-SYMBOLS-ESCAPED)
       (CL:RETURN-FROM COMPUTE-SYMBOL-ESCAPE-CODE
        KWD-SYMBOLS-UNESCAPED)))
     (2
      (CL:IF
       (CL:AND
        (CL:EQL
         (CL:LET ((SELF NAME) (POSITION 0))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION)))
         #\/)
        (STRING-EQL? NAME "/"))
       (CL:RETURN-FROM COMPUTE-SYMBOL-ESCAPE-CODE
        KWD-SYMBOLS-UNESCAPED)
       (CL:RETURN-FROM COMPUTE-SYMBOL-ESCAPE-CODE
        KWD-SYMBOLS-ESCAPED)))
     (3
      (CL:RETURN-FROM COMPUTE-SYMBOL-ESCAPE-CODE
       KWD-SYMBOLS-COMPLEX-ESCAPED))))))

;;; (DEFUN PRINT-SYMBOL-NAME-READABLY ...)

(CL:DEFUN PRINT-SYMBOL-NAME-READABLY (NAME STREAM CASESENSITIVE?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((TEST-VALUE-000 (COMPUTE-SYMBOL-ESCAPE-CODE NAME CASESENSITIVE?)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-SYMBOLS-UNESCAPED)
     (%%PRINT-STREAM STREAM NAME))
    ((CL:EQ TEST-VALUE-000 KWD-SYMBOLS-ESCAPED)
     (%%PRINT-STREAM STREAM "|" NAME "|"))
    ((CL:EQ TEST-VALUE-000 KWD-SYMBOLS-COMPLEX-ESCAPED)
     (%%PRINT-STREAM STREAM "|")
     (CL:LET*
      ((CH NULL-CHARACTER) (VECTOR-000 NAME) (INDEX-000 0)
       (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
       (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ CH
        (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
          (CL:THE CL:FIXNUM POSITION))))
       (CL:WHEN (CL:OR (CL:EQL CH #\\) (CL:EQL CH #\|))
        (%%PRINT-STREAM STREAM "\\"))
       (%%PRINT-STREAM STREAM CH)
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (%%PRINT-STREAM STREAM "|"))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
  :VOID)

;;; (DEFUN (READABLE-SYMBOL-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING CL:T) CL:SIMPLE-STRING)
  READABLE-SYMBOL-NAME))
(CL:DEFUN READABLE-SYMBOL-NAME (NAME CASESENSITIVE?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((TEST-VALUE-000 (COMPUTE-SYMBOL-ESCAPE-CODE NAME CASESENSITIVE?)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-SYMBOLS-UNESCAPED)
     (CL:RETURN-FROM READABLE-SYMBOL-NAME NAME))
    ((CL:EQ TEST-VALUE-000 KWD-SYMBOLS-ESCAPED)
     (CL:RETURN-FROM READABLE-SYMBOL-NAME (CONCATENATE "|" NAME "|")))
    ((CL:EQ TEST-VALUE-000 KWD-SYMBOLS-COMPLEX-ESCAPED)
     (CL:LET* ((S (NEW-OUTPUT-STRING-STREAM)))
      (PRINT-SYMBOL-NAME-READABLY NAME (%NATIVE-STREAM S)
       CASESENSITIVE?)
      (CL:RETURN-FROM READABLE-SYMBOL-NAME (THE-STRING-READER S))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN PRINT-SYMBOL ...)

(CL:DEFUN PRINT-SYMBOL (SELF STREAM)
  (CL:LET*
   ((VISIBLE?
     (CL:EQ SELF
      (LOOKUP-SYMBOL-IN-MODULE (%SYMBOL-NAME SELF) *MODULE* CL:NIL)))
    (MODULE (%HOME-CONTEXT SELF)))
   (CL:WHEN (CL:NOT VISIBLE?)
    (CL:IF (CL:= (%SYMBOL-ID SELF) -1)
     (%%PRINT-STREAM STREAM "<<UNINTERNED>>/")
     (CL:WHEN (CL:NOT (CL:EQ MODULE NULL))
      (CL:IF
       (CL:AND *PRINTREADABLY?* (CL:EQ MODULE *COMMON-LISP-MODULE*))
       (CL:PROGN (%%PRINT-STREAM STREAM "CL:" (%SYMBOL-NAME SELF))
        (CL:RETURN-FROM PRINT-SYMBOL))
       (%%PRINT-STREAM STREAM (%MODULE-FULL-NAME MODULE) "/")))))
   (CL:IF *PRINTREADABLY?*
    (PRINT-SYMBOL-NAME-READABLY (%SYMBOL-NAME SELF) STREAM
     (%CASE-SENSITIVE? *MODULE*))
    (%%PRINT-STREAM STREAM (%SYMBOL-NAME SELF))))
  :VOID)

;;; (DEFUN PRINT-SURROGATE ...)

(CL:DEFUN PRINT-SURROGATE (SELF STREAM)
  (CL:LET*
   ((VISIBLE?
     (CL:EQ SELF
      (LOOKUP-SURROGATE-IN-MODULE (%SYMBOL-NAME SELF) *MODULE*
       CL:NIL)))
    (MODULE (%HOME-CONTEXT SELF)))
   (CL:WHEN (CL:NOT VISIBLE?)
    (CL:IF (CL:OR (CL:= (%SYMBOL-ID SELF) -1) (CL:EQ MODULE NULL))
     (%%PRINT-STREAM STREAM "<<UNINTERNED>>/")
     (%%PRINT-STREAM STREAM (%MODULE-FULL-NAME MODULE) "/")))
   (%%PRINT-STREAM STREAM "@")
   (CL:IF *PRINTREADABLY?*
    (PRINT-SYMBOL-NAME-READABLY (%SYMBOL-NAME SELF) STREAM
     (%CASE-SENSITIVE? *MODULE*))
    (%%PRINT-STREAM STREAM (%SYMBOL-NAME SELF))))
  :VOID)

;;; (DEFUN PRINT-KEYWORD ...)

(CL:DEFUN PRINT-KEYWORD (SELF STREAM)
  (%%PRINT-STREAM STREAM ":")
  (CL:IF *PRINTREADABLY?*
   (PRINT-SYMBOL-NAME-READABLY (%SYMBOL-NAME SELF) STREAM CL:NIL)
   (%%PRINT-STREAM STREAM (%SYMBOL-NAME SELF)))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYMBOLS1 ()
  (CL:PROGN
   (CL:SETQ SYM-SYMBOLS-STELLA-MODULE-LISP-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-LISP-PACKAGE" NULL 0))
   (CL:SETQ SYM-SYMBOLS-STELLA-JAVA-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-PACKAGE" NULL 0))
   (CL:SETQ SYM-SYMBOLS-STELLA-MODULE-CPP-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-CPP-PACKAGE" NULL 0))
   (CL:SETQ SYM-SYMBOLS-STELLA-CODE-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CODE-ONLY?" NULL 0))
   (CL:SETQ KWD-SYMBOLS-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 2))
   (CL:SETQ KWD-SYMBOLS-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE" NULL 2))
   (CL:SETQ KWD-SYMBOLS-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" NULL 2))
   (CL:SETQ KWD-SYMBOLS-LETTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LETTER" NULL 2))
   (CL:SETQ KWD-SYMBOLS-DIGIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIGIT" NULL 2))
   (CL:SETQ KWD-SYMBOLS-SYMBOL-CONSTITUENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-CONSTITUENT" NULL 2))
   (CL:SETQ KWD-SYMBOLS-ESCAPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ESCAPED" NULL 2))
   (CL:SETQ KWD-SYMBOLS-UNESCAPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNESCAPED" NULL 2))
   (CL:SETQ KWD-SYMBOLS-COMPLEX-ESCAPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEX-ESCAPED" NULL 2))
   (CL:SETQ SYM-SYMBOLS-STELLA-STARTUP-SYMBOLS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-SYMBOLS" NULL 0))
   (CL:SETQ SYM-SYMBOLS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYMBOLS2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "NEXT-FREE-OFFSET"
    "(DEFUN (NEXT-FREE-OFFSET INTEGER) ((SELF EXTENSIBLE-SYMBOL-ARRAY)))"
    (CL:FUNCTION NEXT-FREE-OFFSET) NULL)
   (DEFINE-FUNCTION-OBJECT "FREE-SYMBOL-OFFSET"
    "(DEFUN FREE-SYMBOL-OFFSET ((SELF EXTENSIBLE-SYMBOL-ARRAY) (OFFSET INTEGER)))"
    (CL:FUNCTION FREE-SYMBOL-OFFSET) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-TO-SYMBOL-ARRAY-AT"
    "(DEFUN ADD-TO-SYMBOL-ARRAY-AT ((ARRAY EXTENSIBLE-SYMBOL-ARRAY) (OFFSET INTEGER) (SYMBOL GENERALIZED-SYMBOL)))"
    (CL:FUNCTION ADD-TO-SYMBOL-ARRAY-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-TO-SYMBOL-ARRAY"
    "(DEFUN (ADD-TO-SYMBOL-ARRAY INTEGER) ((ARRAY EXTENSIBLE-SYMBOL-ARRAY) (SYMBOL GENERALIZED-SYMBOL)))"
    (CL:FUNCTION ADD-TO-SYMBOL-ARRAY) NULL)
   (DEFINE-FUNCTION-OBJECT "LEGAL-SYMBOL-ARRAY-OFFSET?"
    "(DEFUN (LEGAL-SYMBOL-ARRAY-OFFSET? BOOLEAN) ((ARRAY EXTENSIBLE-SYMBOL-ARRAY) (OFFSET INTEGER)))"
    (CL:FUNCTION LEGAL-SYMBOL-ARRAY-OFFSET?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SYM"
    "(DEFUN (GET-SYM SYMBOL) ((OFFSET INTEGER)) :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION GET-SYM) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SGT"
    "(DEFUN (GET-SGT SURROGATE) ((OFFSET INTEGER)) :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION GET-SGT) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-KWD"
    "(DEFUN (GET-KWD KEYWORD) ((OFFSET INTEGER)) :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION GET-KWD) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-GENERALIZED-SYMBOL-FROM-OFFSET"
    "(DEFUN (GET-GENERALIZED-SYMBOL-FROM-OFFSET GENERALIZED-SYMBOL) ((SYMBOLARRAY EXTENSIBLE-SYMBOL-ARRAY) (OFFSET INTEGER)) :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION GET-GENERALIZED-SYMBOL-FROM-OFFSET) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SYM-FROM-OFFSET"
    "(DEFUN (GET-SYM-FROM-OFFSET SYMBOL) ((OFFSET INTEGER)) :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION GET-SYM-FROM-OFFSET) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SGT-FROM-OFFSET"
    "(DEFUN (GET-SGT-FROM-OFFSET SURROGATE) ((OFFSET INTEGER)) :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION GET-SGT-FROM-OFFSET) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-KWD-FROM-OFFSET"
    "(DEFUN (GET-KWD-FROM-OFFSET KEYWORD) ((OFFSET INTEGER)) :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION GET-KWD-FROM-OFFSET) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-SYMBOL-OFFSET-TABLE"
    "(DEFUN (SELECT-SYMBOL-OFFSET-TABLE STRING-TO-INTEGER-HASH-TABLE) ((MODULE MODULE) (KINDOFSYM INTEGER)))"
    (CL:FUNCTION SELECT-SYMBOL-OFFSET-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-SYMBOL-ARRAY"
    "(DEFUN (SELECT-SYMBOL-ARRAY EXTENSIBLE-SYMBOL-ARRAY) ((KINDOFSYM INTEGER)))"
    (CL:FUNCTION SELECT-SYMBOL-ARRAY) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-RIGID-SYMBOL-LOCALLY"
    "(DEFUN (LOOKUP-RIGID-SYMBOL-LOCALLY GENERALIZED-SYMBOL) ((NAME STRING) (MODULE MODULE) (KINDOFSYM INTEGER)) :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION LOOKUP-RIGID-SYMBOL-LOCALLY) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-VISIBLE-RIGID-SYMBOLS-WRT-MODULE"
    "(DEFUN (YIELD-VISIBLE-RIGID-SYMBOLS-WRT-MODULE (CONS OF GENERALIZED-SYMBOL)) ((NAME STRING) (MODULE MODULE) (KINDOFSYM INTEGER)))"
    (CL:FUNCTION YIELD-VISIBLE-RIGID-SYMBOLS-WRT-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "VISIBLE-RIGID-SYMBOLS-WRT-MODULE"
    "(DEFUN (VISIBLE-RIGID-SYMBOLS-WRT-MODULE (ITERATOR OF GENERALIZED-SYMBOL)) ((NAME STRING) (MODULE MODULE) (KINDOFSYM INTEGER)))"
    (CL:FUNCTION VISIBLE-RIGID-SYMBOLS-WRT-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-SHADOWED-SYMBOLS"
    "(DEFUN (REMOVE-SHADOWED-SYMBOLS (CONS OF GENERALIZED-SYMBOL)) ((VISIBLESYMBOLS (CONS OF GENERALIZED-SYMBOL))))"
    (CL:FUNCTION REMOVE-SHADOWED-SYMBOLS) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-RIGID-SYMBOL-OFFSET-WRT-MODULE"
    "(DEFUN (LOOKUP-RIGID-SYMBOL-OFFSET-WRT-MODULE INTEGER) ((NAME STRING) (MODULE MODULE) (KINDOFSYM INTEGER)))"
    (CL:FUNCTION LOOKUP-RIGID-SYMBOL-OFFSET-WRT-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-RIGID-SYMBOL-WRT-MODULE"
    "(DEFUN (LOOKUP-RIGID-SYMBOL-WRT-MODULE GENERALIZED-SYMBOL) ((NAME STRING) (MODULE MODULE) (KINDOFSYM INTEGER)))"
    (CL:FUNCTION LOOKUP-RIGID-SYMBOL-WRT-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-RIGID-SYMBOL"
    "(DEFUN (LOOKUP-RIGID-SYMBOL GENERALIZED-SYMBOL) ((NAME STRING) (KINDOFSYM INTEGER)) :DOCUMENTATION \"Return the permanent symbol with name 'name' and type
`kindOfSym' visible from the current module (case-sensitive).\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION LOOKUP-RIGID-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-SYMBOL"
    "(DEFUN (LOOKUP-SYMBOL SYMBOL) ((NAME STRING)) :DOCUMENTATION \"Return the first symbol with `name' visible from the current module.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION LOOKUP-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-SYMBOL-IN-MODULE"
    "(DEFUN (LOOKUP-SYMBOL-IN-MODULE SYMBOL) ((NAME STRING) (MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Return the first symbol with `name' visible from `module'.
If `local?' only consider symbols directly interned in `module'.
If `module' is `null', use `*MODULE*' instead.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION LOOKUP-SYMBOL-IN-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-VISIBLE-SYMBOLS-IN-MODULE"
    "(DEFUN (LOOKUP-VISIBLE-SYMBOLS-IN-MODULE (CONS OF SYMBOL)) ((NAME STRING) (MODULE MODULE) (ENFORCESHADOWING? BOOLEAN)) :DOCUMENTATION \"Return the list of symbols with `name' visible from `module'.
More specific symbols (relative to the module precedence order defined by
`visible-modules') come earlier in the list.  If `module' is `null', start
from `*MODULE*' instead.  If `enforceShadowing?' is true, do not return any
symbols that are shadowed due to some :SHADOW declaration.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-VISIBLE-SYMBOLS-IN-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-SURROGATE"
    "(DEFUN (LOOKUP-SURROGATE SURROGATE) ((NAME STRING)) :DOCUMENTATION \"Return the first surrogate with `name' visible from the current module.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION LOOKUP-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-SURROGATE-IN-MODULE"
    "(DEFUN (LOOKUP-SURROGATE-IN-MODULE SURROGATE) ((NAME STRING) (MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Return the first surrogate with `name' visible from `module'.
If `local?' only consider surrogates directly interned in `module'.
If `module' is `null', use `*MODULE*' instead.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION LOOKUP-SURROGATE-IN-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-VISIBLE-SURROGATES-IN-MODULE"
    "(DEFUN (LOOKUP-VISIBLE-SURROGATES-IN-MODULE (CONS OF SURROGATE)) ((NAME STRING) (MODULE MODULE) (ENFORCESHADOWING? BOOLEAN)) :DOCUMENTATION \"Return the list of surrogates with `name' visible from `module'.
More specific surrogates (relative to the module precedence order defined by
`visible-modules') come earlier in the list.  If `module' is `null', start
from `*MODULE*' instead.  If `enforceShadowing?' is true, do not return any
surrogates that are shadowed due to some :SHADOW declaration.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-VISIBLE-SURROGATES-IN-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-KEYWORD"
    "(DEFUN (LOOKUP-KEYWORD KEYWORD) ((NAME STRING)) :DOCUMENTATION \"Return the keyword with `name' if it exists.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION LOOKUP-KEYWORD) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-INTERN-GENERALIZED-SYMBOL"
    "(DEFUN (HELP-INTERN-GENERALIZED-SYMBOL GENERALIZED-SYMBOL) ((NAME STRING) (KINDOFSYM INTEGER) (ARRAY EXTENSIBLE-SYMBOL-ARRAY) (OFFSET INTEGER) (MODULE MODULE)) :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION HELP-INTERN-GENERALIZED-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-RIGID-SYMBOL-WRT-MODULE"
    "(DEFUN (INTERN-RIGID-SYMBOL-WRT-MODULE GENERALIZED-SYMBOL) ((NAME STRING) (MODULE MODULE) (KINDOFSYM INTEGER)) :PUBLIC? TRUE :CONSTRUCTOR? TRUE :DOCUMENTATION \"Return a newly-created or existing rigid symbol with
name `name'.\")" (CL:FUNCTION INTERN-RIGID-SYMBOL-WRT-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-RIGID-SYMBOL-LOCALLY"
    "(DEFUN (INTERN-RIGID-SYMBOL-LOCALLY GENERALIZED-SYMBOL) ((NAME STRING) (MODULE MODULE) (KINDOFSYM INTEGER)) :PUBLIC? TRUE :CONSTRUCTOR? TRUE :DOCUMENTATION \"Return a newly-created or existing rigid symbol
interned into the module `module' with name `name'.\")"
    (CL:FUNCTION INTERN-RIGID-SYMBOL-LOCALLY) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-RIGID-SYMBOL-CASE-SENSITIVELY"
    "(DEFUN (INTERN-RIGID-SYMBOL-CASE-SENSITIVELY GENERALIZED-SYMBOL) ((NAME STRING) (KINDOFSYM INTEGER) (TRYUPCASING? BOOLEAN)) :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION INTERN-RIGID-SYMBOL-CASE-SENSITIVELY) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-PERMANENT-SYMBOL"
    "(DEFUN (INTERN-PERMANENT-SYMBOL SYMBOL) ((NAME STRING)) :PUBLIC? TRUE :CONSTRUCTOR? TRUE :DOCUMENTATION \"Return a newly-created or existing permanent symbol with
name `name'.\")" (CL:FUNCTION INTERN-PERMANENT-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-SYMBOL"
    "(DEFUN (INTERN-SYMBOL SYMBOL) ((NAME STRING)) :DOCUMENTATION \"Return a newly-created or existing symbol with name `name'.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION INTERN-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-SYMBOL-IN-MODULE"
    "(DEFUN (INTERN-SYMBOL-IN-MODULE SYMBOL) ((NAME STRING) (MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Look for a symbol named `name' in `module' (if `local?' do
not consider inherited modules).  If none exists, intern it locally in
`module'.  Return the existing or newly-created symbol.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION INTERN-SYMBOL-IN-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-DERIVED-SYMBOL"
    "(DEFUN (INTERN-DERIVED-SYMBOL SYMBOL) ((BASESYMBOL GENERALIZED-SYMBOL) (NEWNAME STRING)) :PUBLIC? TRUE :CONSTRUCTOR? TRUE :DOCUMENTATION \"Return a newly-created or existing symbol with name
`newName' which is interned in the same module as `baseSymbol'.\")"
    (CL:FUNCTION INTERN-DERIVED-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-SURROGATE"
    "(DEFUN (INTERN-SURROGATE SURROGATE) ((NAME STRING)) :DOCUMENTATION \"Return a newly-created or existing surrogate with name `name'.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION INTERN-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-SURROGATE-IN-MODULE"
    "(DEFUN (INTERN-SURROGATE-IN-MODULE SURROGATE) ((NAME STRING) (MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Look for a symbol named `name' in `module' (if `local?' do
not consider inherited modules).  If none exists, intern it locally in
`module'.  Return the existing or newly-created symbol.\" :PUBLIC? TRUE :CONSTRUCTOR? TRUE)"
    (CL:FUNCTION INTERN-SURROGATE-IN-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-DERIVED-SURROGATE"
    "(DEFUN (INTERN-DERIVED-SURROGATE SURROGATE) ((BASESYMBOL GENERALIZED-SYMBOL) (NEWNAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return a newly-created or existing surrogate with name
`newName' which is interned in the same module as `baseSymbol'.\")"
    (CL:FUNCTION INTERN-DERIVED-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-KEYWORD"
    "(DEFUN (INTERN-KEYWORD KEYWORD) ((NAME STRING)) :DOCUMENTATION \"Return a newly-created or existing keyword with name
`name'.  Storage note: a COPY of `name' is stored in the keyword\" :PUBLIC? TRUE)"
    (CL:FUNCTION INTERN-KEYWORD) NULL)
   (DEFINE-FUNCTION-OBJECT "IMPORT-SYMBOL"
    "(DEFUN (IMPORT-SYMBOL SYMBOL) ((SYMBOL SYMBOL) (MODULE MODULE)) :DOCUMENTATION \"Import `symbol' into `module' and return the imported `symbol'.
Signal an error if a different symbol with the same name already exists
locally in `module'.  Any symbol with the same name visible in `module' by
inheritance will be shadowed by the newly imported `symbol'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION IMPORT-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "IMPORT-SURROGATE"
    "(DEFUN (IMPORT-SURROGATE SURROGATE) ((SURROGATE SURROGATE) (MODULE MODULE)) :DOCUMENTATION \"Import `surrogate' into `module' and return the imported `surrogate'.
Signal an error if a different surrogate with the same name already exists
locally in `module'.  Any surrogate with the same name visible in `module' by
inheritance will be shadowed by the newly imported `surrogate'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION IMPORT-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFE-IMPORT-SYMBOL"
    "(DEFUN (SAFE-IMPORT-SYMBOL SYMBOL) ((SYMBOL SYMBOL) (MODULE MODULE)) :DOCUMENTATION \"Safe version of `import-symbol' (which see).  Only imports `symbol' if
no symbol with that name is currently interned or visible in `module'.
Returns `symbol' if it was imported or the conflicting symbol in `module'
otherwise.\" :PUBLIC? TRUE)" (CL:FUNCTION SAFE-IMPORT-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFE-IMPORT-SURROGATE"
    "(DEFUN (SAFE-IMPORT-SURROGATE SURROGATE) ((SURROGATE SURROGATE) (MODULE MODULE)) :DOCUMENTATION \"Safe version of `import-surrogate' (which see).  Only imports `surrogate' if
no surrogate with that name is currently interned or visible in `module'.
Returns `surrogate' if it was imported or the conflicting surrogate in `module'
otherwise.\" :PUBLIC? TRUE)" (CL:FUNCTION SAFE-IMPORT-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "UNINTERN-SYMBOL"
    "(DEFUN UNINTERN-SYMBOL ((SELF SYMBOL)) :DOCUMENTATION \"Remove `self' from its home module and the symbol table.\" :PUBLIC? TRUE)"
    (CL:FUNCTION UNINTERN-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "UNINTERN-SURROGATE"
    "(DEFUN UNINTERN-SURROGATE ((SELF SURROGATE)) :DOCUMENTATION \"Remove `self' from its home module and the surrogate table.\")"
    (CL:FUNCTION UNINTERN-SURROGATE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DELETED? BOOLEAN) ((SELF GENERALIZED-SYMBOL)) :GLOBALLY-INLINE? TRUE (RETURN (EQL? (SYMBOL-ID SELF) -1)))"
    (CL:FUNCTION DELETED?) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-BOOTSTRAP-SYMBOL-AT"
    "(DEFUN (INTERN-BOOTSTRAP-SYMBOL-AT GENERALIZED-SYMBOL) ((NAME STRING) (OFFSET INTEGER) (KINDOFSYM INTEGER)) :DOCUMENTATION \"Interns a symbol, or keyword with
`name' and symbol-id `offset'.
If a symbol with that ID already existed, an error is signaled.  This
function is used to recreate the symbol table in a way where symbol IDs
which got hardwired into translated code will refer to the correct objects.\")"
    (CL:FUNCTION INTERN-BOOTSTRAP-SYMBOL-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-SYMBOL-AT"
    "(DEFUN (INTERN-SYMBOL-AT SYMBOL) ((NAME STRING) (OFFSET INTEGER)))"
    (CL:FUNCTION INTERN-SYMBOL-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-SURROGATE-AT"
    "(DEFUN (INTERN-SURROGATE-AT SURROGATE) ((NAME STRING) (OFFSET INTEGER)))"
    (CL:FUNCTION INTERN-SURROGATE-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-KEYWORD-AT"
    "(DEFUN (INTERN-KEYWORD-AT KEYWORD) ((NAME STRING) (OFFSET INTEGER)))"
    (CL:FUNCTION INTERN-KEYWORD-AT) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-KERNEL-MODULE"
    "(DEFUN INITIALIZE-KERNEL-MODULE ((MODULE MODULE) (NAME STRING) (FULLNAME STRING) (PARENT MODULE)))"
    (CL:FUNCTION INITIALIZE-KERNEL-MODULE) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-KERNEL-MODULES"
    "(DEFUN INITIALIZE-KERNEL-MODULES ())"
    (CL:FUNCTION INITIALIZE-KERNEL-MODULES) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-SYMBOLS-AND-KERNEL-MODULES"
    "(DEFUN INITIALIZE-SYMBOLS-AND-KERNEL-MODULES ())"
    (CL:FUNCTION INITIALIZE-SYMBOLS-AND-KERNEL-MODULES) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-TRANSIENT-SYMBOL"
    "(DEFUN (LOOKUP-TRANSIENT-SYMBOL SYMBOL) ((NAME STRING)))"
    (CL:FUNCTION LOOKUP-TRANSIENT-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-TRANSIENT-SYMBOL"
    "(DEFUN (INTERN-TRANSIENT-SYMBOL SYMBOL) ((NAME STRING)))"
    (CL:FUNCTION INTERN-TRANSIENT-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "FREE-TRANSIENT-SYMBOLS"
    "(DEFUN FREE-TRANSIENT-SYMBOLS ())"
    (CL:FUNCTION FREE-TRANSIENT-SYMBOLS) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-COMMON-LISP-SYMBOL"
    "(DEFUN (INTERN-COMMON-LISP-SYMBOL SYMBOL) ((NAME STRING)))"
    (CL:FUNCTION INTERN-COMMON-LISP-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL-COMMON-LISP?"
    "(DEFUN (SYMBOL-COMMON-LISP? BOOLEAN) ((SELF SYMBOL)))"
    (CL:FUNCTION SYMBOL-COMMON-LISP?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMMON-LISP-SYMBOL?"
    "(DEFUN (COMMON-LISP-SYMBOL? BOOLEAN) ((SELF OBJECT)))"
    (CL:FUNCTION COMMON-LISP-SYMBOL?) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-SYMBOLS3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-PARSING-TABLES"
    "(DEFUN INITIALIZE-PARSING-TABLES () :DOCUMENTATION \"Create indices for recording transient symbols and
Common Lisp symbols while parsing.\")"
    (CL:FUNCTION INITIALIZE-PARSING-TABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-GENSYM-NAME"
    "(DEFUN (YIELD-GENSYM-NAME STRING) ((PREFIX STRING) (COUNTER INTEGER)))"
    (CL:FUNCTION YIELD-GENSYM-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-UNIQUE-GENSYM-NAME"
    "(DEFUN (YIELD-UNIQUE-GENSYM-NAME STRING) ((PREFIX STRING) (MODULE MODULE)))"
    (CL:FUNCTION YIELD-UNIQUE-GENSYM-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "GENSYM"
    "(DEFUN (GENSYM SYMBOL) ((PREFIX STRING)) :DOCUMENTATION \"Return a transient symbol with a name beginning with
`prefix' and ending with a globally gensym'd integer.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GENSYM) NULL)
   (DEFINE-FUNCTION-OBJECT "SURROGATE-TO-SYMBOL"
    "(DEFUN (SURROGATE-TO-SYMBOL SYMBOL) ((SELF SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION SURROGATE-TO-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "TYPE-TO-SYMBOL"
    "(DEFUN (TYPE-TO-SYMBOL SYMBOL) ((TYPE TYPE)) :DOCUMENTATION \"Convert `type' into a symbol with the same name and module.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (INTERN-SYMBOL-IN-MODULE (SYMBOL-NAME TYPE) (INTERNED-IN TYPE) TRUE)))"
    (CL:FUNCTION TYPE-TO-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOLIZE"
    "(DEFUN (SYMBOLIZE SYMBOL) ((SURROGATE SURROGATE)) :DOCUMENTATION \"Convert `surrogate' into a symbol with the same name and module.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (INTERN-SYMBOL-IN-MODULE (SYMBOL-NAME SURROGATE) (INTERNED-IN SURROGATE) FALSE)))"
    (CL:FUNCTION SYMBOLIZE) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL-TO-TYPE"
    "(DEFUN (SYMBOL-TO-TYPE SURROGATE) ((SELF SYMBOL)) :DOCUMENTATION \"Convert `self' into a surrogate with the same name and module.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (INTERN-SURROGATE-IN-MODULE (SYMBOL-NAME SELF) (INTERNED-IN SELF) TRUE)))"
    (CL:FUNCTION SYMBOL-TO-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-TO-SURROGATE"
    "(DEFUN (STRING-TO-SURROGATE SURROGATE) ((SELF STRING)) :DOCUMENTATION \"Return a surrogate with the name 'self' visible
in the current module.  Very tricky: The logic is designed to avoid
returning an inherited surrogate that has no value.  In that case,
a new local surrogate is created that shadows the inherited surrogate.\" :PUBLIC? TRUE)"
    (CL:FUNCTION STRING-TO-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL-TO-SURROGATE"
    "(DEFUN (SYMBOL-TO-SURROGATE SURROGATE) ((SELF SYMBOL)) :DOCUMENTATION \"Return a surrogate with the same name as 'self'.
Very tricky: The logic is designed to avoid returning an inherited surrogate
that has no value.  In that case, a new local surrogate is created that shadows
the inherited surrogate.  Unlike 'string-to-surrogate', the search starts first
from the home context of 'self', and if that fails, then it restarts in
*module*.\" :PUBLIC? TRUE)" (CL:FUNCTION SYMBOL-TO-SURROGATE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SURROGATIFY SURROGATE) ((SELF SURROGATE)) :DOCUMENTATION \"Converts 'self' into a surrogate.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SURROGATIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SURROGATIFY SURROGATE) ((SELF SYMBOL)) :PUBLIC? TRUE :DOCUMENTATION \"Converts 'self' into a surrogate (same semantics
as `symbol-to-surrogate' which see).\")" (CL:FUNCTION SURROGATIFY)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SURROGATIFY SURROGATE) ((SELF STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Converts 'self' into a surrogate.\")"
    (CL:FUNCTION SURROGATIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SURROGATIFY SURROGATE) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION SURROGATIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "TYPIFY"
    "(DEFUN (TYPIFY TYPE) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION TYPIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (KEYWORDIFY KEYWORD) ((SELF KEYWORD)) :PUBLIC? TRUE)"
    (CL:FUNCTION KEYWORDIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (KEYWORDIFY KEYWORD) ((SELF GENERALIZED-SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION KEYWORDIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (KEYWORDIFY KEYWORD) ((SELF STRING-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION KEYWORDIFY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (KEYWORDIFY KEYWORD) ((SELF STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION KEYWORDIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "IN-PLACE-OBJECTS-TO-SYMBOLS"
    "(DEFUN IN-PLACE-OBJECTS-TO-SYMBOLS ((CONSLIST CONS)))"
    (CL:FUNCTION IN-PLACE-OBJECTS-TO-SYMBOLS) NULL)
   (DEFINE-FUNCTION-OBJECT "IN-PLACE-OBJECTS-TO-TYPES"
    "(DEFUN IN-PLACE-OBJECTS-TO-TYPES ((CONSLIST CONS)))"
    (CL:FUNCTION IN-PLACE-OBJECTS-TO-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "SURROGATE-NAME?"
    "(DEFUN (SURROGATE-NAME? BOOLEAN) ((NAME STRING)) :DOCUMENTATION \"Return TRUE if name is prefixed by 'SURROGATE-PREFIX-CHARACTER'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SURROGATE-NAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "KEYWORD-NAME?"
    "(DEFUN (KEYWORD-NAME? BOOLEAN) ((NAME STRING)) :DOCUMENTATION \"Return TRUE if name is prefixed by ':'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION KEYWORD-NAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-STELLA-NAME"
    "(DEFUN (INTERN-STELLA-NAME GENERALIZED-SYMBOL) ((NAME STRING)) :DOCUMENTATION \"Parse `name' which is assumed to be the printed
representation of a STELLA symbol, surrogate or keyword, intern
it into the current or specified module and return the result.
This is identical to calling `unstringify' on `name' but 10-15
times faster.\" :PUBLIC? TRUE)" (CL:FUNCTION INTERN-STELLA-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-FULL-NAME"
    "(DEFUN (COMPUTE-FULL-NAME STRING) ((NAME STRING) (MODULE MODULE)) :PUBLIC? TRUE)"
    (CL:FUNCTION COMPUTE-FULL-NAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOCAL-PRINT-NAME STRING) ((SELF GENERALIZED-SYMBOL) (READABLE? BOOLEAN)))"
    (CL:FUNCTION LOCAL-PRINT-NAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOCAL-PRINT-NAME STRING) ((SELF SURROGATE) (READABLE? BOOLEAN)))"
    (CL:FUNCTION LOCAL-PRINT-NAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (RELATIVE-NAME STRING) ((SELF GENERALIZED-SYMBOL) (READABLE? BOOLEAN)))"
    (CL:FUNCTION RELATIVE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "VISIBLE-SYMBOL?"
    "(DEFUN (VISIBLE-SYMBOL? BOOLEAN) ((SELF SYMBOL)) :DOCUMENTATION \"Return `true' if `self' is visible from the current module.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (EQL? SELF (LOOKUP-SYMBOL-IN-MODULE (SYMBOL-NAME SELF) *MODULE* FALSE))))"
    (CL:FUNCTION VISIBLE-SYMBOL?) NULL)
   (DEFINE-FUNCTION-OBJECT "VISIBLE-SURROGATE?"
    "(DEFUN (VISIBLE-SURROGATE? BOOLEAN) ((SELF SURROGATE)) :DOCUMENTATION \"Return `true' if `self' is visible from the current module.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (EQL? SELF (LOOKUP-SURROGATE-IN-MODULE (SYMBOL-NAME SELF) *MODULE* FALSE))))"
    (CL:FUNCTION VISIBLE-SURROGATE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (VISIBLE-NAME STRING) ((SELF GENERALIZED-SYMBOL) (READABLE? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION VISIBLE-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL-VALUE"
    "(DEFUN (SYMBOL-VALUE OBJECT) ((SYMBOL SYMBOL)) :DOCUMENTATION \"Return the value of `symbol'.  Note, that this value is not
visible to code that references a variable with the same name as `symbol'.
The `symbol-value' is simply a special property that can always be accessed
in constant time.  The `symbol-value' of a symbol can be changed with `setf'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (VALUE (SYMBOL-VALUE-AND-PLIST SYMBOL))))"
    (CL:FUNCTION SYMBOL-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL-VALUE-SETTER"
    "(DEFUN (SYMBOL-VALUE-SETTER OBJECT) ((SYMBOL SYMBOL) (VALUE OBJECT)))"
    (CL:FUNCTION SYMBOL-VALUE-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL-PLIST"
    "(DEFUN (SYMBOL-PLIST CONS) ((SYMBOL SYMBOL)) :DOCUMENTATION \"Return the property list of `symbol'.  The `symbol-plist'
of a symbol can be set with `setf'.  IMPORTANT: Property list are modified 
destructively, hence, if you supply it as a whole make sure to always supply
a modfiable copy, e.g., by using `bquote'.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (REST (SYMBOL-VALUE-AND-PLIST SYMBOL))))"
    (CL:FUNCTION SYMBOL-PLIST) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL-PLIST-SETTER"
    "(DEFUN (SYMBOL-PLIST-SETTER CONS) ((SYMBOL SYMBOL) (PLIST CONS)))"
    (CL:FUNCTION SYMBOL-PLIST-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL-PROPERTY"
    "(DEFUN (SYMBOL-PROPERTY OBJECT) ((SYMBOL SYMBOL) (KEY STANDARD-OBJECT)) :DOCUMENTATION \"Return the property of `symbol' whose key is `eq?' to `key'.
Symbol properties can be set with `setf'.\")"
    (CL:FUNCTION SYMBOL-PROPERTY) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL-PROPERTY-SETTER"
    "(DEFUN (SYMBOL-PROPERTY-SETTER OBJECT) ((SYMBOL SYMBOL) (VALUE OBJECT) (KEY STANDARD-OBJECT)))"
    (CL:FUNCTION SYMBOL-PROPERTY-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "SYMBOL-CONSTITUENT-CHARACTER?"
    "(DEFUN (SYMBOL-CONSTITUENT-CHARACTER? BOOLEAN) ((CHARACTER CHARACTER)))"
    (CL:FUNCTION SYMBOL-CONSTITUENT-CHARACTER?) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-SYMBOL-ESCAPE-CODE-TABLE"
    "(DEFUN (INITIALIZE-SYMBOL-ESCAPE-CODE-TABLE STRING) ((CASESENSITIVE? BOOLEAN)))"
    (CL:FUNCTION INITIALIZE-SYMBOL-ESCAPE-CODE-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-SYMBOL-ESCAPE-CODE"
    "(DEFUN (COMPUTE-SYMBOL-ESCAPE-CODE KEYWORD) ((NAME STRING) (CASESENSITIVE? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-SYMBOL-ESCAPE-CODE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-SYMBOL-NAME-READABLY"
    "(DEFUN PRINT-SYMBOL-NAME-READABLY ((NAME STRING) (STREAM NATIVE-OUTPUT-STREAM) (CASESENSITIVE? BOOLEAN)))"
    (CL:FUNCTION PRINT-SYMBOL-NAME-READABLY) NULL)
   (DEFINE-FUNCTION-OBJECT "READABLE-SYMBOL-NAME"
    "(DEFUN (READABLE-SYMBOL-NAME STRING) ((NAME STRING) (CASESENSITIVE? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION READABLE-SYMBOL-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-SYMBOL"
    "(DEFUN PRINT-SYMBOL ((SELF SYMBOL) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-SURROGATE"
    "(DEFUN PRINT-SURROGATE ((SELF SURROGATE) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-KEYWORD"
    "(DEFUN PRINT-KEYWORD ((SELF KEYWORD) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-KEYWORD) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-SYMBOLS"
    "(DEFUN STARTUP-SYMBOLS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-SYMBOLS) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-SYMBOLS-STELLA-STARTUP-SYMBOLS)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
     SYM-SYMBOLS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupSymbols") NULL-STRING-WRAPPER)))
  :VOID)

(CL:DEFUN STARTUP-SYMBOLS ()
  (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 0)
   (CL:WHEN (CL:EQ *FIXED-SYMBOL-ARRAY* NULL)
    (INITIALIZE-SYMBOLS-AND-KERNEL-MODULES))
   (INITIALIZE-PARSING-TABLES))
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-SYMBOLS1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *STELLA-MODULE*)
     SYM-SYMBOLS-STELLA-JAVA-PACKAGE (WRAP-STRING "edu.isi.stella")
     NULL-STRING-WRAPPER)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *STELLA-MODULE*)
     SYM-SYMBOLS-STELLA-MODULE-LISP-PACKAGE (WRAP-STRING "STELLA")
     NULL-STRING-WRAPPER)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *STELLA-MODULE*)
     SYM-SYMBOLS-STELLA-MODULE-CPP-PACKAGE (WRAP-STRING "stella")
     NULL-STRING-WRAPPER)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *ROOT-MODULE*)
     SYM-SYMBOLS-STELLA-CODE-ONLY? TRUE-WRAPPER FALSE-WRAPPER)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *STELLA-MODULE*)
     SYM-SYMBOLS-STELLA-CODE-ONLY? TRUE-WRAPPER FALSE-WRAPPER)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *COMMON-LISP-MODULE*)
     SYM-SYMBOLS-STELLA-CODE-ONLY? TRUE-WRAPPER FALSE-WRAPPER)
    (CL:SETQ *SYMBOL-ESCAPE-CODE-TABLE*
     (INITIALIZE-SYMBOL-ESCAPE-CODE-TABLE CL:NIL))
    (CL:SETQ *CASE-SENSITIVE-SYMBOL-ESCAPE-CODE-TABLE*
     (INITIALIZE-SYMBOL-ESCAPE-CODE-TABLE CL:T)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-SYMBOLS2)
    (HELP-STARTUP-SYMBOLS3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SYMBOL-ARRAY* (EXTENSIBLE-SYMBOL-ARRAY OF SYMBOL) NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SURROGATE-ARRAY* (EXTENSIBLE-SYMBOL-ARRAY OF SURROGATE) NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *KEYWORD-ARRAY* (EXTENSIBLE-SYMBOL-ARRAY OF KEYWORD) NULL :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *KEYWORD-OFFSET-TABLE* STRING-TO-INTEGER-HASH-TABLE NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FIXED-SYMBOL-ARRAY* (EXTENSIBLE-SYMBOL-ARRAY OF SYMBOL) NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FIXED-SURROGATE-ARRAY* (EXTENSIBLE-SYMBOL-ARRAY OF SURROGATE) NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FIXED-KEYWORD-ARRAY* (EXTENSIBLE-SYMBOL-ARRAY OF KEYWORD) NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TRANSIENT-SYMBOL-LOOKUP-TABLE* STRING-HASH-TABLE NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *COMMON-LISP-SYMBOL-LOOKUP-TABLE* STRING-HASH-TABLE NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT SYMBOL-SYM INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT SURROGATE-SYM INTEGER 1)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT KEYWORD-SYM INTEGER 2)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ROOT-MODULE* MODULE NULL :PUBLIC? TRUE :DOCUMENTATION \"Pointer to the top-most module ROOT-MODULE.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *STELLA-MODULE* MODULE NULL :PUBLIC? TRUE :DOCUMENTATION \"Pointer to the module STELLA containing definitions of 
STELLA classes and methods.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *COMMON-LISP-MODULE* MODULE NULL :PUBLIC? TRUE :DOCUMENTATION \"Pointer to the module COMMON-LISP containing Common
Lisp symbols (and maybe other things).\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ALTERNATE-STELLA-MODULE* MODULE NULL :DOCUMENTATION \"Pointer to the module ALTERNATE-STELLA containing
definitions of STELLA classes and methods generated during the
translation of STELLA files.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CONTEXT* CONTEXT :UNBOUND-SPECIAL-VARIABLE :DOCUMENTATION \"Points to the current context (either a module or a
world).  Set by calls to `change-world' and `change-module'.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *MODULE* MODULE :UNBOUND-SPECIAL-VARIABLE :DOCUMENTATION \"Points to the current module.  Set by calls to
`change-context' and `change-module'.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT SURROGATE-PREFIX-CHARACTER CHARACTER #\\@ :DOCUMENTATION \"Character used to prefix the name of a surrogate.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT MODULE-SEPARATOR-CHARACTER CHARACTER #\\/ :DOCUMENTATION \"Character used to concatenate a module name
to a symbol or surrogate name to form a qualified name.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT MODULE-SEPARATOR-STRING STRING \"/\" :DOCUMENTATION \"String containing character used to concatenate a module name
to a symbol or surrogate name to form a qualified name.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CONTEXT-NUMBER-COUNTER* INTEGER -2 :DOCUMENTATION \"Contains the number of the last-created
context (all 'live' contexts are even-numbered).\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GENSYM-COUNTER* INTEGER 0 :DOCUMENTATION \"Incremented once for each gensym call.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GENSYM-MASK* STRING \"-000\" :DOCUMENTATION \"Defines the separator character for gensyms,
and the fill digits.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SYMBOL-ESCAPE-CODE-TABLE* STRING (INITIALIZE-SYMBOL-ESCAPE-CODE-TABLE FALSE))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CASE-SENSITIVE-SYMBOL-ESCAPE-CODE-TABLE* STRING (INITIALIZE-SYMBOL-ESCAPE-CODE-TABLE TRUE))")))
  :VOID)
