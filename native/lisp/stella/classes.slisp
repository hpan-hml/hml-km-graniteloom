;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; classes.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2014      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-CLASSES-STELLA-CLASS NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-OBJECT NULL)
(CL:DEFVAR KWD-CLASSES-PUBLIC? NULL)
(CL:DEFVAR KWD-CLASSES-PARAMETERS NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-TYPE-SPECIFIER NULL)
(CL:DEFVAR KWD-CLASSES-REQUIRED? NULL)
(CL:DEFVAR KWD-CLASSES-COMPONENT? NULL)
(CL:DEFVAR KWD-CLASSES-READ-ONLY? NULL)
(CL:DEFVAR KWD-CLASSES-ACTIVE? NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-STORED-ACTIVE? NULL)
(CL:DEFVAR KWD-CLASSES-CONTEXT-SENSITIVE? NULL)
(CL:DEFVAR KWD-CLASSES-HARDWIRED? NULL)
(CL:DEFVAR KWD-CLASSES-ABSTRACT? NULL)
(CL:DEFVAR KWD-CLASSES-ALLOCATION NULL)
(CL:DEFVAR KWD-CLASSES-CLASS NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-ALLOCATION NULL)
(CL:DEFVAR KWD-CLASSES-INITIALLY NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-INITIAL-VALUE NULL)
(CL:DEFVAR KWD-CLASSES-DEFAULT NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-DEFAULT-EXPRESSION NULL)
(CL:DEFVAR KWD-CLASSES-READER NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-READER NULL)
(CL:DEFVAR KWD-CLASSES-WRITER NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-WRITER NULL)
(CL:DEFVAR KWD-CLASSES-INVERSE NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-INVERSE NULL)
(CL:DEFVAR KWD-CLASSES-RENAMES NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-RENAMES NULL)
(CL:DEFVAR KWD-CLASSES-DOCUMENTATION NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR KWD-CLASSES-PROPERTIES NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-PROPERTIES NULL)
(CL:DEFVAR KWD-CLASSES-META-ATTRIBUTES NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-META-ATTRIBUTES NULL)
(CL:DEFVAR KWD-CLASSES-OPTION-KEYWORD NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-OPTION-KEYWORD NULL)
(CL:DEFVAR KWD-CLASSES-OPTION-HANDLER NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-OPTION-HANDLER NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-BOOLEAN NULL)
(CL:DEFVAR KWD-CLASSES-BIT NULL)
(CL:DEFVAR KWD-CLASSES-CL-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-CL-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-CLASSES-CPP-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-CPP-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-CLASSES-IDL-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-IDL-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-CLASSES-JAVA-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-JAVA-NATIVE-TYPE NULL)
(CL:DEFVAR KWD-CLASSES-CL-STRUCT? NULL)
(CL:DEFVAR KWD-CLASSES-MIXIN? NULL)
(CL:DEFVAR KWD-CLASSES-RECYCLE-METHOD NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-RECYCLE-METHOD NULL)
(CL:DEFVAR KWD-CLASSES-EXTENSION NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-EXTENSION-NAME NULL)
(CL:DEFVAR KWD-CLASSES-CREATOR NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-CREATOR NULL)
(CL:DEFVAR KWD-CLASSES-INITIALIZER NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-INITIALIZER NULL)
(CL:DEFVAR KWD-CLASSES-TERMINATOR NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-TERMINATOR NULL)
(CL:DEFVAR KWD-CLASSES-DESTRUCTOR NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-DESTRUCTOR NULL)
(CL:DEFVAR KWD-CLASSES-INITIAL-VALUE NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-INITIAL-VALUE NULL)
(CL:DEFVAR KWD-CLASSES-PRINT-FORM NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-PRINT-FORM NULL)
(CL:DEFVAR KWD-CLASSES-EQUALITY-TEST NULL)
(CL:DEFVAR KWD-CLASSES-KEY NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-KEY NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-PARAMETERS NULL)
(CL:DEFVAR KWD-CLASSES-SYNONYMS NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-SYNONYMS NULL)
(CL:DEFVAR KWD-CLASSES-CHILDREN NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-METHOD-SLOT NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-GUARD-DEMONS NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SLOT-DEMONS NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-CONSTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-DESTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-ACTIVE-OBJECT NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-STANDARD-OBJECT NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-PRIMARY-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-SELF NULL)
(CL:DEFVAR KWD-CLASSES-TYPE NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-TYPE NULL)
(CL:DEFVAR KWD-CLASSES-AUXILIARY? NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-TRUE NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-RETURN NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-EXTENSION NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-BAD? NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-SET NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-ACTIVE-SET NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-LIST NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-ACTIVE-LIST NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-UNKNOWN NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-SET-MIXIN NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-INVERSE NULL)
(CL:DEFVAR KWD-CLASSES-DYNAMIC NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-DYNAMIC-SLOTS-MIXIN NULL)
(CL:DEFVAR KWD-CLASSES-INSTANCE NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-CONTEXT-SENSITIVE-OBJECT NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-CONTEXT-SENSITIVE-MIXIN NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-VOID NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-METHOD-MACRO? NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-TABLE NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-CLASS-REQUIRED-SLOT-NAMES NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-ALL-CLASS-SLOTS-ITERATOR NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-ITERATOR-CONS-LIST NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-ITERATOR-OBJECT NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-FALSE NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-PRINT-UNBOUND-SURROGATES NULL)
(CL:DEFVAR KWD-CLASSES-COMMON-LISP NULL)
(CL:DEFVAR KWD-CLASSES-FUNCTION NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-PRINT-UNDEFINED-SUPER-CLASSES NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-ANY NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-ANY NULL)
(CL:DEFVAR SGT-CLASSES-STELLA-SLOT NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-STARTUP-CLASSES NULL)
(CL:DEFVAR SYM-CLASSES-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL STANDARD-ERROR NULL-INTEGER TRUE-WRAPPER
  *FINALIZE-RELATION-HOOKS* FALSE-WRAPPER *STELLA-MODULE*
  *REDEFINE-RELATION-HOOKS*
  *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES* NULL-STRING-WRAPPER
  STANDARD-WARNING *DEBUGLEVEL* *CLASS-TAXONOMY-GRAPH* SYMBOL-SYM
  STANDARD-OUTPUT EOL *MODULE* NIL SURROGATE-SYM))

;;; (DEFUN (CLASS-NAME STRING) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) CLASS-NAME))
(CL:DEFUN CLASS-NAME (CLASS)
  (CL:RETURN-FROM CLASS-NAME
   (%SURROGATE.SYMBOL-NAME (%CLASS.CLASS-TYPE CLASS))))

;;; (DEFUN (CLASS-SYMBOL SYMBOL) ...)

(CL:DEFUN CLASS-SYMBOL (CLASS)
  (CL:RETURN-FROM CLASS-SYMBOL
   (INTERN-SYMBOL-IN-MODULE
    (%SURROGATE.SYMBOL-NAME (%CLASS.CLASS-TYPE CLASS))
    (%SURROGATE.HOME-CONTEXT (%CLASS.CLASS-TYPE CLASS)) CL:T)))

;;; (DEFMETHOD (PRIMARY-CLASS CLASS) ...)

(%%DEFCONSMETHOD PRIMARY-CLASS ((SELF OBJECT))
  (CL:WHEN (CL:NOT (CL:EQ (PRIMARY-TYPE SELF) NULL))
   (CL:RETURN-FROM PRIMARY-CLASS
    (%SURROGATE.SURROGATE-VALUE (PRIMARY-TYPE SELF))))
  (CL:RETURN-FROM PRIMARY-CLASS NULL))

;;; (DEFMETHOD (LOOKUP-CLASS CLASS) ...)

(CL:DEFMETHOD LOOKUP-CLASS ((NAME CL:STRING))
  "Return a class with name `name'.  Scan all
visible surrogates looking for one that has a class defined for it."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((CLASS NULL) (SURROGATE NULL))
   (CL:LET* ((MODULE NULL) (ITER-000 (VISIBLE-MODULES *MODULE*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ MODULE (%%VALUE ITER-000))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:LET* ()
       (CL:SETQ SURROGATE
        (LOOKUP-RIGID-SYMBOL-LOCALLY NAME MODULE SURROGATE-SYM))
       (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ SURROGATE NULL))))
      (CL:WHEN TEST-VALUE-000
       (CL:LET* ()
        (CL:SETQ CLASS (%SURROGATE.SURROGATE-VALUE SURROGATE))
        (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ CLASS NULL))))
       (CL:WHEN TEST-VALUE-000
        (CL:SETQ TEST-VALUE-000
         (ISA? CLASS SGT-CLASSES-STELLA-CLASS))))
      (CL:WHEN TEST-VALUE-000 (CL:RETURN-FROM LOOKUP-CLASS CLASS)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM LOOKUP-CLASS NULL)))

;;; (DEFMETHOD (LOOKUP-CLASS CLASS) ...)

(CL:DEFMETHOD LOOKUP-CLASS ((NAME SYMBOL))
  "Return a class with name `name'.  Scan all
visible surrogates looking for one that has a class defined for it."
  (CL:LET* ((*MODULE* (%SYMBOL.HOME-CONTEXT NAME)))
   (CL:DECLARE (CL:SPECIAL *MODULE*))
   (CL:RETURN-FROM LOOKUP-CLASS
    (LOOKUP-CLASS (%SYMBOL.SYMBOL-NAME NAME)))))

;;; (DEFUN (TYPE-TO-CLASS CLASS) ...)

(CL:DEFUN TYPE-TO-CLASS (TYPE)
  (CL:RETURN-FROM TYPE-TO-CLASS (%SURROGATE.SURROGATE-VALUE TYPE)))

;;; (DEFMETHOD (GET-STELLA-CLASS CLASS) ...)

(CL:DEFMETHOD GET-STELLA-CLASS ((CLASS-NAME SURROGATE) ERROR?)
  "Return a class with name `class-name'.  If none exists, break
if `error?', else return `null'."
  (CL:LET* ((CLASS (%SURROGATE.SURROGATE-VALUE CLASS-NAME)))
   (CL:WHEN (CL:AND (CL:NOT (CL:EQ CLASS NULL)) (STELLA-CLASS? CLASS))
    (CL:RETURN-FROM GET-STELLA-CLASS CLASS))
   (CL:WHEN ERROR?
    (CL:CERROR "Continue anyway? " "Class `~A' does not exist."
     CLASS-NAME))
   (CL:RETURN-FROM GET-STELLA-CLASS NULL)))

;;; (DEFMETHOD (GET-STELLA-CLASS CLASS) ...)

(CL:DEFMETHOD GET-STELLA-CLASS ((CLASS-NAME CL:STRING) ERROR?)
  "Return a class with name `class-name'.  If none exists, break
if `error?', else return `null'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CLASS-NAME))
  #+MCL
  (CL:CHECK-TYPE CLASS-NAME CL:SIMPLE-STRING)
  (CL:LET* ((TYPE (LOOKUP-SURROGATE CLASS-NAME)))
   (CL:WHEN (CL:NOT (CL:EQ TYPE NULL))
    (CL:RETURN-FROM GET-STELLA-CLASS (GET-STELLA-CLASS TYPE ERROR?)))
   (CL:WHEN ERROR?
    (CL:CERROR "Continue anyway? " "Class `~A' does not exist."
     CLASS-NAME))
   (CL:RETURN-FROM GET-STELLA-CLASS NULL)))

;;; (DEFMETHOD (GET-STELLA-CLASS CLASS) ...)

(CL:DEFMETHOD GET-STELLA-CLASS ((CLASS-NAME SYMBOL) ERROR?)
  "Return a class with name `class-name'.  If non exists, break
if `error?', else return `null'."
  (CL:RETURN-FROM GET-STELLA-CLASS
   (GET-STELLA-CLASS (%SYMBOL.SYMBOL-NAME CLASS-NAME) ERROR?)))

;;; (DEFSPECIAL *WARNIFREDEFINE?* ...)

(CL:DEFVAR *WARNIFREDEFINE?* CL:T
  "If set, warn about each redefinition.")

;;; (DEFUN (BIND-TO-SURROGATE? BOOLEAN OBJECT SURROGATE) ...)

(CL:DEFUN BIND-TO-SURROGATE? (SELF NAME CLIPOLDVALUE? ASKFORPERMISSION?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((OLDSURROGATE (LOOKUP-SURROGATE NAME))
    (OLDVALUE
     (CL:IF (CL:NOT (CL:EQ OLDSURROGATE NULL))
      (%SURROGATE.SURROGATE-VALUE OLDSURROGATE) NULL))
    (SURROGATE (SHADOW-SURROGATE NAME)) (OLDMODULE NULL))
   (CL:WHEN (CL:EQ OLDVALUE NULL)
    (CL:SETF (%SURROGATE.SURROGATE-VALUE SURROGATE) SELF)
    (CL:RETURN-FROM BIND-TO-SURROGATE?
     (CL:VALUES CL:T NULL SURROGATE)))
   (CL:WHEN (EQL? OLDVALUE SELF)
    (CL:RETURN-FROM BIND-TO-SURROGATE?
     (CL:VALUES CL:T NULL SURROGATE)))
   (CL:SETQ OLDMODULE (%SURROGATE.HOME-CONTEXT OLDSURROGATE))
   (CL:COND
    ((CL:NOT (CL:EQ OLDMODULE *MODULE*))
     (CL:SETF (%SURROGATE.SURROGATE-VALUE SURROGATE) SELF)
     (CL:WHEN ASKFORPERMISSION?
      (CL:WARN "Shadowing the `~A' named `~A'"
       (%SURROGATE.SYMBOL-NAME (PRIMARY-TYPE SELF)) NAME)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "CAUTION: Automatic shadowing can be dangerous, because forward "
       EOL
       "   references to a shadowed object may be bound to the now-shadowed "
       EOL "   object.  Suggestion: Explicitly shadow the name using"
       EOL "   DEFMODULE's `:shadow' option." EOL)
      (CL:WHEN (YES-OR-NO? "Do it anyway? ")
       (CL:SETF (%SURROGATE.SURROGATE-VALUE SURROGATE) SELF)
       (CL:RETURN-FROM BIND-TO-SURROGATE?
        (CL:VALUES CL:T OLDVALUE SURROGATE))))
     (CL:RETURN-FROM BIND-TO-SURROGATE?
      (CL:VALUES CL:T NULL SURROGATE)))
    (CLIPOLDVALUE?
     (CL:WHEN *WARNIFREDEFINE?*
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "Redefining the `" (%SURROGATE.SYMBOL-NAME (PRIMARY-TYPE SELF))
       "' named `" NAME "'" EOL))
     (CL:SETF (%SURROGATE.SURROGATE-VALUE SURROGATE) SELF)
     (CL:WHEN
      (CL:NOT (CL:EQ (PRIMARY-TYPE SELF) (PRIMARY-TYPE OLDVALUE)))
      (CL:SETQ OLDVALUE NULL))
     (CL:RETURN-FROM BIND-TO-SURROGATE?
      (CL:VALUES CL:T OLDVALUE SURROGATE)))
    (CL:T
     (CL:WHEN ASKFORPERMISSION?
      (CL:WARN
       "Can't define the `~A' named `~A' in module `~A'~%   because that term is already bound to `~A'~%"
       (%SURROGATE.SYMBOL-NAME (PRIMARY-TYPE SELF)) NAME *MODULE*
       OLDVALUE)
      (CL:WHEN (YES-OR-NO? "Do it anyway? ")
       (CL:SETF (%SURROGATE.SURROGATE-VALUE SURROGATE) SELF)
       (CL:RETURN-FROM BIND-TO-SURROGATE?
        (CL:VALUES CL:T OLDVALUE SURROGATE))))
     (CL:RETURN-FROM BIND-TO-SURROGATE?
      (CL:VALUES CL:NIL NULL SURROGATE))))))

;;; (DEFMETHOD UNBIND-FROM-SURROGATE ...)

(CL:DEFMETHOD UNBIND-FROM-SURROGATE ((SELF CLASS))
  (CL:LET* ((SURROGATE (%CLASS.CLASS-TYPE SELF)))
   (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
    (CL:SETF (%SURROGATE.SURROGATE-VALUE SURROGATE) NULL)
    (CL:SETF (%CLASS.CLASS-TYPE SELF) NULL)))
  :VOID)

;;; (DEFUN (SHADOW-SYMBOL SYMBOL) ...)

(CL:DEFUN SHADOW-SYMBOL (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM SHADOW-SYMBOL
   (INTERN-RIGID-SYMBOL-LOCALLY NAME *MODULE* SYMBOL-SYM)))

;;; (DEFUN (SHADOW-SURROGATE SURROGATE) ...)

(CL:DEFUN SHADOW-SURROGATE (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (SHADOW-SYMBOL NAME)
  (CL:RETURN-FROM SHADOW-SURROGATE
   (INTERN-RIGID-SYMBOL-LOCALLY NAME *MODULE* SURROGATE-SYM)))

;;; (DEFUN (SHADOWED-SYMBOL? BOOLEAN) ...)

(CL:DEFUN SHADOWED-SYMBOL? (SYMBOL)
  "Return `true' if `symbol' is shadowed in its home module."
  (CL:LET*
   ((SYMBOLNAME (%GENERALIZED-SYMBOL.SYMBOL-NAME SYMBOL))
    (MODULE (%GENERALIZED-SYMBOL.HOME-CONTEXT SYMBOL)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYMBOLNAME))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ MODULE NULL)))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((SHADOW NULL)
        (ITER-000 (%LIST.THE-CONS-LIST (SHADOWED-SURROGATES MODULE))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ SHADOW (%%VALUE ITER-000))
        (CL:WHEN
         (STRING-EQL? (%SURROGATE.SYMBOL-NAME SHADOW) SYMBOLNAME)
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000)))
    (CL:LET* ((VALUE-000 TEST-VALUE-000))
     (CL:RETURN-FROM SHADOWED-SYMBOL? VALUE-000)))))

;;; (DEFUN (GET-CONSTRUCTOR FUNCTION-CODE) ...)

(CL:DEFUN GET-CONSTRUCTOR (CLASS WARN?)
  (CL:LET* ((CONSTRUCTOR (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)))
   (CL:WHEN (CL:NOT (CL:EQ CONSTRUCTOR NULL))
    (CL:RETURN-FROM GET-CONSTRUCTOR CONSTRUCTOR))
   (CL:WHEN WARN?
    (CL:WHEN (%CLASS.ABSTRACT? CLASS)
     (CL:WARN "The abstract class `~A' cannot have a constructor."
      (CLASS-SYMBOL CLASS))
     (CL:RETURN-FROM GET-CONSTRUCTOR NULL))
    (CL:WARN "The `~A'class `~A' does not have a callable constructor."
     (CL:IF (PRIVATE? CLASS) "private " "") (CLASS-SYMBOL CLASS)))
   (CL:RETURN-FROM GET-CONSTRUCTOR NULL)))

;;; (DEFUN (CREATE-OBJECT OBJECT) ...)

(CL:DEFUN CREATE-OBJECT (TYPE CL:&REST INITIAL-VALUE-PAIRS)
  "Funcallable version of the `new' operator.
Return an instance of the class named by `type'.  If `initial-value-pairs'
is supplied, it has to be a key/value list similar to what's accepted by `new'
and the named slots will be initialized with the supplied values.  Similar to
`new', all required arguments for `type' must be included.  Since all the
slot initialization, etc. is handled dynamically at run time, `create-object'
is much slower than `new'; therefore, it should only be used if `type' cannot
be known at translation time."
  (CL:LET*
   ((CLASS (GET-STELLA-CLASS TYPE CL:T))
    (CONSTRUCTORCODE (GET-CONSTRUCTOR CLASS CL:T)))
   (CL:LET* ((CHOOSE-VALUE-000 NULL))
    (CL:IF (CL:= (CL:LENGTH INITIAL-VALUE-PAIRS) 0)
     (CL:SETQ CHOOSE-VALUE-000 NULL)
     (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
      (CL:LET* ((ARGLIST-000 NIL))
       (CL:LET*
        ((ARG-000 NULL) (ITER-000 INITIAL-VALUE-PAIRS)
         (COLLECT-000 NULL))
        (CL:LOOP WHILE ITER-000 DO (CL:SETQ ARG-000 (CL:POP ITER-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG-000 NIL))
           (CL:IF (CL:EQ ARGLIST-000 NIL)
            (CL:SETQ ARGLIST-000 COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST ARGLIST-000 COLLECT-000)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG-000 NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
       (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000) ARGLIST-000))
      (CL:SETQ CHOOSE-VALUE-000 SELF-000)))
    (CL:LET*
     ((INITIALVALUES CHOOSE-VALUE-000)
      (REQUIREDSLOTS (CLASS-REQUIRED-SLOT-NAMES CLASS))
      (REQUIREDSLOTVALUES NIL) (SLOTVALUE NULL) (SLOT NULL)
      (OBJECT NULL))
     (CL:WHEN (CL:EQ CONSTRUCTORCODE NULL)
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "create-object: no funcallable constructor available for `"
        TYPE "'")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
     (CL:WHEN (NON-EMPTY? REQUIREDSLOTS)
      (CL:WHEN (CL:EQ INITIALVALUES NULL)
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
         "create-object: missing initial values for `" TYPE
         "''s required slots")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))
      (CL:LET*
       ((REQSLOTNAME NULL)
        (ITER-001 (%LIST.THE-CONS-LIST REQUIREDSLOTS))
        (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ REQSLOTNAME (%%VALUE ITER-001))
        (CL:SETQ SLOT (LOOKUP-SLOT CLASS REQSLOTNAME))
        (CL:WHEN
         (CL:NOT (SUBTYPE-OF? (TYPE SLOT) SGT-CLASSES-STELLA-OBJECT))
         (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
           "create-object: can't yet initialize required slot `" TYPE
           "'.`" REQSLOTNAME
           "', since its type is not a subtype of OBJECT")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))
        (CL:SETQ SLOTVALUE
         (LOOKUP INITIALVALUES (KEYWORDIFY REQSLOTNAME)))
        (REMOVE-AT INITIALVALUES (KEYWORDIFY REQSLOTNAME))
        (CL:WHEN (CL:EQ SLOTVALUE NULL)
         (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003)
           "create-object: missing initial value for required slot `"
           TYPE "'.`" REQSLOTNAME "'")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-003)))))
        (CL:IF (CL:EQ COLLECT-001 NULL)
         (CL:PROGN (CL:SETQ COLLECT-001 (CONS SLOTVALUE NIL))
          (CL:IF (CL:EQ REQUIREDSLOTVALUES NIL)
           (CL:SETQ REQUIREDSLOTVALUES COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST REQUIREDSLOTVALUES
            COLLECT-001)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS SLOTVALUE NIL))
          (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
        (CL:SETQ ITER-001 (%%REST ITER-001)))))
     (CL:SETQ OBJECT (APPLY CONSTRUCTORCODE REQUIREDSLOTVALUES))
     (CL:WHEN (CL:NOT (CL:EQ INITIALVALUES NULL))
      (CL:LET*
       ((SLOTNAME NULL) (VALUE NULL)
        (ITER-002 (%PROPERTY-LIST.THE-PLIST INITIALVALUES)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ SLOTNAME (%%VALUE ITER-002))
        (CL:SETQ VALUE (%%VALUE (%%REST ITER-002)))
        (CL:COND
         ((SUBTYPE-OF-KEYWORD? (SAFE-PRIMARY-TYPE SLOTNAME))
          (CL:PROGN
           (CL:SETQ SLOT
            (LOOKUP-SLOT CLASS
             (INTERN-DERIVED-SYMBOL TYPE
              (%KEYWORD.SYMBOL-NAME SLOTNAME))))
           (CL:WHEN (CL:NOT (STORAGE-SLOT? SLOT))
            (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM
              (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004)
              "create-object: slot `" SLOTNAME
              "' does not exist on class `" TYPE "'")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-004)))))
           (PUT-SLOT-VALUE OBJECT SLOT VALUE)))
         (CL:T
          (CL:LET* ((STREAM-005 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-005)
            "create-object: illegal initialization option: `" SLOTNAME
            "'")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-005))))))
        (CL:SETQ ITER-002 (%%REST (%%REST ITER-002))))))
     (CL:RETURN-FROM CREATE-OBJECT OBJECT)))))

;;; (DEFMETHOD FREE ...)

(%%DEFCONSMETHOD FREE ((SELF OBJECT))
  "Default method.  Deallocate storage for `self'."
  (UNMAKE SELF)
  :VOID)

;;; (DEFMETHOD FREE ...)

(CL:DEFMETHOD FREE ((SELF ACTIVE-OBJECT))
  "Remove all pointers between `self' and other objects,
and then deallocate the storage for self."
  (UNMAKE SELF)
  :VOID)

;;; (DEFUN (DEFINE-STELLA-CLASS CLASS) ...)

(CL:DEFUN DEFINE-STELLA-CLASS (NAME SUPERS SLOTS OPTIONS)
  "Return a Stella class with name `name'.
Caution:  If the class already exists, the Stella class object gets
redefined, but the native C++ class is not redefined."
  (CL:LET*
   ((CLASS (NEW-CLASS))
    (PARAMETERSLOTS (LOOKUP OPTIONS KWD-CLASSES-PARAMETERS))
    (OLDCLASS NULL) (SUCCESS? CL:NIL))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ (%SURROGATE.HOME-CONTEXT NAME) *MODULE*))
     (CL:NOT (VISIBLE-FROM? (%SURROGATE.HOME-CONTEXT NAME) *MODULE*)))
    (CL:WARN
     "Can't define a class named `~A' because the module ~%   `~A' is not visible from the current module `~A'.~%"
     NAME (CONTEXT-NAME (%SURROGATE.HOME-CONTEXT NAME))
     (CONTEXT-NAME *MODULE*))
    (CL:RETURN-FROM DEFINE-STELLA-CLASS NULL))
   (CL:MULTIPLE-VALUE-SETQ (SUCCESS? OLDCLASS NAME)
    (BIND-TO-SURROGATE? CLASS (%SURROGATE.SYMBOL-NAME NAME) CL:T CL:T))
   (CL:WHEN (CL:NOT SUCCESS?)
    (CL:RETURN-FROM DEFINE-STELLA-CLASS NULL))
   (CL:SETF (%CLASS.CLASS-TYPE CLASS) NAME)
   (CL:WHEN (CL:NOT (CL:EQ PARAMETERSLOTS NULL))
    (CL:LET* ((S NULL) (ITER-000 (%LIST.THE-CONS-LIST PARAMETERSLOTS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ S (%%VALUE ITER-000)) (CL:SETF (%SLOT.ABSTRACT? S) CL:T)
      (INSERT-LAST SLOTS S) (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (INITIALIZE-SLOT-AND-METHOD-CACHE CLASS)
   (CL:LET*
    ((S NULL) (ITER-001 (%LIST.THE-CONS-LIST SUPERS))
     (INTO-000 (%CLASS.CLASS-DIRECT-SUPERS CLASS)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ S (%%VALUE ITER-001))
     (CL:WHEN
      (CL:AND (CL:NOT (STELLA-CLASS? (%SURROGATE.SURROGATE-VALUE S)))
       (CL:NOT (CL:EQ (%SURROGATE.HOME-CONTEXT S) *MODULE*))
       (VISIBLE-FROM? (%SURROGATE.HOME-CONTEXT S) *MODULE*))
      (CL:WHEN (CL:>= *DEBUGLEVEL* 3)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "Automatically shadowing bogus super `" S "' of class `" NAME
        "'" EOL))
      (CL:SETQ S (SHADOW-SURROGATE (%SURROGATE.SYMBOL-NAME S))))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS S NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST INTO-000) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST INTO-000) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST INTO-000)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS S NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (INCORPORATE-CLASS-OPTIONS CLASS OPTIONS)
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000 (CL:NOT (PRIMITIVE? CLASS)))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET* ((SLOT NULL) (ITER-002 (%LIST.THE-CONS-LIST SLOTS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ SLOT (%%VALUE ITER-002))
        (CL:WHEN (PRIMITIVE? SLOT) (CL:SETQ FOUND?-000 CL:T)
         (CL:RETURN))
        (CL:SETQ ITER-002 (%%REST ITER-002))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000)))
    (CL:WHEN TEST-VALUE-000
     (CL:WARN "Defined class `~A' illegally specifies primitive slots."
      CLASS)))
   (CL:SETF (%CLASS.CLASS-LOCAL-SLOTS CLASS) SLOTS)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ OLDCLASS NULL))
     (ISA? OLDCLASS SGT-CLASSES-STELLA-CLASS))
    (UNDEFINE-OLD-CLASS OLDCLASS CLASS))
   (CL:WHEN (CL:EQ (%CLASS.CLASS-TAXONOMY-NODE CLASS) NULL)
    (CL:SETF (%CLASS.CLASS-TAXONOMY-NODE CLASS)
     (CREATE-TAXONOMY-NODE *CLASS-TAXONOMY-GRAPH* NULL CLASS
      (EMPTY? (%CLASS.CLASS-DIRECT-SUPERS CLASS)))))
   (CL:LET* ((SLOT NULL) (ITER-003 (%LIST.THE-CONS-LIST SLOTS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
     (CL:SETQ SLOT (%%VALUE ITER-003)) (REGISTER-SLOT-NAME SLOT)
     (CL:SETQ ITER-003 (%%REST ITER-003))))
   (REMEMBER-UNFINALIZED-CLASS CLASS CL:T)
   (CL:RETURN-FROM DEFINE-STELLA-CLASS CLASS)))

;;; (DEFUN (DEFINE-STELLA-SLOT SLOT) ...)

(CL:DEFUN DEFINE-STELLA-SLOT (NAME OWNER BASETYPE TYPESPECIFIER OPTIONS)
  (CL:LET* ((SLOT (NEW-STORAGE-SLOT)))
   (CL:SETF (%STORAGE-SLOT.SLOT-NAME SLOT) NAME)
   (CL:SETF (%STORAGE-SLOT.SLOT-OWNER SLOT) OWNER)
   (CL:SETF (%STORAGE-SLOT.SLOT-BASE-TYPE SLOT) BASETYPE)
   (CL:WHEN (CL:NOT (CL:EQ TYPESPECIFIER NIL))
    (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
     SYM-CLASSES-STELLA-SLOT-TYPE-SPECIFIER
     (YIELD-TYPE-SPECIFIER TYPESPECIFIER) NULL))
   (CL:LET*
    ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR OPTIONS)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ KEY (%KV-LIST-ITERATOR.KEY ITER-000))
     (CL:SETQ VALUE (%KV-LIST-ITERATOR.VALUE ITER-000))
     (CL:COND
      ((CL:EQ KEY KWD-CLASSES-PUBLIC?)
       (CL:SETF (%STORAGE-SLOT.SLOT-PUBLIC? SLOT)
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
      ((CL:EQ KEY KWD-CLASSES-REQUIRED?)
       (CL:SETF (%STORAGE-SLOT.SLOT-REQUIRED? SLOT)
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
      ((CL:EQ KEY KWD-CLASSES-COMPONENT?)
       (CL:SETF (%STORAGE-SLOT.SLOT-COMPONENT? SLOT)
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
      ((CL:EQ KEY KWD-CLASSES-READ-ONLY?)
       (CL:SETF (%STORAGE-SLOT.SLOT-READ-ONLY? SLOT)
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
      ((CL:EQ KEY KWD-CLASSES-ACTIVE?)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-STORED-ACTIVE? VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-CONTEXT-SENSITIVE?)
       (CL:SETF (%STORAGE-SLOT.SLOT-CONTEXT-SENSITIVE? SLOT)
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
      ((CL:EQ KEY KWD-CLASSES-HARDWIRED?)
       (CL:SETF (%STORAGE-SLOT.SLOT-HARDWIRED? SLOT)
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
      ((CL:EQ KEY KWD-CLASSES-ABSTRACT?)
       (CL:SETF (%STORAGE-SLOT.ABSTRACT? SLOT)
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
      ((CL:EQ KEY KWD-CLASSES-ALLOCATION)
       (CL:IF (CL:EQ VALUE KWD-CLASSES-CLASS)
        (CL:WARN
         "In definition of slot `~A': ':class' allocation is unsupported right now.~% Maybe use ':hardwired? TRUE' for read-only slots."
         SLOT)
        (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
         SYM-CLASSES-STELLA-SLOT-ALLOCATION VALUE NULL)))
      ((CL:EQ KEY KWD-CLASSES-INITIALLY)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-SLOT-INITIAL-VALUE VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-DEFAULT)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-SLOT-DEFAULT-EXPRESSION VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-READER)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-SLOT-READER VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-WRITER)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-SLOT-WRITER VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-INVERSE)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-SLOT-INVERSE VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-RENAMES)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-SLOT-RENAMES VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-DOCUMENTATION)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-DOCUMENTATION
        (WRAP-STRING (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
        NULL-STRING-WRAPPER))
      ((CL:EQ KEY KWD-CLASSES-PROPERTIES)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-PROPERTIES VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-META-ATTRIBUTES)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-META-ATTRIBUTES VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-OPTION-KEYWORD)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-SLOT-OPTION-KEYWORD VALUE NULL))
      ((CL:EQ KEY KWD-CLASSES-OPTION-HANDLER)
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
        SYM-CLASSES-STELLA-SLOT-OPTION-HANDLER VALUE NULL))
      (CL:T
       (CL:WHEN (CL:NOT (RUN-OPTION-HANDLER? SLOT KEY VALUE))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-WARNING)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
          (%%PRINT-STREAM
           (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
           " Skipping invalid slot option `" (DE-UGLIFY-PARSE-TREE KEY)
           "'" EOL "in the definition of slot `"
           (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME OWNER)
            (%SURROGATE.HOME-CONTEXT OWNER) CL:T)
           "'.`" (DE-UGLIFY-PARSE-TREE NAME) "'." EOL))))))))
   (CL:WHEN
    (CL:AND (CL:EQ (SLOT-ALLOCATION SLOT) NULL)
     (CL:EQ BASETYPE SGT-CLASSES-STELLA-BOOLEAN))
    (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
     SYM-CLASSES-STELLA-SLOT-ALLOCATION KWD-CLASSES-BIT NULL))
   (CL:RETURN-FROM DEFINE-STELLA-SLOT SLOT)))

;;; (DEFUN INCORPORATE-CLASS-OPTIONS ...)

(CL:DEFUN INCORPORATE-CLASS-OPTIONS (CLASS OPTIONS)
  (CL:LET*
   ((KEY NULL) (VALUE NULL) (ITER-000 (ALLOCATE-ITERATOR OPTIONS)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ KEY (%KV-LIST-ITERATOR.KEY ITER-000))
    (CL:SETQ VALUE (%KV-LIST-ITERATOR.VALUE ITER-000))
    (CL:COND
     ((CL:EQ KEY KWD-CLASSES-DOCUMENTATION)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-DOCUMENTATION
       (WRAP-STRING (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
       NULL-STRING-WRAPPER))
     ((CL:EQ KEY KWD-CLASSES-CL-NATIVE-TYPE)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-CL-NATIVE-TYPE
       (WRAP-STRING (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
       NULL-STRING-WRAPPER))
     ((CL:EQ KEY KWD-CLASSES-CPP-NATIVE-TYPE)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-CPP-NATIVE-TYPE
       (WRAP-STRING (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
       NULL-STRING-WRAPPER))
     ((CL:EQ KEY KWD-CLASSES-IDL-NATIVE-TYPE)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-IDL-NATIVE-TYPE
       (WRAP-STRING (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
       NULL-STRING-WRAPPER))
     ((CL:EQ KEY KWD-CLASSES-JAVA-NATIVE-TYPE)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-JAVA-NATIVE-TYPE
       (WRAP-STRING (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
       NULL-STRING-WRAPPER))
     ((CL:EQ KEY KWD-CLASSES-PUBLIC?)
      (CL:SETF (%CLASS.CLASS-PUBLIC? CLASS)
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
     ((CL:EQ KEY KWD-CLASSES-ABSTRACT?)
      (CL:SETF (%CLASS.ABSTRACT? CLASS)
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
     ((CL:EQ KEY KWD-CLASSES-ACTIVE?)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-STORED-ACTIVE? VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-CL-STRUCT?)
      (CL:SETF (%CLASS.CL-STRUCT? CLASS)
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
     ((CL:EQ KEY KWD-CLASSES-MIXIN?)
      (CL:SETF (%CLASS.MIXIN? CLASS)
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
      (CL:WHEN (%CLASS.MIXIN? CLASS)
       (CL:SETF (%CLASS.ABSTRACT? CLASS) CL:T)))
     ((CL:EQ KEY KWD-CLASSES-RECYCLE-METHOD)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-RECYCLE-METHOD VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-EXTENSION)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-EXTENSION-NAME VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-CREATOR)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-CREATOR VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-INITIALIZER)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-INITIALIZER VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-TERMINATOR)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-TERMINATOR VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-DESTRUCTOR)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-DESTRUCTOR VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-INITIAL-VALUE)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-INITIAL-VALUE VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-PRINT-FORM)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-PRINT-FORM VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-EQUALITY-TEST))
     ((CL:EQ KEY KWD-CLASSES-KEY)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-KEY (NEW-LIST) NULL)
      (CL:LET*
       ((SLOTNAME NULL) (ITER-001 VALUE) (INTO-000 (CLASS-KEY CLASS))
        (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ SLOTNAME (%%VALUE ITER-001))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS SLOTNAME NIL))
          (CL:IF (CL:EQ (%LIST.THE-CONS-LIST INTO-000) NIL)
           (CL:SETF (%LIST.THE-CONS-LIST INTO-000) COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST INTO-000)
            COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS SLOTNAME NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
        (CL:SETQ ITER-001 (%%REST ITER-001)))))
     ((CL:EQ KEY KWD-CLASSES-PARAMETERS)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-PARAMETERS (NEW-LIST) NULL)
      (CL:LET*
       ((SLOT NULL) (ITER-002 (%LIST.THE-CONS-LIST VALUE))
        (INTO-001 (CLASS-PARAMETERS CLASS)) (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ SLOT (%%VALUE ITER-002))
        (CL:IF (CL:EQ COLLECT-001 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-001 (CONS (%SLOT.SLOT-NAME SLOT) NIL))
          (CL:IF (CL:EQ (%LIST.THE-CONS-LIST INTO-001) NIL)
           (CL:SETF (%LIST.THE-CONS-LIST INTO-001) COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST INTO-001)
            COLLECT-001)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-001)
           (CONS (%SLOT.SLOT-NAME SLOT) NIL))
          (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
        (CL:SETQ ITER-002 (%%REST ITER-002)))))
     ((CL:EQ KEY KWD-CLASSES-SYNONYMS)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-SYNONYMS (NEW-LIST) NULL)
      (CL:LET*
       ((TYPE NULL) (ITER-003 VALUE) (INTO-002 (CLASS-SYNONYMS CLASS))
        (COLLECT-002 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
        (CL:SETQ TYPE (%%VALUE ITER-003))
        (CL:IF (CL:EQ COLLECT-002 NULL)
         (CL:PROGN (CL:SETQ COLLECT-002 (CONS TYPE NIL))
          (CL:IF (CL:EQ (%LIST.THE-CONS-LIST INTO-002) NIL)
           (CL:SETF (%LIST.THE-CONS-LIST INTO-002) COLLECT-002)
           (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST INTO-002)
            COLLECT-002)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-002) (CONS TYPE NIL))
          (CL:SETQ COLLECT-002 (%%REST COLLECT-002))))
        (CL:SETQ ITER-003 (%%REST ITER-003)))))
     ((CL:EQ KEY KWD-CLASSES-PROPERTIES)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-PROPERTIES VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-META-ATTRIBUTES)
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-META-ATTRIBUTES VALUE NULL))
     ((CL:EQ KEY KWD-CLASSES-CHILDREN)
      (CL:SETF (%CLASS.CLASS-DIRECT-SUBS CLASS) VALUE)
      (PUSH *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES* CLASS))
     (CL:T
      (CL:WHEN (CL:NOT (RUN-OPTION-HANDLER? CLASS KEY VALUE))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-WARNING)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
         (%%PRINT-STREAM
          (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING) EOL
          " Skipping invalid class option `" (DE-UGLIFY-PARSE-TREE KEY)
          "'" EOL "in the definition of class `" (CLASS-SYMBOL CLASS)
          "'." EOL))))))))
  :VOID)

;;; (DEFUN (INLINE-METHOD? BOOLEAN) ...)

(CL:DEFUN INLINE-METHOD? (SLOT)
  (CL:RETURN-FROM INLINE-METHOD?
   (CL:AND (CL:NOT (%SLOT.SLOT-EXTERNAL? SLOT))
    (ISA? SLOT SGT-CLASSES-STELLA-METHOD-SLOT)
    (CL:NOT (%METHOD-SLOT.METHOD-FUNCTION? SLOT)))))

;;; (DEFUN TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS ...)

(CL:DEFUN TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS (EXTERNALSLOT NEWCLASS)
  (CL:LET*
   ((NEWCLASSSLOT
     (LOOKUP-LOCAL-SLOT NEWCLASS (%SLOT.SLOT-NAME EXTERNALSLOT))))
   (CL:COND
    ((CL:EQ NEWCLASSSLOT NULL)
     (INSERT (%CLASS.CLASS-LOCAL-SLOTS NEWCLASS) EXTERNALSLOT))
    ((CL:OR (INLINE-METHOD? NEWCLASSSLOT)
      (CL:NOT
       (CL:EQ (PRIMARY-TYPE NEWCLASSSLOT) (PRIMARY-TYPE EXTERNALSLOT)))
      CL:NIL))
    (CL:T
     (SUBSTITUTE (%CLASS.CLASS-LOCAL-SLOTS NEWCLASS) EXTERNALSLOT
      NEWCLASSSLOT)
     (FREE NEWCLASSSLOT))))
  :VOID)

;;; (DEFUN TRANSFER-DEMONS-FROM-OLDCLASS ...)

(CL:DEFUN TRANSFER-DEMONS-FROM-OLDCLASS (OLDCLASS NEWCLASS)
  (CL:LET* ((NEWSLOT NULL))
   (CL:LET*
    ((OLDSLOT NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS OLDCLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ OLDSLOT (%%VALUE ITER-000))
     (CL:LET* ()
      (CL:SETQ NEWSLOT
       (LOOKUP-LOCAL-SLOT NEWCLASS (%SLOT.SLOT-NAME OLDSLOT)))
      (CL:WHEN (CL:NOT (CL:EQ NEWSLOT NULL))
       (CL:COND
        ((SUBTYPE-OF-STORAGE-SLOT? (SAFE-PRIMARY-TYPE OLDSLOT))
         (CL:PROGN
          (CL:COND
           ((SUBTYPE-OF-STORAGE-SLOT? (SAFE-PRIMARY-TYPE NEWSLOT))
            (CL:PROGN
             (SET-DYNAMIC-SLOT-VALUE
              (%STORAGE-SLOT.DYNAMIC-SLOTS NEWSLOT)
              SYM-CLASSES-STELLA-SLOT-GUARD-DEMONS
              (SLOT-GUARD-DEMONS OLDSLOT) NULL)
             (SET-DYNAMIC-SLOT-VALUE
              (%STORAGE-SLOT.DYNAMIC-SLOTS OLDSLOT)
              SYM-CLASSES-STELLA-SLOT-GUARD-DEMONS NULL NULL)
             (SET-DYNAMIC-SLOT-VALUE
              (%STORAGE-SLOT.DYNAMIC-SLOTS NEWSLOT)
              SYM-CLASSES-STELLA-SLOT-DEMONS (SLOT-DEMONS OLDSLOT)
              NULL)
             (SET-DYNAMIC-SLOT-VALUE
              (%STORAGE-SLOT.DYNAMIC-SLOTS OLDSLOT)
              SYM-CLASSES-STELLA-SLOT-DEMONS NULL NULL)))
           (CL:T))))
        (CL:T))))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS NEWCLASS)
   SYM-CLASSES-STELLA-CLASS-CONSTRUCTOR-DEMONS
   (CLASS-CONSTRUCTOR-DEMONS OLDCLASS) NULL)
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS OLDCLASS)
   SYM-CLASSES-STELLA-CLASS-CONSTRUCTOR-DEMONS NULL NULL)
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS NEWCLASS)
   SYM-CLASSES-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS
   (CLASS-GUARD-CONSTRUCTOR-DEMONS OLDCLASS) NULL)
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS OLDCLASS)
   SYM-CLASSES-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS NULL NULL)
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS NEWCLASS)
   SYM-CLASSES-STELLA-CLASS-DESTRUCTOR-DEMONS
   (CLASS-DESTRUCTOR-DEMONS OLDCLASS) NULL)
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS OLDCLASS)
   SYM-CLASSES-STELLA-CLASS-DESTRUCTOR-DEMONS NULL NULL)
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS NEWCLASS)
   SYM-CLASSES-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS
   (CLASS-GUARD-DESTRUCTOR-DEMONS OLDCLASS) NULL)
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS OLDCLASS)
   SYM-CLASSES-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS NULL NULL)
  :VOID)

;;; (DEFUN UNDEFINE-OLD-CLASS ...)

(CL:DEFUN UNDEFINE-OLD-CLASS (OLDCLASS NEWCLASS)
  (CL:LET*
   ((NEWSUBS
     (COPY-CONS-LIST
      (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUBS NEWCLASS)))))
   (UNFINALIZE-CLASS-AND-SUBCLASSES OLDCLASS)
   (FORGET-UNFINALIZED-CLASS OLDCLASS)
   (CL:LET*
    ((OLDSUB NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUBS OLDCLASS)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ OLDSUB (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS OLDSUB NIL))
       (CL:IF (CL:EQ NEWSUBS NIL) (CL:SETQ NEWSUBS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST NEWSUBS COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS OLDSUB NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CLEAR (%CLASS.CLASS-DIRECT-SUBS NEWCLASS))
   (CL:SETF (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUBS NEWCLASS))
    (REMOVE-DUPLICATES NEWSUBS))
   (CLEAR (%CLASS.CLASS-DIRECT-SUBS OLDCLASS)))
  (CL:LET* ((TAXONOMYNODE (%CLASS.CLASS-TAXONOMY-NODE OLDCLASS)))
   (CL:LET*
    ((SUPER NULL)
     (ITER-001
      (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS OLDCLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ SUPER (%%VALUE ITER-001))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUPER) NULL))
       (CL:NOT (MEMBER? (%CLASS.CLASS-DIRECT-SUPERS NEWCLASS) SUPER)))
      (UNLINK-TAXONOMY-NODES *CLASS-TAXONOMY-GRAPH*
       (%CLASS.CLASS-TAXONOMY-NODE (%SURROGATE.SURROGATE-VALUE SUPER))
       TAXONOMYNODE))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:SETF (%CLASS.CLASS-TAXONOMY-NODE NEWCLASS) TAXONOMYNODE)
   (CL:SETF (%CLASS.CLASS-TAXONOMY-NODE OLDCLASS) NULL))
  (CL:LET*
   ((OLDSLOT NULL)
    (ITER-002
     (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS OLDCLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
    (CL:SETQ OLDSLOT (%%VALUE ITER-002))
    (CL:WHEN (%SLOT.SLOT-EXTERNAL? OLDSLOT)
     (TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS OLDSLOT NEWCLASS))
    (CL:SETQ ITER-002 (%%REST ITER-002))))
  (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE NEWCLASS)
   (%CLASS.CLASS-CONSTRUCTOR-CODE OLDCLASS))
  (TRANSFER-DEMONS-FROM-OLDCLASS OLDCLASS NEWCLASS)
  (RUN-HOOKS *REDEFINE-RELATION-HOOKS* (LIST OLDCLASS NEWCLASS))
  (FREE OLDCLASS)
  :VOID)

;;; (DEFMETHOD DESTROY-CLASS ...)

(CL:DEFMETHOD DESTROY-CLASS ((SELF CLASS))
  "Destroy the Stella class `self'.  
Unfinalize its subclasses (if it has any)."
  (CL:WHEN (DELETED? SELF) (CL:RETURN-FROM DESTROY-CLASS))
  (CL:WHEN
   (CL:EQ (%SURROGATE.HOME-CONTEXT (%CLASS.CLASS-TYPE SELF))
    *STELLA-MODULE*)
   (CL:WARN "Can't delete STELLA class `~A'." (CLASS-NAME SELF))
   (CL:RETURN-FROM DESTROY-CLASS))
  (UNFINALIZE-CLASS-AND-SUBCLASSES SELF)
  (UNBIND-FROM-SURROGATE SELF)
  (CL:WHEN (CL:NOT (CL:EQ (%CLASS.CLASS-TAXONOMY-NODE SELF) NULL))
   (REMOVE-TAXONOMY-NODE *CLASS-TAXONOMY-GRAPH*
    (%CLASS.CLASS-TAXONOMY-NODE SELF)))
  (DELETED?-SETTER SELF CL:T)
  (FREE SELF)
  :VOID)

;;; (DEFMETHOD DESTROY-CLASS ...)

(CL:DEFMETHOD DESTROY-CLASS ((SELF SURROGATE))
  (CL:LET* ((CLASS (%SURROGATE.SURROGATE-VALUE SELF)))
   (CL:IF (CL:EQ CLASS NULL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Can't destroy non-existent class `" SELF "'." EOL)
    (DESTROY-CLASS CLASS)))
  :VOID)

;;; (DEFUN DESTROY-CLASS-AND-SUBCLASSES ...)

(CL:DEFUN DESTROY-CLASS-AND-SUBCLASSES (SELF)
  "Destroy the Stella class `self' and all its subclasses."
  (CL:LET*
   ((SUBTYPE NULL)
    (ITER-000 (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUBS SELF))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ SUBTYPE (%%VALUE ITER-000))
    (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUBTYPE) NULL))
     (DESTROY-CLASS-AND-SUBCLASSES
      (%SURROGATE.SURROGATE-VALUE SUBTYPE)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (DESTROY-CLASS SELF)
  :VOID)

;;; (DEFMETHOD (PRIMITIVE? BOOLEAN) ...)

(CL:DEFMETHOD PRIMITIVE? ((SELF RELATION))
  "Return `true' if `self' is not a defined relation."
  (CL:RETURN-FROM PRIMITIVE? CL:T))

;;; (DEFUN INSERT-PRIMITIVE-SUPER ...)

(CL:DEFUN INSERT-PRIMITIVE-SUPER (NEWSUPER SUPERS)
  (CL:LET* ((FOUND?-000 CL:NIL))
   (CL:LET* ((SUP NULL) (ITER-000 (%LIST.THE-CONS-LIST SUPERS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUP (%%VALUE ITER-000))
     (CL:WHEN (SUBTYPE-OF? NEWSUPER SUP) (CL:SETQ FOUND?-000 CL:T)
      (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:NOT FOUND?-000)
    (CL:LET* ((SUBSUMEDSUPER NULL))
     (CL:LOOP
      (CL:LET* ()
       (CL:LET* ((VALUE-000 NULL))
        (CL:LET* ((SUP NULL) (ITER-001 (%LIST.THE-CONS-LIST SUPERS)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ SUP (%%VALUE ITER-001))
          (CL:WHEN (SUBTYPE-OF? SUP NEWSUPER) (CL:SETQ VALUE-000 SUP)
           (CL:RETURN))
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:SETQ SUBSUMEDSUPER VALUE-000))
       (CL:WHEN (CL:EQ SUBSUMEDSUPER NULL) (CL:RETURN)))
      (CL:SETQ SUPERS (REMOVE SUPERS SUBSUMEDSUPER)))
     (INSERT SUPERS NEWSUPER))))
  :VOID)

;;; (DEFUN COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS ...)

(CL:DEFUN COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS (CLASS SUPERS)
  (CL:LET*
   ((SUPER NULL)
    (ITER-000
     (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS CLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ SUPER (%%VALUE ITER-000))
    (CL:IF (PRIMITIVE? (TYPE-TO-CLASS SUPER))
     (INSERT-PRIMITIVE-SUPER SUPER SUPERS)
     (COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS (TYPE-TO-CLASS SUPER)
      SUPERS))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

;;; (DEFUN (MOST-SPECIFIC-PRIMITIVE-SUPERS (LIST OF TYPE)) ...)

(CL:DEFUN MOST-SPECIFIC-PRIMITIVE-SUPERS (CLASS)
  (CL:LET* ((SUPERS (NEW-LIST)))
   (COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS CLASS SUPERS)
   (CL:RETURN-FROM MOST-SPECIFIC-PRIMITIVE-SUPERS (REVERSE SUPERS))))

;;; (DEFUN (CLASS-NATIVE-SUPERS (LIST OF TYPE)) ...)

(CL:DEFUN CLASS-NATIVE-SUPERS (CLASS)
  (CL:LET* ((ALWAYS?-000 CL:T))
   (CL:LET*
    ((SUPER NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS CLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPER (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (PRIMITIVE? (TYPE-TO-CLASS SUPER)))
      (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:IF ALWAYS?-000
    (CL:RETURN-FROM CLASS-NATIVE-SUPERS
     (%CLASS.CLASS-DIRECT-SUPERS CLASS))
    (CL:RETURN-FROM CLASS-NATIVE-SUPERS
     (MOST-SPECIFIC-PRIMITIVE-SUPERS CLASS)))))

;;; (DEFGLOBAL *UNFINALIZED-CLASSES* ...)

(CL:DEFVAR *UNFINALIZED-CLASSES* NULL
  "List of classes whose class or slot inheritance is
currently unfinalized.")

;;; (DEFGLOBAL *NEWLY-UNFINALIZED-CLASSES?* ...)

(CL:DEFVAR *NEWLY-UNFINALIZED-CLASSES?* CL:NIL
  "Set to `true' by `remember-unfinalized-class'; set
to `false' by `cleanup-unfinalized-classes'.  Minimizes the time that
`finalize-classes' spends searching for classes to finalize.")

;;; (DEFGLOBAL *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES* ...)

(CL:DEFVAR *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES* NULL
  "List of classes defined with a :children option
which still have some of their children references unresolved.")

;;; (DEFUN REMEMBER-UNFINALIZED-CLASS ...)

(CL:DEFUN REMEMBER-UNFINALIZED-CLASS (CLASS FORCE?)
  (CL:WHEN
   (CL:OR FORCE?
    (CL:AND (%CLASS.CLASS-FINALIZED? CLASS)
     (%CLASS.CLASS-SLOTS-FINALIZED? CLASS)))
   (PUSH *UNFINALIZED-CLASSES* CLASS)
   (CL:SETQ *NEWLY-UNFINALIZED-CLASSES?* CL:T))
  :VOID)

;;; (DEFUN FORGET-UNFINALIZED-CLASS ...)

(CL:DEFUN FORGET-UNFINALIZED-CLASS (CLASS)
  (CL:WHEN
   (CL:NOT
    (CL:AND (%CLASS.CLASS-FINALIZED? CLASS)
     (%CLASS.CLASS-SLOTS-FINALIZED? CLASS)))
   (REMOVE *UNFINALIZED-CLASSES* CLASS))
  :VOID)

;;; (DEFUN FINALIZE-CLASSES ...)

(CL:DEFUN FINALIZE-CLASSES ()
  "Finalize all currently unfinalized classes."
  (CL:WHEN (CL:NOT *NEWLY-UNFINALIZED-CLASSES?*)
   (CL:RETURN-FROM FINALIZE-CLASSES))
  (CL:LET* ((HIERARCHYMIGHTHAVECHANGED? CL:NIL))
   (REMOVE-DELETED-MEMBERS *UNFINALIZED-CLASSES*)
   (RESOLVE-CHILDREN-REFERENCES)
   (CL:LET*
    ((CLASS NULL)
     (ITER-000 (%LIST.THE-CONS-LIST *UNFINALIZED-CLASSES*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLASS (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (%CLASS.CLASS-FINALIZED? CLASS))
       (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (BAD? CLASS))))
      (FINALIZE-CLASS CLASS) (CL:SETQ HIERARCHYMIGHTHAVECHANGED? CL:T))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN HIERARCHYMIGHTHAVECHANGED?
    (FINALIZE-TAXONOMY-GRAPH *CLASS-TAXONOMY-GRAPH*)))
  :VOID)

;;; (DEFUN RESOLVE-CHILDREN-REFERENCES ...)

(CL:DEFUN RESOLVE-CHILDREN-REFERENCES ()
  (CL:WHEN
   (CL:OR (EMPTY? *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES*)
    (EMPTY? *UNFINALIZED-CLASSES*))
   (CL:RETURN-FROM RESOLVE-CHILDREN-REFERENCES))
  (CL:LET* ((UNRESOLVABLECLASSES NIL))
   (REMOVE-DELETED-MEMBERS
    *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES*)
   (CL:LET*
    ((CLASS NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST
       *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLASS (%%VALUE ITER-000))
     (ADD-DIRECT-SUBS-BACK-LINKS CLASS)
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((SUB NULL)
        (ITER-001
         (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUBS CLASS))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ SUB (%%VALUE ITER-001))
        (CL:WHEN (CL:EQ (TYPE-TO-CLASS SUB) NULL)
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CL:WHEN FOUND?-000
       (CL:SETQ UNRESOLVABLECLASSES (CONS CLASS UNRESOLVABLECLASSES))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CLEAR *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES*)
   (CL:SETF
    (%LIST.THE-CONS-LIST *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES*)
    UNRESOLVABLECLASSES))
  :VOID)

;;; (DEFUN FINALIZE-SLOTS ...)

(CL:DEFUN FINALIZE-SLOTS ()
  "Finalize all currently unfinalized slots."
  (CL:WHEN (CL:NOT *NEWLY-UNFINALIZED-CLASSES?*)
   (CL:RETURN-FROM FINALIZE-SLOTS))
  (CL:LET*
   ((CLASS NULL)
    (ITER-000 (%LIST.THE-CONS-LIST *UNFINALIZED-CLASSES*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ CLASS (%%VALUE ITER-000))
    (CL:WHEN
     (CL:AND (%CLASS.CLASS-FINALIZED? CLASS)
      (CL:NOT (%CLASS.CLASS-SLOTS-FINALIZED? CLASS))
      (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (BAD? CLASS))))
     (FINALIZE-CLASS-SLOTS CLASS))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

;;; (DEFUN CLEANUP-UNFINALIZED-CLASSES ...)

(CL:DEFUN CLEANUP-UNFINALIZED-CLASSES ()
  "Remove all finalized classes from `*UNFINALIZED-CLASSES*',
and set `*NEWLY-UNFINALIZED-CLASSES?*' to `false'."
  (CL:LET* ((UNFINALIZEDCLASSES NIL))
   (CL:LET*
    ((CLASS NULL)
     (ITER-000 (%LIST.THE-CONS-LIST *UNFINALIZED-CLASSES*))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLASS (%%VALUE ITER-000))
     (CL:WHEN
      (CL:OR (CL:NOT (%CLASS.CLASS-FINALIZED? CLASS))
       (CL:NOT (%CLASS.CLASS-SLOTS-FINALIZED? CLASS)))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS CLASS NIL))
        (CL:IF (CL:EQ UNFINALIZEDCLASSES NIL)
         (CL:SETQ UNFINALIZEDCLASSES COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST UNFINALIZEDCLASSES
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS CLASS NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CLEAR *UNFINALIZED-CLASSES*)
   (CL:SETF (%LIST.THE-CONS-LIST *UNFINALIZED-CLASSES*)
    UNFINALIZEDCLASSES)
   (CL:SETQ *NEWLY-UNFINALIZED-CLASSES?* CL:NIL))
  :VOID)

;;; (DEFUN FINALIZE-CLASSES-AND-SLOTS ...)

(CL:DEFUN FINALIZE-CLASSES-AND-SLOTS ()
  "Finalize all currently unfinalized classes and slots."
  (FINALIZE-CLASSES)
  (FINALIZE-SLOTS)
  (CLEANUP-UNFINALIZED-CLASSES)
  :VOID)

;;; (DEFUN ACTIVATE-CLASS ...)

(CL:DEFUN ACTIVATE-CLASS (CLASS)
  (CL:LET*
   ((ACTIVEOBJECTCLASS
     (TYPE-TO-CLASS SGT-CLASSES-STELLA-ACTIVE-OBJECT))
    (SUPERS (%CLASS.CLASS-DIRECT-SUPERS CLASS)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ ACTIVEOBJECTCLASS NULL))
     (SUBCLASS-OF? CLASS ACTIVEOBJECTCLASS))
    (CL:RETURN-FROM ACTIVATE-CLASS))
   (CL:COND
    ((CL:= (LENGTH SUPERS) 0)
     (INSERT SUPERS SGT-CLASSES-STELLA-ACTIVE-OBJECT))
    ((CL:AND (CL:= (LENGTH SUPERS) 1)
      (CL:OR (CL:EQ (FIRST SUPERS) SGT-CLASSES-STELLA-OBJECT)
       (CL:EQ (FIRST SUPERS) SGT-CLASSES-STELLA-STANDARD-OBJECT)))
     (REMOVE-DIRECT-SUPERS-BACK-LINKS CLASS) (CLEAR SUPERS)
     (INSERT SUPERS SGT-CLASSES-STELLA-ACTIVE-OBJECT))
    (CL:T
     (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
      SYM-CLASSES-STELLA-STORED-ACTIVE? FALSE-WRAPPER NULL)
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
         SYM-CLASSES-STELLA-CLASS-EXTENSION-NAME NULL)
        NULL))
      (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-EXTENSION-NAME NULL NULL))
     (CL:WARN
      "Cannot convert `~A' into an ACTIVE-OBJECT.~%You have to modify its superclasses by hand."
      CLASS)
     (CL:RETURN-FROM ACTIVATE-CLASS)))
   (ADD-DIRECT-SUPERS-BACK-LINKS CLASS) (INHERIT-SUPERCLASSES CLASS))
  :VOID)

;;; (DEFUN ADD-PRIMARY-TYPE ...)

(CL:DEFUN ADD-PRIMARY-TYPE (CLASS)
  (CL:LET* ((CLASSTYPE (%CLASS.CLASS-TYPE CLASS)) (SLOTTREE NULL))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000 (CL:NOT (%CLASS.ABSTRACT? CLASS)))
    (CL:WHEN TEST-VALUE-000
     (CL:SETQ TEST-VALUE-000
      (SUBTYPE-OF? CLASSTYPE SGT-CLASSES-STELLA-OBJECT))
     (CL:WHEN TEST-VALUE-000
      (CL:LET* ((FOUND?-000 CL:NIL))
       (CL:LET*
        ((SLOT NULL)
         (ITER-000
          (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ SLOT (%%VALUE ITER-000))
         (CL:WHEN
          (CL:EQ (%SLOT.SLOT-NAME SLOT)
           SYM-CLASSES-STELLA-PRIMARY-TYPE)
          (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:SETQ TEST-VALUE-000 FOUND?-000))
      (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))))
    (CL:WHEN TEST-VALUE-000
     (CL:SETQ SLOTTREE
      (LIST*
       (CONS
        (LIST* SYM-CLASSES-STELLA-SELF
         (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME CLASSTYPE)
          (%SURROGATE.HOME-CONTEXT CLASSTYPE) CL:T)
         NIL)
        NIL)
       KWD-CLASSES-TYPE SYM-CLASSES-STELLA-TYPE KWD-CLASSES-AUXILIARY?
       SYM-CLASSES-STELLA-TRUE
       (LIST* SYM-CLASSES-STELLA-RETURN CLASSTYPE NIL) NIL))
     (PUSH (%CLASS.CLASS-LOCAL-SLOTS CLASS)
      (DEFINE-INLINE-METHOD SYM-CLASSES-STELLA-PRIMARY-TYPE
       SLOTTREE)))))
  :VOID)

;;; (DEFUN FINALIZE-ONE-CLASS ...)

(CL:DEFUN FINALIZE-ONE-CLASS (CLASS)
  (CL:LET* ((*MODULE* (HOME-MODULE CLASS)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-EXTENSION-NAME NULL)
      NULL))
    (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
     SYM-CLASSES-STELLA-STORED-ACTIVE? TRUE-WRAPPER NULL))
   (ADD-DIRECT-SUPERS-BACK-LINKS CLASS) (INHERIT-SUPERCLASSES CLASS)
   (CL:WHEN
    (CL:AND
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
        SYM-CLASSES-STELLA-STORED-ACTIVE? NULL)
       NULL))
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
      (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-STORED-ACTIVE? NULL)))
    (ACTIVATE-CLASS CLASS))
   (ADD-PRIMARY-TYPE CLASS)
   (CL:LET*
    ((ALIAS NULL)
     (ITER-000 (%LIST.THE-CONS-LIST (CLASS-SYNONYMS CLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ALIAS (%%VALUE ITER-000))
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE ALIAS) NULL))
       (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE ALIAS) CLASS))
       (CL:NOT
        (STRING-EQL? (CLASS-NAME (%SURROGATE.SURROGATE-VALUE ALIAS))
         (CLASS-NAME CLASS))))
      (CL:WARN
       "Alias `~A' can't point to `~A' because it already points to ~%the class `~A'."
       (INTERN-SYMBOL-IN-MODULE (%SURROGATE.SYMBOL-NAME ALIAS)
        (%SURROGATE.HOME-CONTEXT ALIAS) CL:T)
       (CLASS-SYMBOL CLASS)
       (CLASS-SYMBOL (%SURROGATE.SURROGATE-VALUE ALIAS)))
      (CL:SETF (%SURROGATE.SURROGATE-VALUE ALIAS) CLASS))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN
    (CL:AND
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
        SYM-CLASSES-STELLA-CLASS-EXTENSION-NAME NULL)
       NULL))
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
       SYM-CLASSES-STELLA-CLASS-EXTENSION NULL)
      NULL))
    (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
     SYM-CLASSES-STELLA-CLASS-EXTENSION (NEW-CLASS-EXTENSION) NULL))
   (RUN-HOOKS *FINALIZE-RELATION-HOOKS* CLASS)
   (CL:SETF (%CLASS.CLASS-FINALIZED? CLASS) CL:T))
  :VOID)

;;; (DEFUN (FINALIZE-CLASS BOOLEAN) ...)

(CL:DEFUN FINALIZE-CLASS (CLASS)
  (CL:RETURN-FROM FINALIZE-CLASS (HELP-FINALIZE-CLASS CLASS NULL)))

;;; (DEFUN (HELP-FINALIZE-CLASS BOOLEAN) ...)

(CL:DEFUN HELP-FINALIZE-CLASS (CLASS FINALIZEDPARENT)
  (CL:WHEN (%CLASS.CLASS-FINALIZED? CLASS)
   (CL:RETURN-FROM HELP-FINALIZE-CLASS CL:T))
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
   SYM-CLASSES-STELLA-BAD? TRUE-WRAPPER NULL)
  (CL:LET*
   ((SUPER NULL)
    (ITER-000
     (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS CLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ SUPER (%%VALUE ITER-000))
    (CL:WHEN (CL:NOT (CL:EQ SUPER FINALIZEDPARENT))
     (CL:LET* ((SUPERCLASS (TYPE-TO-CLASS SUPER)))
      (CL:IF (CL:NOT (CL:EQ SUPERCLASS NULL))
       (CL:WHEN (CL:NOT (HELP-FINALIZE-CLASS SUPERCLASS NULL))
        (CL:RETURN-FROM HELP-FINALIZE-CLASS CL:NIL))
       (CL:RETURN-FROM HELP-FINALIZE-CLASS CL:NIL))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:WHEN (%CLASS.CLASS-FINALIZED? CLASS)
   (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
    SYM-CLASSES-STELLA-BAD? NULL NULL)
   (CL:RETURN-FROM HELP-FINALIZE-CLASS CL:T))
  (FINALIZE-ONE-CLASS CLASS)
  (CL:LET*
   ((SUB NULL)
    (ITER-001 (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUBS CLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ SUB (%%VALUE ITER-001))
    (CL:LET* ((SUBCLASS (TYPE-TO-CLASS SUB)))
     (CL:WHEN (CL:NOT (CL:EQ SUBCLASS NULL))
      (HELP-FINALIZE-CLASS SUBCLASS (%CLASS.CLASS-TYPE CLASS))))
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
   SYM-CLASSES-STELLA-BAD? NULL NULL)
  (CL:RETURN-FROM HELP-FINALIZE-CLASS CL:T))

;;; (DEFUN UNFINALIZE-CLASS-AND-SUBCLASSES ...)

(CL:DEFUN UNFINALIZE-CLASS-AND-SUBCLASSES (CLASS)
  (CL:WHEN (CL:NOT (%CLASS.CLASS-FINALIZED? CLASS))
   (CL:RETURN-FROM UNFINALIZE-CLASS-AND-SUBCLASSES))
  (REMOVE-DIRECT-SUPERS-BACK-LINKS CLASS)
  (CL:LET* ((SUBS (COPY (%CLASS.CLASS-DIRECT-SUBS CLASS))))
   (CL:LET* ((SUBTYPE NULL) (ITER-000 (%LIST.THE-CONS-LIST SUBS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUBTYPE (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUBTYPE) NULL))
      (UNFINALIZE-CLASS-AND-SUBCLASSES
       (%SURROGATE.SURROGATE-VALUE SUBTYPE)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (FREE SUBS))
  (CL:LET*
   ((ALIAS NULL)
    (ITER-001 (%LIST.THE-CONS-LIST (CLASS-SYNONYMS CLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ ALIAS (%%VALUE ITER-001))
    (CL:WHEN (CL:EQ (%SURROGATE.SURROGATE-VALUE ALIAS) CLASS)
     (CL:SETF (%SURROGATE.SURROGATE-VALUE ALIAS) NULL))
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  (UNINHERIT-SUPERCLASSES CLASS)
  (UNFINALIZE-CLASS-SLOTS CLASS)
  (REMEMBER-UNFINALIZED-CLASS CLASS CL:NIL)
  (CL:SETF (%CLASS.CLASS-FINALIZED? CLASS) CL:NIL)
  :VOID)

;;; (DEFUN (ATTACH-SLOT-TO-OWNER SLOT) ...)

(CL:DEFUN ATTACH-SLOT-TO-OWNER (NEWSLOT)
  (CL:LET*
   ((NAME (%SLOT.SLOT-NAME NEWSLOT))
    (OWNERCLASS
     (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-OWNER NEWSLOT)))
    (OLDSLOT (LOOKUP-LOCAL-SLOT OWNERCLASS NAME)))
   (CL:SETF (%SLOT.SLOT-EXTERNAL? NEWSLOT) CL:T)
   (REGISTER-SLOT-NAME NEWSLOT)
   (CL:COND
    ((CL:EQ OLDSLOT NULL)
     (INSERT (%CLASS.CLASS-LOCAL-SLOTS OWNERCLASS) NEWSLOT)
     (UNFINALIZE-CLASS-SLOTS OWNERCLASS)
     (CL:RETURN-FROM ATTACH-SLOT-TO-OWNER NEWSLOT))
    ((CL:NOT (LOCAL-SLOT? OLDSLOT OWNERCLASS))
     (INSERT (%CLASS.CLASS-LOCAL-SLOTS OWNERCLASS) NEWSLOT)
     (UNFINALIZE-CLASS-SLOTS OWNERCLASS)
     (CL:RETURN-FROM ATTACH-SLOT-TO-OWNER NEWSLOT))
    ((CL:NOT (CL:EQ (PRIMARY-TYPE NEWSLOT) (PRIMARY-TYPE OLDSLOT)))
     (CL:WARN
      "Can't define a `~A' named `~A' on the class `~A'~%because it already has a `~A' with the same name."
      (PRIMARY-TYPE NEWSLOT) NAME (CLASS-NAME OWNERCLASS)
      (PRIMARY-TYPE OLDSLOT))
     (CL:RETURN-FROM ATTACH-SLOT-TO-OWNER NULL))
    (CL:T
     (SUBSTITUTE (%CLASS.CLASS-LOCAL-SLOTS OWNERCLASS) NEWSLOT OLDSLOT)
     (RUN-HOOKS *REDEFINE-RELATION-HOOKS* (LIST OLDSLOT NEWSLOT))
     (FREE OLDSLOT) (HELP-UNFINALIZE-CLASS-SLOTS OWNERCLASS)
     (CL:RETURN-FROM ATTACH-SLOT-TO-OWNER NEWSLOT)))))

;;; (DEFUN COMPUTE-SLOT-DIRECT-EQUIVALENT ...)

(CL:DEFUN COMPUTE-SLOT-DIRECT-EQUIVALENT (SELF)
  (CL:LET*
   ((CLASS (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-OWNER SELF)))
    (SLOTNAME (%SLOT.SLOT-NAME SELF))
    (SLOTRENAMES
     (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
      SYM-CLASSES-STELLA-SLOT-RENAMES NULL))
    (RENAMESSLOT NULL))
   (CL:COND
    ((CL:NOT (CL:EQ SLOTRENAMES NULL))
     (CL:LET* ((VALUE-000 NULL))
      (CL:LET* ((S NULL) (ITER-000 (CLASS-SLOTS CLASS)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ S (%ITERATOR.VALUE ITER-000))
        (CL:WHEN (CL:EQ (%SLOT.SLOT-NAME S) SLOTRENAMES)
         (CL:SETQ VALUE-000 S) (CL:RETURN))))
      (CL:SETQ RENAMESSLOT VALUE-000))
     (CL:COND
      ((CL:NOT (CL:EQ RENAMESSLOT NULL))
       (CL:SETF (%SLOT.SLOT-DIRECT-EQUIVALENT SELF) RENAMESSLOT)
       (CL:SETF (%SLOT.SLOT-RENAMED? RENAMESSLOT) CL:T))
      (CL:T
       (CL:WARN
        "Slot `~A' renames a non-existent self: `~A'.~%Cancelling the renames option."
        SLOTNAME SLOTRENAMES)
       (SET-DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
        SYM-CLASSES-STELLA-SLOT-RENAMES NULL NULL))))
    (CL:T
     (CL:LET* ((VALUE-001 NULL))
      (CL:LET* ((S NULL) (ITER-001 (CLASS-SLOTS CLASS)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO
        (CL:SETQ S (%ITERATOR.VALUE ITER-001))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ S SELF))
          (CL:EQ (%SLOT.SLOT-NAME S) SLOTNAME))
         (CL:SETQ VALUE-001 S) (CL:RETURN))))
      (CL:SETF (%SLOT.SLOT-DIRECT-EQUIVALENT SELF) VALUE-001)))))
  :VOID)

;;; (DEFUN CHECK-CONFORMANCE-OF-SLOT-SIGNATURE ...)

(CL:DEFUN CHECK-CONFORMANCE-OF-SLOT-SIGNATURE (SELF)
  (CL:LET* ((EQUIVALENTSLOT (%SLOT.SLOT-DIRECT-EQUIVALENT SELF)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ EQUIVALENTSLOT NULL))
     (CL:NOT (CONFORMING-SIGNATURES? SELF EQUIVALENTSLOT)))
    (CL:WARN
     "The signature of slot `~A' does not conform to the~%   signature of the inherited slot `~A'"
     SELF EQUIVALENTSLOT)))
  :VOID)

;;; (DEFUN (COLLECTION-TO-ACTIVE-COLLECTION TYPE) ...)

(CL:DEFUN COLLECTION-TO-ACTIVE-COLLECTION (TYPE)
  (CL:COND
   ((CL:OR (CL:EQ TYPE SGT-CLASSES-STELLA-SET)
     (CL:EQ TYPE SGT-CLASSES-STELLA-ACTIVE-SET))
    (CL:RETURN-FROM COLLECTION-TO-ACTIVE-COLLECTION
     SGT-CLASSES-STELLA-ACTIVE-SET))
   ((CL:OR (CL:EQ TYPE SGT-CLASSES-STELLA-LIST)
     (CL:EQ TYPE SGT-CLASSES-STELLA-ACTIVE-LIST))
    (CL:RETURN-FROM COLLECTION-TO-ACTIVE-COLLECTION
     SGT-CLASSES-STELLA-ACTIVE-LIST))
   (CL:T (CL:RETURN-FROM COLLECTION-TO-ACTIVE-COLLECTION NULL))))

;;; (DEFUN ACTIVATE-SLOT ...)

(CL:DEFUN ACTIVATE-SLOT (SELF)
  (CL:WHEN (COLLECTION-VALUED? SELF)
   (CL:LET*
    ((ACTIVECOLLECTION
      (COLLECTION-TO-ACTIVE-COLLECTION
       (%STORAGE-SLOT.SLOT-BASE-TYPE SELF))))
    (CL:WHEN (CL:EQ ACTIVECOLLECTION NULL)
     (CL:WARN
      "No active collection defined for `~A'.~%   Cannot activate slot `~A'."
      (%STORAGE-SLOT.SLOT-BASE-TYPE SELF) SELF)
     (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
      SYM-CLASSES-STELLA-STORED-ACTIVE? FALSE-WRAPPER NULL)
     (CL:RETURN-FROM ACTIVATE-SLOT))
    (CL:SETF (%STORAGE-SLOT.SLOT-BASE-TYPE SELF)
     (COLLECTION-TO-ACTIVE-COLLECTION
      (%STORAGE-SLOT.SLOT-BASE-TYPE SELF)))))
  (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
   SYM-CLASSES-STELLA-STORED-ACTIVE? TRUE-WRAPPER NULL)
  :VOID)

;;; (DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ...)

(CL:DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF SLOT))
  :VOID)

;;; (DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ...)

(CL:DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF STORAGE-SLOT))
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
      SYM-CLASSES-STELLA-SLOT-TYPE-SPECIFIER NULL)
     NULL))
   (CL:SETF (%STORAGE-SLOT.SLOT-BASE-TYPE SELF)
    (VALIDATE-TYPE-SPECIFIER
     (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
      SYM-CLASSES-STELLA-SLOT-TYPE-SPECIFIER NULL)
     (%SURROGATE.SURROGATE-VALUE (%STORAGE-SLOT.SLOT-OWNER SELF))
     CL:NIL)))
  (CL:WHEN (CL:EQ (%STORAGE-SLOT.SLOT-BASE-TYPE SELF) NULL)
   (CL:SETF (%STORAGE-SLOT.SLOT-BASE-TYPE SELF) (TYPE SELF)))
  (CL:WHEN (CL:EQ (%STORAGE-SLOT.SLOT-BASE-TYPE SELF) NULL)
   (CL:WHEN (CL:NOT (%STORAGE-SLOT.ABSTRACT? SELF))
    (CL:WARN "Missing type specification for the slot `~A'" SELF))
   (CL:SETF (%STORAGE-SLOT.SLOT-BASE-TYPE SELF)
    SGT-CLASSES-STELLA-UNKNOWN)
   (CL:RETURN-FROM FINALIZE-SLOT-TYPE-COMPUTATIONS))
  (CL:WHEN (ACTIVE? SELF) (ACTIVATE-SLOT SELF))
  :VOID)

;;; (DEFUN (MULTI-VALUED-SLOT-WITH-DUPLICATES? BOOLEAN) ...)

(CL:DEFUN MULTI-VALUED-SLOT-WITH-DUPLICATES? (SELF)
  (CL:RETURN-FROM MULTI-VALUED-SLOT-WITH-DUPLICATES?
   (CL:AND (SUBTYPE-OF? (TYPE SELF) SGT-CLASSES-STELLA-COLLECTION)
    (CL:NOT (SUBTYPE-OF? (TYPE SELF) SGT-CLASSES-STELLA-SET-MIXIN)))))

;;; (DEFUN COMPUTE-SLOT-INVERSES ...)

(CL:DEFUN COMPUTE-SLOT-INVERSES (SELF)
  (CL:WHEN
   (CL:EQ
    (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
     SYM-CLASSES-STELLA-SLOT-INVERSE NULL)
    NULL)
   (CL:RETURN-FROM COMPUTE-SLOT-INVERSES))
  (CL:WHEN (MULTI-VALUED-SLOT-WITH-DUPLICATES? SELF)
   (CL:WARN
    "Can't define an inverse on slot `~A' because it allows duplicate values."
    SELF)
   (SET-DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
    SYM-CLASSES-STELLA-SLOT-INVERSE NULL NULL)
   (CL:RETURN-FROM COMPUTE-SLOT-INVERSES))
  (CL:LET*
   ((INVERSECLASS (%SURROGATE.SURROGATE-VALUE (TYPE SELF)))
    (INVERSESLOT
     (LOOKUP-SLOT INVERSECLASS
      (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
       SYM-CLASSES-STELLA-SLOT-INVERSE NULL))))
   (CL:WHEN (CL:NOT (CL:EQ INVERSESLOT NULL))
    (CL:WHEN (MULTI-VALUED-SLOT-WITH-DUPLICATES? INVERSESLOT)
     (CL:WARN
      "Can't define an inverse on slot `~A' because it allows duplicate values."
      INVERSESLOT)
     (SET-DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
      SYM-CLASSES-STELLA-SLOT-INVERSE NULL NULL)
     (SET-DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS INVERSESLOT)
      SYM-CLASSES-STELLA-SLOT-INVERSE NULL NULL)
     (CL:RETURN-FROM COMPUTE-SLOT-INVERSES))
    (CL:WHEN (CL:NOT (ACTIVE? INVERSESLOT))
     (SET-DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS INVERSESLOT)
      SYM-CLASSES-STELLA-SLOT-INVERSE (%SLOT.SLOT-NAME SELF) NULL)
     (FINALIZE-SLOT-TYPE-COMPUTATIONS INVERSESLOT))
    (SET-DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS INVERSESLOT)
     SYM-CLASSES-STELLA-INVERSE SELF NULL)
    (ATTACH-INVERSE-SLOT-DEMON SELF)
    (SET-DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
     SYM-CLASSES-STELLA-INVERSE INVERSESLOT NULL)
    (ATTACH-INVERSE-SLOT-DEMON INVERSESLOT)
    (CL:RETURN-FROM COMPUTE-SLOT-INVERSES))
   (CL:IF (CL:EQ INVERSECLASS NULL)
    (CL:WARN
     "Can't finalize inverse slot computation for slot `~A'~% because the class `~A' is not defined."
     SELF (TYPE SELF))
    (CL:WARN
     "Can't finalize inverse slot computation for slot `~A'~% because the inverse slot `~A' does not exist."
     SELF
     (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SELF)
      SYM-CLASSES-STELLA-SLOT-INVERSE NULL))))
  :VOID)

;;; (DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF SLOT))
  :VOID)

;;; (DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF STORAGE-SLOT))
  (CL:LET*
   ((OWNER
     (%SURROGATE.SURROGATE-VALUE (%STORAGE-SLOT.SLOT-OWNER SELF))))
   (CL:WHEN
    (CL:AND (CL:EQ (ALLOCATION SELF) KWD-CLASSES-DYNAMIC)
     (CL:NOT
      (SUBTYPE-OF? (%CLASS.CLASS-TYPE OWNER)
       SGT-CLASSES-STELLA-DYNAMIC-SLOTS-MIXIN))
     (CL:NOT (%CLASS.ABSTRACT? OWNER)))
    (CL:WARN
     "Slot `~A' on the class `~A'~%   can't have :dynamic slot allocation because the class doesn't~%   inherit the class `DYNAMIC-SLOTS-MIXIN'.  Resetting the~%   allocation to ':instance'."
     (%STORAGE-SLOT.SLOT-NAME SELF) (CLASS-SYMBOL OWNER))
    (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
     SYM-CLASSES-STELLA-SLOT-ALLOCATION KWD-CLASSES-INSTANCE NULL))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
       SYM-CLASSES-STELLA-SLOT-RENAMES NULL)
      NULL))
    (CL:LET*
     ((RENAMESSLOT
       (LOOKUP-SLOT OWNER
        (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
         SYM-CLASSES-STELLA-SLOT-RENAMES NULL))))
     (CL:COND
      ((CL:NOT (CL:EQ (PRIMARY-TYPE SELF) (PRIMARY-TYPE RENAMESSLOT)))
       (CL:WARN
        "Slot `~A' renames a slot of a different kind~%   (e.g., a storage slot renaming a method slot, or vice-versa).~%  Cancelling the renames option."
        (%STORAGE-SLOT.SLOT-NAME SELF))
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
        SYM-CLASSES-STELLA-SLOT-RENAMES NULL NULL))
      ((CL:NOT (CL:EQ (ALLOCATION SELF) (ALLOCATION RENAMESSLOT)))
       (CL:WARN
        "Slot `~A' renames a slot with a different~%   allocation.  Changing its allocation to `~A'."
        (%STORAGE-SLOT.SLOT-NAME SELF) (ALLOCATION RENAMESSLOT))
       (SET-DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
        SYM-CLASSES-STELLA-SLOT-ALLOCATION (ALLOCATION RENAMESSLOT)
        NULL)))))
   (CL:WHEN
    (CL:AND (%STORAGE-SLOT.SLOT-CONTEXT-SENSITIVE? SELF)
     (CL:NOT
      (SUBTYPE-OF? (%STORAGE-SLOT.SLOT-OWNER SELF)
       SGT-CLASSES-STELLA-CONTEXT-SENSITIVE-OBJECT))
     (CL:NOT
      (SUBTYPE-OF? (%CLASS.CLASS-TYPE OWNER)
       SGT-CLASSES-STELLA-CONTEXT-SENSITIVE-MIXIN)))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Class `"
      (%SURROGATE.SYMBOL-NAME (%STORAGE-SLOT.SLOT-OWNER SELF))
      "' must inherit either the class CONTEXT-SENSITIVE-OBJECT" EOL
      "   or the class CONTEXT-SENSITIVE-MIXIN because it contains the"
      EOL "   context sensitive slot `" (%STORAGE-SLOT.SLOT-NAME SELF)
      "' " EOL)
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  :VOID)

;;; (DEFUN FINALIZE-LOCAL-SLOT ...)

(CL:DEFUN FINALIZE-LOCAL-SLOT (SELF)
  (COMPUTE-SLOT-DIRECT-EQUIVALENT SELF)
  (FINALIZE-SLOT-TYPE-COMPUTATIONS SELF)
  (CHECK-CONFORMANCE-OF-SLOT-SIGNATURE SELF)
  (COMPUTE-SLOT-INVERSES SELF)
  (HELP-FINALIZE-LOCAL-SLOT SELF)
  (RUN-HOOKS *FINALIZE-RELATION-HOOKS* SELF)
  :VOID)

;;; (DEFMETHOD UNFINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF SLOT))
  :VOID)

;;; (DEFMETHOD UNFINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF STORAGE-SLOT))
  :VOID)

;;; (DEFUN FINALIZE-CLASS-SLOTS ...)

(CL:DEFUN FINALIZE-CLASS-SLOTS (CLASS)
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
   SYM-CLASSES-STELLA-BAD? TRUE-WRAPPER NULL)
  (CL:LET*
   ((SUPER NULL)
    (ITER-000
     (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS CLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ SUPER (%%VALUE ITER-000))
    (CL:WHEN
     (CL:NOT
      (%CLASS.CLASS-SLOTS-FINALIZED?
       (%SURROGATE.SURROGATE-VALUE SUPER)))
     (FINALIZE-CLASS-SLOTS (%SURROGATE.SURROGATE-VALUE SUPER)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (COMPUTE-REQUIRED-SLOT-NAMES CLASS)
  (CL:LET* ((CLASSTYPE (%CLASS.CLASS-TYPE CLASS)))
   (CL:LET*
    ((SLOT NULL)
     (ITER-001 (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ SLOT (%%VALUE ITER-001)) (REGISTER-SLOT-NAME SLOT)
     (CL:SETF (%SLOT.SLOT-OWNER SLOT) CLASSTYPE)
     (CL:SETQ ITER-001 (%%REST ITER-001)))))
  (CL:LET*
   ((SLOT NULL)
    (ITER-002 (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
    (CL:SETQ SLOT (%%VALUE ITER-002)) (FINALIZE-LOCAL-SLOT SLOT)
    (CL:SETQ ITER-002 (%%REST ITER-002))))
  (CL:SETF (%CLASS.CLASS-SLOTS-FINALIZED? CLASS) CL:T)
  (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
   SYM-CLASSES-STELLA-BAD? NULL NULL)
  :VOID)

;;; (DEFUN UNFINALIZE-CLASS-SLOTS ...)

(CL:DEFUN UNFINALIZE-CLASS-SLOTS (CLASS)
  (CL:WHEN (CL:NOT (%CLASS.CLASS-SLOTS-FINALIZED? CLASS))
   (CLEAR-SLOT-AND-METHOD-CACHE CLASS)
   (CL:RETURN-FROM UNFINALIZE-CLASS-SLOTS))
  (CL:LET*
   ((SUBTYPE NULL)
    (ITER-000 (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUBS CLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ SUBTYPE (%%VALUE ITER-000))
    (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUBTYPE) NULL))
     (UNFINALIZE-CLASS-SLOTS (%SURROGATE.SURROGATE-VALUE SUBTYPE)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (HELP-UNFINALIZE-CLASS-SLOTS CLASS)
  :VOID)

;;; (DEFUN HELP-UNFINALIZE-CLASS-SLOTS ...)

(CL:DEFUN HELP-UNFINALIZE-CLASS-SLOTS (CLASS)
  (CLEAR-SLOT-AND-METHOD-CACHE CLASS)
  (CL:WHEN (CL:NOT (%CLASS.CLASS-SLOTS-FINALIZED? CLASS))
   (CL:RETURN-FROM HELP-UNFINALIZE-CLASS-SLOTS))
  (FREE-REQUIRED-SLOT-NAMES CLASS)
  (CL:LET*
   ((SLOT NULL) (ITER-000 (%LIST.THE-CONS-LIST (LOCAL-SLOTS CLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ SLOT (%%VALUE ITER-000)) (UNFINALIZE-LOCAL-SLOT SLOT)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (REMEMBER-UNFINALIZED-CLASS CLASS CL:NIL)
  (CL:SETF (%CLASS.CLASS-SLOTS-FINALIZED? CLASS) CL:NIL)
  :VOID)

;;; (DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ...)

(CL:DEFMETHOD MULTIPLE-PARENTS? ((CLASS CLASS))
  "Return `true' if `class' has more than one direct superclass."
  (CL:RETURN-FROM MULTIPLE-PARENTS?
   (CL:NOT (CL:EQ (REST (%CLASS.CLASS-DIRECT-SUPERS CLASS)) NIL))))

;;; (DEFUN ADD-DIRECT-SUPERS-BACK-LINKS ...)

(CL:DEFUN ADD-DIRECT-SUPERS-BACK-LINKS (CLASS)
  (CL:LET*
   ((DIRECTSUPERS (%CLASS.CLASS-DIRECT-SUPERS CLASS))
    (CLASSTYPE (%CLASS.CLASS-TYPE CLASS)))
   (REMOVE-DUPLICATES DIRECTSUPERS)
   (CL:LET*
    ((SUPERTYPE NULL) (ITER-000 (%LIST.THE-CONS-LIST DIRECTSUPERS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPERTYPE (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUPERTYPE) NULL))
      (CL:LET* ((SUPERCLASS (%SURROGATE.SURROGATE-VALUE SUPERTYPE)))
       (INSERT-NEW (%CLASS.CLASS-DIRECT-SUBS SUPERCLASS) CLASSTYPE)
       (LINK-TAXONOMY-NODES *CLASS-TAXONOMY-GRAPH*
        (%CLASS.CLASS-TAXONOMY-NODE
         (%SURROGATE.SURROGATE-VALUE SUPERTYPE))
        (%CLASS.CLASS-TAXONOMY-NODE CLASS))))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  :VOID)

;;; (DEFUN ADD-DIRECT-SUBS-BACK-LINKS ...)

(CL:DEFUN ADD-DIRECT-SUBS-BACK-LINKS (CLASS)
  (CL:LET*
   ((DIRECTSUBS (%CLASS.CLASS-DIRECT-SUBS CLASS))
    (CLASSTYPE (%CLASS.CLASS-TYPE CLASS)))
   (REMOVE-DUPLICATES DIRECTSUBS)
   (CL:LET*
    ((SUBTYPE NULL) (ITER-000 (%LIST.THE-CONS-LIST DIRECTSUBS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUBTYPE (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUBTYPE) NULL))
      (CL:LET* ((SUBCLASS (%SURROGATE.SURROGATE-VALUE SUBTYPE)))
       (CL:IF (%CLASS.CLASS-FINALIZED? SUBCLASS)
        (CL:WHEN
         (CL:NOT
          (MEMBER? (%CLASS.CLASS-ALL-SUPER-CLASSES SUBCLASS) CLASS))
         (INSERT (%CLASS.CLASS-DIRECT-SUPERS SUBCLASS) CLASSTYPE)
         (UNFINALIZE-CLASS-AND-SUBCLASSES CLASS))
        (INSERT-NEW (%CLASS.CLASS-DIRECT-SUPERS SUBCLASS) CLASSTYPE))))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  :VOID)

;;; (DEFUN REMOVE-DIRECT-SUPERS-BACK-LINKS ...)

(CL:DEFUN REMOVE-DIRECT-SUPERS-BACK-LINKS (CLASS)
  (CL:LET* ((CLASSTYPE (%CLASS.CLASS-TYPE CLASS)))
   (CL:LET*
    ((SUPERTYPE NULL)
     (ITER-000
      (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS CLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPERTYPE (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUPERTYPE) NULL))
      (REMOVE
       (%CLASS.CLASS-DIRECT-SUBS
        (%SURROGATE.SURROGATE-VALUE SUPERTYPE))
       CLASSTYPE))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  :VOID)

;;; (DEFUN COLLECT-DIRECT-SUPER-CLASSES ...)

(CL:DEFUN COLLECT-DIRECT-SUPER-CLASSES (CLASS PARENTS)
  (CL:LET*
   ((DIRECTSUPERTYPES (%CLASS.CLASS-DIRECT-SUPERS CLASS))
    (NONDIRECTPARENTS (NEW-LIST)))
   (CL:LET*
    ((SUPERTYPE NULL) (ITER-000 (%LIST.THE-CONS-LIST DIRECTSUPERTYPES))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPERTYPE (%%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUPERTYPE) NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000
         (CONS (%SURROGATE.SURROGATE-VALUE SUPERTYPE) NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST PARENTS) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST PARENTS) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST PARENTS)
          COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (%SURROGATE.SURROGATE-VALUE SUPERTYPE) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((SUPERCLASS NULL) (ITER-001 (%LIST.THE-CONS-LIST PARENTS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ SUPERCLASS (%%VALUE ITER-001))
     (CL:LET*
      ((OTHERSUPERCLASS NULL) (ITER-002 (%LIST.THE-CONS-LIST PARENTS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ OTHERSUPERCLASS (%%VALUE ITER-002))
       (CL:WHEN (CL:NOT (CL:EQ OTHERSUPERCLASS SUPERCLASS))
        (CL:WHEN
         (MEMBER? (%CLASS.CLASS-ALL-SUPER-CLASSES SUPERCLASS)
          OTHERSUPERCLASS)
         (INSERT NONDIRECTPARENTS OTHERSUPERCLASS)))
       (CL:SETQ ITER-002 (%%REST ITER-002))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET*
    ((P NULL) (ITER-003 (%LIST.THE-CONS-LIST NONDIRECTPARENTS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
     (CL:SETQ P (%%VALUE ITER-003)) (REMOVE PARENTS P)
     (CL:SETQ ITER-003 (%%REST ITER-003))))
   (FREE NONDIRECTPARENTS))
  :VOID)

;;; (DEFUN INHERIT-SUPERCLASSES ...)

(CL:DEFUN INHERIT-SUPERCLASSES (CLASS)
  (CL:LET* ((PARENTCLASSES (NEW-LIST)))
   (COLLECT-DIRECT-SUPER-CLASSES CLASS PARENTCLASSES)
   (CL:WHEN (CL:NOT (MULTIPLE-PARENTS? CLASS))
    (CL:LET* ((ONLYPARENT (FIRST PARENTCLASSES)))
     (CL:WHEN (CL:EQ ONLYPARENT NULL)
      (CL:RETURN-FROM INHERIT-SUPERCLASSES))
     (CL:SETF (%CLASS.CLASS-ALL-SUPER-CLASSES CLASS)
      (CONS ONLYPARENT (%CLASS.CLASS-ALL-SUPER-CLASSES ONLYPARENT)))
     (CL:RETURN-FROM INHERIT-SUPERCLASSES)))
   (CL:SETQ PARENTCLASSES (REVERSE PARENTCLASSES))
   (CL:LET* ((ALLSUPERCLASSES NIL) (SUBLIST NULL))
    (CL:LET*
     ((PARENT NULL) (ITER-000 (%LIST.THE-CONS-LIST PARENTCLASSES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ PARENT (%%VALUE ITER-000)) (CL:SETQ SUBLIST NIL)
      (CL:LET*
       ((ANCESTOR NULL)
        (ITER-001 (%CLASS.CLASS-ALL-SUPER-CLASSES PARENT))
        (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ ANCESTOR (%%VALUE ITER-001))
        (CL:WHEN (CL:NOT (MEMBER? ALLSUPERCLASSES ANCESTOR))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN (CL:SETQ COLLECT-000 (CONS ANCESTOR NIL))
           (CL:IF (CL:EQ SUBLIST NIL) (CL:SETQ SUBLIST COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST SUBLIST COLLECT-000)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ANCESTOR NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CL:SETQ SUBLIST (CONS PARENT SUBLIST))
      (CL:SETQ ALLSUPERCLASSES (CONCATENATE SUBLIST ALLSUPERCLASSES))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETF (%CLASS.CLASS-ALL-SUPER-CLASSES CLASS) ALLSUPERCLASSES)))
  :VOID)

;;; (DEFUN UNINHERIT-SUPERCLASSES ...)

(CL:DEFUN UNINHERIT-SUPERCLASSES (CLASS)
  (CL:SETF (%CLASS.CLASS-ALL-SUPER-CLASSES CLASS) NIL)
  :VOID)

;;; (DEFUN (TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS CLASS) ...)

(CL:DEFUN TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS (CLASS1 CLASS2)
  "Return the most specific class that is a superclass of
both `class1' and `class2'.  If there is more than one, arbitrarily pick one.
If there is none, return `null'."
  (CL:WHEN (SUBCLASS-OF? CLASS1 CLASS2)
   (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS CLASS2))
  (CL:WHEN (SUBCLASS-OF? CLASS2 CLASS1)
   (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS CLASS1))
  (CL:LET*
   ((C NULL) (ITER-000 (%CLASS.CLASS-ALL-SUPER-CLASSES CLASS1)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ C (%%VALUE ITER-000))
    (CL:SETF (%CLASS.CLASS-MARKED? C) CL:NIL)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET*
   ((C NULL) (ITER-001 (%CLASS.CLASS-ALL-SUPER-CLASSES CLASS2)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ C (%%VALUE ITER-001))
    (CL:SETF (%CLASS.CLASS-MARKED? C) CL:T)
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  (CL:LET*
   ((C NULL) (ITER-002 (%CLASS.CLASS-ALL-SUPER-CLASSES CLASS1)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
    (CL:SETQ C (%%VALUE ITER-002))
    (CL:WHEN (%CLASS.CLASS-MARKED? C)
     (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS C))
    (CL:SETQ ITER-002 (%%REST ITER-002))))
  (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS NULL))

;;; (DEFUN (TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE TYPE-SPEC) ...)

(CL:DEFUN TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE (TYPE1 TYPE2)
  "Return the most specific type that is a supertype of
both `type1' and `type2'.  If there is more than one, arbitrarily pick one.
If there is none, return @VOID.  If one or both types are parametric,
also try to generalize parameter types if necessary."
  (CL:WHEN (CL:EQ TYPE1 TYPE2)
   (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE TYPE1))
  (CL:LET*
   ((BASETYPE1 (TYPE-SPEC-TO-BASE-TYPE TYPE1))
    (BASETYPE2 (TYPE-SPEC-TO-BASE-TYPE TYPE2))
    (SUPERCLASS
     (TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS
      (%SURROGATE.SURROGATE-VALUE BASETYPE1)
      (%SURROGATE.SURROGATE-VALUE BASETYPE2))))
   (CL:WHEN (CL:EQ SUPERCLASS NULL)
    (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE
     SGT-CLASSES-STELLA-VOID))
   (CL:WHEN (CL:AND (CL:EQ TYPE1 BASETYPE1) (CL:EQ TYPE2 BASETYPE2))
    (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE
     (%CLASS.CLASS-TYPE SUPERCLASS)))
   (CL:LET*
    ((SUPERTYPE (%CLASS.CLASS-TYPE SUPERCLASS))
     (SUPERTYPESPEC (BASE-TYPE-TO-TYPE-SPEC SUPERTYPE))
     (PARAMETERS (PARAMETERS SUPERCLASS)) (PARAMETERTYPES NULL)
     (SPTYPE NULL) (PTYPE1 NULL) (PTYPE2 NULL)
     (PARAMETEREXISTS? CL:NIL) (RESULT NULL))
    (CL:WHEN (EMPTY? PARAMETERS)
     (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE SUPERTYPE))
    (CL:SETQ PARAMETERTYPES (NEW-LIST))
    (CL:LET*
     ((PARAMETER NULL) (ITER-000 (%LIST.THE-CONS-LIST PARAMETERS))
      (COLLECT-000 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ PARAMETER (%%VALUE ITER-000))
      (CL:MULTIPLE-VALUE-SETQ (PTYPE1 PARAMETEREXISTS?)
       (EXTRACT-PARAMETER-TYPE TYPE1 PARAMETER))
      (CL:WHEN
       (CL:OR (CL:NOT PARAMETEREXISTS?)
        (UNKNOWN-TYPE? (TYPE-SPEC-TO-BASE-TYPE PTYPE1)))
       (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE SUPERTYPE))
      (CL:MULTIPLE-VALUE-SETQ (PTYPE2 PARAMETEREXISTS?)
       (EXTRACT-PARAMETER-TYPE TYPE2 PARAMETER))
      (CL:WHEN
       (CL:OR (CL:NOT PARAMETEREXISTS?)
        (UNKNOWN-TYPE? (TYPE-SPEC-TO-BASE-TYPE PTYPE2)))
       (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE SUPERTYPE))
      (CL:SETQ SPTYPE
       (TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE PTYPE1 PTYPE2))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ SUPERTYPE SUPERTYPESPEC))
        (CL:NOT
         (SUB-TYPE-SPEC-OF? SPTYPE
          (EXTRACT-PARAMETER-TYPE SUPERTYPE PARAMETER))))
       (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE SUPERTYPE))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS SPTYPE NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST PARAMETERTYPES) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST PARAMETERTYPES) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST
          (%LIST.THE-CONS-LIST PARAMETERTYPES) COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS SPTYPE NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:LET* ((SELF-001 (NEW-PARAMETRIC-TYPE-SPECIFIER)))
     (CL:SETF (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF-001)
      SUPERTYPE)
     (CL:SETF
      (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES SELF-001)
      PARAMETERTYPES)
     (CL:SETQ RESULT SELF-001))
    (CL:WHEN
     (CL:AND (ARRAY-TYPE-SPECIFIER? TYPE1)
      (ARRAY-TYPE-SPECIFIER? TYPE2))
     (CL:WHEN
      (CL:NOT
       (EQUAL-CONS-TREES?
        (%LIST.THE-CONS-LIST (ARRAY-TYPE-DIMENSIONS TYPE1))
        (%LIST.THE-CONS-LIST (ARRAY-TYPE-DIMENSIONS TYPE2))))
      (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE SUPERTYPE))
     (CL:SETF (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-DIMENSIONS RESULT)
      (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-DIMENSIONS TYPE1)))
    (CL:RETURN-FROM TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE RESULT))))

;;; (DEFUN INHERIT-SLOTS ...)

(CL:DEFUN INHERIT-SLOTS (CLASS)
  (CL:LET*
   ((SLOTS
     (COPY-CONS-LIST
      (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS)))))
   (CL:COND ((EMPTY? (%CLASS.CLASS-DIRECT-SUPERS CLASS)))
    ((MULTIPLE-PARENTS? CLASS)
     (CL:LET*
      ((SUPERTYPE NULL)
       (ITER-000
        (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS CLASS))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SUPERTYPE (%%VALUE ITER-000))
       (CL:SETQ SLOTS
        (CONCATENATE SLOTS
         (COPY-CONS-LIST
          (%CLASS.CLASS-ALL-SLOTS
           (%SURROGATE.SURROGATE-VALUE SUPERTYPE)))))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ SLOTS (REVERSE SLOTS)) (REMOVE-DUPLICATES SLOTS)
     (CL:SETQ SLOTS (REVERSE SLOTS)))
    (CL:T
     (CL:LET*
      ((PARENTSLOTS
        (%CLASS.CLASS-ALL-SLOTS
         (%SURROGATE.SURROGATE-VALUE
          (FIRST (%CLASS.CLASS-DIRECT-SUPERS CLASS))))))
      (CL:SETQ SLOTS (CONCATENATE SLOTS PARENTSLOTS)))))
   (CL:SETF (%CLASS.CLASS-ALL-SLOTS CLASS) SLOTS))
  :VOID)

;;; (DEFUN (LOCAL-SLOT? BOOLEAN) ...)

(CL:DEFUN LOCAL-SLOT? (SLOT CLASS)
  (CL:RETURN-FROM LOCAL-SLOT?
   (CL:EQ (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-OWNER SLOT)) CLASS)))

;;; (DEFUN UNINHERIT-SLOTS ...)

(CL:DEFUN UNINHERIT-SLOTS (CLASS)
  (CL:LET* ((SLOTSCURSOR (%CLASS.CLASS-ALL-SLOTS CLASS)))
   (CL:WHEN (CL:NOT (CL:EQ SLOTSCURSOR NULL))
    (CL:WHEN (CL:NOT (MULTIPLE-PARENTS? CLASS))
     (CL:LET* ((SLOT NULL) (ITER-000 (%CLASS.CLASS-ALL-SLOTS CLASS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SLOT (%%VALUE ITER-000))
       (CL:IF
        (CL:AND (CL:NOT (CL:EQ (%%REST SLOTSCURSOR) NIL))
         (LOCAL-SLOT? (%%VALUE (%%REST SLOTSCURSOR)) CLASS))
        (CL:SETQ SLOTSCURSOR (%%REST SLOTSCURSOR)) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETF (%%REST SLOTSCURSOR) NIL))
    (CL:SETF (%CLASS.CLASS-ALL-SLOTS CLASS) NULL)))
  :VOID)

;;; (DEFGLOBAL *SYMBOL-SLOT-OFFSET-COUNTER* ...)

(CL:DEFVAR *SYMBOL-SLOT-OFFSET-COUNTER* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *SYMBOL-SLOT-OFFSET-COUNTER*))

;;; (DEFGLOBAL *SLOT-CACHE-SIZE* ...)

(CL:DEFVAR *SLOT-CACHE-SIZE* 20)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *SLOT-CACHE-SIZE*))

;;; (DEFUN INITIALIZE-SLOT-AND-METHOD-CACHE ...)

(CL:DEFUN INITIALIZE-SLOT-AND-METHOD-CACHE (CLASS)
  (CL:SETF (%CLASS.CLASS-SLOT-AND-METHOD-CACHE CLASS)
   (NEW-VECTOR (CL:1+ *SLOT-CACHE-SIZE*)))
  :VOID)

;;; (DEFUN REGISTER-SLOT-NAME ...)

(CL:DEFUN REGISTER-SLOT-NAME (SLOT)
  "Register the name symbol of `slot' as a slot name, and
initialize its `symbol-slot-offset' so that it can be used by `lookup-slot'."
  (WARN-ABOUT-SLOT-SHADOWED-BY-A-FUNCTION? SLOT)
  (CL:SETF (%SYMBOL.SYMBOL-SLOT-OFFSET (%SLOT.SLOT-NAME SLOT)) 0)
  :VOID)

;;; (DEFUN UNREGISTER-SLOT-NAME ...)

(CL:DEFUN UNREGISTER-SLOT-NAME (SLOT)
  "Unregister the name symbol of `slot' as a slot name,
so that it can no longer be used by `lookup-slot'."
  (CL:SETF (%SYMBOL.SYMBOL-SLOT-OFFSET (%SLOT.SLOT-NAME SLOT))
   NULL-INTEGER)
  :VOID)

;;; (DEFUN (REGISTERED-SLOT-NAME? BOOLEAN) ...)

(CL:DEFUN REGISTERED-SLOT-NAME? (SLOT-NAME)
  "Return `true' if `slot-name' is the name of some registered;
slot in the system."
  (CL:RETURN-FROM REGISTERED-SLOT-NAME?
   (CL:NOT (CL:= (%SYMBOL.SYMBOL-SLOT-OFFSET SLOT-NAME) NULL-INTEGER))))

;;; (DEFUN (WARN-ABOUT-SLOT-SHADOWED-BY-A-FUNCTION? BOOLEAN) ...)

(CL:DEFUN WARN-ABOUT-SLOT-SHADOWED-BY-A-FUNCTION? (SLOT)
  (CL:LET* ((NAME (%SLOT.SLOT-NAME SLOT)))
   (CL:WHEN (CL:= (%SYMBOL.SYMBOL-SLOT-OFFSET NAME) NULL-INTEGER)
    (CL:WHEN (CL:NOT (CL:EQ (LOOKUP-MACRO NAME) NULL))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-WARNING)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
        EOL " Slot `" (DE-UGLIFY-PARSE-TREE SLOT)
        "' is shadowed by the macro `" (DE-UGLIFY-PARSE-TREE NAME) "'."
        EOL)))
     (CL:RETURN-FROM WARN-ABOUT-SLOT-SHADOWED-BY-A-FUNCTION? CL:T))
    (CL:WHEN (CL:NOT (CL:EQ (LOOKUP-FUNCTION NAME) NULL))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-WARNING)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
        EOL " Slot `" (DE-UGLIFY-PARSE-TREE SLOT)
        "' is shadowed by the function `" (DE-UGLIFY-PARSE-TREE NAME)
        "'." EOL)))
     (CL:RETURN-FROM WARN-ABOUT-SLOT-SHADOWED-BY-A-FUNCTION? CL:T)))
   (CL:RETURN-FROM WARN-ABOUT-SLOT-SHADOWED-BY-A-FUNCTION? CL:NIL)))

;;; (DEFUN (WARN-ABOUT-FUNCTION-SHADOWING-SLOTS? BOOLEAN) ...)

(CL:DEFUN WARN-ABOUT-FUNCTION-SHADOWING-SLOTS? (FUNCTION)
  (CL:LET* ((NAME (%METHOD-SLOT.SLOT-NAME FUNCTION)))
   (CL:WHEN
    (CL:NOT (CL:= (%SYMBOL.SYMBOL-SLOT-OFFSET NAME) NULL-INTEGER))
    (CL:LET* ((SLOTS NIL))
     (CL:LET* ((MODULE NULL) (ITER-000 (ALL-MODULES)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO
       (CL:SETQ MODULE (%ITERATOR.VALUE ITER-000))
       (CL:LET*
        ((SLOT NULL) (ITER-001 (ALL-SLOTS MODULE CL:T))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (NEXT? ITER-001) DO
         (CL:SETQ SLOT (%ITERATOR.VALUE ITER-001))
         (CL:WHEN (CL:EQ (%SLOT.SLOT-NAME SLOT) NAME)
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS SLOT NIL))
            (CL:IF (CL:EQ SLOTS NIL) (CL:SETQ SLOTS COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST SLOTS COLLECT-000)))
           (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS SLOT NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))))
     (CL:IF
      (%BOOLEAN-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
        SYM-CLASSES-STELLA-METHOD-MACRO? FALSE-WRAPPER))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-WARNING)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
         EOL " Macro `" (DE-UGLIFY-PARSE-TREE NAME)
         "' shadows the following methods/slots:" EOL "    `"
         (DE-UGLIFY-PARSE-TREE SLOTS) "'." EOL)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (SIGNAL-TRANSLATION-WARNING)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-WARNING)
         EOL " Function `" (DE-UGLIFY-PARSE-TREE NAME)
         "' shadows the following methods/slots:" EOL "    `"
         (DE-UGLIFY-PARSE-TREE SLOTS) "'." EOL))))
     (CL:RETURN-FROM WARN-ABOUT-FUNCTION-SHADOWING-SLOTS? CL:T)))
   (CL:RETURN-FROM WARN-ABOUT-FUNCTION-SHADOWING-SLOTS? CL:NIL)))

;;; (DEFUN (LOOKUP-SLOT SLOT) ...)

(CL:DEFUN LOOKUP-SLOT (CLASS SLOT-NAME)
  "Return a slot owned by the class `class' with name `slot-name'.
Multiply inherited slots are disambiguated by a left-to-right class
precedence order for classes with multiple parents (similar to CLOS)."
  (CL:WHEN (CL:EQ CLASS NULL) (CL:RETURN-FROM LOOKUP-SLOT NULL))
  (CL:LET*
   ((OFFSET (%SYMBOL.SYMBOL-SLOT-OFFSET SLOT-NAME)) (CACHEDSLOT NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OFFSET))
   (CL:WHEN (CL:NOT (CL:= OFFSET NULL-INTEGER))
    (CL:SETQ CACHEDSLOT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%CLASS.CLASS-SLOT-AND-METHOD-CACHE CLASS)))
      (CL:THE CL:FIXNUM (%SYMBOL.SYMBOL-SLOT-OFFSET SLOT-NAME))))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ CACHEDSLOT NULL))
      (CL:EQ (%SLOT.SLOT-NAME CACHEDSLOT) SLOT-NAME))
     (CL:RETURN-FROM LOOKUP-SLOT CACHEDSLOT)))
   (CL:SETQ CACHEDSLOT NULL)
   (CL:LET* ((SLOT NULL) (ITER-000 (CLASS-SLOTS CLASS)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SLOT (%ITERATOR.VALUE ITER-000))
     (CL:WHEN (CL:EQ (%SLOT.SLOT-NAME SLOT) SLOT-NAME)
      (CL:SETQ CACHEDSLOT SLOT) (CL:RETURN))))
   (CL:WHEN (CL:EQ CACHEDSLOT NULL) (CL:RETURN-FROM LOOKUP-SLOT NULL))
   (CL:LET*
    ((NEWOFFSET
      (CL:THE CL:FIXNUM
       (CL:REM (CL:THE CL:FIXNUM (CL:1+ *SYMBOL-SLOT-OFFSET-COUNTER*))
        *SLOT-CACHE-SIZE*))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM NEWOFFSET))
    (CL:SETQ *SYMBOL-SLOT-OFFSET-COUNTER* NEWOFFSET)
    (CL:SETF (%SYMBOL.SYMBOL-SLOT-OFFSET SLOT-NAME) NEWOFFSET)
    (INSERT-AT (%CLASS.CLASS-SLOT-AND-METHOD-CACHE CLASS) NEWOFFSET
     CACHEDSLOT)
    (INSERT-AT (%CLASS.CLASS-SLOT-AND-METHOD-CACHE CLASS)
     *SLOT-CACHE-SIZE* CACHEDSLOT)
    (CL:RETURN-FROM LOOKUP-SLOT CACHEDSLOT))))

;;; (DEFUN (SAFE-LOOKUP-SLOT SLOT) ...)

(CL:DEFUN SAFE-LOOKUP-SLOT (CLASS SLOT-NAME)
  "Alias for `lookup-slot'.  Kept for backwards compatibility."
  (CL:RETURN-FROM SAFE-LOOKUP-SLOT (LOOKUP-SLOT CLASS SLOT-NAME)))

;;; (DEFUN (LOOKUP-VISIBLE-SLOT SLOT) ...)

(CL:DEFUN LOOKUP-VISIBLE-SLOT (CLASS SLOT-NAME)
  (CL:LET*
   ((SLOT NULL) (SLOTNAMESTRING STELLA::NULL-STRING) (MODULE *MODULE*))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SLOTNAMESTRING))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SLOT-NAME)))
    (CL:COND
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ SLOT (LOOKUP-SLOT CLASS SLOT-NAME))
       (CL:WHEN (CL:NOT (CL:EQ SLOT NULL))
        (CL:RETURN-FROM LOOKUP-VISIBLE-SLOT SLOT))
       (CL:SETQ SLOTNAMESTRING (%SYMBOL.SYMBOL-NAME SLOT-NAME))
       (CL:SETQ MODULE (%SYMBOL.HOME-CONTEXT SLOT-NAME))))
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ SLOTNAMESTRING (%SURROGATE.SYMBOL-NAME SLOT-NAME))
       (CL:SETQ MODULE (%SURROGATE.HOME-CONTEXT SLOT-NAME))))
     ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ SLOTNAMESTRING (%KEYWORD.SYMBOL-NAME SLOT-NAME))))
     ((SUBTYPE-OF-STRING? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ SLOTNAMESTRING
        (%STRING-WRAPPER.WRAPPER-VALUE SLOT-NAME))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "Illegal slot name: `" SLOT-NAME "'")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:LET*
    ((SYMBOL NULL)
     (ITER-000
      (LOOKUP-VISIBLE-SYMBOLS-IN-MODULE SLOTNAMESTRING MODULE CL:T)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SYMBOL (%%VALUE ITER-000))
     (CL:SETQ SLOT (LOOKUP-SLOT CLASS SYMBOL))
     (CL:WHEN (CL:NOT (CL:EQ SLOT NULL))
      (CL:RETURN-FROM LOOKUP-VISIBLE-SLOT SLOT))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM LOOKUP-VISIBLE-SLOT NULL)))

;;; (DEFUN (LOOKUP-LOCAL-SLOT SLOT) ...)

(CL:DEFUN LOOKUP-LOCAL-SLOT (CLASS SLOT-NAME)
  "Lookup a local slot with `slot-name' on `class'."
  (CL:LET*
   ((SLOT NULL)
    (ITER-000 (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS CLASS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ SLOT (%%VALUE ITER-000))
    (CL:WHEN (CL:EQ (%SLOT.SLOT-NAME SLOT) SLOT-NAME)
     (CL:RETURN-FROM LOOKUP-LOCAL-SLOT SLOT))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:RETURN-FROM LOOKUP-LOCAL-SLOT NULL))

;;; (DEFUN CLEAR-SLOT-AND-METHOD-CACHE ...)

(CL:DEFUN CLEAR-SLOT-AND-METHOD-CACHE (CLASS)
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY (%CLASS.CLASS-SLOT-AND-METHOD-CACHE CLASS)))
      *SLOT-CACHE-SIZE*)
     NULL))
   (CLEAR (%CLASS.CLASS-SLOT-AND-METHOD-CACHE CLASS)))
  :VOID)

;;; (DEFUN RESIZE-SLOT-CACHES ...)

(CL:DEFUN RESIZE-SLOT-CACHES (SIZE)
  "Reset all slot caches to have size `size'."
  (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
  #+MCL
  (CL:CHECK-TYPE SIZE CL:FIXNUM)
  (CL:SETQ *SLOT-CACHE-SIZE* SIZE)
  (CL:LET* ((C NULL) (ITER-000 (ALL-CLASSES NULL CL:NIL)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ C (%ITERATOR.VALUE ITER-000))
    (CL:SETF (%CLASS.CLASS-SLOT-AND-METHOD-CACHE C) (NEW-VECTOR SIZE))
    (CL:LET*
     ((S NULL) (ITER-001 (%LIST.THE-CONS-LIST (LOCAL-SLOTS C))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ S (%%VALUE ITER-001))
      (CL:SETF (%SYMBOL.SYMBOL-SLOT-OFFSET (%SLOT.SLOT-NAME S)) 0)
      (CL:SETQ ITER-001 (%%REST ITER-001))))))
  :VOID)

;;; (DEFUN (GET-SLOT SLOT) ...)

(CL:DEFUN GET-SLOT (SELF SLOT-NAME)
  "Return the slot named `slot-name' on the class
representing the type of `self'."
  (CL:RETURN-FROM GET-SLOT (LOOKUP-SLOT (PRIMARY-CLASS SELF) SLOT-NAME)))

;;; (DEFUN (CONFORMING-TYPE-SPEC? BOOLEAN) ...)

(CL:DEFUN CONFORMING-TYPE-SPEC? (SUB-TYPE-SPEC SUPER-TYPE-SPEC)
  (CL:RETURN-FROM CONFORMING-TYPE-SPEC?
   (CL:OR (CL:EQ SUB-TYPE-SPEC NULL)
    (CL:EQ SUB-TYPE-SPEC SGT-CLASSES-STELLA-UNKNOWN)
    (CL:AND (TYPE? SUB-TYPE-SPEC)
     (CL:EQ (%SURROGATE.SURROGATE-VALUE SUB-TYPE-SPEC) NULL))
    (ANCHORED-TYPE-SPECIFIER? SUB-TYPE-SPEC)
    (CL:EQ SUPER-TYPE-SPEC NULL)
    (CL:EQ SUPER-TYPE-SPEC SGT-CLASSES-STELLA-UNKNOWN)
    (CL:AND (TYPE? SUPER-TYPE-SPEC)
     (CL:EQ (%SURROGATE.SURROGATE-VALUE SUPER-TYPE-SPEC) NULL))
    (ANCHORED-TYPE-SPECIFIER? SUPER-TYPE-SPEC)
    (SUB-TYPE-SPEC-OF? SUB-TYPE-SPEC SUPER-TYPE-SPEC))))

;;; (DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ...)

(CL:DEFMETHOD CONFORMING-SIGNATURES? ((SELF SLOT) SUPERSLOT)
  (CL:SETQ SUPERSLOT SUPERSLOT)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "conforming-signatures?: Not defined on `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ...)

(CL:DEFMETHOD CONFORMING-SIGNATURES? ((SELF STORAGE-SLOT) SUPERSLOT)
  (CL:RETURN-FROM CONFORMING-SIGNATURES?
   (CL:AND
    (CONFORMING-TYPE-SPEC? (%STORAGE-SLOT.SLOT-BASE-TYPE SELF)
     (TYPE SUPERSLOT))
    (CONFORMING-TYPE-SPEC?
     (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
      SYM-CLASSES-STELLA-SLOT-TYPE-SPECIFIER NULL)
     (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SUPERSLOT)
      SYM-CLASSES-STELLA-SLOT-TYPE-SPECIFIER NULL))
    (CL:= (METHOD-ARGUMENT-COUNT SUPERSLOT) 1))))

;;; (DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ...)

(CL:DEFMETHOD CONFORMING-SIGNATURES? ((SELF METHOD-SLOT) SUPERSLOT)
  (CL:WHEN
   (CL:AND
    (CONFORMING-TYPE-SPEC? (%METHOD-SLOT.SLOT-BASE-TYPE SELF)
     (TYPE SUPERSLOT))
    (CONFORMING-TYPE-SPEC?
     (DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS SELF)
      SYM-CLASSES-STELLA-SLOT-TYPE-SPECIFIER NULL)
     (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SUPERSLOT)
      SYM-CLASSES-STELLA-SLOT-TYPE-SPECIFIER NULL))
    (CL:= (METHOD-ARGUMENT-COUNT SELF)
     (METHOD-ARGUMENT-COUNT SUPERSLOT)))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SUPERSLOT)))
    (CL:COND
     ((SUBTYPE-OF-STORAGE-SLOT? TEST-VALUE-001)
      (CL:PROGN
       (CL:RETURN-FROM CONFORMING-SIGNATURES?
        (CL:= (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS SELF)) 1))))
     ((SUBTYPE-OF-METHOD-SLOT? TEST-VALUE-001)
      (CL:PROGN
       (CL:LET* ((TEST-VALUE-000 CL:NIL))
        (CL:LET* ((ALWAYS?-000 CL:T))
         (CL:LET*
          ((TS1 NULL)
           (ITER-000 (REST (METHOD-PARAMETER-TYPE-SPECIFIERS SELF)))
           (TS2 NULL)
           (ITER-001
            (REST (METHOD-PARAMETER-TYPE-SPECIFIERS SUPERSLOT))))
          (CL:LOOP WHILE
           (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
            (CL:NOT (CL:EQ ITER-001 NIL)))
           DO (CL:SETQ TS1 (%%VALUE ITER-000))
           (CL:SETQ TS2 (%%VALUE ITER-001))
           (CL:WHEN (CL:NOT (CONFORMING-TYPE-SPEC? TS2 TS1))
            (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
           (CL:SETQ ITER-000 (%%REST ITER-000))
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
        (CL:WHEN TEST-VALUE-000
         (CL:LET* ((ALWAYS?-001 CL:T))
          (CL:LET*
           ((TS1 NULL)
            (ITER-002
             (%LIST.THE-CONS-LIST
              (METHOD-RETURN-TYPE-SPECIFIERS SELF)))
            (TS2 NULL)
            (ITER-003
             (%LIST.THE-CONS-LIST
              (METHOD-RETURN-TYPE-SPECIFIERS SUPERSLOT))))
           (CL:LOOP WHILE
            (CL:AND (CL:NOT (CL:EQ ITER-002 NIL))
             (CL:NOT (CL:EQ ITER-003 NIL)))
            DO (CL:SETQ TS1 (%%VALUE ITER-002))
            (CL:SETQ TS2 (%%VALUE ITER-003))
            (CL:WHEN (CL:NOT (CONFORMING-TYPE-SPEC? TS1 TS2))
             (CL:SETQ ALWAYS?-001 CL:NIL) (CL:RETURN))
            (CL:SETQ ITER-002 (%%REST ITER-002))
            (CL:SETQ ITER-003 (%%REST ITER-003))))
          (CL:SETQ TEST-VALUE-000 ALWAYS?-001)))
        (CL:LET* ((VALUE-000 TEST-VALUE-000))
         (CL:RETURN-FROM CONFORMING-SIGNATURES? VALUE-000)))))
     (CL:T))))
  (CL:RETURN-FROM CONFORMING-SIGNATURES? CL:NIL))

;;; (DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ...)

(CL:DEFMETHOD CONFORMING-SIGNATURES? ((SELF TABLE) SUPERSLOT)
  (CL:WHEN
   (CL:AND
    (CONFORMING-TYPE-SPEC? (%TABLE.SLOT-BASE-TYPE SELF)
     (TYPE SUPERSLOT))
    (CONFORMING-TYPE-SPEC?
     (DYNAMIC-SLOT-VALUE (%TABLE.DYNAMIC-SLOTS SELF)
      SYM-CLASSES-STELLA-SLOT-TYPE-SPECIFIER NULL)
     (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SUPERSLOT)
      SYM-CLASSES-STELLA-SLOT-TYPE-SPECIFIER NULL))
    (CL:= (METHOD-ARGUMENT-COUNT SELF)
     (METHOD-ARGUMENT-COUNT SUPERSLOT)))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SUPERSLOT)
      SGT-CLASSES-STELLA-TABLE)
     (CL:PROGN
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET*
        ((TS1 NULL) (ITER-000 (REST (%TABLE.TUPLE-DOMAINS SELF)))
         (TS2 NULL) (ITER-001 (REST (%TABLE.TUPLE-DOMAINS SUPERSLOT))))
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
          (CL:NOT (CL:EQ ITER-001 NIL)))
         DO (CL:SETQ TS1 (%%VALUE ITER-000))
         (CL:SETQ TS2 (%%VALUE ITER-001))
         (CL:WHEN (CL:NOT (CONFORMING-TYPE-SPEC? TS2 TS1))
          (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:LET* ((VALUE-000 ALWAYS?-000))
        (CL:RETURN-FROM CONFORMING-SIGNATURES? VALUE-000)))))
    (CL:T)))
  (CL:RETURN-FROM CONFORMING-SIGNATURES? CL:NIL))

;;; (DEFUN (IDENTICAL-SIGNATURES? BOOLEAN) ...)

(CL:DEFUN IDENTICAL-SIGNATURES? (METHOD1 METHOD2)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET*
     ((TS1 NULL)
      (ITER-000 (REST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD1)))
      (TS2 NULL)
      (ITER-001 (REST (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD2))))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
       (CL:NOT (CL:EQ ITER-001 NIL)))
      DO (CL:SETQ TS1 (%%VALUE ITER-000))
      (CL:SETQ TS2 (%%VALUE ITER-001))
      (CL:WHEN
       (CL:NOT
        (CL:AND
         (SUB-TYPE-SPEC-OF?
          (CL:SETQ TS1
           (COMPUTE-RELATIVE-TYPE-SPEC TS1
            (%METHOD-SLOT.SLOT-OWNER METHOD1)))
          (CL:SETQ TS2
           (COMPUTE-RELATIVE-TYPE-SPEC TS2
            (%METHOD-SLOT.SLOT-OWNER METHOD2))))
         (SUB-TYPE-SPEC-OF? TS2 TS1)))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
   (CL:WHEN TEST-VALUE-000
    (CL:LET* ((ALWAYS?-001 CL:T))
     (CL:LET*
      ((TS1 NULL)
       (ITER-002
        (%LIST.THE-CONS-LIST (METHOD-RETURN-TYPE-SPECIFIERS METHOD1)))
       (TS2 NULL)
       (ITER-003
        (%LIST.THE-CONS-LIST (METHOD-RETURN-TYPE-SPECIFIERS METHOD2))))
      (CL:LOOP WHILE
       (CL:AND (CL:NOT (CL:EQ ITER-002 NIL))
        (CL:NOT (CL:EQ ITER-003 NIL)))
       DO (CL:SETQ TS1 (%%VALUE ITER-002))
       (CL:SETQ TS2 (%%VALUE ITER-003))
       (CL:WHEN
        (CL:NOT
         (CL:AND
          (SUB-TYPE-SPEC-OF?
           (CL:SETQ TS1
            (COMPUTE-RELATIVE-TYPE-SPEC TS1
             (%METHOD-SLOT.SLOT-OWNER METHOD1)))
           (CL:SETQ TS2
            (COMPUTE-RELATIVE-TYPE-SPEC TS2
             (%METHOD-SLOT.SLOT-OWNER METHOD2))))
          (SUB-TYPE-SPEC-OF? TS2 TS1)))
        (CL:SETQ ALWAYS?-001 CL:NIL) (CL:RETURN))
       (CL:SETQ ITER-002 (%%REST ITER-002))
       (CL:SETQ ITER-003 (%%REST ITER-003))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-001)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000))
    (CL:RETURN-FROM IDENTICAL-SIGNATURES? VALUE-000))))

;;; (DEFUN COMPUTE-REQUIRED-SLOT-NAMES ...)

(CL:DEFUN COMPUTE-REQUIRED-SLOT-NAMES (CLASS)
  (CL:LET* ((SLOTNAMES (NEW-LIST)))
   (CL:LET* ((SLOT NULL) (ITER-000 (CLASS-SLOTS CLASS)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SLOT (%ITERATOR.VALUE ITER-000))
     (CL:WHEN
      (CL:AND (STORAGE-SLOT? SLOT) (%STORAGE-SLOT.SLOT-REQUIRED? SLOT)
       (CL:NOT (MEMBER? SLOTNAMES (%SLOT.SLOT-NAME SLOT))))
      (PUSH SLOTNAMES (%SLOT.SLOT-NAME SLOT)))))
   (CL:IF (EMPTY? SLOTNAMES) (FREE SLOTNAMES)
    (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
     SYM-CLASSES-STELLA-CLASS-REQUIRED-SLOT-NAMES (REVERSE SLOTNAMES)
     NULL)))
  :VOID)

;;; (DEFUN FREE-REQUIRED-SLOT-NAMES ...)

(CL:DEFUN FREE-REQUIRED-SLOT-NAMES (CLASS)
  (CL:WHEN (NON-EMPTY? (CLASS-REQUIRED-SLOT-NAMES CLASS))
   (FREE (CLASS-REQUIRED-SLOT-NAMES CLASS))
   (SET-DYNAMIC-SLOT-VALUE (%CLASS.DYNAMIC-SLOTS CLASS)
    SYM-CLASSES-STELLA-CLASS-REQUIRED-SLOT-NAMES NULL NULL))
  :VOID)

;;; (DEFMETHOD (DYNAMIC-STORAGE? BOOLEAN) ...)

(CL:DEFMETHOD DYNAMIC-STORAGE? ((SELF STORAGE-SLOT))
  (CL:LET* ((ALLOCATION (ALLOCATION SELF)))
   (CL:RETURN-FROM DYNAMIC-STORAGE?
    (CL:OR (CL:EQ ALLOCATION KWD-CLASSES-DYNAMIC)
     (CL:EQ ALLOCATION KWD-CLASSES-BIT)))))

;;; (DEFMETHOD (PRIVATE? BOOLEAN) ...)

(CL:DEFMETHOD PRIVATE? ((SELF RELATION))
  "Return `true' if `self' is not public."
  (CL:RETURN-FROM PRIVATE? (CL:NOT (PUBLIC? SELF))))

;;; (DEFMETHOD (PUBLIC? BOOLEAN) ...)

(CL:DEFMETHOD PUBLIC? ((SELF SLOT))
  "True if `self' or one it its ancestors is marked public."
  (CL:RETURN-FROM PUBLIC?
   (CL:OR (%SLOT.SLOT-PUBLIC? SELF)
    (CL:AND (CL:NOT (CL:EQ (%SLOT.SLOT-DIRECT-EQUIVALENT SELF) NULL))
     (PUBLIC? (%SLOT.SLOT-DIRECT-EQUIVALENT SELF))))))

;;; (DEFMETHOD (PUBLIC-SLOTS (ITERATOR OF SLOT)) ...)

(CL:DEFMETHOD PUBLIC-SLOTS ((SELF CLASS))
  "Return an iterator over public slots of `self'."
  (CL:LET* ((PUBLICSLOTS NIL) (ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:LET* ((SLOT NULL) (ITER-000 (CLASS-SLOTS SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SLOT (%ITERATOR.VALUE ITER-000))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:SETQ TEST-VALUE-000 (%SLOT.SLOT-PUBLIC? SLOT))
      (CL:WHEN TEST-VALUE-000
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET* ((PS NULL) (ITER-001 PUBLICSLOTS))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ PS (%%VALUE ITER-001))
          (CL:WHEN (CL:EQ (%SLOT.SLOT-NAME PS) (%SLOT.SLOT-NAME SLOT))
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:SETQ TEST-VALUE-000 FOUND?-000))
       (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000)))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ PUBLICSLOTS (CONS SLOT PUBLICSLOTS))))))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION ITERATOR-CONS-LIST-NEXT?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-CONS-LIST ITERATOR)
    PUBLICSLOTS)
   (CL:SETF (%ALL-PURPOSE-ITERATOR.FIRST-ITERATION? ITERATOR) CL:T)
   (CL:RETURN-FROM PUBLIC-SLOTS ITERATOR)))

;;; (DEFMETHOD (PUBLIC-SLOTS (ITERATOR OF SLOT)) ...)

(%%DEFCONSMETHOD PUBLIC-SLOTS ((SELF OBJECT))
  "Return an iterator over public slots of `self'."
  (CL:RETURN-FROM PUBLIC-SLOTS (PUBLIC-SLOTS (PRIMARY-CLASS SELF))))

(CL:DEFUN NEW-ALL-CLASS-SLOTS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-ALL-CLASS-SLOTS-ITERATOR))
   (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-OBJECT SELF) NULL)
   (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-CONS-LIST SELF) NULL)
   (CL:RETURN-FROM NEW-ALL-CLASS-SLOTS-ITERATOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ALL-CLASS-SLOTS-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-CLASSES-STELLA-ALL-CLASS-SLOTS-ITERATOR))

(CL:DEFUN ACCESS-ALL-CLASS-SLOTS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-CLASSES-STELLA-ITERATOR-CONS-LIST)
    (CL:IF SETVALUE?
     (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-CONS-LIST SELF)
      VALUE)
     (CL:SETQ VALUE
      (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-CONS-LIST SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSES-STELLA-ITERATOR-OBJECT)
    (CL:IF SETVALUE?
     (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-OBJECT SELF) VALUE)
     (CL:SETQ VALUE (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-OBJECT SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-ALL-CLASS-SLOTS-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFMETHOD (ALL-CLASS-SLOTS (ITERATOR OF SLOT)) ...)

(CL:DEFMETHOD ALL-CLASS-SLOTS ((SELF CLASS))
  (CL:LET* ((ITERATOR (NEW-ALL-CLASS-SLOTS-ITERATOR)))
   (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-CONS-LIST ITERATOR)
    (%LIST.THE-CONS-LIST (%CLASS.CLASS-LOCAL-SLOTS SELF)))
   (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-OBJECT ITERATOR)
    (%CLASS.CLASS-ALL-SUPER-CLASSES SELF))
   (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.FIRST-ITERATION? ITERATOR) CL:T)
   (CL:RETURN-FROM ALL-CLASS-SLOTS ITERATOR)))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF ALL-CLASS-SLOTS-ITERATOR))
  (CL:LET*
   ((LOCALSLOTS (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-CONS-LIST SELF)))
   (CL:COND
    ((CL:EQ LOCALSLOTS NIL)
     (CL:LET*
      ((CLASSES (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-OBJECT SELF)))
      (CL:LOOP WHILE
       (CL:AND (CL:NOT (CL:EQ CLASSES NIL)) (CL:EQ LOCALSLOTS NIL)) DO
       (CL:SETQ LOCALSLOTS
        (%LIST.THE-CONS-LIST
         (%CLASS.CLASS-LOCAL-SLOTS (%%VALUE CLASSES))))
       (CL:SETQ CLASSES (%%REST CLASSES)))
      (CL:WHEN (CL:EQ CLASSES NIL)
       (CL:WHEN (CL:EQ LOCALSLOTS NIL)
        (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.VALUE SELF) NULL)
        (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-OBJECT SELF) NULL)
        (CL:RETURN-FROM NEXT? CL:NIL)))
      (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-OBJECT SELF)
       CLASSES)
      (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.VALUE SELF)
       (%%VALUE LOCALSLOTS))
      (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-CONS-LIST SELF)
       (%%REST LOCALSLOTS))
      (CL:RETURN-FROM NEXT? CL:T)))
    (CL:T
     (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.VALUE SELF)
      (%%VALUE LOCALSLOTS))
     (CL:SETF (%ALL-CLASS-SLOTS-ITERATOR.ITERATOR-CONS-LIST SELF)
      (%%REST LOCALSLOTS))
     (CL:RETURN-FROM NEXT? CL:T)))))

;;; (DEFMETHOD (CLASS-SLOTS (ITERATOR OF SLOT)) ...)

(CL:DEFMETHOD CLASS-SLOTS ((SELF CLASS))
  (CL:RETURN-FROM CLASS-SLOTS (ALL-CLASS-SLOTS SELF)))

;;; (DEFMETHOD (LOCAL-SLOTS (LIST OF SLOT)) ...)

(CL:DEFMETHOD LOCAL-SLOTS ((SELF CLASS))
  (CL:RETURN-FROM LOCAL-SLOTS (%CLASS.CLASS-LOCAL-SLOTS SELF)))

;;; (DEFMETHOD (DIRECT-SUPER-CLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFMETHOD DIRECT-SUPER-CLASSES ((SELF CLASS))
  "Returns an iterator that generates all direct
super classes of `self'."
  (CL:RETURN-FROM DIRECT-SUPER-CLASSES
   (NEW-TYPES-TO-CLASSES-ITERATOR
    (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS SELF)))))

;;; (DEFMETHOD (SUPER-CLASSES (ITERATOR OF CLASS)) ...)

(CL:DEFMETHOD SUPER-CLASSES ((SELF CLASS))
  "Returns an iterator that generates all super classes
of `self'.  Non-reflexive."
  (CL:LET* ((ITERATOR (NEW-LIST-ITERATOR)))
   (CL:SETF (%LIST-ITERATOR.LIST-ITERATOR-CURSOR ITERATOR)
    (%CLASS.CLASS-ALL-SUPER-CLASSES SELF))
   (CL:RETURN-FROM SUPER-CLASSES ITERATOR)))

;;; (DEFMETHOD (ACTIVE? BOOLEAN) ...)

(CL:DEFMETHOD ACTIVE? ((SLOT SLOT))
  (CL:RETURN-FROM ACTIVE?
   (CL:IF
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SLOT)
       SYM-CLASSES-STELLA-STORED-ACTIVE? NULL)
      NULL))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
     (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SLOT)
      SYM-CLASSES-STELLA-STORED-ACTIVE? NULL))
    (CL:AND
     (CL:NOT
      (CL:EQ (%SURROGATE.SURROGATE-VALUE SGT-CLASSES-STELLA-COLLECTION)
       NULL))
     (CL:NOT
      (CL:EQ (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-BASE-TYPE SLOT))
       NULL))
     (CL:NOT
      (CL:EQ (%SURROGATE.SURROGATE-VALUE (%SLOT.SLOT-OWNER SLOT))
       NULL))
     (PRIMITIVE? SLOT)
     (CL:OR
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%SLOT.DYNAMIC-SLOTS SLOT)
         SYM-CLASSES-STELLA-SLOT-INVERSE NULL)
        NULL))
      (CL:AND (CL:NOT (CL:EQ (%SLOT.SLOT-DIRECT-EQUIVALENT SLOT) NULL))
       (ACTIVE? (%SLOT.SLOT-DIRECT-EQUIVALENT SLOT))))))))

;;; (DEFMETHOD (INITIAL-VALUE OBJECT) ...)

(CL:DEFMETHOD INITIAL-VALUE ((SELF STORAGE-SLOT))
  "Return an initial value for `self', or `null'.  The
initial value can be defined by the slot itself, inherited from an
equivalent slot, or inherit from the :initial-value option for the 
class representing the type of `self'."
  (CL:LET*
   ((SLOT SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
      SYM-CLASSES-STELLA-SLOT-INITIAL-VALUE NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM INITIAL-VALUE VALUE))
    (CL:SETQ SLOT (%STORAGE-SLOT.SLOT-DIRECT-EQUIVALENT SLOT))
    (CL:IF (CL:NOT (CL:EQ SLOT NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SLOT)
       SYM-CLASSES-STELLA-SLOT-INITIAL-VALUE NULL))
     (CL:RETURN)))
   (CL:RETURN-FROM INITIAL-VALUE
    (DYNAMIC-SLOT-VALUE
     (%CLASS.DYNAMIC-SLOTS (%SURROGATE.SURROGATE-VALUE (TYPE SELF)))
     SYM-CLASSES-STELLA-CLASS-INITIAL-VALUE NULL))))

;;; (DEFMETHOD (SYSTEM-DEFAULT-VALUE OBJECT) ...)

(CL:DEFMETHOD SYSTEM-DEFAULT-VALUE ((SELF SLOT))
  "Return a default value expression, or if `self'
has dynamic storage, an initial value expression."
  (CL:RETURN-FROM SYSTEM-DEFAULT-VALUE
   (DYNAMIC-SLOT-VALUE
    (%CLASS.DYNAMIC-SLOTS (%SURROGATE.SURROGATE-VALUE (TYPE SELF)))
    SYM-CLASSES-STELLA-CLASS-INITIAL-VALUE NULL)))

;;; (DEFMETHOD (SYSTEM-DEFAULT-VALUE OBJECT) ...)

(CL:DEFMETHOD SYSTEM-DEFAULT-VALUE ((SELF STORAGE-SLOT))
  "Return a default value expression, or if `self'
has dynamic storage, an initial value expression."
  (CL:LET* ((VALUE (DEFAULT-FORM SELF)))
   (CL:COND
    ((CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM SYSTEM-DEFAULT-VALUE VALUE))
    ((CL:AND (DYNAMIC-STORAGE? SELF)
      (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE (TYPE SELF)) NULL)))
     (CL:RETURN-FROM SYSTEM-DEFAULT-VALUE
      (DYNAMIC-SLOT-VALUE
       (%CLASS.DYNAMIC-SLOTS (%SURROGATE.SURROGATE-VALUE (TYPE SELF)))
       SYM-CLASSES-STELLA-CLASS-INITIAL-VALUE NULL)))
    (CL:T (CL:RETURN-FROM SYSTEM-DEFAULT-VALUE NULL)))))

;;; (DEFMETHOD (INITIALLY OBJECT) ...)

(CL:DEFMETHOD INITIALLY ((SELF STORAGE-SLOT))
  "Defines the value of a slot before it has been assigned
a value."
  (CL:LET*
   ((VALUE
     (DYNAMIC-SLOT-VALUE (%STORAGE-SLOT.DYNAMIC-SLOTS SELF)
      SYM-CLASSES-STELLA-SLOT-INITIAL-VALUE NULL)))
   (CL:COND
    ((CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM INITIALLY VALUE))
    ((CL:NOT (CL:EQ (%STORAGE-SLOT.SLOT-DIRECT-EQUIVALENT SELF) NULL))
     (CL:RETURN-FROM INITIALLY
      (INITIALLY (%STORAGE-SLOT.SLOT-DIRECT-EQUIVALENT SELF))))
    ((CL:EQ (%STORAGE-SLOT.SLOT-BASE-TYPE SELF)
      SGT-CLASSES-STELLA-BOOLEAN)
     (CL:RETURN-FROM INITIALLY SYM-CLASSES-STELLA-FALSE))
    (CL:T (CL:RETURN-FROM INITIALLY NULL)))))

;;; (DEFUN REPAIR-SLOTS ...)

(CL:DEFUN REPAIR-SLOTS ()
  (CL:LET*
   ((TOP (%SURROGATE.SURROGATE-VALUE SGT-CLASSES-STELLA-OBJECT)))
   (UNFINALIZE-CLASS-SLOTS TOP) (FINALIZE-CLASSES-AND-SLOTS))
  :VOID)

;;; (DEFUN DISCONNECT-CLASSES ...)

(CL:DEFUN DISCONNECT-CLASSES ()
  (CL:LET*
   ((SURROGATE NULL) (ITER-000 (ALL-SURROGATES *MODULE* CL:NIL)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO
    (CL:SETQ SURROGATE (%ITERATOR.VALUE ITER-000))
    (CL:WHEN
     (CL:AND
      (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SURROGATE) NULL))
      (STELLA-CLASS? (%SURROGATE.SURROGATE-VALUE SURROGATE)))
     (CL:SETF (%SURROGATE.SURROGATE-VALUE SURROGATE) NULL))))
  :VOID)

;;; (DEFUN (FILTER-UNBOUND-SURROGATE? BOOLEAN) ...)

(CL:DEFUN FILTER-UNBOUND-SURROGATE? (SELF ITERATOR)
  (CL:SETQ ITERATOR ITERATOR)
  (CL:RETURN-FROM FILTER-UNBOUND-SURROGATE?
   (CL:EQ (%SURROGATE.SURROGATE-VALUE SELF) NULL)))

;;; (DEFUN (UNBOUND-SURROGATES (ITERATOR OF SURROGATE)) ...)

(CL:DEFUN UNBOUND-SURROGATES (MODULE LOCAL?)
  "Iterate over all unbound surrogates visible from `module'.
Look at all modules if `module' is `null'.  If `local?', only consider
surrogates interned in `module'."
  (CL:LET* ((ITERATOR (NEW-ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NESTED-ITERATOR ITERATOR)
    (ALL-SURROGATES MODULE LOCAL?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-NEXT-CODE ITERATOR)
    (CL:FUNCTION FILTERED-NESTED-ITERATOR-NEXT?))
   (CL:SETF (%ALL-PURPOSE-ITERATOR.ITERATOR-FILTER-CODE ITERATOR)
    (CL:FUNCTION FILTER-UNBOUND-SURROGATE?))
   (CL:RETURN-FROM UNBOUND-SURROGATES ITERATOR)))

;;; (DEFUN (NAME-TO-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) NAME-TO-STRING))
(CL:DEFUN NAME-TO-STRING (NAME)
  "Return the string represented by `name'.  Return `null'
if `name' is undefined or does not represent a string."
  (CL:WHEN (CL:NOT (CL:EQ NAME NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NAME)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000
       SGT-CLASSES-STELLA-GENERALIZED-SYMBOL)
      (CL:PROGN
       (CL:RETURN-FROM NAME-TO-STRING
        (%GENERALIZED-SYMBOL.SYMBOL-NAME NAME))))
     ((SUBTYPE-OF-STRING? TEST-VALUE-000)
      (CL:PROGN
       (CL:RETURN-FROM NAME-TO-STRING
        (%STRING-WRAPPER.WRAPPER-VALUE NAME))))
     (CL:T))))
  (CL:RETURN-FROM NAME-TO-STRING STELLA::NULL-STRING))

;;; (DEFUN PRINT-UNBOUND-SURROGATES ...)

(CL:DEFUN %PRINT-UNBOUND-SURROGATES (ARGS)
  "Print all unbound surrogates visible from the module named by the first
argument (a symbol or string).  Look at all modules if no module name or
`null' was supplied.  If the second argument is `true', only consider
surrogates interned in the specified module."
  (CL:LET*
   ((ARGLIST ARGS) (NAME (NAME-TO-STRING (%%VALUE ARGLIST)))
    (MODULE
     (CL:IF (CL:NOT (CL:EQ NAME STELLA::NULL-STRING))
      (GET-STELLA-MODULE NAME CL:T) NULL))
    (LOCAL? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
   (CL:WHEN (CL:EQ (%%VALUE (%%REST ARGLIST)) SYM-CLASSES-STELLA-TRUE)
    (CL:SETQ LOCAL? CL:T))
   (CL:LET*
    ((SURROGATE NULL) (ITER-000 (UNBOUND-SURROGATES MODULE LOCAL?)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ SURROGATE (%ITERATOR.VALUE ITER-000))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      SURROGATE EOL))))
  :VOID)

(CL:DEFUN PRINT-UNBOUND-SURROGATES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%PRINT-UNBOUND-SURROGATES ARGUMENTS)
  :VOID)

(CL:DEFMACRO PRINT-UNBOUND-SURROGATES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Print all unbound surrogates visible from the module named by the first
argument (a symbol or string).  Look at all modules if no module name or
`null' was supplied.  If the second argument is `true', only consider
surrogates interned in the specified module."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/PRINT-UNBOUND-SURROGATES|)) (CL:MACRO-FUNCTION (CL:QUOTE PRINT-UNBOUND-SURROGATES)))

;;; (DEFUN (COERCE-TO-SYMBOL GENERALIZED-SYMBOL) ...)

(CL:DEFUN COERCE-TO-SYMBOL (NAME)
  "Return the (generalized) symbol represented by `name'.
Return `null' if `name' is undefined or does not represent a string."
  (CL:WHEN (CL:NOT (CL:EQ NAME NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NAME)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000
       SGT-CLASSES-STELLA-GENERALIZED-SYMBOL)
      (CL:PROGN (CL:RETURN-FROM COERCE-TO-SYMBOL NAME)))
     ((SUBTYPE-OF-STRING? TEST-VALUE-000)
      (CL:PROGN
       (CL:RETURN-FROM COERCE-TO-SYMBOL
        (LOOKUP-SYMBOL (%STRING-WRAPPER.WRAPPER-VALUE NAME)))))
     (CL:T))))
  (CL:RETURN-FROM COERCE-TO-SYMBOL NULL))

;;; (DEFUN PRINT-UNDEFINED-SUPER-CLASSES ...)

(CL:DEFUN %PRINT-UNDEFINED-SUPER-CLASSES (CLASS)
  "Print all undefined or bad (indirect) super classes of `class'."
  (CL:LET*
   ((TYPE (TYPIFY (COERCE-TO-SYMBOL CLASS))) (BADONES (NEW-LIST)))
   (CL:WHEN (CL:EQ TYPE NULL)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Illegal class name: " CLASS EOL)
    (CL:RETURN-FROM %PRINT-UNDEFINED-SUPER-CLASSES))
   (COLLECT-BAD-SUPER-CLASSES TYPE BADONES)
   (CL:WHEN (MEMBER? BADONES TYPE)
    (CL:IF (CL:EQ (%SURROGATE.SURROGATE-VALUE TYPE) NULL)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      TYPE " is itself undefined." EOL)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      TYPE " itself points to non-class "
      (%SURROGATE.SURROGATE-VALUE TYPE) EOL))
    (CL:RETURN-FROM %PRINT-UNDEFINED-SUPER-CLASSES))
   (CL:LET* ((FOUND?-000 CL:NIL))
    (CL:LET* ((SUPER NULL) (ITER-000 (%LIST.THE-CONS-LIST BADONES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ SUPER (%%VALUE ITER-000))
      (CL:WHEN (CL:EQ (%SURROGATE.SURROGATE-VALUE SUPER) NULL)
       (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:WHEN FOUND?-000
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "The following (indirect) super(s) of " TYPE " are undefined:"
      EOL)
     (CL:LET* ((SUPER NULL) (ITER-001 (%LIST.THE-CONS-LIST BADONES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ SUPER (%%VALUE ITER-001))
       (CL:WHEN (CL:EQ (%SURROGATE.SURROGATE-VALUE SUPER) NULL)
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "    " SUPER EOL))
       (CL:SETQ ITER-001 (%%REST ITER-001))))))
   (CL:LET* ((FOUND?-001 CL:NIL))
    (CL:LET* ((SUPER NULL) (ITER-002 (%LIST.THE-CONS-LIST BADONES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:SETQ SUPER (%%VALUE ITER-002))
      (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUPER) NULL))
       (CL:SETQ FOUND?-001 CL:T) (CL:RETURN))
      (CL:SETQ ITER-002 (%%REST ITER-002))))
    (CL:WHEN FOUND?-001
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "The following (indirect) super(s) of " TYPE
      " point to non-classes:" EOL)
     (CL:LET* ((SUPER NULL) (ITER-003 (%LIST.THE-CONS-LIST BADONES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
       (CL:SETQ SUPER (%%VALUE ITER-003))
       (CL:WHEN
        (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUPER) NULL))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
         "    " SUPER " points to " (%SURROGATE.SURROGATE-VALUE SUPER)
         EOL))
       (CL:SETQ ITER-003 (%%REST ITER-003)))))))
  :VOID)

(CL:DEFMACRO PRINT-UNDEFINED-SUPER-CLASSES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Print all undefined or bad (indirect) super classes of `class'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/PRINT-UNDEFINED-SUPER-CLASSES|)) (CL:MACRO-FUNCTION (CL:QUOTE PRINT-UNDEFINED-SUPER-CLASSES)))

;;; (DEFUN (COLLECT-BAD-SUPER-CLASSES (LIST OF TYPE)) ...)

(CL:DEFUN COLLECT-BAD-SUPER-CLASSES (TYPE BADONES)
  (CL:LET* ((VALUE (%SURROGATE.SURROGATE-VALUE TYPE)))
   (CL:IF (STELLA-CLASS? VALUE)
    (CL:LET*
     ((SUPER NULL)
      (ITER-000
       (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUPERS VALUE))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ SUPER (%%VALUE ITER-000))
      (COLLECT-BAD-SUPER-CLASSES SUPER BADONES)
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (INSERT-NEW BADONES TYPE))
   (CL:RETURN-FROM COLLECT-BAD-SUPER-CLASSES BADONES)))

;;; (DEFUN (ROOT-CLASS? BOOLEAN) ...)

(CL:DEFUN ROOT-CLASS? (CLASS)
  (CL:RETURN-FROM ROOT-CLASS?
   (CL:AND (EMPTY? (%CLASS.CLASS-DIRECT-SUPERS CLASS))
    (CL:NOT (%CLASS.MIXIN? CLASS)))))

;;; (DEFGLOBAL *CLASS-TAXONOMY-GRAPH* ...)

(CL:DEFVAR *CLASS-TAXONOMY-GRAPH* NULL)

;;; (DEFUN CREATE-CLASS-TAXONOMY ...)

(CL:DEFUN CREATE-CLASS-TAXONOMY ()
  (CL:LET* ((GRAPH *CLASS-TAXONOMY-GRAPH*))
   (CL:IF (CL:EQ GRAPH NULL) (CL:SETQ GRAPH (NEW-TAXONOMY-GRAPH))
    (INITIALIZE-TAXONOMY-GRAPH GRAPH))
   (CL:LET* ((CLASS NULL) (ITER-000 (ALL-CLASSES NULL CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ CLASS (%ITERATOR.VALUE ITER-000))
     (CL:SETF (%CLASS.CLASS-TAXONOMY-NODE CLASS)
      (CREATE-TAXONOMY-NODE GRAPH (%CLASS.CLASS-TAXONOMY-NODE CLASS)
       CLASS (EMPTY? (%CLASS.CLASS-DIRECT-SUPERS CLASS))))))
   (CL:LET* ((CLASS NULL) (ITER-001 (ALL-CLASSES NULL CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO
     (CL:SETQ CLASS (%ITERATOR.VALUE ITER-001))
     (CL:LET*
      ((SUB NULL)
       (ITER-002
        (%LIST.THE-CONS-LIST (%CLASS.CLASS-DIRECT-SUBS CLASS))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ SUB (%%VALUE ITER-002))
       (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE.SURROGATE-VALUE SUB) NULL))
        (LINK-TAXONOMY-NODES GRAPH (%CLASS.CLASS-TAXONOMY-NODE CLASS)
         (%CLASS.CLASS-TAXONOMY-NODE
          (%SURROGATE.SURROGATE-VALUE SUB))))
       (CL:SETQ ITER-002 (%%REST ITER-002))))))
   (FINALIZE-TAXONOMY-GRAPH GRAPH)
   (CL:SETQ *CLASS-TAXONOMY-GRAPH* GRAPH))
  :VOID)

;;; (DEFUN (SUBCLASS-OF? BOOLEAN) ...)

(CL:DEFUN SUBCLASS-OF? (SUBCLASS SUPERCLASS)
  "Return `true' if `subClass' is a subclass of `superClass'."
  (CL:WHEN (CL:EQ SUBCLASS SUPERCLASS)
   (CL:RETURN-FROM SUBCLASS-OF? CL:T))
  (CL:LET*
   ((SUBNODE (%CLASS.CLASS-TAXONOMY-NODE SUBCLASS))
    (SUPERNODE (%CLASS.CLASS-TAXONOMY-NODE SUPERCLASS))
    (SUBLABEL NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SUBLABEL))
   (CL:WHEN
    (CL:OR (CL:EQ SUBNODE NULL) (CL:EQ SUPERNODE NULL)
     (CL:= (CL:SETQ SUBLABEL (%TAXONOMY-NODE.LABEL SUBNODE))
      NULL-INTEGER))
    (CL:RETURN-FROM SUBCLASS-OF?
     (MEMB? (%CLASS.CLASS-ALL-SUPER-CLASSES SUBCLASS) SUPERCLASS)))
   (CL:LET*
    ((INTERVAL NULL) (ITER-000 (%TAXONOMY-NODE.INTERVALS SUPERNODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ INTERVAL (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:>= SUBLABEL (%INTERVAL.LOWER-BOUND INTERVAL))
       (CL:<= SUBLABEL (%INTERVAL.UPPER-BOUND INTERVAL)))
      (CL:RETURN-FROM SUBCLASS-OF? CL:T))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM SUBCLASS-OF? CL:NIL)))

;;; (DEFUN (FAST-SUBCLASS-OF? BOOLEAN) ...)

(CL:DEFUN FAST-SUBCLASS-OF? (SUBCLASS SUPERCLASS)
  (CL:LET*
   ((SUBLABEL
     (%TAXONOMY-NODE.LABEL (%CLASS.CLASS-TAXONOMY-NODE SUBCLASS))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SUBLABEL))
   (CL:LET*
    ((INTERVAL NULL)
     (ITER-000
      (%TAXONOMY-NODE.INTERVALS
       (%CLASS.CLASS-TAXONOMY-NODE SUPERCLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ INTERVAL (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:>= SUBLABEL (%INTERVAL.LOWER-BOUND INTERVAL))
       (CL:<= SUBLABEL (%INTERVAL.UPPER-BOUND INTERVAL)))
      (CL:RETURN-FROM FAST-SUBCLASS-OF? CL:T))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM FAST-SUBCLASS-OF? CL:NIL)))

;;; (DEFUN (SUBTYPE-OF? BOOLEAN) ...)

(CL:DEFUN SUBTYPE-OF? (SUB-TYPE SUPER-TYPE)
  "Return `true' iff the class named `sub-type' is a subclass 
of the class named `super-type'."
  (CL:DECLARE (CL:INLINE SUBCLASS-OF?))
  (CL:LET*
   ((SUBCLASS (TYPE-TO-CLASS SUB-TYPE))
    (SUPERCLASS (TYPE-TO-CLASS SUPER-TYPE)))
   (CL:WHEN (CL:EQ SUBCLASS NULL)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Reference to non-existent class: `"
       (DE-UGLIFY-PARSE-TREE SUB-TYPE) "'" EOL "." EOL)))
    (CL:RETURN-FROM SUBTYPE-OF? CL:NIL))
   (CL:WHEN (CL:EQ SUPERCLASS NULL)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Reference to non-existent class: `"
       (DE-UGLIFY-PARSE-TREE SUPER-TYPE) "'" EOL "." EOL)))
    (CL:RETURN-FROM SUBTYPE-OF? CL:NIL))
   (CL:RETURN-FROM SUBTYPE-OF? (SUBCLASS-OF? SUBCLASS SUPERCLASS))))

;;; (DEFUN (ISA? BOOLEAN) ...)

(CL:DEFUN ISA? (OBJECT TYPE)
  "Return `true' iff `object' is an instance of the class named `type'."
  (CL:RETURN-FROM ISA?
   (SUBCLASS-OF? (%SURROGATE.SURROGATE-VALUE (PRIMARY-TYPE OBJECT))
    (%SURROGATE.SURROGATE-VALUE TYPE))))

;;; (DEFUN (TAXONOMY-SUBCLASS-OF? BOOLEAN) ...)

(CL:DEFUN TAXONOMY-SUBCLASS-OF? (SUBCLASS SUPERCLASS)
  (CL:RETURN-FROM TAXONOMY-SUBCLASS-OF?
   (SUBCLASS-OF? SUBCLASS SUPERCLASS)))

;;; (DEFUN (TAXONOMY-ISA? BOOLEAN) ...)

(CL:DEFUN TAXONOMY-ISA? (OBJECT TYPE)
  (CL:RETURN-FROM TAXONOMY-ISA? (ISA? OBJECT TYPE)))

;;; (DEFUN (INTERN-SLOTREF SLOTREF) ...)

(CL:DEFUN INTERN-SLOTREF (CLASSNAME SLOTNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CLASSNAME SLOTNAME))
  #+MCL
  (CL:CHECK-TYPE CLASSNAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SLOTNAME CL:SIMPLE-STRING)
  (CL:RETURN-FROM INTERN-SLOTREF
   (INTERN-SURROGATE
    (CONCATENATE CLASSNAME (CONCATENATE "." SLOTNAME)))))

;;; (DEFUN (LOOKUP-SLOTREF SLOTREF) ...)

(CL:DEFUN LOOKUP-SLOTREF (SELF SLOTNAME)
  (CL:SETQ SELF (REAL-TYPE-SPECIFIER SELF))
  (CL:LET*
   ((CLASS (%SURROGATE.SURROGATE-VALUE SELF)) (SLOT NULL)
    (SLOTREF NULL))
   (CL:SETQ SLOT (LOOKUP-FUNCTION SLOTNAME))
   (CL:WHEN (CL:EQ SLOT NULL)
    (CL:SETQ SLOT (LOOKUP-SLOT CLASS SLOTNAME)))
   (CL:COND
    ((CL:EQ SLOT NULL)
     (CL:WHEN (CL:NOT (CL:EQ CLASS NULL))
      (CL:RETURN-FROM LOOKUP-SLOTREF NULL)))
    (CL:T (CL:SETQ SELF (%SLOT.SLOT-OWNER SLOT))
     (CL:WHEN (CL:EQ SELF NULL) (CL:SETQ SELF SGT-CLASSES-STELLA-ANY))
     (CL:SETQ SLOTREF (%SLOT.SLOT-SLOTREF SLOT))))
   (CL:WHEN (CL:EQ SLOTREF NULL)
    (CL:LET*
     ((*MODULE*
       (CL:IF (CL:NOT (CL:EQ SLOT NULL)) (HOME-MODULE SLOT)
        (%SYMBOL.HOME-CONTEXT (PERMANENTIFY SLOTNAME))))
      (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CL:SETQ SLOTREF
      (INTERN-SLOTREF (%SURROGATE.SYMBOL-NAME SELF)
       (%SYMBOL.SYMBOL-NAME SLOTNAME))))
    (CL:SETF (%SURROGATE.SURROGATE-VALUE SLOTREF) SLOT)
    (CL:WHEN (CL:NOT (CL:EQ SLOT NULL))
     (CL:SETF (%SLOT.SLOT-SLOTREF SLOT) SLOTREF)))
   (CL:RETURN-FROM LOOKUP-SLOTREF SLOTREF)))

;;; (DEFUN (SLOTREF? BOOLEAN) ...)

(CL:DEFUN SLOTREF? (SELF)
  (CL:RETURN-FROM SLOTREF?
   (CL:NOT
    (CL:= (POSITION (%SURROGATE.SYMBOL-NAME SELF) #\. 0) NULL-INTEGER))))

;;; (DEFUN (LOOKUP-SLOT-FROM-SLOTREF SLOT) ...)

(CL:DEFUN LOOKUP-SLOT-FROM-SLOTREF (SLOTREF)
  (CL:LET* ((VALUE (%SURROGATE.SURROGATE-VALUE SLOTREF)))
   (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
    (CL:WHEN (ISA? VALUE SGT-CLASSES-STELLA-SLOT)
     (CL:RETURN-FROM LOOKUP-SLOT-FROM-SLOTREF VALUE))
    (CL:WARN
     "lookup-slot-from-slotref: `~A' already points to non-slot `~A'"
     SLOTREF VALUE)
    (CL:RETURN-FROM LOOKUP-SLOT-FROM-SLOTREF NULL)))
  (CL:LET*
   ((SLOTREFNAME (%SURROGATE.SYMBOL-NAME SLOTREF))
    (SLOTREFMODULE (%SURROGATE.HOME-CONTEXT SLOTREF))
    (DOTPOSITION (POSITION SLOTREFNAME #\. 0)) (TYPE NULL)
    (SLOTNAME NULL) (SLOT NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SLOTREFNAME)
    (CL:TYPE CL:FIXNUM DOTPOSITION))
   (CL:COND
    ((CL:NOT (CL:= DOTPOSITION NULL-INTEGER))
     (CL:SETQ TYPE
      (LOOKUP-SURROGATE-IN-MODULE
       (SUBSEQUENCE SLOTREFNAME 0 DOTPOSITION) SLOTREFMODULE CL:NIL)))
    (CL:T (CL:SETQ TYPE SGT-CLASSES-STELLA-ANY)
     (CL:SETQ DOTPOSITION -1)))
   (CL:WHEN (CL:NOT (CL:EQ TYPE NULL))
    (CL:SETQ TYPE (REAL-TYPE-SPECIFIER TYPE)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ TYPE NULL))
     (STELLA-CLASS? (%SURROGATE.SURROGATE-VALUE TYPE)))
    (CL:SETQ SLOTNAME
     (LOOKUP-SYMBOL-IN-MODULE
      (SUBSEQUENCE SLOTREFNAME (CL:1+ DOTPOSITION) NULL-INTEGER)
      SLOTREFMODULE CL:NIL))
    (CL:WHEN (CL:NOT (CL:EQ SLOTNAME NULL))
     (CL:SETQ SLOT (LOOKUP-FUNCTION SLOTNAME))
     (CL:WHEN (CL:EQ SLOT NULL)
      (CL:SETQ SLOT
       (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE TYPE) SLOTNAME)))
     (CL:WHEN (CL:NOT (CL:EQ SLOT NULL))
      (CL:WHEN (CL:EQ (%SLOT.SLOT-SLOTREF SLOT) NULL)
       (LOOKUP-SLOTREF
        (CL:IF (CL:EQ (%SLOT.SLOT-OWNER SLOT) NULL)
         SGT-CLASSES-STELLA-ANY (%SLOT.SLOT-OWNER SLOT))
        (%SLOT.SLOT-NAME SLOT)))
      (CL:SETF (%SURROGATE.SURROGATE-VALUE SLOTREF) SLOT))))
   (CL:RETURN-FROM LOOKUP-SLOT-FROM-SLOTREF SLOT)))

;;; (DEFUN (SLOTREF-TYPE TYPE) ...)

(CL:DEFUN SLOTREF-TYPE (SLOTREF)
  (CL:RETURN-FROM SLOTREF-TYPE
   (TYPE (%SURROGATE.SURROGATE-VALUE SLOTREF))))

(CL:DEFUN HELP-STARTUP-CLASSES1 ()
  (CL:PROGN
   (CL:SETQ SGT-CLASSES-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 1))
   (CL:SETQ SGT-CLASSES-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
   (CL:SETQ KWD-CLASSES-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
   (CL:SETQ KWD-CLASSES-PARAMETERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETERS" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-TYPE-SPECIFIER" NULL 0))
   (CL:SETQ KWD-CLASSES-REQUIRED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REQUIRED?" NULL 2))
   (CL:SETQ KWD-CLASSES-COMPONENT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPONENT?" NULL 2))
   (CL:SETQ KWD-CLASSES-READ-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "READ-ONLY?" NULL 2))
   (CL:SETQ KWD-CLASSES-ACTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE?" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-STORED-ACTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORED-ACTIVE?" NULL 0))
   (CL:SETQ KWD-CLASSES-CONTEXT-SENSITIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-SENSITIVE?" NULL 2))
   (CL:SETQ KWD-CLASSES-HARDWIRED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HARDWIRED?" NULL 2))
   (CL:SETQ KWD-CLASSES-ABSTRACT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT?" NULL 2))
   (CL:SETQ KWD-CLASSES-ALLOCATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATION" NULL 2))
   (CL:SETQ KWD-CLASSES-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-ALLOCATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-ALLOCATION" NULL 0))
   (CL:SETQ KWD-CLASSES-INITIALLY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIALLY" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-INITIAL-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-INITIAL-VALUE" NULL 0))
   (CL:SETQ KWD-CLASSES-DEFAULT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-DEFAULT-EXPRESSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DEFAULT-EXPRESSION" NULL 0))
   (CL:SETQ KWD-CLASSES-READER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "READER" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-READER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-READER" NULL 0))
   (CL:SETQ KWD-CLASSES-WRITER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRITER" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-WRITER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-WRITER" NULL 0))
   (CL:SETQ KWD-CLASSES-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-INVERSE" NULL 0))
   (CL:SETQ KWD-CLASSES-RENAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RENAMES" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-RENAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-RENAMES" NULL 0))
   (CL:SETQ KWD-CLASSES-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
   (CL:SETQ KWD-CLASSES-PROPERTIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-PROPERTIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 0))
   (CL:SETQ KWD-CLASSES-META-ATTRIBUTES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-META-ATTRIBUTES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 0))
   (CL:SETQ KWD-CLASSES-OPTION-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTION-KEYWORD" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-OPTION-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-OPTION-KEYWORD" NULL 0))
   (CL:SETQ KWD-CLASSES-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPTION-HANDLER" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-OPTION-HANDLER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-OPTION-HANDLER" NULL 0))
   (CL:SETQ SGT-CLASSES-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ KWD-CLASSES-BIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BIT" NULL 2))
   (CL:SETQ KWD-CLASSES-CL-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CL-NATIVE-TYPE" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-CL-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-NATIVE-TYPE" NULL 0))
   (CL:SETQ KWD-CLASSES-CPP-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-NATIVE-TYPE" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-CPP-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CPP-NATIVE-TYPE" NULL 0))
   (CL:SETQ KWD-CLASSES-IDL-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IDL-NATIVE-TYPE" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-IDL-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-IDL-NATIVE-TYPE" NULL 0))
   (CL:SETQ KWD-CLASSES-JAVA-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-NATIVE-TYPE" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-JAVA-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-JAVA-NATIVE-TYPE" NULL 0))
   (CL:SETQ KWD-CLASSES-CL-STRUCT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CL-STRUCT?" NULL 2))
   (CL:SETQ KWD-CLASSES-MIXIN?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MIXIN?" NULL 2))
   (CL:SETQ KWD-CLASSES-RECYCLE-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RECYCLE-METHOD" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-RECYCLE-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-RECYCLE-METHOD" NULL 0))
   (CL:SETQ KWD-CLASSES-EXTENSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSION" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-EXTENSION-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-EXTENSION-NAME" NULL 0))
   (CL:SETQ KWD-CLASSES-CREATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATOR" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-CREATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CREATOR" NULL 0))
   (CL:SETQ KWD-CLASSES-INITIALIZER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIALIZER" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-INITIALIZER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-INITIALIZER" NULL 0))
   (CL:SETQ KWD-CLASSES-TERMINATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TERMINATOR" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-TERMINATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-TERMINATOR" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-CLASSES2 ()
  (CL:PROGN
   (CL:SETQ KWD-CLASSES-DESTRUCTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESTRUCTOR" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-DESTRUCTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DESTRUCTOR" NULL 0))
   (CL:SETQ KWD-CLASSES-INITIAL-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-VALUE" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-INITIAL-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-INITIAL-VALUE" NULL 0))
   (CL:SETQ KWD-CLASSES-PRINT-FORM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-FORM" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-PRINT-FORM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-FORM" NULL 0))
   (CL:SETQ KWD-CLASSES-EQUALITY-TEST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUALITY-TEST" NULL 2))
   (CL:SETQ KWD-CLASSES-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-KEY" NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-PARAMETERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-PARAMETERS" NULL 0))
   (CL:SETQ KWD-CLASSES-SYNONYMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYNONYMS" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-SYNONYMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-SYNONYMS" NULL 0))
   (CL:SETQ KWD-CLASSES-CHILDREN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILDREN" NULL 2))
   (CL:SETQ SGT-CLASSES-STELLA-METHOD-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT" NULL 1))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-GUARD-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-GUARD-DEMONS" NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-SLOT-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DEMONS" NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-CONSTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CONSTRUCTOR-DEMONS" NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-GUARD-CONSTRUCTOR-DEMONS"
     NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-DESTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DESTRUCTOR-DEMONS" NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-GUARD-DESTRUCTOR-DEMONS"
     NULL 0))
   (CL:SETQ SGT-CLASSES-STELLA-ACTIVE-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-OBJECT" NULL 1))
   (CL:SETQ SGT-CLASSES-STELLA-STANDARD-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STANDARD-OBJECT" NULL 1))
   (CL:SETQ SYM-CLASSES-STELLA-PRIMARY-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMARY-TYPE" NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-SELF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" NULL 0))
   (CL:SETQ KWD-CLASSES-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 0))
   (CL:SETQ KWD-CLASSES-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY?" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-RETURN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-EXTENSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-EXTENSION" NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-BAD?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD?" NULL 0))
   (CL:SETQ SGT-CLASSES-STELLA-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET" NULL 1))
   (CL:SETQ SGT-CLASSES-STELLA-ACTIVE-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-SET" NULL 1))
   (CL:SETQ SGT-CLASSES-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
   (CL:SETQ SGT-CLASSES-STELLA-ACTIVE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-LIST" NULL 1))
   (CL:SETQ SGT-CLASSES-STELLA-UNKNOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 1))
   (CL:SETQ SGT-CLASSES-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION" NULL 1))
   (CL:SETQ SGT-CLASSES-STELLA-SET-MIXIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-MIXIN" NULL 1))
   (CL:SETQ SYM-CLASSES-STELLA-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE" NULL 0))
   (CL:SETQ KWD-CLASSES-DYNAMIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC" NULL 2))
   (CL:SETQ SGT-CLASSES-STELLA-DYNAMIC-SLOTS-MIXIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC-SLOTS-MIXIN" NULL 1))
   (CL:SETQ KWD-CLASSES-INSTANCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INSTANCE" NULL 2))
   (CL:SETQ SGT-CLASSES-STELLA-CONTEXT-SENSITIVE-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-SENSITIVE-OBJECT" NULL 1))
   (CL:SETQ SGT-CLASSES-STELLA-CONTEXT-SENSITIVE-MIXIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-SENSITIVE-MIXIN" NULL 1))
   (CL:SETQ SGT-CLASSES-STELLA-VOID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
   (CL:SETQ SYM-CLASSES-STELLA-METHOD-MACRO?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-MACRO?" NULL 0))
   (CL:SETQ SGT-CLASSES-STELLA-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE" NULL 1))
   (CL:SETQ SYM-CLASSES-STELLA-CLASS-REQUIRED-SLOT-NAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-REQUIRED-SLOT-NAMES" NULL
     0))
   (CL:SETQ SGT-CLASSES-STELLA-ALL-CLASS-SLOTS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-CLASS-SLOTS-ITERATOR" NULL 1))
   (CL:SETQ SYM-CLASSES-STELLA-ITERATOR-CONS-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-CONS-LIST" NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-ITERATOR-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-OBJECT" NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ SGT-CLASSES-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL" NULL 1))
   (CL:SETQ SYM-CLASSES-STELLA-PRINT-UNBOUND-SURROGATES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-UNBOUND-SURROGATES" NULL 0))
   (CL:SETQ KWD-CLASSES-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-CLASSES-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-CLASSES-STELLA-PRINT-UNDEFINED-SUPER-CLASSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-UNDEFINED-SUPER-CLASSES"
     NULL 0))
   (CL:SETQ SYM-CLASSES-STELLA-ANY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY" NULL 0))
   (CL:SETQ SGT-CLASSES-STELLA-ANY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY" NULL 1))
   (CL:SETQ SGT-CLASSES-STELLA-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT" NULL 1)))
  :VOID)

(CL:DEFUN HELP-STARTUP-CLASSES3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "CLASS-NAME"
    "(DEFUN (CLASS-NAME STRING) ((CLASS CLASS)) :PUBLIC? TRUE)"
    (CL:FUNCTION CLASS-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-SYMBOL"
    "(DEFUN (CLASS-SYMBOL SYMBOL) ((CLASS CLASS)) :PUBLIC? TRUE)"
    (CL:FUNCTION CLASS-SYMBOL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PRIMARY-CLASS CLASS) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION PRIMARY-CLASS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP-CLASS CLASS) ((NAME STRING)) :DOCUMENTATION \"Return a class with name `name'.  Scan all
visible surrogates looking for one that has a class defined for it.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-CLASS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOOKUP-CLASS CLASS) ((NAME SYMBOL)) :DOCUMENTATION \"Return a class with name `name'.  Scan all
visible surrogates looking for one that has a class defined for it.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "TYPE-TO-CLASS"
    "(DEFUN (TYPE-TO-CLASS CLASS) ((TYPE TYPE)))"
    (CL:FUNCTION TYPE-TO-CLASS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-STELLA-CLASS CLASS) ((CLASS-NAME TYPE) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return a class with name `class-name'.  If none exists, break
if `error?', else return `null'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-STELLA-CLASS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-STELLA-CLASS CLASS) ((CLASS-NAME STRING) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return a class with name `class-name'.  If none exists, break
if `error?', else return `null'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-STELLA-CLASS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (GET-STELLA-CLASS CLASS) ((CLASS-NAME SYMBOL) (ERROR? BOOLEAN)) :DOCUMENTATION \"Return a class with name `class-name'.  If non exists, break
if `error?', else return `null'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-STELLA-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "BIND-TO-SURROGATE?"
    "(DEFUN (BIND-TO-SURROGATE? BOOLEAN OBJECT SURROGATE) ((SELF OBJECT) (NAME STRING) (CLIPOLDVALUE? BOOLEAN) (ASKFORPERMISSION? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION BIND-TO-SURROGATE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD UNBIND-FROM-SURROGATE ((SELF CLASS)))"
    (CL:FUNCTION UNBIND-FROM-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "SHADOW-SYMBOL"
    "(DEFUN (SHADOW-SYMBOL SYMBOL) ((NAME STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION SHADOW-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "SHADOW-SURROGATE"
    "(DEFUN (SHADOW-SURROGATE SURROGATE) ((NAME STRING)) :PUBLIC? TRUE)"
    (CL:FUNCTION SHADOW-SURROGATE) NULL)
   (DEFINE-FUNCTION-OBJECT "SHADOWED-SYMBOL?"
    "(DEFUN (SHADOWED-SYMBOL? BOOLEAN) ((SYMBOL GENERALIZED-SYMBOL)) :DOCUMENTATION \"Return `true' if `symbol' is shadowed in its home module.\" :PUBLIC? TRUE)"
    (CL:FUNCTION SHADOWED-SYMBOL?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-CONSTRUCTOR"
    "(DEFUN (GET-CONSTRUCTOR FUNCTION-CODE) ((CLASS CLASS) (WARN? BOOLEAN)))"
    (CL:FUNCTION GET-CONSTRUCTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-OBJECT"
    "(DEFUN (CREATE-OBJECT OBJECT) ((TYPE TYPE) |&REST| (INITIAL-VALUE-PAIRS OBJECT)) :DOCUMENTATION \"Funcallable version of the `new' operator.
Return an instance of the class named by `type'.  If `initial-value-pairs'
is supplied, it has to be a key/value list similar to what's accepted by `new'
and the named slots will be initialized with the supplied values.  Similar to
`new', all required arguments for `type' must be included.  Since all the
slot initialization, etc. is handled dynamically at run time, `create-object'
is much slower than `new'; therefore, it should only be used if `type' cannot
be known at translation time.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-OBJECT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD FREE ((SELF OBJECT)) :DOCUMENTATION \"Default method.  Deallocate storage for `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FREE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD FREE ((SELF ACTIVE-OBJECT)) :DOCUMENTATION \"Remove all pointers between `self' and other objects,
and then deallocate the storage for self.\")" (CL:FUNCTION FREE) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-STELLA-CLASS"
    "(DEFUN (DEFINE-STELLA-CLASS CLASS) ((NAME TYPE) (SUPERS (LIST OF TYPE)) (SLOTS (LIST OF SLOT)) (OPTIONS KEYWORD-KEY-VALUE-LIST)) :DOCUMENTATION \"Return a Stella class with name `name'.
Caution:  If the class already exists, the Stella class object gets
redefined, but the native C++ class is not redefined.\" :PUBLIC? TRUE)"
    (CL:FUNCTION DEFINE-STELLA-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-STELLA-SLOT"
    "(DEFUN (DEFINE-STELLA-SLOT SLOT) ((NAME SYMBOL) (OWNER TYPE) (BASETYPE TYPE) (TYPESPECIFIER CONS) (OPTIONS KEYWORD-KEY-VALUE-LIST)))"
    (CL:FUNCTION DEFINE-STELLA-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "INCORPORATE-CLASS-OPTIONS"
    "(DEFUN INCORPORATE-CLASS-OPTIONS ((CLASS CLASS) (OPTIONS KEYWORD-KEY-VALUE-LIST)))"
    (CL:FUNCTION INCORPORATE-CLASS-OPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "INLINE-METHOD?"
    "(DEFUN (INLINE-METHOD? BOOLEAN) ((SLOT SLOT)))"
    (CL:FUNCTION INLINE-METHOD?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS"
    "(DEFUN TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS ((EXTERNALSLOT SLOT) (NEWCLASS CLASS)))"
    (CL:FUNCTION TRANSFER-EXTERNAL-SLOT-TO-NEW-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFER-DEMONS-FROM-OLDCLASS"
    "(DEFUN TRANSFER-DEMONS-FROM-OLDCLASS ((OLDCLASS CLASS) (NEWCLASS CLASS)))"
    (CL:FUNCTION TRANSFER-DEMONS-FROM-OLDCLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNDEFINE-OLD-CLASS"
    "(DEFUN UNDEFINE-OLD-CLASS ((OLDCLASS CLASS) (NEWCLASS CLASS)))"
    (CL:FUNCTION UNDEFINE-OLD-CLASS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESTROY-CLASS ((SELF CLASS)) :DOCUMENTATION \"Destroy the Stella class `self'.  
Unfinalize its subclasses (if it has any).\" :PUBLIC? TRUE)"
    (CL:FUNCTION DESTROY-CLASS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DESTROY-CLASS ((SELF TYPE)) :PUBLIC? TRUE)"
    (CL:FUNCTION DESTROY-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-CLASS-AND-SUBCLASSES"
    "(DEFUN DESTROY-CLASS-AND-SUBCLASSES ((SELF CLASS)) :DOCUMENTATION \"Destroy the Stella class `self' and all its subclasses.\")"
    (CL:FUNCTION DESTROY-CLASS-AND-SUBCLASSES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PRIMITIVE? BOOLEAN) ((SELF RELATION)) :DOCUMENTATION \"Return `true' if `self' is not a defined relation.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PRIMITIVE?) NULL)
   (DEFINE-FUNCTION-OBJECT "INSERT-PRIMITIVE-SUPER"
    "(DEFUN INSERT-PRIMITIVE-SUPER ((NEWSUPER TYPE) (SUPERS (LIST OF TYPE))))"
    (CL:FUNCTION INSERT-PRIMITIVE-SUPER) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS"
    "(DEFUN COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS ((CLASS CLASS) (SUPERS (LIST OF TYPE))))"
    (CL:FUNCTION COLLECT-MOST-SPECIFIC-PRIMITIVE-SUPERS) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-SPECIFIC-PRIMITIVE-SUPERS"
    "(DEFUN (MOST-SPECIFIC-PRIMITIVE-SUPERS (LIST OF TYPE)) ((CLASS CLASS)))"
    (CL:FUNCTION MOST-SPECIFIC-PRIMITIVE-SUPERS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASS-NATIVE-SUPERS"
    "(DEFUN (CLASS-NATIVE-SUPERS (LIST OF TYPE)) ((CLASS CLASS)))"
    (CL:FUNCTION CLASS-NATIVE-SUPERS) NULL)
   (DEFINE-FUNCTION-OBJECT "REMEMBER-UNFINALIZED-CLASS"
    "(DEFUN REMEMBER-UNFINALIZED-CLASS ((CLASS CLASS) (FORCE? BOOLEAN)))"
    (CL:FUNCTION REMEMBER-UNFINALIZED-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "FORGET-UNFINALIZED-CLASS"
    "(DEFUN FORGET-UNFINALIZED-CLASS ((CLASS CLASS)))"
    (CL:FUNCTION FORGET-UNFINALIZED-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-CLASSES"
    "(DEFUN FINALIZE-CLASSES () :DOCUMENTATION \"Finalize all currently unfinalized classes.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FINALIZE-CLASSES) NULL)
   (DEFINE-FUNCTION-OBJECT "RESOLVE-CHILDREN-REFERENCES"
    "(DEFUN RESOLVE-CHILDREN-REFERENCES ())"
    (CL:FUNCTION RESOLVE-CHILDREN-REFERENCES) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-SLOTS"
    "(DEFUN FINALIZE-SLOTS () :PUBLIC? TRUE :DOCUMENTATION \"Finalize all currently unfinalized slots.\")"
    (CL:FUNCTION FINALIZE-SLOTS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEANUP-UNFINALIZED-CLASSES"
    "(DEFUN CLEANUP-UNFINALIZED-CLASSES () :PUBLIC? TRUE :DOCUMENTATION \"Remove all finalized classes from `*UNFINALIZED-CLASSES*',
and set `*NEWLY-UNFINALIZED-CLASSES?*' to `false'.\")"
    (CL:FUNCTION CLEANUP-UNFINALIZED-CLASSES) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-CLASSES-AND-SLOTS"
    "(DEFUN FINALIZE-CLASSES-AND-SLOTS () :PUBLIC? TRUE :DOCUMENTATION \"Finalize all currently unfinalized classes and slots.\")"
    (CL:FUNCTION FINALIZE-CLASSES-AND-SLOTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ACTIVATE-CLASS"
    "(DEFUN ACTIVATE-CLASS ((CLASS CLASS)))"
    (CL:FUNCTION ACTIVATE-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-PRIMARY-TYPE"
    "(DEFUN ADD-PRIMARY-TYPE ((CLASS CLASS)))"
    (CL:FUNCTION ADD-PRIMARY-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-ONE-CLASS"
    "(DEFUN FINALIZE-ONE-CLASS ((CLASS CLASS)))"
    (CL:FUNCTION FINALIZE-ONE-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-CLASS"
    "(DEFUN (FINALIZE-CLASS BOOLEAN) ((CLASS CLASS)))"
    (CL:FUNCTION FINALIZE-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-FINALIZE-CLASS"
    "(DEFUN (HELP-FINALIZE-CLASS BOOLEAN) ((CLASS CLASS) (FINALIZEDPARENT TYPE)))"
    (CL:FUNCTION HELP-FINALIZE-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNFINALIZE-CLASS-AND-SUBCLASSES"
    "(DEFUN UNFINALIZE-CLASS-AND-SUBCLASSES ((CLASS CLASS)))"
    (CL:FUNCTION UNFINALIZE-CLASS-AND-SUBCLASSES) NULL)
   (DEFINE-FUNCTION-OBJECT "ATTACH-SLOT-TO-OWNER"
    "(DEFUN (ATTACH-SLOT-TO-OWNER SLOT) ((NEWSLOT SLOT)) :PUBLIC? TRUE)"
    (CL:FUNCTION ATTACH-SLOT-TO-OWNER) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-SLOT-DIRECT-EQUIVALENT"
    "(DEFUN COMPUTE-SLOT-DIRECT-EQUIVALENT ((SELF SLOT)))"
    (CL:FUNCTION COMPUTE-SLOT-DIRECT-EQUIVALENT) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-CONFORMANCE-OF-SLOT-SIGNATURE"
    "(DEFUN CHECK-CONFORMANCE-OF-SLOT-SIGNATURE ((SELF SLOT)))"
    (CL:FUNCTION CHECK-CONFORMANCE-OF-SLOT-SIGNATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECTION-TO-ACTIVE-COLLECTION"
    "(DEFUN (COLLECTION-TO-ACTIVE-COLLECTION TYPE) ((TYPE TYPE)))"
    (CL:FUNCTION COLLECTION-TO-ACTIVE-COLLECTION) NULL)
   (DEFINE-FUNCTION-OBJECT "ACTIVATE-SLOT"
    "(DEFUN ACTIVATE-SLOT ((SELF STORAGE-SLOT)))"
    (CL:FUNCTION ACTIVATE-SLOT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF SLOT)))"
    (CL:FUNCTION FINALIZE-SLOT-TYPE-COMPUTATIONS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF STORAGE-SLOT)))"
    (CL:FUNCTION FINALIZE-SLOT-TYPE-COMPUTATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "MULTI-VALUED-SLOT-WITH-DUPLICATES?"
    "(DEFUN (MULTI-VALUED-SLOT-WITH-DUPLICATES? BOOLEAN) ((SELF SLOT)))"
    (CL:FUNCTION MULTI-VALUED-SLOT-WITH-DUPLICATES?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-SLOT-INVERSES"
    "(DEFUN COMPUTE-SLOT-INVERSES ((SELF SLOT)))"
    (CL:FUNCTION COMPUTE-SLOT-INVERSES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF SLOT)))"
    (CL:FUNCTION HELP-FINALIZE-LOCAL-SLOT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF STORAGE-SLOT)))"
    (CL:FUNCTION HELP-FINALIZE-LOCAL-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-LOCAL-SLOT"
    "(DEFUN FINALIZE-LOCAL-SLOT ((SELF SLOT)))"
    (CL:FUNCTION FINALIZE-LOCAL-SLOT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF SLOT)))"
    (CL:FUNCTION UNFINALIZE-LOCAL-SLOT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF STORAGE-SLOT)))"
    (CL:FUNCTION UNFINALIZE-LOCAL-SLOT) NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-CLASSES4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "FINALIZE-CLASS-SLOTS"
    "(DEFUN FINALIZE-CLASS-SLOTS ((CLASS CLASS)))"
    (CL:FUNCTION FINALIZE-CLASS-SLOTS) NULL)
   (DEFINE-FUNCTION-OBJECT "UNFINALIZE-CLASS-SLOTS"
    "(DEFUN UNFINALIZE-CLASS-SLOTS ((CLASS CLASS)))"
    (CL:FUNCTION UNFINALIZE-CLASS-SLOTS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-UNFINALIZE-CLASS-SLOTS"
    "(DEFUN HELP-UNFINALIZE-CLASS-SLOTS ((CLASS CLASS)))"
    (CL:FUNCTION HELP-UNFINALIZE-CLASS-SLOTS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MULTIPLE-PARENTS? BOOLEAN) ((CLASS CLASS)) :DOCUMENTATION \"Return `true' if `class' has more than one direct superclass.\" :PUBLIC? TRUE)"
    (CL:FUNCTION MULTIPLE-PARENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-DIRECT-SUPERS-BACK-LINKS"
    "(DEFUN ADD-DIRECT-SUPERS-BACK-LINKS ((CLASS CLASS)))"
    (CL:FUNCTION ADD-DIRECT-SUPERS-BACK-LINKS) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-DIRECT-SUBS-BACK-LINKS"
    "(DEFUN ADD-DIRECT-SUBS-BACK-LINKS ((CLASS CLASS)))"
    (CL:FUNCTION ADD-DIRECT-SUBS-BACK-LINKS) NULL)
   (DEFINE-FUNCTION-OBJECT "REMOVE-DIRECT-SUPERS-BACK-LINKS"
    "(DEFUN REMOVE-DIRECT-SUPERS-BACK-LINKS ((CLASS CLASS)))"
    (CL:FUNCTION REMOVE-DIRECT-SUPERS-BACK-LINKS) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-DIRECT-SUPER-CLASSES"
    "(DEFUN COLLECT-DIRECT-SUPER-CLASSES ((CLASS CLASS) (PARENTS (LIST OF CLASS))))"
    (CL:FUNCTION COLLECT-DIRECT-SUPER-CLASSES) NULL)
   (DEFINE-FUNCTION-OBJECT "INHERIT-SUPERCLASSES"
    "(DEFUN INHERIT-SUPERCLASSES ((CLASS CLASS)))"
    (CL:FUNCTION INHERIT-SUPERCLASSES) NULL)
   (DEFINE-FUNCTION-OBJECT "UNINHERIT-SUPERCLASSES"
    "(DEFUN UNINHERIT-SUPERCLASSES ((CLASS CLASS)))"
    (CL:FUNCTION UNINHERIT-SUPERCLASSES) NULL)
   (DEFINE-FUNCTION-OBJECT "TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS"
    "(DEFUN (TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS CLASS) ((CLASS1 CLASS) (CLASS2 CLASS)) :DOCUMENTATION \"Return the most specific class that is a superclass of
both `class1' and `class2'.  If there is more than one, arbitrarily pick one.
If there is none, return `null'.\")"
    (CL:FUNCTION TWO-ARGUMENT-LEAST-COMMON-SUPERCLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE"
    "(DEFUN (TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE TYPE-SPEC) ((TYPE1 TYPE-SPEC) (TYPE2 TYPE-SPEC)) :DOCUMENTATION \"Return the most specific type that is a supertype of
both `type1' and `type2'.  If there is more than one, arbitrarily pick one.
If there is none, return @VOID.  If one or both types are parametric,
also try to generalize parameter types if necessary.\")"
    (CL:FUNCTION TWO-ARGUMENT-LEAST-COMMON-SUPERTYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "INHERIT-SLOTS"
    "(DEFUN INHERIT-SLOTS ((CLASS CLASS)))" (CL:FUNCTION INHERIT-SLOTS)
    NULL)
   (DEFINE-FUNCTION-OBJECT "LOCAL-SLOT?"
    "(DEFUN (LOCAL-SLOT? BOOLEAN) ((SLOT SLOT) (CLASS CLASS)))"
    (CL:FUNCTION LOCAL-SLOT?) NULL)
   (DEFINE-FUNCTION-OBJECT "UNINHERIT-SLOTS"
    "(DEFUN UNINHERIT-SLOTS ((CLASS CLASS)))"
    (CL:FUNCTION UNINHERIT-SLOTS) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-SLOT-AND-METHOD-CACHE"
    "(DEFUN INITIALIZE-SLOT-AND-METHOD-CACHE ((CLASS CLASS)))"
    (CL:FUNCTION INITIALIZE-SLOT-AND-METHOD-CACHE) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-SLOT-NAME"
    "(DEFUN REGISTER-SLOT-NAME ((SLOT SLOT)) :PUBLIC? TRUE :DOCUMENTATION \"Register the name symbol of `slot' as a slot name, and
initialize its `symbol-slot-offset' so that it can be used by `lookup-slot'.\")"
    (CL:FUNCTION REGISTER-SLOT-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "UNREGISTER-SLOT-NAME"
    "(DEFUN UNREGISTER-SLOT-NAME ((SLOT SLOT)) :PUBLIC? TRUE :DOCUMENTATION \"Unregister the name symbol of `slot' as a slot name,
so that it can no longer be used by `lookup-slot'.\")"
    (CL:FUNCTION UNREGISTER-SLOT-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTERED-SLOT-NAME?"
    "(DEFUN (REGISTERED-SLOT-NAME? BOOLEAN) ((SLOT-NAME SYMBOL)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if `slot-name' is the name of some registered;
slot in the system.\" (RETURN (DEFINED? (SYMBOL-SLOT-OFFSET SLOT-NAME))))"
    (CL:FUNCTION REGISTERED-SLOT-NAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "WARN-ABOUT-SLOT-SHADOWED-BY-A-FUNCTION?"
    "(DEFUN (WARN-ABOUT-SLOT-SHADOWED-BY-A-FUNCTION? BOOLEAN) ((SLOT SLOT)))"
    (CL:FUNCTION WARN-ABOUT-SLOT-SHADOWED-BY-A-FUNCTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "WARN-ABOUT-FUNCTION-SHADOWING-SLOTS?"
    "(DEFUN (WARN-ABOUT-FUNCTION-SHADOWING-SLOTS? BOOLEAN) ((FUNCTION METHOD-SLOT)))"
    (CL:FUNCTION WARN-ABOUT-FUNCTION-SHADOWING-SLOTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-SLOT"
    "(DEFUN (LOOKUP-SLOT SLOT) ((CLASS CLASS) (SLOT-NAME SYMBOL)) :DOCUMENTATION \"Return a slot owned by the class `class' with name `slot-name'.
Multiply inherited slots are disambiguated by a left-to-right class
precedence order for classes with multiple parents (similar to CLOS).\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "SAFE-LOOKUP-SLOT"
    "(DEFUN (SAFE-LOOKUP-SLOT SLOT) ((CLASS CLASS) (SLOT-NAME SYMBOL)) :DOCUMENTATION \"Alias for `lookup-slot'.  Kept for backwards compatibility.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (LOOKUP-SLOT CLASS SLOT-NAME)))"
    (CL:FUNCTION SAFE-LOOKUP-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-VISIBLE-SLOT"
    "(DEFUN (LOOKUP-VISIBLE-SLOT SLOT) ((CLASS CLASS) (SLOT-NAME OBJECT)))"
    (CL:FUNCTION LOOKUP-VISIBLE-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-LOCAL-SLOT"
    "(DEFUN (LOOKUP-LOCAL-SLOT SLOT) ((CLASS CLASS) (SLOT-NAME SYMBOL)) :DOCUMENTATION \"Lookup a local slot with `slot-name' on `class'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION LOOKUP-LOCAL-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-SLOT-AND-METHOD-CACHE"
    "(DEFUN CLEAR-SLOT-AND-METHOD-CACHE ((CLASS CLASS)))"
    (CL:FUNCTION CLEAR-SLOT-AND-METHOD-CACHE) NULL)
   (DEFINE-FUNCTION-OBJECT "RESIZE-SLOT-CACHES"
    "(DEFUN RESIZE-SLOT-CACHES ((SIZE INTEGER)) :DOCUMENTATION \"Reset all slot caches to have size `size'.\")"
    (CL:FUNCTION RESIZE-SLOT-CACHES) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SLOT"
    "(DEFUN (GET-SLOT SLOT) ((SELF STANDARD-OBJECT) (SLOT-NAME SYMBOL)) :DOCUMENTATION \"Return the slot named `slot-name' on the class
representing the type of `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION GET-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "CONFORMING-TYPE-SPEC?"
    "(DEFUN (CONFORMING-TYPE-SPEC? BOOLEAN) ((SUB-TYPE-SPEC TYPE-SPEC) (SUPER-TYPE-SPEC TYPE-SPEC)))"
    (CL:FUNCTION CONFORMING-TYPE-SPEC?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ((SELF SLOT) (SUPERSLOT SLOT)))"
    (CL:FUNCTION CONFORMING-SIGNATURES?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ((SELF STORAGE-SLOT) (SUPERSLOT SLOT)))"
    (CL:FUNCTION CONFORMING-SIGNATURES?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ((SELF METHOD-SLOT) (SUPERSLOT SLOT)))"
    (CL:FUNCTION CONFORMING-SIGNATURES?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONFORMING-SIGNATURES? BOOLEAN) ((SELF TABLE) (SUPERSLOT SLOT)))"
    (CL:FUNCTION CONFORMING-SIGNATURES?) NULL)
   (DEFINE-FUNCTION-OBJECT "IDENTICAL-SIGNATURES?"
    "(DEFUN (IDENTICAL-SIGNATURES? BOOLEAN) ((METHOD1 METHOD-SLOT) (METHOD2 METHOD-SLOT)))"
    (CL:FUNCTION IDENTICAL-SIGNATURES?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-REQUIRED-SLOT-NAMES"
    "(DEFUN COMPUTE-REQUIRED-SLOT-NAMES ((CLASS CLASS)))"
    (CL:FUNCTION COMPUTE-REQUIRED-SLOT-NAMES) NULL)
   (DEFINE-FUNCTION-OBJECT "FREE-REQUIRED-SLOT-NAMES"
    "(DEFUN FREE-REQUIRED-SLOT-NAMES ((CLASS CLASS)))"
    (CL:FUNCTION FREE-REQUIRED-SLOT-NAMES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DYNAMIC-STORAGE? BOOLEAN) ((SELF STORAGE-SLOT)))"
    (CL:FUNCTION DYNAMIC-STORAGE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PRIVATE? BOOLEAN) ((SELF RELATION)) :DOCUMENTATION \"Return `true' if `self' is not public.\" :PUBLIC? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION PRIVATE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PUBLIC? BOOLEAN) ((SELF SLOT)) :DOCUMENTATION \"True if `self' or one it its ancestors is marked public.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PUBLIC?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PUBLIC-SLOTS (ITERATOR OF SLOT)) ((SELF CLASS)) :DOCUMENTATION \"Return an iterator over public slots of `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PUBLIC-SLOTS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PUBLIC-SLOTS (ITERATOR OF SLOT)) ((SELF OBJECT)) :DOCUMENTATION \"Return an iterator over public slots of `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION PUBLIC-SLOTS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALL-CLASS-SLOTS (ITERATOR OF SLOT)) ((SELF CLASS)))"
    (CL:FUNCTION ALL-CLASS-SLOTS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF ALL-CLASS-SLOTS-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CLASS-SLOTS (ITERATOR OF SLOT)) ((SELF CLASS)))"
    (CL:FUNCTION CLASS-SLOTS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LOCAL-SLOTS (LIST OF SLOT)) ((SELF CLASS)))"
    (CL:FUNCTION LOCAL-SLOTS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DIRECT-SUPER-CLASSES (ITERATOR OF CLASS)) ((SELF CLASS)) :PUBLIC? TRUE :DOCUMENTATION \"Returns an iterator that generates all direct
super classes of `self'.\")" (CL:FUNCTION DIRECT-SUPER-CLASSES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SUPER-CLASSES (ITERATOR OF CLASS)) ((SELF CLASS)) :PUBLIC? TRUE :DOCUMENTATION \"Returns an iterator that generates all super classes
of `self'.  Non-reflexive.\")" (CL:FUNCTION SUPER-CLASSES) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD (ACTIVE? BOOLEAN) ((SLOT SLOT)))"
    (CL:FUNCTION ACTIVE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (INITIAL-VALUE OBJECT) ((SELF STORAGE-SLOT)) :DOCUMENTATION \"Return an initial value for `self', or `null'.  The
initial value can be defined by the slot itself, inherited from an
equivalent slot, or inherit from the :initial-value option for the 
class representing the type of `self'.\")" (CL:FUNCTION INITIAL-VALUE)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SYSTEM-DEFAULT-VALUE OBJECT) ((SELF SLOT)) :DOCUMENTATION \"Return a default value expression, or if `self'
has dynamic storage, an initial value expression.\")"
    (CL:FUNCTION SYSTEM-DEFAULT-VALUE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SYSTEM-DEFAULT-VALUE OBJECT) ((SELF STORAGE-SLOT)) :DOCUMENTATION \"Return a default value expression, or if `self'
has dynamic storage, an initial value expression.\")"
    (CL:FUNCTION SYSTEM-DEFAULT-VALUE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (INITIALLY OBJECT) ((SELF STORAGE-SLOT)) :DOCUMENTATION \"Defines the value of a slot before it has been assigned
a value.\" :PUBLIC? TRUE)" (CL:FUNCTION INITIALLY) NULL)
   (DEFINE-FUNCTION-OBJECT "REPAIR-SLOTS" "(DEFUN REPAIR-SLOTS ())"
    (CL:FUNCTION REPAIR-SLOTS) NULL)
   (DEFINE-FUNCTION-OBJECT "DISCONNECT-CLASSES"
    "(DEFUN DISCONNECT-CLASSES ())" (CL:FUNCTION DISCONNECT-CLASSES)
    NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-UNBOUND-SURROGATE?"
    "(DEFUN (FILTER-UNBOUND-SURROGATE? BOOLEAN) ((SELF SURROGATE) (ITERATOR ALL-PURPOSE-ITERATOR)))"
    (CL:FUNCTION FILTER-UNBOUND-SURROGATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "UNBOUND-SURROGATES"
    "(DEFUN (UNBOUND-SURROGATES (ITERATOR OF SURROGATE)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Iterate over all unbound surrogates visible from `module'.
Look at all modules if `module' is `null'.  If `local?', only consider
surrogates interned in `module'.\")" (CL:FUNCTION UNBOUND-SURROGATES)
    NULL)
   (DEFINE-FUNCTION-OBJECT "NAME-TO-STRING"
    "(DEFUN (NAME-TO-STRING STRING) ((NAME OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return the string represented by `name'.  Return `null'
if `name' is undefined or does not represent a string.\")"
    (CL:FUNCTION NAME-TO-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-UNBOUND-SURROGATES"
    "(DEFUN PRINT-UNBOUND-SURROGATES (|&REST| (ARGS OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Print all unbound surrogates visible from the module named by the first
argument (a symbol or string).  Look at all modules if no module name or
`null' was supplied.  If the second argument is `true', only consider
surrogates interned in the specified module.\")"
    (CL:FUNCTION %PRINT-UNBOUND-SURROGATES)
    (CL:FUNCTION PRINT-UNBOUND-SURROGATES-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-SYMBOL"
    "(DEFUN (COERCE-TO-SYMBOL GENERALIZED-SYMBOL) ((NAME NAME)) :PUBLIC? TRUE :DOCUMENTATION \"Return the (generalized) symbol represented by `name'.
Return `null' if `name' is undefined or does not represent a string.\")"
    (CL:FUNCTION COERCE-TO-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-UNDEFINED-SUPER-CLASSES"
    "(DEFUN PRINT-UNDEFINED-SUPER-CLASSES ((CLASS NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Print all undefined or bad (indirect) super classes of `class'.\")"
    (CL:FUNCTION %PRINT-UNDEFINED-SUPER-CLASSES) NULL))
  :VOID)

(CL:DEFUN STARTUP-CLASSES ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-CLASSES1)
    (HELP-STARTUP-CLASSES2)
    (CL:SETQ SYM-CLASSES-STELLA-STARTUP-CLASSES
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-CLASSES" NULL 0))
    (CL:SETQ SYM-CLASSES-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL
      0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *UNFINALIZED-CLASSES* (NEW-LIST))
    (CL:SETQ *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES* (NEW-LIST))
    (CL:SETQ *CLASS-TAXONOMY-GRAPH* (NEW-TAXONOMY-GRAPH)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ALL-CLASS-SLOTS-ITERATOR"
        "(DEFCLASS ALL-CLASS-SLOTS-ITERATOR (ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE SLOT)) :SLOTS ((ITERATOR-CONS-LIST :TYPE CONS) (ITERATOR-OBJECT :TYPE OBJECT)))")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-ALL-CLASS-SLOTS-ITERATOR))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-ALL-CLASS-SLOTS-ITERATOR-SLOT-VALUE)))
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE ANY UNKNOWN)"))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-CLASSES3)
    (HELP-STARTUP-CLASSES4)
    (DEFINE-FUNCTION-OBJECT "COLLECT-BAD-SUPER-CLASSES"
     "(DEFUN (COLLECT-BAD-SUPER-CLASSES (LIST OF TYPE)) ((TYPE TYPE) (BADONES (LIST OF TYPE))) :PUBLIC? TRUE)"
     (CL:FUNCTION COLLECT-BAD-SUPER-CLASSES) NULL)
    (DEFINE-FUNCTION-OBJECT "ROOT-CLASS?"
     "(DEFUN (ROOT-CLASS? BOOLEAN) ((CLASS CLASS)))"
     (CL:FUNCTION ROOT-CLASS?) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-CLASS-TAXONOMY"
     "(DEFUN CREATE-CLASS-TAXONOMY ())"
     (CL:FUNCTION CREATE-CLASS-TAXONOMY) NULL)
    (DEFINE-FUNCTION-OBJECT "SUBCLASS-OF?"
     "(DEFUN (SUBCLASS-OF? BOOLEAN) ((SUBCLASS CLASS) (SUPERCLASS CLASS)) :DOCUMENTATION \"Return `true' if `subClass' is a subclass of `superClass'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION SUBCLASS-OF?) NULL)
    (DEFINE-FUNCTION-OBJECT "FAST-SUBCLASS-OF?"
     "(DEFUN (FAST-SUBCLASS-OF? BOOLEAN) ((SUBCLASS CLASS) (SUPERCLASS CLASS)))"
     (CL:FUNCTION FAST-SUBCLASS-OF?) NULL)
    (DEFINE-FUNCTION-OBJECT "SUBTYPE-OF?"
     "(DEFUN (SUBTYPE-OF? BOOLEAN) ((SUB-TYPE TYPE) (SUPER-TYPE TYPE)) :DOCUMENTATION \"Return `true' iff the class named `sub-type' is a subclass 
of the class named `super-type'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION SUBTYPE-OF?) NULL)
    (DEFINE-FUNCTION-OBJECT "ISA?"
     "(DEFUN (ISA? BOOLEAN) ((OBJECT OBJECT) (TYPE TYPE)) :DOCUMENTATION \"Return `true' iff `object' is an instance of the class named `type'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION ISA?) NULL)
    (DEFINE-FUNCTION-OBJECT "TAXONOMY-SUBCLASS-OF?"
     "(DEFUN (TAXONOMY-SUBCLASS-OF? BOOLEAN) ((SUBCLASS CLASS) (SUPERCLASS CLASS)) :GLOBALLY-INLINE? TRUE (RETURN (SUBCLASS-OF? SUBCLASS SUPERCLASS)))"
     (CL:FUNCTION TAXONOMY-SUBCLASS-OF?) NULL)
    (DEFINE-FUNCTION-OBJECT "TAXONOMY-ISA?"
     "(DEFUN (TAXONOMY-ISA? BOOLEAN) ((OBJECT OBJECT) (TYPE TYPE)) :GLOBALLY-INLINE? TRUE (RETURN (ISA? OBJECT TYPE)))"
     (CL:FUNCTION TAXONOMY-ISA?) NULL)
    (DEFINE-FUNCTION-OBJECT "INTERN-SLOTREF"
     "(DEFUN (INTERN-SLOTREF SLOTREF) ((CLASSNAME STRING) (SLOTNAME STRING)))"
     (CL:FUNCTION INTERN-SLOTREF) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-SLOTREF"
     "(DEFUN (LOOKUP-SLOTREF SLOTREF) ((SELF TYPE) (SLOTNAME SYMBOL)) :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-SLOTREF) NULL)
    (DEFINE-FUNCTION-OBJECT "SLOTREF?"
     "(DEFUN (SLOTREF? BOOLEAN) ((SELF SURROGATE)))"
     (CL:FUNCTION SLOTREF?) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-SLOT-FROM-SLOTREF"
     "(DEFUN (LOOKUP-SLOT-FROM-SLOTREF SLOT) ((SLOTREF SLOTREF)))"
     (CL:FUNCTION LOOKUP-SLOT-FROM-SLOTREF) NULL)
    (DEFINE-FUNCTION-OBJECT "SLOTREF-TYPE"
     "(DEFUN (SLOTREF-TYPE TYPE) ((SLOTREF SLOTREF)))"
     (CL:FUNCTION SLOTREF-TYPE) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-CLASSES"
     "(DEFUN STARTUP-CLASSES () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-CLASSES) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-CLASSES-STELLA-STARTUP-CLASSES)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-CLASSES-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupClasses") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *WARNIFREDEFINE?* BOOLEAN TRUE :DOCUMENTATION \"If set, warn about each redefinition.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *UNFINALIZED-CLASSES* (LIST OF CLASS) (NEW LIST) :DOCUMENTATION \"List of classes whose class or slot inheritance is
currently unfinalized.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NEWLY-UNFINALIZED-CLASSES?* BOOLEAN FALSE :DOCUMENTATION \"Set to `true' by `remember-unfinalized-class'; set
to `false' by `cleanup-unfinalized-classes'.  Minimizes the time that
`finalize-classes' spends searching for classes to finalize.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CLASSES-WITH-UNRESOLVED-CHILDREN-REFERENCES* (LIST OF CLASS) (NEW LIST) :DOCUMENTATION \"List of classes defined with a :children option
which still have some of their children references unresolved.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SYMBOL-SLOT-OFFSET-COUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SLOT-CACHE-SIZE* INTEGER 20)")
    (REGISTER-NATIVE-NAME SYM-CLASSES-STELLA-PRINT-UNBOUND-SURROGATES
     KWD-CLASSES-COMMON-LISP KWD-CLASSES-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-CLASSES-STELLA-PRINT-UNDEFINED-SUPER-CLASSES
     KWD-CLASSES-COMMON-LISP KWD-CLASSES-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CLASS-TAXONOMY-GRAPH* TAXONOMY-GRAPH (NEW TAXONOMY-GRAPH))")))
  :VOID)
