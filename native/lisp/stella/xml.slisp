;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; xml.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2014      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-XML-STELLA-XML-OBJECT NULL)
(CL:DEFVAR SYM-XML-STELLA-NAME NULL)
(CL:DEFVAR SYM-XML-STELLA-SURFACE-FORM NULL)
(CL:DEFVAR SGT-XML-STELLA-XML-ELEMENT NULL)
(CL:DEFVAR SYM-XML-STELLA-NAMESPACE-NAME NULL)
(CL:DEFVAR SYM-XML-STELLA-NAMESPACE-URI NULL)
(CL:DEFVAR SYM-XML-STELLA-ELEMENT-DICTIONARY NULL)
(CL:DEFVAR SGT-XML-STELLA-XML-LOCAL-ATTRIBUTE NULL)
(CL:DEFVAR SYM-XML-STELLA-PARENT-ELEMENT NULL)
(CL:DEFVAR SGT-XML-STELLA-XML-GLOBAL-ATTRIBUTE NULL)
(CL:DEFVAR SGT-XML-STELLA-XML-PROCESSING-INSTRUCTION NULL)
(CL:DEFVAR SYM-XML-STELLA-DATA NULL)
(CL:DEFVAR SGT-XML-STELLA-XML-DECLARATION NULL)
(CL:DEFVAR SGT-XML-STELLA-XML-DOCTYPE-DECLARATION NULL)
(CL:DEFVAR SGT-XML-STELLA-XML-SPECIAL NULL)
(CL:DEFVAR SGT-XML-STELLA-XML-COMMENT NULL)
(CL:DEFVAR SGT-XML-STELLA-XML-DOCTYPE NULL)
(CL:DEFVAR SYM-XML-STELLA-ENTITY-TABLE NULL)
(CL:DEFVAR SYM-XML-STELLA-PARAMETER-ENTITY-TABLE NULL)
(CL:DEFVAR SGT-XML-STELLA-STRING-WRAPPER NULL)
(CL:DEFVAR KWD-XML-START NULL)
(CL:DEFVAR KWD-XML-INCLUDE NULL)
(CL:DEFVAR KWD-XML-SKIP-WHITESPACE NULL)
(CL:DEFVAR SYM-XML-STELLA-! NULL)
(CL:DEFVAR KWD-XML-OPEN-TAG NULL)
(CL:DEFVAR KWD-XML-EOF NULL)
(CL:DEFVAR SYM-XML-STELLA-* NULL)
(CL:DEFVAR KWD-XML-OTHERWISE NULL)
(CL:DEFVAR KWD-XML-CONTENT NULL)
(CL:DEFVAR KWD-XML-START-TAG-END NULL)
(CL:DEFVAR KWD-XML-OPEN-END-TAG NULL)
(CL:DEFVAR KWD-XML-OPEN-PI-TAG NULL)
(CL:DEFVAR KWD-XML-OPEN-DECLARATION-TAG NULL)
(CL:DEFVAR KWD-XML-START-TAG NULL)
(CL:DEFVAR KWD-XML-OPEN-EMPTY-TAG-END NULL)
(CL:DEFVAR KWD-XML-SKIP-TO-ATTRIBUTE-NAME NULL)
(CL:DEFVAR KWD-XML-ANY NULL)
(CL:DEFVAR KWD-XML-START-PI-TAG NULL)
(CL:DEFVAR KWD-XML-OPEN-PI-TAG-END NULL)
(CL:DEFVAR KWD-XML-PI-TAG-DATA NULL)
(CL:DEFVAR KWD-XML-PI-TAG-DATA-OR-END NULL)
(CL:DEFVAR KWD-XML-EMPTY-TAG-END NULL)
(CL:DEFVAR KWD-XML-ERROR NULL)
(CL:DEFVAR KWD-XML-END-TAG-END NULL)
(CL:DEFVAR KWD-XML-END-TAG NULL)
(CL:DEFVAR KWD-XML-ATTRIBUTE-NAME NULL)
(CL:DEFVAR KWD-XML-SKIP-TO-ATTRIBUTE-VALUE NULL)
(CL:DEFVAR KWD-XML-SINGLE-QUOTED-ATTRIBUTE-VALUE NULL)
(CL:DEFVAR KWD-XML-DOUBLE-QUOTED-ATTRIBUTE-VALUE NULL)
(CL:DEFVAR KWD-XML-UNQUOTED-ATTRIBUTE-VALUE NULL)
(CL:DEFVAR KWD-XML-QUOTED-ATTRIBUTE-VALUE NULL)
(CL:DEFVAR KWD-XML-START-TAG-OR-COMMENT NULL)
(CL:DEFVAR KWD-XML-OPEN-SPECIAL-TAG NULL)
(CL:DEFVAR KWD-XML-START-DECLARATION-TAG NULL)
(CL:DEFVAR KWD-XML-DECLARATION-WHITESPACE NULL)
(CL:DEFVAR KWD-XML-DECLARATION-TAG-MARKUP-DATA-START NULL)
(CL:DEFVAR KWD-XML-SINGLE-QUOTED-DECLARATION-TAG-DATA NULL)
(CL:DEFVAR KWD-XML-DOUBLE-QUOTED-DECLARATION-TAG-DATA NULL)
(CL:DEFVAR KWD-XML-DECLARATION-TAG-DATA NULL)
(CL:DEFVAR KWD-XML-QUOTED-DECLARATION-TAG-DATA NULL)
(CL:DEFVAR KWD-XML-DECLARATION-TAG-MARKUP-DATA NULL)
(CL:DEFVAR KWD-XML-START-SPECIAL-TAG NULL)
(CL:DEFVAR KWD-XML-SPECIAL-TAG-DATA NULL)
(CL:DEFVAR KWD-XML-SPECIAL-TAG-DATA-OR-END NULL)
(CL:DEFVAR KWD-XML-SPECIAL-TAG-DATA-OR-END2 NULL)
(CL:DEFVAR KWD-XML-DATA-TAG-END NULL)
(CL:DEFVAR KWD-XML-COMMENT-BODY NULL)
(CL:DEFVAR KWD-XML-END-COMMENT-OR-COMMENT NULL)
(CL:DEFVAR KWD-XML-END-COMMENT-OR-COMMENT2 NULL)
(CL:DEFVAR KWD-XML-COMMENT NULL)
(CL:DEFVAR KWD-XML-ATTRIBUTE-VALUE NULL)
(CL:DEFVAR KWD-XML-WHITE-SPACE NULL)
(CL:DEFVAR SGT-XML-STELLA-XML-EXPRESSION-ITERATOR NULL)
(CL:DEFVAR SYM-XML-STELLA-REGION-TAG NULL)
(CL:DEFVAR SYM-XML-STELLA-REGION-MATCH-FUNCTION NULL)
(CL:DEFVAR SYM-XML-STELLA-DOCTYPE NULL)
(CL:DEFVAR SYM-XML-STELLA-DOCTYPE-ITERATOR? NULL)
(CL:DEFVAR SGT-XML-STELLA-CONS NULL)
(CL:DEFVAR SGT-XML-STELLA-XML-ATTRIBUTE NULL)
(CL:DEFVAR SYM-XML-STELLA-XML-ELEMENT-MATCH? NULL)
(CL:DEFVAR SYM-XML-STELLA-NULL NULL)
(CL:DEFVAR SYM-XML-STELLA-STRING-EQL? NULL)
(CL:DEFVAR SYM-XML-STELLA-OTHERWISE NULL)
(CL:DEFVAR SYM-XML-STELLA-COND NULL)
(CL:DEFVAR SGT-XML-STELLA-SYMBOL NULL)
(CL:DEFVAR SYM-XML-STELLA-LET NULL)
(CL:DEFVAR SYM-XML-STELLA-XML-ELEMENT NULL)
(CL:DEFVAR SYM-XML-STELLA-STARTUP-XML NULL)
(CL:DEFVAR SYM-XML-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* EOL NULL-CHARACTER TRUE-WRAPPER
  FALSE-WRAPPER STANDARD-INPUT *CHARACTER-TYPE-TABLE* NULL-INTEGER NIL))

;;; (DEFCONSTANT *XML-URN* ...)

(CL:DEFVAR *XML-URN* "http://www.w3.org/XML/1998/namespaces")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *XML-URN*))

;;; (DEFCONSTANT *HTML-V4-0-URN* ...)

(CL:DEFVAR *HTML-V4-0-URN* "http://www.w3.org/TR/REC-html40")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *HTML-V4-0-URN*))

(CL:DEFUN NEW-XML-OBJECT ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-XML-OBJECT))
   (CL:SETF (%XML-OBJECT.SURFACE-FORM SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-OBJECT.NAME SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-XML-OBJECT SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF XML-OBJECT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-XML-STELLA-XML-OBJECT))

(CL:DEFUN ACCESS-XML-OBJECT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-XML-STELLA-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-OBJECT.NAME SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%XML-OBJECT.NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-XML-STELLA-SURFACE-FORM)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-OBJECT.SURFACE-FORM SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%XML-OBJECT.SURFACE-FORM SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-XML-OBJECT-SLOT-VALUE VALUE))

(CL:DEFUN NEW-XML-ELEMENT ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-XML-ELEMENT))
   (CL:SETF (%XML-ELEMENT.SURFACE-FORM SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-ELEMENT.NAME SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-ELEMENT.ELEMENT-DICTIONARY SELF) NULL)
   (CL:SETF (%XML-ELEMENT.NAMESPACE-URI SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-ELEMENT.NAMESPACE-NAME SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-XML-ELEMENT SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF XML-ELEMENT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-XML-STELLA-XML-ELEMENT))

(CL:DEFUN ACCESS-XML-ELEMENT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-XML-STELLA-NAMESPACE-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-ELEMENT.NAMESPACE-NAME SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%XML-ELEMENT.NAMESPACE-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-XML-STELLA-NAMESPACE-URI)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-ELEMENT.NAMESPACE-URI SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%XML-ELEMENT.NAMESPACE-URI SELF)))))
   ((CL:EQ SLOTNAME SYM-XML-STELLA-ELEMENT-DICTIONARY)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-ELEMENT.ELEMENT-DICTIONARY SELF) VALUE)
     (CL:SETQ VALUE (%XML-ELEMENT.ELEMENT-DICTIONARY SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-XML-ELEMENT-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF XML-ELEMENT) STREAM)
  (%%PRINT-STREAM STREAM "<" (%XML-ELEMENT.SURFACE-FORM SELF) ">")
  :VOID)

(CL:DEFUN ACCESS-XML-ATTRIBUTE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-XML-STELLA-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-ATTRIBUTE.NAME SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%XML-ATTRIBUTE.NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-XML-STELLA-SURFACE-FORM)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-ATTRIBUTE.SURFACE-FORM SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%XML-ATTRIBUTE.SURFACE-FORM SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-XML-ATTRIBUTE-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF XML-ATTRIBUTE) STREAM)
  (%%PRINT-STREAM STREAM "<" (%XML-ATTRIBUTE.SURFACE-FORM SELF) ">")
  :VOID)

(CL:DEFUN NEW-XML-LOCAL-ATTRIBUTE ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-XML-LOCAL-ATTRIBUTE))
   (CL:SETF (%XML-LOCAL-ATTRIBUTE.SURFACE-FORM SELF)
    STELLA::NULL-STRING)
   (CL:SETF (%XML-LOCAL-ATTRIBUTE.NAME SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-LOCAL-ATTRIBUTE.PARENT-ELEMENT SELF) NULL)
   (CL:RETURN-FROM NEW-XML-LOCAL-ATTRIBUTE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF XML-LOCAL-ATTRIBUTE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-XML-STELLA-XML-LOCAL-ATTRIBUTE))

(CL:DEFUN ACCESS-XML-LOCAL-ATTRIBUTE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-XML-STELLA-PARENT-ELEMENT)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-LOCAL-ATTRIBUTE.PARENT-ELEMENT SELF) VALUE)
     (CL:SETQ VALUE (%XML-LOCAL-ATTRIBUTE.PARENT-ELEMENT SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-XML-LOCAL-ATTRIBUTE-SLOT-VALUE VALUE))

(CL:DEFUN NEW-XML-GLOBAL-ATTRIBUTE ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-XML-GLOBAL-ATTRIBUTE))
   (CL:SETF (%XML-GLOBAL-ATTRIBUTE.SURFACE-FORM SELF)
    STELLA::NULL-STRING)
   (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAME SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-URI SELF)
    STELLA::NULL-STRING)
   (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-NAME SELF)
    STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-XML-GLOBAL-ATTRIBUTE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF XML-GLOBAL-ATTRIBUTE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-XML-STELLA-XML-GLOBAL-ATTRIBUTE))

(CL:DEFUN ACCESS-XML-GLOBAL-ATTRIBUTE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-XML-STELLA-NAMESPACE-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-NAME SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-STRING (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-XML-STELLA-NAMESPACE-URI)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-URI SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-STRING (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-URI SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-XML-GLOBAL-ATTRIBUTE-SLOT-VALUE VALUE))

(CL:DEFUN NEW-XML-PROCESSING-INSTRUCTION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (%MAKE-XML-PROCESSING-INSTRUCTION))
   (CL:SETF (%XML-PROCESSING-INSTRUCTION.SURFACE-FORM SELF)
    STELLA::NULL-STRING)
   (CL:SETF (%XML-PROCESSING-INSTRUCTION.NAME SELF)
    STELLA::NULL-STRING)
   (CL:SETF (%XML-PROCESSING-INSTRUCTION.DATA SELF)
    STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-XML-PROCESSING-INSTRUCTION SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF XML-PROCESSING-INSTRUCTION))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-XML-STELLA-XML-PROCESSING-INSTRUCTION))

(CL:DEFUN ACCESS-XML-PROCESSING-INSTRUCTION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-XML-STELLA-DATA)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-PROCESSING-INSTRUCTION.DATA SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-STRING (%XML-PROCESSING-INSTRUCTION.DATA SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-XML-PROCESSING-INSTRUCTION-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF XML-PROCESSING-INSTRUCTION) STREAM)
  (CL:IF
   (CL:EQ (%XML-PROCESSING-INSTRUCTION.DATA SELF) STELLA::NULL-STRING)
   (%%PRINT-STREAM STREAM "<?"
    (%XML-PROCESSING-INSTRUCTION.SURFACE-FORM SELF) ">")
   (%%PRINT-STREAM STREAM "<?"
    (%XML-PROCESSING-INSTRUCTION.SURFACE-FORM SELF) " "
    (%XML-PROCESSING-INSTRUCTION.DATA SELF) ">"))
  :VOID)

(CL:DEFUN NEW-XML-DECLARATION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-XML-DECLARATION))
   (CL:SETF (%XML-DECLARATION.SURFACE-FORM SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-DECLARATION.NAME SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-DECLARATION.DATA SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-XML-DECLARATION SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF XML-DECLARATION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-XML-STELLA-XML-DECLARATION))

(CL:DEFUN ACCESS-XML-DECLARATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-XML-STELLA-DATA)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-DECLARATION.DATA SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%XML-DECLARATION.DATA SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-XML-DECLARATION-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF XML-DECLARATION) STREAM)
  (CL:IF (CL:EQ (%XML-DECLARATION.DATA SELF) STELLA::NULL-STRING)
   (%%PRINT-STREAM STREAM "<!" (%XML-DECLARATION.SURFACE-FORM SELF)
    ">")
   (%%PRINT-STREAM STREAM "<!" (%XML-DECLARATION.SURFACE-FORM SELF) " "
    (%XML-DECLARATION.DATA SELF) ">"))
  :VOID)

(CL:DEFUN NEW-XML-DOCTYPE-DECLARATION ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-XML-DOCTYPE-DECLARATION))
   (CL:SETF (%XML-DOCTYPE-DECLARATION.SURFACE-FORM SELF)
    STELLA::NULL-STRING)
   (CL:SETF (%XML-DOCTYPE-DECLARATION.NAME SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-DOCTYPE-DECLARATION.DATA SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-XML-DOCTYPE-DECLARATION SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF XML-DOCTYPE-DECLARATION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-XML-STELLA-XML-DOCTYPE-DECLARATION))

(CL:DEFMETHOD PRINT-OBJECT ((SELF XML-DOCTYPE-DECLARATION) STREAM)
  (CL:IF
   (CL:EQ (%XML-DOCTYPE-DECLARATION.DATA SELF) STELLA::NULL-STRING)
   (%%PRINT-STREAM STREAM "<!"
    (%XML-DOCTYPE-DECLARATION.SURFACE-FORM SELF) ">")
   (%%PRINT-STREAM STREAM "<!"
    (%XML-DOCTYPE-DECLARATION.SURFACE-FORM SELF) " ...>"))
  :VOID)

(CL:DEFUN NEW-XML-SPECIAL ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-XML-SPECIAL))
   (CL:SETF (%XML-SPECIAL.SURFACE-FORM SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-SPECIAL.NAME SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-SPECIAL.DATA SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-XML-SPECIAL SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF XML-SPECIAL))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-XML-STELLA-XML-SPECIAL))

(CL:DEFUN ACCESS-XML-SPECIAL-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-XML-STELLA-DATA)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-SPECIAL.DATA SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%XML-SPECIAL.DATA SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-XML-SPECIAL-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF XML-SPECIAL) STREAM)
  (%%PRINT-STREAM STREAM "<!" (%XML-SPECIAL.SURFACE-FORM SELF) ">")
  :VOID)

(CL:DEFUN NEW-XML-COMMENT ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-XML-COMMENT))
   (CL:SETF (%XML-COMMENT.SURFACE-FORM SELF) STELLA::NULL-STRING)
   (CL:SETF (%XML-COMMENT.NAME SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-XML-COMMENT SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF XML-COMMENT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-XML-STELLA-XML-COMMENT))

(CL:DEFMETHOD PRINT-OBJECT ((SELF XML-COMMENT) STREAM)
  (CL:IF (CL:EQ (%XML-COMMENT.SURFACE-FORM SELF) STELLA::NULL-STRING)
   (%%PRINT-STREAM STREAM "<!-- -->")
   (%%PRINT-STREAM STREAM "<!-- "
    (CL:THE CL:FIXNUM
     (CL:LENGTH
      (CL:THE CL:SIMPLE-STRING (%XML-COMMENT.SURFACE-FORM SELF))))
    " chars -->"))
  :VOID)

(CL:DEFUN NEW-XML-DOCTYPE ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-XML-DOCTYPE))
   (CL:SETF (%XML-DOCTYPE.PARAMETER-ENTITY-TABLE SELF)
    (NEW-KEY-VALUE-LIST))
   (CL:SETF (%XML-DOCTYPE.ENTITY-TABLE SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%XML-DOCTYPE.NAME SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-XML-DOCTYPE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF XML-DOCTYPE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-XML-STELLA-XML-DOCTYPE))

(CL:DEFUN ACCESS-XML-DOCTYPE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-XML-STELLA-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-DOCTYPE.NAME SELF)
      (%STRING-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%XML-DOCTYPE.NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-XML-STELLA-ENTITY-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%XML-DOCTYPE.ENTITY-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%XML-DOCTYPE.ENTITY-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-XML-STELLA-PARAMETER-ENTITY-TABLE)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-DOCTYPE.PARAMETER-ENTITY-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%XML-DOCTYPE.PARAMETER-ENTITY-TABLE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-XML-DOCTYPE-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF XML-DOCTYPE) STREAM)
  (%%PRINT-STREAM STREAM "<!DOCTYPE " (%XML-DOCTYPE.NAME SELF) ">")
  :VOID)

;;; (DEFGLOBAL *XML-ELEMENT-NULL-NAMESPACE-TABLE* ...)

(CL:DEFVAR *XML-ELEMENT-NULL-NAMESPACE-TABLE* NULL
  "Hash Table for interning XML elements that don't appear in any namespace.")

;;; (DEFGLOBAL *XML-ELEMENT-HASH-TABLE* ...)

(CL:DEFVAR *XML-ELEMENT-HASH-TABLE* NULL
  "Hash Table mapping URI's (for namespaces) to a Hash Table
for interning XML elements.")

;;; (DEFGLOBAL *XML-GLOBAL-ATTRIBUTE-HASH-TABLE* ...)

(CL:DEFVAR *XML-GLOBAL-ATTRIBUTE-HASH-TABLE* NULL
  "Hash Table mapping URI's (for namespaces) to a Hash Table
for interning XML global attributes.")

;;; (DEFUN RESET-XML-HASH-TABLES ...)

(CL:DEFUN RESET-XML-HASH-TABLES ()
  "Resets Hashtables used for interning XML elements and global
attribute objects.  This will allow garbage collection of no-longer used
objects, but will also mean that newly parsed xml elements and global attributes
will not be eq? to already existing ones with the same name."
  (CL:SETQ *XML-ELEMENT-NULL-NAMESPACE-TABLE* (NEW-STRING-HASH-TABLE))
  (CL:SETQ *XML-ELEMENT-HASH-TABLE* (NEW-STRING-HASH-TABLE))
  (CL:SETQ *XML-GLOBAL-ATTRIBUTE-HASH-TABLE* (NEW-STRING-HASH-TABLE))
  :VOID)

;;; (DEFUN (MAKE-NAMESPACE-TABLE (KV-CONS OF STRING-WRAPPER STRING-WRAPPER)) ...)

(CL:DEFUN MAKE-NAMESPACE-TABLE ()
  (CL:RETURN-FROM MAKE-NAMESPACE-TABLE
   (KV-CONS (WRAP-STRING "xml") (WRAP-STRING *XML-URN*) NULL)))

;;; (DEFUN (MAKE-XML-CDATA-FORM CONS) ...)

(CL:DEFUN MAKE-XML-CDATA-FORM (THE-DATA)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING THE-DATA))
  #+MCL
  (CL:CHECK-TYPE THE-DATA CL:SIMPLE-STRING)
  (CL:LET* ((SELF-000 (NEW-XML-SPECIAL)))
   (CL:SETF (%XML-SPECIAL.NAME SELF-000) "CDATA")
   (CL:SETF (%XML-SPECIAL.SURFACE-FORM SELF-000) "CDATA")
   (CL:LET* ((TAG SELF-000))
    (CL:RETURN-FROM MAKE-XML-CDATA-FORM
     (CONS TAG (CONS (CONS (WRAP-STRING THE-DATA) NIL) NIL))))))

;;; (DEFUN (MAKE-XMLNS-ATTRIBUTE XML-ATTRIBUTE) ...)

(CL:DEFUN MAKE-XMLNS-ATTRIBUTE (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((COLON-POSITION (POSITION NAME #\: 0)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COLON-POSITION))
   (CL:IF (CL:= COLON-POSITION NULL-INTEGER)
    (CL:LET* ((SELF-000 (NEW-XML-GLOBAL-ATTRIBUTE)))
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAME SELF-000) "")
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-NAME SELF-000) "xmlns")
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.SURFACE-FORM SELF-000) NAME)
     (CL:LET* ((VALUE-000 SELF-000))
      (CL:RETURN-FROM MAKE-XMLNS-ATTRIBUTE VALUE-000)))
    (CL:LET* ((SELF-001 (NEW-XML-GLOBAL-ATTRIBUTE)))
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAME SELF-001)
      (SUBSEQUENCE NAME (CL:1+ COLON-POSITION) NULL-INTEGER))
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-NAME SELF-001) "xmlns")
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.SURFACE-FORM SELF-001) NAME)
     (CL:LET* ((VALUE-001 SELF-001))
      (CL:RETURN-FROM MAKE-XMLNS-ATTRIBUTE VALUE-001))))))

;;; (DEFUN (MAKE-XML-ELEMENT-INTERNAL XML-ELEMENT) ...)

(CL:DEFUN MAKE-XML-ELEMENT-INTERNAL (NAME NAMESPACE-NAME NAMESPACE SURFACE-FORM)
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING NAME NAMESPACE-NAME NAMESPACE
    SURFACE-FORM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SURFACE-FORM CL:SIMPLE-STRING)
  (CL:LET* ((NS-HASH-TABLE NULL) (ELEMENT NULL))
   (CL:COND
    ((CL:NOT (CL:EQ NAMESPACE STELLA::NULL-STRING))
     (CL:SETQ NS-HASH-TABLE
      (LOOKUP *XML-ELEMENT-HASH-TABLE* NAMESPACE))
     (CL:WHEN (CL:EQ NS-HASH-TABLE NULL)
      (CL:SETQ NS-HASH-TABLE (NEW-STRING-HASH-TABLE))
      (INSERT-AT *XML-ELEMENT-HASH-TABLE* NAMESPACE NS-HASH-TABLE)))
    (CL:T (CL:SETQ NS-HASH-TABLE *XML-ELEMENT-NULL-NAMESPACE-TABLE*)))
   (CL:SETQ ELEMENT (LOOKUP NS-HASH-TABLE NAME))
   (CL:WHEN (CL:EQ ELEMENT NULL)
    (CL:LET* ((SELF-001 (NEW-XML-ELEMENT)))
     (CL:SETF (%XML-ELEMENT.NAME SELF-001) NAME)
     (CL:SETF (%XML-ELEMENT.NAMESPACE-NAME SELF-001) NAMESPACE-NAME)
     (CL:SETF (%XML-ELEMENT.NAMESPACE-URI SELF-001) NAMESPACE)
     (CL:SETF (%XML-ELEMENT.SURFACE-FORM SELF-001) SURFACE-FORM)
     (CL:SETF (%XML-ELEMENT.ELEMENT-DICTIONARY SELF-001)
      (NEW-KEY-VALUE-LIST))
     (CL:SETQ ELEMENT SELF-001))
    (INSERT-AT NS-HASH-TABLE NAME ELEMENT))
   (CL:RETURN-FROM MAKE-XML-ELEMENT-INTERNAL ELEMENT)))

;;; (DEFUN (MAKE-XML-ELEMENT XML-ELEMENT) ...)

(CL:DEFUN MAKE-XML-ELEMENT (NAME NAMESPACE-NAME NAMESPACE)
  "Creates and interns an XML element object `name' using `namespace-name'
to refer to  `namespace'.  If `namespace' is `null', then the element will
be interned in the null namespace.   `namespace' must otherwise be a URI."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME NAMESPACE-NAME NAMESPACE))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE CL:SIMPLE-STRING)
  (CL:IF
   (CL:OR (CL:EQ NAMESPACE-NAME STELLA::NULL-STRING)
    (STRING-EQL? NAMESPACE-NAME ""))
   (CL:RETURN-FROM MAKE-XML-ELEMENT
    (MAKE-XML-ELEMENT-INTERNAL NAME "" NAMESPACE NAME))
   (CL:RETURN-FROM MAKE-XML-ELEMENT
    (MAKE-XML-ELEMENT-INTERNAL NAME NAMESPACE-NAME NAMESPACE
     (CONCATENATE NAMESPACE-NAME ":" NAME)))))

;;; (DEFUN (MAKE-XML-ELEMENT-RESPECTING-NAMESPACE XML-ELEMENT) ...)

(CL:DEFUN MAKE-XML-ELEMENT-RESPECTING-NAMESPACE (NAME NAMESPACE-TABLE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((COLON-POSITION (POSITION NAME #\: 0)) (NS-PART "") (RAW-NAME "")
    (NAMESPACE-URI STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COLON-POSITION)
    (CL:TYPE CL:SIMPLE-STRING NS-PART RAW-NAME NAMESPACE-URI))
   (CL:IF (CL:= COLON-POSITION NULL-INTEGER) (CL:SETQ RAW-NAME NAME)
    (CL:PROGN (CL:SETQ NS-PART (SUBSEQUENCE NAME 0 COLON-POSITION))
     (CL:SETQ RAW-NAME
      (SUBSEQUENCE NAME (CL:1+ COLON-POSITION) NULL-INTEGER))))
   (CL:SETQ NAMESPACE-URI
    (UNWRAP-STRING (LOOKUP NAMESPACE-TABLE (WRAP-STRING NS-PART))))
   (CL:WHEN
    (CL:AND (CL:EQ NAMESPACE-URI STELLA::NULL-STRING)
     (CL:NOT (STRING-EQL? NS-PART "")))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Undefined Namespace for Element: `" NS-PART "'")
     (CL:ERROR
      (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (CL:RETURN-FROM MAKE-XML-ELEMENT-RESPECTING-NAMESPACE
    (MAKE-XML-ELEMENT-INTERNAL RAW-NAME NS-PART NAMESPACE-URI NAME))))

;;; (DEFUN (MAKE-XML-GLOBAL-ATTRIBUTE-INTERNAL XML-GLOBAL-ATTRIBUTE) ...)

(CL:DEFUN MAKE-XML-GLOBAL-ATTRIBUTE-INTERNAL (NAME NAMESPACE-NAME NAMESPACE-URI SURFACE-FORM)
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING NAME NAMESPACE-NAME NAMESPACE-URI
    SURFACE-FORM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE-URI CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SURFACE-FORM CL:SIMPLE-STRING)
  (CL:WHEN
   (CL:OR (CL:EQ NAMESPACE-URI STELLA::NULL-STRING)
    (CL:EQ NAMESPACE-NAME STELLA::NULL-STRING)
    (STRING-EQL? NAMESPACE-URI "") (STRING-EQL? NAMESPACE-NAME ""))
   (CL:ERROR
    (NEW-BAD-ARGUMENT-EXCEPTION
     "namespace-name and namespace must be specified")))
  (CL:LET*
   ((NS-HASH-TABLE
     (LOOKUP *XML-GLOBAL-ATTRIBUTE-HASH-TABLE* NAMESPACE-URI))
    (ATTRIBUTE NULL))
   (CL:WHEN (CL:EQ NS-HASH-TABLE NULL)
    (CL:SETQ NS-HASH-TABLE (NEW-STRING-HASH-TABLE))
    (INSERT-AT *XML-GLOBAL-ATTRIBUTE-HASH-TABLE* NAMESPACE-URI
     NS-HASH-TABLE))
   (CL:SETQ ATTRIBUTE (LOOKUP NS-HASH-TABLE NAME))
   (CL:WHEN (CL:EQ ATTRIBUTE NULL)
    (CL:LET* ((SELF-002 (NEW-XML-GLOBAL-ATTRIBUTE)))
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAME SELF-002) NAME)
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-NAME SELF-002)
      NAMESPACE-NAME)
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-URI SELF-002)
      NAMESPACE-URI)
     (CL:SETF (%XML-GLOBAL-ATTRIBUTE.SURFACE-FORM SELF-002)
      SURFACE-FORM)
     (CL:SETQ ATTRIBUTE SELF-002))
    (INSERT-AT NS-HASH-TABLE NAME ATTRIBUTE))
   (CL:RETURN-FROM MAKE-XML-GLOBAL-ATTRIBUTE-INTERNAL ATTRIBUTE)))

;;; (DEFUN (MAKE-XML-GLOBAL-ATTRIBUTE XML-GLOBAL-ATTRIBUTE) ...)

(CL:DEFUN MAKE-XML-GLOBAL-ATTRIBUTE (NAME NAMESPACE-NAME NAMESPACE)
  "Creates and interns an XML global attribute object with `name' using 
`namespace-name' to refer to  `namespace'.  `namespace'must be a URI."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME NAMESPACE-NAME NAMESPACE))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE CL:SIMPLE-STRING)
  (CL:RETURN-FROM MAKE-XML-GLOBAL-ATTRIBUTE
   (MAKE-XML-GLOBAL-ATTRIBUTE-INTERNAL NAME NAMESPACE-NAME NAMESPACE
    (CONCATENATE NAME ":" NAMESPACE-NAME))))

;;; (DEFUN (MAKE-XML-GLOBAL-ATTRIBUTE-RESPECTING-NAMESPACE XML-GLOBAL-ATTRIBUTE) ...)

(CL:DEFUN MAKE-XML-GLOBAL-ATTRIBUTE-RESPECTING-NAMESPACE (NAME NAMESPACE-NAME SURFACE-FORM NAMESPACE-TABLE)
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING NAME NAMESPACE-NAME SURFACE-FORM))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SURFACE-FORM CL:SIMPLE-STRING)
  (CL:LET*
   ((NAMESPACE-URI
     (LOOKUP NAMESPACE-TABLE (WRAP-STRING NAMESPACE-NAME))))
   (CL:WHEN (CL:EQ NAMESPACE-URI NULL)
    (CL:ERROR
     (NEW-BAD-ARGUMENT-EXCEPTION
      "Undefined Namespace for Attribute!")))
   (CL:RETURN-FROM MAKE-XML-GLOBAL-ATTRIBUTE-RESPECTING-NAMESPACE
    (MAKE-XML-GLOBAL-ATTRIBUTE-INTERNAL NAME NAMESPACE-NAME
     (%STRING-WRAPPER.WRAPPER-VALUE NAMESPACE-URI) SURFACE-FORM))))

;;; (DEFUN (MAKE-XML-LOCAL-ATTRIBUTE XML-LOCAL-ATTRIBUTE) ...)

(CL:DEFUN MAKE-XML-LOCAL-ATTRIBUTE (NAME ELEMENT)
  "Make an XML-LOCAL-ATTRIBUTE named `name' associated with `element'"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((DICTIONARY (%XML-ELEMENT.ELEMENT-DICTIONARY ELEMENT))
    (ATTRIBUTE (LOOKUP DICTIONARY (WRAP-STRING NAME))))
   (CL:WHEN (CL:EQ ATTRIBUTE NULL)
    (CL:LET* ((SELF-000 (NEW-XML-LOCAL-ATTRIBUTE)))
     (CL:SETF (%XML-LOCAL-ATTRIBUTE.NAME SELF-000) NAME)
     (CL:SETF (%XML-LOCAL-ATTRIBUTE.PARENT-ELEMENT SELF-000) ELEMENT)
     (CL:SETF (%XML-LOCAL-ATTRIBUTE.SURFACE-FORM SELF-000) NAME)
     (CL:SETQ ATTRIBUTE SELF-000))
    (INSERT-AT (%XML-ELEMENT.ELEMENT-DICTIONARY ELEMENT)
     (WRAP-STRING NAME) ATTRIBUTE))
   (CL:RETURN-FROM MAKE-XML-LOCAL-ATTRIBUTE ATTRIBUTE)))

;;; (DEFUN (MAKE-XML-ATTRIBUTE-RESPECTING-NAMESPACE XML-ATTRIBUTE) ...)

(CL:DEFUN MAKE-XML-ATTRIBUTE-RESPECTING-NAMESPACE (NAME ELEMENT NAMESPACE-TABLE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((COLON-POSITION (POSITION NAME #\: 0)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COLON-POSITION))
   (CL:IF (CL:= COLON-POSITION NULL-INTEGER)
    (CL:RETURN-FROM MAKE-XML-ATTRIBUTE-RESPECTING-NAMESPACE
     (MAKE-XML-LOCAL-ATTRIBUTE NAME ELEMENT))
    (CL:RETURN-FROM MAKE-XML-ATTRIBUTE-RESPECTING-NAMESPACE
     (MAKE-XML-GLOBAL-ATTRIBUTE-RESPECTING-NAMESPACE
      (SUBSEQUENCE NAME (CL:1+ COLON-POSITION) NULL-INTEGER)
      (SUBSEQUENCE NAME 0 COLON-POSITION) NAME NAMESPACE-TABLE)))))

;;; (DEFUN (XMLNS-ATTRIBUTE? BOOLEAN) ...)

(CL:DEFUN XMLNS-ATTRIBUTE? (ATTRIBUTE)
  (CL:RETURN-FROM XMLNS-ATTRIBUTE?
   (CL:AND (ISA? ATTRIBUTE SGT-XML-STELLA-XML-GLOBAL-ATTRIBUTE)
    (STRING-EQL? "xmlns"
     (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-NAME ATTRIBUTE)))))

;;; (DEFUN (XMLNS-ATTRIBUTE-NAME? BOOLEAN) ...)

(CL:DEFUN XMLNS-ATTRIBUTE-NAME? (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((COLON-POSITION (POSITION NAME #\: 0)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COLON-POSITION))
   (CL:IF (CL:= COLON-POSITION NULL-INTEGER)
    (CL:RETURN-FROM XMLNS-ATTRIBUTE-NAME? (STRING-EQL? NAME "xmlns"))
    (CL:RETURN-FROM XMLNS-ATTRIBUTE-NAME?
     (STRING-EQL? (SUBSEQUENCE NAME 0 COLON-POSITION) "xmlns")))))

;;; (DEFUN (EXTRACT-XMLNS-NAME STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  EXTRACT-XMLNS-NAME))
(CL:DEFUN EXTRACT-XMLNS-NAME (KEYNAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING KEYNAME))
  #+MCL
  (CL:CHECK-TYPE KEYNAME CL:SIMPLE-STRING)
  (CL:LET* ((COLON-POSITION (POSITION KEYNAME #\: 0)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COLON-POSITION))
   (CL:IF (CL:= COLON-POSITION NULL-INTEGER)
    (CL:RETURN-FROM EXTRACT-XMLNS-NAME "")
    (CL:RETURN-FROM EXTRACT-XMLNS-NAME
     (SUBSEQUENCE KEYNAME (CL:1+ COLON-POSITION) NULL-INTEGER)))))

;;; (DEFGLOBAL *XML-BASE-ENTITY-TABLE* ...)

(CL:DEFVAR *XML-BASE-ENTITY-TABLE* NULL)

;;; (DEFUN ADD-XML-REFERENCE ...)

(CL:DEFUN ADD-XML-REFERENCE (NAME SUBSTITUTION TABLE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME SUBSTITUTION))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SUBSTITUTION CL:SIMPLE-STRING)
  (INSERT-AT TABLE (WRAP-STRING NAME) (WRAP-STRING SUBSTITUTION))
  :VOID)

;;; (DEFUN (MAKE-XML-ENTITY-TABLE (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER)) ...)

(CL:DEFUN MAKE-XML-ENTITY-TABLE ()
  (CL:LET* ((TABLE (NEW-KEY-VALUE-LIST)))
   (ADD-XML-REFERENCE "lt" "&#60;" TABLE)
   (ADD-XML-REFERENCE "gt" "&#62;" TABLE)
   (ADD-XML-REFERENCE "amp" "&#38;" TABLE)
   (ADD-XML-REFERENCE "apos" "&#39;" TABLE)
   (ADD-XML-REFERENCE "quot" "&#34;" TABLE)
   (ADD-XML-REFERENCE "nbsp" "&#160;" TABLE)
   (CL:RETURN-FROM MAKE-XML-ENTITY-TABLE TABLE)))

;;; (DEFUN (DECODE-XML-CHAR-REF STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:SIMPLE-STRING) CL:SIMPLE-STRING)
  DECODE-XML-CHAR-REF))
(CL:DEFUN DECODE-XML-CHAR-REF (DIGITS)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DIGITS))
  #+MCL
  (CL:CHECK-TYPE DIGITS CL:SIMPLE-STRING)
  (CL:LET* ((N 0) (END (CL:- (CL:THE CL:FIXNUM (CL:LENGTH DIGITS)) 2)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM N END))
   (CL:IF
    (CL:EQL
     (CL:LET ((SELF DIGITS) (POSITION 2))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION)))
     #\x)
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 3) (UPPER-BOUND-000 END)
      (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
      (CL:SETQ I ITER-000)
      (CL:SETQ N
       (CL:+ (CL:* N 16)
        (HEX-CHARACTER-VALUE
         (CL:LET ((SELF DIGITS) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-001 2) (UPPER-BOUND-001 END)
      (UNBOUNDED?-001 (CL:= UPPER-BOUND-001 NULL-INTEGER)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-001 (CL:<= ITER-001 UPPER-BOUND-001)) DO
      (CL:SETQ I ITER-001)
      (CL:SETQ N
       (CL:+ (CL:* N 10)
        (DIGIT-VALUE
         (CL:LET ((SELF DIGITS) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
           (CL:THE CL:FIXNUM POSITION))))))
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
   (CL:RETURN-FROM DECODE-XML-CHAR-REF
    (MAKE-STRING 1 (CL:CODE-CHAR N)))))

;;; (DEFUN (INTERNAL-DTD-DEFINITION? BOOLEAN) ...)

(CL:DEFUN INTERNAL-DTD-DEFINITION? (DEFINITION)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DEFINITION))
  #+MCL
  (CL:CHECK-TYPE DEFINITION CL:SIMPLE-STRING)
  (CL:RETURN-FROM INTERNAL-DTD-DEFINITION?
   (CL:AND
    (CL:EQL
     (CL:LET ((SELF DEFINITION) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION)))
     #\[)
    (CL:EQL
     (CL:LET
      ((SELF DEFINITION)
       (POSITION (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH DEFINITION)))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION)))
     #\]))))

;;; (DEFUN (GET-DOCTYPE-DEFINITION INPUT-STREAM) ...)

(CL:DEFUN GET-DOCTYPE-DEFINITION (DOCTYPE)
  (CL:LET*
   ((DEFINITION
     (%STRING-WRAPPER.WRAPPER-VALUE
      (%%VALUE (%%REST (%%VALUE (%%REST DOCTYPE)))))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DEFINITION))
   (CL:IF (INTERNAL-DTD-DEFINITION? DEFINITION)
    (CL:RETURN-FROM GET-DOCTYPE-DEFINITION
     (NEW-INPUT-STRING-STREAM
      (SUBSEQUENCE DEFINITION 1
       (CL:- (CL:THE CL:FIXNUM (CL:LENGTH DEFINITION)) 2))))
    (CL:RETURN-FROM GET-DOCTYPE-DEFINITION NULL))))

;;; (DEFUN (EXTERNAL-ID-HEAD? BOOLEAN) ...)

(CL:DEFUN EXTERNAL-ID-HEAD? (ATTRIBUTE)
  "Checks to see if this `attribute' is the literal marking either
a PUBLIC or SYSTEM literal for an XML Elternal ID.  (See 4.2.2)"
  (CL:RETURN-FROM EXTERNAL-ID-HEAD?
   (CL:AND (ISA? ATTRIBUTE SGT-XML-STELLA-STRING-WRAPPER)
    (CL:OR
     (STRING-EQL? (%STRING-WRAPPER.WRAPPER-VALUE ATTRIBUTE) "SYSTEM")
     (STRING-EQL? (%STRING-WRAPPER.WRAPPER-VALUE ATTRIBUTE) "PUBLIC")))))

;;; (DEFUN (DECODE-XML-ENTITY-REF STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:SIMPLE-STRING CL:T) CL:SIMPLE-STRING)
  DECODE-XML-ENTITY-REF))
(CL:DEFUN DECODE-XML-ENTITY-REF (DOCTYPE NAME PE-REFERENCE-ALLOWED?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((VALUE NULL))
   (CL:WHEN (CL:NOT (CL:EQ DOCTYPE NULL))
    (CL:SETQ VALUE
     (LOOKUP (%XML-DOCTYPE.ENTITY-TABLE DOCTYPE) (WRAP-STRING NAME))))
   (CL:WHEN (CL:EQ VALUE NULL)
    (CL:SETQ VALUE
     (LOOKUP *XML-BASE-ENTITY-TABLE* (WRAP-STRING NAME))))
   (CL:IF (CL:EQ VALUE NULL)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "Couldn't find entity reference for `" NAME "'")
     (CL:ERROR
      (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-000))))
    (CL:RETURN-FROM DECODE-XML-ENTITY-REF
     (DECODE-XML-STRING DOCTYPE (%STRING-WRAPPER.WRAPPER-VALUE VALUE)
      PE-REFERENCE-ALLOWED?)))))

;;; (DEFUN (DECODE-XML-PARAMETER-ENTITY-REF STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:SIMPLE-STRING CL:T) CL:SIMPLE-STRING)
  DECODE-XML-PARAMETER-ENTITY-REF))
(CL:DEFUN DECODE-XML-PARAMETER-ENTITY-REF (DOCTYPE NAME PE-REFERENCE-ALLOWED?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:WHEN (CL:NOT PE-REFERENCE-ALLOWED?)
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
     "Illegal XML Parameter Entity Reference: `" NAME "'")
    (CL:ERROR
     (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-000)))))
  (CL:WHEN (CL:EQ DOCTYPE NULL)
   (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
     "Parameter Entity References need a Doctype object: `" NAME "'")
    (CL:ERROR
     (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-001)))))
  (CL:LET*
   ((VALUE
     (%STRING-WRAPPER.WRAPPER-VALUE
      (LOOKUP (%XML-DOCTYPE.ENTITY-TABLE DOCTYPE)
       (WRAP-STRING NAME)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
   (CL:IF (CL:NOT (CL:EQ VALUE STELLA::NULL-STRING))
    (CL:RETURN-FROM DECODE-XML-PARAMETER-ENTITY-REF
     (DECODE-XML-STRING DOCTYPE VALUE PE-REFERENCE-ALLOWED?))
    (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
      "No Parameter Entity found to match `" NAME "'")
     (CL:ERROR
      (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-002)))))))

;;; (DEFUN (DECODE-XML-REFERENCE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:SIMPLE-STRING CL:T) CL:SIMPLE-STRING)
  DECODE-XML-REFERENCE))
(CL:DEFUN DECODE-XML-REFERENCE (DOCTYPE REFERENCE PE-REFERENCE-ALLOWED?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING REFERENCE))
  #+MCL
  (CL:CHECK-TYPE REFERENCE CL:SIMPLE-STRING)
  (CL:IF
   (CL:EQL
    (CL:LET ((SELF REFERENCE) (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
      (CL:TYPE CL:FIXNUM POSITION))
     (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
      (CL:THE CL:FIXNUM POSITION)))
    #\&)
   (CL:IF
    (CL:EQL
     (CL:LET ((SELF REFERENCE) (POSITION 1))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
       (CL:THE CL:FIXNUM POSITION)))
     #\#)
    (CL:RETURN-FROM DECODE-XML-REFERENCE
     (DECODE-XML-CHAR-REF REFERENCE))
    (CL:RETURN-FROM DECODE-XML-REFERENCE
     (DECODE-XML-ENTITY-REF DOCTYPE
      (SUBSEQUENCE REFERENCE 1
       (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH REFERENCE))))
      PE-REFERENCE-ALLOWED?)))
   (CL:RETURN-FROM DECODE-XML-REFERENCE
    (DECODE-XML-PARAMETER-ENTITY-REF DOCTYPE
     (SUBSEQUENCE REFERENCE 1
      (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH REFERENCE))))
     PE-REFERENCE-ALLOWED?))))

;;; (DEFUN (FIND-REFERENCE-START INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:SIMPLE-STRING CL:FIXNUM CL:FIXNUM) CL:FIXNUM)
  FIND-REFERENCE-START))
(CL:DEFUN FIND-REFERENCE-START (INPUT START END)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT)
   (CL:TYPE CL:FIXNUM START END))
  #+MCL
  (CL:CHECK-TYPE INPUT CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE START CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE END CL:FIXNUM)
  (CL:WHEN (CL:= END NULL-INTEGER)
   (CL:SETQ END (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH INPUT)))))
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 START) (UPPER-BOUND-000 END)
    (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE
    (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
    (CL:SETQ I ITER-000)
    (CL:WHEN
     (CL:OR
      (CL:EQL
       (CL:LET ((SELF INPUT) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION)))
       #\&)
      (CL:EQL
       (CL:LET ((SELF INPUT) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
         (CL:THE CL:FIXNUM POSITION)))
       #\%))
     (CL:RETURN-FROM FIND-REFERENCE-START I))
    (CL:SETQ ITER-000 (CL:1+ ITER-000))))
  (CL:RETURN-FROM FIND-REFERENCE-START NULL-INTEGER))

;;; (DEFUN (DECODE-XML-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:SIMPLE-STRING CL:T) CL:SIMPLE-STRING)
  DECODE-XML-STRING))
(CL:DEFUN DECODE-XML-STRING (DOCTYPE INPUT PE-REFERENCE-ALLOWED?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT))
  #+MCL
  (CL:CHECK-TYPE INPUT CL:SIMPLE-STRING)
  (CL:LET*
   ((INPUT-END
     (CL:IF PE-REFERENCE-ALLOWED?
      (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH INPUT))) NULL-INTEGER))
    (REFERENCE-START
     (CL:IF PE-REFERENCE-ALLOWED?
      (FIND-REFERENCE-START INPUT 0 INPUT-END) (POSITION INPUT #\& 0)))
    (SUBSTITUTION STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INPUT-END REFERENCE-START)
    (CL:TYPE CL:SIMPLE-STRING SUBSTITUTION))
   (CL:IF (CL:= REFERENCE-START NULL-INTEGER)
    (CL:RETURN-FROM DECODE-XML-STRING INPUT)
    (CL:LET* ((BUFFER (NEW-OUTPUT-STRING-STREAM)) (REFERENCE-END 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM REFERENCE-END))
     (CL:WHEN (CL:NOT PE-REFERENCE-ALLOWED?)
      (CL:SETQ INPUT-END (CL:1- (CL:THE CL:FIXNUM (CL:LENGTH INPUT)))))
     (CL:LOOP WHILE (CL:NOT (CL:= REFERENCE-START NULL-INTEGER)) DO
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM BUFFER)
       (SUBSEQUENCE INPUT REFERENCE-END REFERENCE-START))
      (CL:SETQ REFERENCE-END (POSITION INPUT #\; REFERENCE-START))
      (CL:WHEN (CL:= REFERENCE-END NULL-INTEGER)
       (CL:ERROR "Safety violation: Unterminated XML reference"))
      (CL:SETQ REFERENCE-END (CL:1+ REFERENCE-END))
      (CL:SETQ SUBSTITUTION
       (DECODE-XML-REFERENCE DOCTYPE
        (SUBSEQUENCE INPUT REFERENCE-START REFERENCE-END)
        PE-REFERENCE-ALLOWED?))
      (CL:IF (CL:EQ SUBSTITUTION STELLA::NULL-STRING)
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "Unrecognized entity reference: `"
         (SUBSEQUENCE INPUT REFERENCE-START REFERENCE-END) "'")
        (CL:ERROR
         (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-000))))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM BUFFER)
        SUBSTITUTION))
      (CL:SETQ REFERENCE-START
       (CL:IF PE-REFERENCE-ALLOWED?
        (FIND-REFERENCE-START INPUT REFERENCE-END INPUT-END)
        (POSITION INPUT #\& REFERENCE-END))))
     (CL:WHEN (CL:NOT (CL:= REFERENCE-END INPUT-END))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM BUFFER)
       (SUBSEQUENCE INPUT REFERENCE-END NULL-INTEGER)))
     (CL:RETURN-FROM DECODE-XML-STRING (THE-STRING-READER BUFFER))))))

;;; (DEFUN (NORMALIZE-ATTRIBUTE-VALUE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:SIMPLE-STRING CL:T) CL:SIMPLE-STRING)
  NORMALIZE-ATTRIBUTE-VALUE))
(CL:DEFUN NORMALIZE-ATTRIBUTE-VALUE (DOCTYPE INPUT PE-REFERENCE-ALLOWED?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING INPUT))
  #+MCL
  (CL:CHECK-TYPE INPUT CL:SIMPLE-STRING)
  (CL:RETURN-FROM NORMALIZE-ATTRIBUTE-VALUE
   (DECODE-XML-STRING DOCTYPE INPUT PE-REFERENCE-ALLOWED?)))

;;; (DEFUN (PROCESS-DOCTYPE XML-DOCTYPE) ...)

(CL:DEFUN PROCESS-DOCTYPE (DOCTYPE-DECLARATION)
  "Takes an S-Expression representing a doctype and processes into
a DOCTYPE object."
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ DOCTYPE-DECLARATION NULL))
    (CL:NOT (CL:EQ DOCTYPE-DECLARATION NIL))
    (ISA? (%%VALUE DOCTYPE-DECLARATION) SGT-XML-STELLA-XML-DECLARATION)
    (STRING-EQL? "DOCTYPE"
     (%XML-DECLARATION.NAME (%%VALUE DOCTYPE-DECLARATION))))
   (CL:LET*
    ((DOCTYPE (NEW-XML-DOCTYPE)) (DEFINITION-STREAM NULL)
     (ITERATOR NULL))
    (CL:UNWIND-PROTECT
     (CL:PROGN
      (CL:SETF (%XML-DOCTYPE.NAME DOCTYPE)
       (%STRING-WRAPPER.WRAPPER-VALUE
        (%%VALUE (%%VALUE (%%REST DOCTYPE-DECLARATION)))))
      (CL:SETQ DEFINITION-STREAM
       (GET-DOCTYPE-DEFINITION DOCTYPE-DECLARATION))
      (CL:WHEN (CL:NOT (CL:EQ DEFINITION-STREAM NULL))
       (CL:LET* ((SELF-001 (NEW-XML-EXPRESSION-ITERATOR)))
        (CL:SETF (%XML-EXPRESSION-ITERATOR.THE-STREAM SELF-001)
         DEFINITION-STREAM)
        (CL:SETF (%XML-EXPRESSION-ITERATOR.DOCTYPE-ITERATOR? SELF-001)
         CL:T)
        (CL:SETF (%XML-EXPRESSION-ITERATOR.DOCTYPE SELF-001) DOCTYPE)
        (CL:SETQ ITERATOR SELF-001))
       (CL:LET* ((DECLARATION NULL) (ITER-000 ITERATOR))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ DECLARATION
          (%XML-EXPRESSION-ITERATOR.VALUE ITER-000))
         (CL:WHEN
          (CL:AND
           (ISA? (%%VALUE DECLARATION) SGT-XML-STELLA-XML-DECLARATION)
           (STRING-EQL? "ENTITY"
            (%XML-DECLARATION.NAME (%%VALUE DECLARATION))))
          (CL:LET* ((ATTRIBUTES (%%VALUE (%%REST DECLARATION))))
           (CL:IF
            (STRING-EQL? "%"
             (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ATTRIBUTES)))
            (CL:IF
             (CL:AND (CL:> (LENGTH ATTRIBUTES) 3)
              (EXTERNAL-ID-HEAD?
               (%%VALUE (%%REST (%%REST ATTRIBUTES)))))
             (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
              (%%PRINT-STREAM
               (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
               "Can't handle external entity definitions: `"
               DECLARATION "'")
              (CL:ERROR
               (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))
             (ADD-XML-REFERENCE
              (%STRING-WRAPPER.WRAPPER-VALUE
               (%%VALUE (%%REST ATTRIBUTES)))
              (%STRING-WRAPPER.WRAPPER-VALUE
               (%%VALUE (%%REST (%%REST ATTRIBUTES))))
              (%XML-DOCTYPE.PARAMETER-ENTITY-TABLE DOCTYPE)))
            (CL:IF
             (CL:AND (CL:> (LENGTH ATTRIBUTES) 2)
              (EXTERNAL-ID-HEAD? (%%VALUE (%%REST ATTRIBUTES))))
             (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
              (%%PRINT-STREAM
               (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
               "Can't handle external entity definitions: `"
               DECLARATION "'")
              (CL:ERROR
               (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))
             (ADD-XML-REFERENCE
              (%STRING-WRAPPER.WRAPPER-VALUE (%%VALUE ATTRIBUTES))
              (%STRING-WRAPPER.WRAPPER-VALUE
               (%%VALUE (%%REST ATTRIBUTES)))
              (%XML-DOCTYPE.ENTITY-TABLE DOCTYPE)))))))))
      (CL:WHEN (CL:NOT (CL:EQ DEFINITION-STREAM NULL))
       (FREE DEFINITION-STREAM))))
    (CL:RETURN-FROM PROCESS-DOCTYPE DOCTYPE))
   (CL:RETURN-FROM PROCESS-DOCTYPE NULL)))

;;; (DEFGLOBAL *XML-TOKENIZER-TABLE-DEFINITION* ...)

(CL:DEFVAR *XML-TOKENIZER-TABLE-DEFINITION* NULL)

;;; (DEFGLOBAL *XML-TOKENIZER-TABLE* ...)

(CL:DEFVAR *XML-TOKENIZER-TABLE* NULL)

;;; (DEFSPECIAL *XML-PRESERVE-ALL-WHITESPACE?* ...)

(CL:DEFVAR *XML-PRESERVE-ALL-WHITESPACE?* CL:NIL
  "If true, all whitespace between tags (newlines, trailing WP, etc.)
will be preserved.  This is a kludge to allow us to read certain `illegal' XML files
where this whitespace is significant but not appropriately encoded.")

;;; (DEFGLOBAL *XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE* ...)

(CL:DEFVAR *XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE* NULL)

;;; (DEFUN (GET-XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE TOKENIZER-TABLE) ...)

(CL:DEFUN GET-XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE ()
  (CL:WHEN (CL:EQ *XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE* NULL)
   (CL:LET*
    ((TOKENIZERDEFINITION
      (COPY-CONS-TREE *XML-TOKENIZER-TABLE-DEFINITION*)))
    (SECOND-SETTER TOKENIZERDEFINITION
     (LIST* KWD-XML-SKIP-WHITESPACE SYM-XML-STELLA-! (WRAP-STRING "<")
      KWD-XML-OPEN-TAG KWD-XML-EOF KWD-XML-EOF SYM-XML-STELLA-*
      KWD-XML-OTHERWISE KWD-XML-CONTENT NIL))
    (CL:SETQ *XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE*
     (PARSE-TOKENIZER-DEFINITION TOKENIZERDEFINITION))))
  (CL:RETURN-FROM GET-XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE
   *XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE*))

;;; (DEFUN (GET-XML-TOKENIZER-TABLE TOKENIZER-TABLE) ...)

(CL:DEFUN GET-XML-TOKENIZER-TABLE ()
  (CL:IF *XML-PRESERVE-ALL-WHITESPACE?*
   (CL:RETURN-FROM GET-XML-TOKENIZER-TABLE
    (GET-XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE))
   (CL:RETURN-FROM GET-XML-TOKENIZER-TABLE *XML-TOKENIZER-TABLE*)))

;;; (DEFUN (TOKENIZE-XML-EXPRESSION TOKENIZER-TOKEN BOOLEAN) ...)

(CL:DEFUN TOKENIZE-XML-EXPRESSION (STREAM TOKENLIST REGIONTAGNAME SKIPTOREGION?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING REGIONTAGNAME))
  #+MCL
  (CL:CHECK-TYPE REGIONTAGNAME CL:SIMPLE-STRING)
  (CL:LET*
   ((PARENBALANCE 0) (STARTTAG STELLA::NULL-STRING)
    (CURRENTTAG STELLA::NULL-STRING)
    (REGIONTAGFOUND?
     (CL:OR (CL:EQ REGIONTAGNAME STELLA::NULL-STRING)
      (CL:NOT SKIPTOREGION?)))
    (ENDOFFILE? CL:T) (TOKENTYPE NULL)
    (TOKENCONTENT STELLA::NULL-STRING) (TOKENCURSOR TOKENLIST))
   (CL:DECLARE (CL:TYPE CL:FIXNUM PARENBALANCE)
    (CL:TYPE CL:SIMPLE-STRING STARTTAG CURRENTTAG TOKENCONTENT))
   (CL:WHEN (CL:EQ TOKENLIST NULL)
    (CL:SETQ TOKENLIST (NEW-TOKENIZER-TOKEN))
    (CL:SETQ TOKENCURSOR TOKENLIST))
   (CL:LET*
    ((TOK_TABLE_ (GET-XML-TOKENIZER-TABLE))
     (TOK_TRANSITIONS_ (%TOKENIZER-TABLE.TRANSITIONS TOK_TABLE_))
     (TOK_STATENAMES_
      (%VECTOR.THE-ARRAY (%TOKENIZER-TABLE.STATE-NAMES TOK_TABLE_)))
     (TOK_TOKENSTART_ -1) (TOK_ENDOFTOKENS?_ CL:NIL)
     (TOK_INPUTSTREAM_ STREAM)
     (TOK_ECHOSTREAM_ (%INPUT-STREAM.ECHO-STREAM TOK_INPUTSTREAM_))
     (TOK_STREAMSTATE_
      (CL:IF
       (CL:EQ (%INPUT-STREAM.TOKENIZER-STATE TOK_INPUTSTREAM_) NULL)
       (CL:SETF (%INPUT-STREAM.TOKENIZER-STATE TOK_INPUTSTREAM_)
        (NEW-TOKENIZER-STREAM-STATE))
       (%INPUT-STREAM.TOKENIZER-STATE TOK_INPUTSTREAM_)))
     (TOK_BUFFER_ (%TOKENIZER-STREAM-STATE.BUFFER TOK_STREAMSTATE_))
     (TOK_SIZE_ (%TOKENIZER-STREAM-STATE.BUFFER-SIZE TOK_STREAMSTATE_))
     (TOK_STATE_ (GET-SAVED-STATE TOK_STREAMSTATE_ TOK_TABLE_))
     (TOK_NEXTSTATE_ TOK_STATE_)
     (TOK_CURSOR_ (%TOKENIZER-STREAM-STATE.CURSOR TOK_STREAMSTATE_))
     (TOK_END_ (%TOKENIZER-STREAM-STATE.END TOK_STREAMSTATE_))
     (TOK_CHECKPOINT_
      (CL:IF (CL:<= TOK_CURSOR_ TOK_END_) TOK_END_ TOK_SIZE_)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TOK_TRANSITIONS_)
     (CL:TYPE CL:SIMPLE-VECTOR TOK_STATENAMES_)
     (CL:TYPE CL:FIXNUM TOK_TOKENSTART_ TOK_SIZE_ TOK_STATE_
      TOK_NEXTSTATE_ TOK_CURSOR_ TOK_END_ TOK_CHECKPOINT_))
    (CL:PROGN (CL:SETQ TOK_STATENAMES_ TOK_STATENAMES_)
     (CL:SETQ TOK_ENDOFTOKENS?_ TOK_ENDOFTOKENS?_))
    (CL:LOOP
     (CL:TAGBODY
      (CL:PROGN (CL:SETQ TOK_TOKENSTART_ -1)
       (CL:LOOP
        (CL:WHEN (CL:= TOK_CURSOR_ TOK_CHECKPOINT_)
         (CL:COND
          ((CL:= TOK_CURSOR_ TOK_END_)
           (CL:SETF (%TOKENIZER-STREAM-STATE.CURSOR TOK_STREAMSTATE_)
            TOK_CURSOR_)
           (CL:SETQ TOK_ENDOFTOKENS?_
            (READ-INTO-TOKENIZER-BUFFER TOK_INPUTSTREAM_
             TOK_STREAMSTATE_ TOK_TOKENSTART_))
           (CL:SETQ TOK_BUFFER_
            (%TOKENIZER-STREAM-STATE.BUFFER TOK_STREAMSTATE_))
           (CL:SETQ TOK_SIZE_
            (%TOKENIZER-STREAM-STATE.BUFFER-SIZE TOK_STREAMSTATE_))
           (CL:SETQ TOK_CURSOR_
            (MOD (%TOKENIZER-STREAM-STATE.CURSOR TOK_STREAMSTATE_)
             TOK_SIZE_))
           (CL:SETQ TOK_END_
            (%TOKENIZER-STREAM-STATE.END TOK_STREAMSTATE_))
           (CL:WHEN TOK_ENDOFTOKENS?_
            (CL:SETQ TOK_CHECKPOINT_ TOK_CURSOR_)
            (CL:COND ((CL:= TOK_NEXTSTATE_ -1))
             ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
               (CL:AREF
                (CL:THE CL:SIMPLE-VECTOR
                 (%VECTOR.THE-ARRAY
                  (%TOKENIZER-TABLE.LEGAL-EOF-STATES TOK_TABLE_)))
                TOK_STATE_))
              (CL:SETQ TOK_NEXTSTATE_ -1)
              (CL:WHEN (CL:NOT (CL:= TOK_TOKENSTART_ -1))
               (CL:SETQ TOK_ENDOFTOKENS?_ CL:NIL)))
             (CL:T (CL:SETQ TOK_ENDOFTOKENS?_ CL:NIL)
              (CL:SETQ TOK_STATE_ 0) (CL:SETQ TOK_NEXTSTATE_ -1)))
            (CL:RETURN))
           (CL:IF (CL:>= TOK_CURSOR_ TOK_END_)
            (CL:SETQ TOK_CHECKPOINT_ TOK_SIZE_)
            (CL:SETQ TOK_CHECKPOINT_ TOK_END_)))
          (CL:T (CL:SETQ TOK_CHECKPOINT_ TOK_END_)
           (CL:SETQ TOK_CURSOR_ 0))))
        (CL:SETQ TOK_NEXTSTATE_
         (CL:THE CL:FIXNUM
          (CL:CHAR-CODE
           (CL:LET ((BUFFER TOK_BUFFER_) (POSITION TOK_CURSOR_))
            (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
            (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
             (CL:THE CL:FIXNUM POSITION))))))
        (CL:WHEN (CL:> TOK_NEXTSTATE_ 255)
         (CL:SETQ TOK_NEXTSTATE_ 255))
        (CL:SETQ TOK_NEXTSTATE_
         (CL:THE CL:FIXNUM
          (CL:CHAR-CODE
           (CL:LET
            ((SELF TOK_TRANSITIONS_)
             (POSITION
              (CL:THE CL:FIXNUM
               (CL:LOGIOR (CL:THE CL:FIXNUM (CL:ASH TOK_STATE_ 8))
                TOK_NEXTSTATE_))))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
             (CL:THE CL:FIXNUM POSITION))))))
        (CL:COND
         ((CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 128)) 0)
          (CL:SETQ TOK_STATE_ TOK_NEXTSTATE_)
          (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
         ((CL:= TOK_TOKENSTART_ -1)
          (CL:WHEN
           (CL:= (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 64)) 0)
           (CL:SETQ TOK_TOKENSTART_ TOK_CURSOR_))
          (CL:SETQ TOK_STATE_
           (CL:THE CL:FIXNUM (CL:LOGAND TOK_NEXTSTATE_ 63)))
          (CL:SETQ TOK_CURSOR_ (CL:1+ TOK_CURSOR_)))
         (CL:T (CL:RETURN)))
        (CL:WHEN (CL:NOT (CL:EQ TOK_ECHOSTREAM_ NULL))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM TOK_ECHOSTREAM_)
          (CL:LET ((BUFFER TOK_BUFFER_) (POSITION (CL:1- TOK_CURSOR_)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
           (CL:SCHAR (CL:THE CL:SIMPLE-STRING BUFFER)
            (CL:THE CL:FIXNUM POSITION)))))))
      (CL:WHEN TOK_ENDOFTOKENS?_ (CL:SETQ ENDOFFILE? CL:T)
       (CL:WHEN (CL:= PARENBALANCE 0) (CL:RETURN))
       (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
        (CL:SETF (%TOKENIZER-STREAM-STATE.CURSOR TOK_STREAMSTATE_)
         TOK_CURSOR_)
        (CL:SETF (%TOKENIZER-STREAM-STATE.TABLE TOK_STREAMSTATE_)
         TOK_TABLE_)
        (CL:SETF (%TOKENIZER-STREAM-STATE.STATE TOK_STREAMSTATE_)
         TOK_STATE_))
       (CL:ERROR
        (NEW-READ-EXCEPTION "XML Expression ended prematurely")))
      (CL:SETQ ENDOFFILE? CL:NIL)
      (CL:SETQ TOKENTYPE (CL:AREF TOK_STATENAMES_ TOK_STATE_))
      (CL:COND (REGIONTAGFOUND?)
       ((CL:AND (CL:EQ TOKENTYPE KWD-XML-START-TAG)
         (STRING-EQL?
          (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
           TOK_CURSOR_ TOK_SIZE_ CL:NIL)
          REGIONTAGNAME))
        (CL:SETQ REGIONTAGFOUND? CL:T))
       (CL:T (CL:GO :CONTINUE)))
      (CL:COND
       ((CL:OR (CL:EQ TOKENTYPE KWD-XML-START-TAG)
         (CL:EQ TOKENTYPE KWD-XML-START-PI-TAG)
         (CL:EQ TOKENTYPE KWD-XML-START-DECLARATION-TAG)
         (CL:EQ TOKENTYPE KWD-XML-START-SPECIAL-TAG))
        (CL:SETQ TOKENCONTENT
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
          TOK_CURSOR_ TOK_SIZE_ CL:NIL))
        (CL:SETQ CURRENTTAG TOKENCONTENT)
        (CL:WHEN (CL:EQ STARTTAG STELLA::NULL-STRING)
         (CL:SETQ STARTTAG TOKENCONTENT))
        (CL:WHEN (STRING-EQL? TOKENCONTENT STARTTAG)
         (CL:SETQ PARENBALANCE (CL:1+ PARENBALANCE))))
       ((CL:EQ TOKENTYPE KWD-XML-START-TAG-END)
        (CL:SETQ TOKENCONTENT ">")
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ REGIONTAGNAME STELLA::NULL-STRING))
          SKIPTOREGION?)
         (CL:SETQ PARENBALANCE (CL:1- PARENBALANCE)))
        (CL:SETQ CURRENTTAG STELLA::NULL-STRING))
       ((CL:OR (CL:EQ TOKENTYPE KWD-XML-END-TAG)
         (CL:EQ TOKENTYPE KWD-XML-EMPTY-TAG-END)
         (CL:EQ TOKENTYPE KWD-XML-DATA-TAG-END))
        (CL:COND
         ((CL:EQ TOKENTYPE KWD-XML-END-TAG)
          (CL:SETQ TOKENCONTENT
           (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
            TOK_CURSOR_ TOK_SIZE_ CL:NIL))
          (CL:SETQ CURRENTTAG TOKENCONTENT))
         (CL:T (CL:SETQ TOKENCONTENT ">")))
        (CL:WHEN
         (CL:OR (STRING-EQL? CURRENTTAG STARTTAG)
          (CL:AND (CL:NOT (CL:EQ REGIONTAGNAME STELLA::NULL-STRING))
           (CL:NOT SKIPTOREGION?)
           (STRING-EQL? CURRENTTAG REGIONTAGNAME)))
         (CL:SETQ PARENBALANCE (CL:1- PARENBALANCE)))
        (CL:SETQ CURRENTTAG STELLA::NULL-STRING))
       ((CL:EQ TOKENTYPE KWD-XML-ATTRIBUTE-NAME)
        (CL:SETQ TOKENCONTENT
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
          TOK_CURSOR_ TOK_SIZE_ CL:NIL)))
       ((CL:OR (CL:EQ TOKENTYPE KWD-XML-QUOTED-ATTRIBUTE-VALUE)
         (CL:EQ TOKENTYPE KWD-XML-QUOTED-DECLARATION-TAG-DATA))
        (CL:SETQ TOKENCONTENT
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ (CL:1+ TOK_TOKENSTART_)
          (CL:+ TOK_CURSOR_ -1) TOK_SIZE_ CL:NIL))
        (CL:SETQ TOKENTYPE KWD-XML-ATTRIBUTE-VALUE))
       ((CL:EQ TOKENTYPE KWD-XML-UNQUOTED-ATTRIBUTE-VALUE)
        (CL:SETQ TOKENCONTENT
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
          TOK_CURSOR_ TOK_SIZE_ CL:NIL))
        (CL:SETQ TOKENTYPE KWD-XML-ATTRIBUTE-VALUE))
       ((CL:EQ TOKENTYPE KWD-XML-PI-TAG-DATA)
        (CL:SETQ TOKENCONTENT
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
          (CL:+ TOK_CURSOR_ -1) TOK_SIZE_ CL:NIL)))
       ((CL:OR (CL:EQ TOKENTYPE KWD-XML-DECLARATION-TAG-DATA)
         (CL:EQ TOKENTYPE KWD-XML-DECLARATION-TAG-MARKUP-DATA))
        (CL:SETQ TOKENCONTENT
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
          TOK_CURSOR_ TOK_SIZE_ CL:NIL)))
       ((CL:EQ TOKENTYPE KWD-XML-SPECIAL-TAG-DATA)
        (CL:SETQ TOKENCONTENT
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ (CL:1+ TOK_TOKENSTART_)
          (CL:+ TOK_CURSOR_ -2) TOK_SIZE_ CL:NIL)))
       ((CL:EQ TOKENTYPE KWD-XML-CONTENT)
        (CL:SETQ TOKENCONTENT
         (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
          TOK_CURSOR_ TOK_SIZE_ CL:NIL))
        (CL:WHEN (CL:NOT *XML-PRESERVE-ALL-WHITESPACE?*)
         (CL:LET*
          ((CURSOR (CL:THE CL:FIXNUM (CL:LENGTH TOKENCONTENT))))
          (CL:DECLARE (CL:TYPE CL:FIXNUM CURSOR))
          (CL:LET* ((I NULL-INTEGER) (ITER-000 0))
           (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000))
           (CL:LOOP WHILE CL:T DO (CL:SETQ I ITER-000)
            (CL:WHEN
             (CL:NOT
              (CL:EQ
               (CL:AREF *CHARACTER-TYPE-TABLE*
                (CL:THE CL:FIXNUM
                 (CL:CHAR-CODE
                  (CL:LET
                   ((SELF TOKENCONTENT)
                    (POSITION (CL:SETQ CURSOR (CL:1- CURSOR))))
                   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
                    (CL:TYPE CL:FIXNUM POSITION))
                   (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                    (CL:THE CL:FIXNUM POSITION))))))
               KWD-XML-WHITE-SPACE))
             (CL:WHEN (CL:> I 0) (CL:SETQ I (CL:- 0 I))
              (CL:SETQ TOKENCONTENT
               (GET-TOKEN-TEXT-INTERNAL TOK_BUFFER_ TOK_TOKENSTART_
                (CL:IF (CL:< I 0) (CL:+ TOK_CURSOR_ I)
                 (CL:+ TOK_TOKENSTART_ I))
                TOK_SIZE_ CL:NIL)))
             (CL:RETURN))
            (CL:SETQ ITER-000 (CL:1+ ITER-000)))))))
       ((CL:EQ TOKENTYPE KWD-XML-ERROR)
        (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
         (CL:SETF (%TOKENIZER-STREAM-STATE.CURSOR TOK_STREAMSTATE_)
          TOK_CURSOR_)
         (CL:SETF (%TOKENIZER-STREAM-STATE.TABLE TOK_STREAMSTATE_)
          TOK_TABLE_)
         (CL:SETF (%TOKENIZER-STREAM-STATE.STATE TOK_STREAMSTATE_)
          TOK_STATE_))
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
          "Illegal XML syntax: `" TOKENCONTENT "'")
         (CL:ERROR
          (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-000)))))
       (CL:T
        (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
         (CL:SETF (%TOKENIZER-STREAM-STATE.CURSOR TOK_STREAMSTATE_)
          TOK_CURSOR_)
         (CL:SETF (%TOKENIZER-STREAM-STATE.TABLE TOK_STREAMSTATE_)
          TOK_TABLE_)
         (CL:SETF (%TOKENIZER-STREAM-STATE.STATE TOK_STREAMSTATE_)
          TOK_STATE_))
        (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
          "Illegal XML syntax: `" TOKENCONTENT "' in state `" TOKENTYPE
          "'")
         (CL:ERROR
          (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-001))))))
      (CL:SETF (%TOKENIZER-TOKEN.TYPE TOKENCURSOR) TOKENTYPE)
      (CL:SETF (%TOKENIZER-TOKEN.CONTENT TOKENCURSOR) TOKENCONTENT)
      (CL:WHEN (CL:EQ (%TOKENIZER-TOKEN.NEXT TOKENCURSOR) NULL)
       (CL:SETF (%TOKENIZER-TOKEN.NEXT TOKENCURSOR)
        (NEW-TOKENIZER-TOKEN)))
      (CL:SETQ TOKENCURSOR (%TOKENIZER-TOKEN.NEXT TOKENCURSOR))
      (CL:WHEN (CL:= PARENBALANCE 0) (CL:RETURN))
      (CL:WHEN (CL:< PARENBALANCE 0)
       (CL:COND
        ((CL:AND (CL:NOT (CL:EQ REGIONTAGNAME STELLA::NULL-STRING))
          (CL:NOT SKIPTOREGION?)
          (STRING-EQL? (%TOKENIZER-TOKEN.CONTENT TOKENLIST)
           REGIONTAGNAME)
          (CL:EQ (%TOKENIZER-TOKEN.NEXT TOKENLIST) TOKENCURSOR))
         (CL:SETQ TOKENLIST NULL) (CL:RETURN))
        (CL:T
         (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
          (CL:SETF (%TOKENIZER-STREAM-STATE.CURSOR TOK_STREAMSTATE_)
           TOK_CURSOR_)
          (CL:SETF (%TOKENIZER-STREAM-STATE.TABLE TOK_STREAMSTATE_)
           TOK_TABLE_)
          (CL:SETF (%TOKENIZER-STREAM-STATE.STATE TOK_STREAMSTATE_)
           TOK_STATE_))
         (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
           "Unmatched end tag encountered: `" TOKENCONTENT "'")
          (CL:ERROR
           (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-002)))))))
      :CONTINUE))
    (CL:SETF (%TOKENIZER-TOKEN.TYPE TOKENCURSOR) NULL)
    (CL:WHEN (CL:NOT (CL:EQ TOK_STREAMSTATE_ NULL))
     (CL:SETF (%TOKENIZER-STREAM-STATE.CURSOR TOK_STREAMSTATE_)
      TOK_CURSOR_)
     (CL:SETF (%TOKENIZER-STREAM-STATE.TABLE TOK_STREAMSTATE_)
      TOK_TABLE_)
     (CL:SETF (%TOKENIZER-STREAM-STATE.STATE TOK_STREAMSTATE_)
      TOK_STATE_))
    (CL:IF ENDOFFILE?
     (CL:RETURN-FROM TOKENIZE-XML-EXPRESSION (CL:VALUES NULL CL:T))
     (CL:RETURN-FROM TOKENIZE-XML-EXPRESSION
      (CL:VALUES TOKENLIST CL:NIL))))))

;;; (DEFUN (PROCESS-ATTRIBUTE-LIST CONS) ...)

(CL:DEFUN PROCESS-ATTRIBUTE-LIST (REVERSEATTRIBUTELIST ELEMENT NAMESPACE-TABLE)
  (CL:WHEN (CL:EQ REVERSEATTRIBUTELIST NIL)
   (CL:RETURN-FROM PROCESS-ATTRIBUTE-LIST NIL))
  (CL:LET*
   ((ATTRIBUTELIST NIL) (CONSCELL NULL)
    (ATTRIBUTENAME STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING ATTRIBUTENAME))
   (CL:LOOP WHILE (CL:NOT (CL:EQ REVERSEATTRIBUTELIST NIL)) DO
    (CL:SETQ CONSCELL (CL:CONS CL:NIL CL:NIL))
    (CL:SETF (%%VALUE CONSCELL) (%%VALUE REVERSEATTRIBUTELIST))
    (CL:SETQ REVERSEATTRIBUTELIST (%%REST REVERSEATTRIBUTELIST))
    (CL:SETF (%%REST CONSCELL) ATTRIBUTELIST)
    (CL:SETQ ATTRIBUTELIST CONSCELL)
    (CL:WHEN (CL:EQ REVERSEATTRIBUTELIST NIL)
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "Malformed attribute list in XML element `" ELEMENT "'")
      (CL:ERROR
       (NEW-BAD-ARGUMENT-EXCEPTION (THE-STRING-READER STREAM-000)))))
    (CL:SETQ ATTRIBUTENAME
     (%TOKENIZER-TOKEN.CONTENT (%%VALUE REVERSEATTRIBUTELIST)))
    (CL:SETQ REVERSEATTRIBUTELIST (%%REST REVERSEATTRIBUTELIST))
    (CL:SETQ CONSCELL (CL:CONS CL:NIL CL:NIL))
    (CL:IF (XMLNS-ATTRIBUTE-NAME? ATTRIBUTENAME)
     (CL:SETF (%%VALUE CONSCELL) (MAKE-XMLNS-ATTRIBUTE ATTRIBUTENAME))
     (CL:SETF (%%VALUE CONSCELL)
      (MAKE-XML-ATTRIBUTE-RESPECTING-NAMESPACE ATTRIBUTENAME ELEMENT
       NAMESPACE-TABLE)))
    (CL:SETF (%%REST CONSCELL) ATTRIBUTELIST)
    (CL:SETQ ATTRIBUTELIST CONSCELL))
   (CL:RETURN-FROM PROCESS-ATTRIBUTE-LIST ATTRIBUTELIST)))

;;; (DEFUN (XML-TOKEN-LIST-TO-S-EXPRESSION OBJECT) ...)

(CL:DEFUN XML-TOKEN-LIST-TO-S-EXPRESSION (TOKENLIST DOCTYPE DOCTYPE-DEFINITION?)
  "Convert the XML `tokenList' (using `doctype' for guidance) into a
representative s-expression and return the result.    The `doctype' argument is
currently only used for expansion of entity references.  It can be 'null'.  The
flag `doctype-definition?' should be true only when processing the DTD definition
of a DOCTYPE tag, since it enables substitution of parameter entity values.

Every XML tag is represented as a cons-list starting with the tag as its header,
followed by a possibly empty list of keyword value pairs representing tag attributes,
followed by a possibly empty list of content expressions which might themselves
be XML expressions.  For example, the expression

    <a a1=v1 a2='v2'> foo <b a3=v3/> bar </a>

becomes

   (<a> (<a1> \"v1\" <a2> \"v2\") \"foo\" (<b> (<a3> \"v3\")) \"bar\")

when represented as an s-expression.  The tag names are subtypes of XML-OBJECT
such as XML-ELEMENT, XML-LOCAL-ATTRIBUTE, XML-GLOBAL-ATTRIBUTE, etc.
?, ! and [ prefixed tags are encoded as their own subtypes of XML-OBJECT, namely
XML-PROCESSING-INSTRUCTION, XML-DECLARATION, XML-SPECIAL, XML-COMMENT, etc.
CDATA is an XML-SPECIAL tag with a name of CDATA.

The name is available using class accessors."
  (CL:LET*
   ((PARSEDTREE NULL) (PARSEDTREESTACK NIL) (PARSEDTOKEN NULL)
    (TAGNAME STELLA::NULL-STRING) (ELEMENT NULL)
    (XMLNS-NAME STELLA::NULL-STRING) (COLON-POSITION 0)
    (ATTRIBUTELIST NIL) (CONSCELL NULL) (TOKENTYPE NULL)
    (NAMESPACE-TABLE (MAKE-NAMESPACE-TABLE)) (NS-STACK NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TAGNAME XMLNS-NAME)
    (CL:TYPE CL:FIXNUM COLON-POSITION))
   (CL:LOOP
    (CL:TAGBODY (CL:SETQ TOKENTYPE (%TOKENIZER-TOKEN.TYPE TOKENLIST))
     (CL:COND
      ((CL:EQ TOKENTYPE KWD-XML-START-TAG)
       (CL:WHEN (CL:NOT (CL:EQ PARSEDTREE NULL))
        (CL:SETQ PARSEDTREESTACK (CONS PARSEDTREE PARSEDTREESTACK)))
       (CL:SETQ NS-STACK (CONS NAMESPACE-TABLE NS-STACK))
       (CL:SETQ PARSEDTREE NIL)
       (CL:SETQ TAGNAME (%TOKENIZER-TOKEN.CONTENT TOKENLIST))
       (CL:SETQ TOKENLIST (%TOKENIZER-TOKEN.NEXT TOKENLIST))
       (CL:GO :CONTINUE))
      ((CL:OR (CL:EQ TOKENTYPE KWD-XML-START-PI-TAG)
        (CL:EQ TOKENTYPE KWD-XML-START-DECLARATION-TAG)
        (CL:EQ TOKENTYPE KWD-XML-START-SPECIAL-TAG))
       (CL:WHEN (CL:NOT (CL:EQ PARSEDTREE NULL))
        (CL:SETQ PARSEDTREESTACK (CONS PARSEDTREE PARSEDTREESTACK)))
       (CL:SETQ PARSEDTREE NIL) (CL:SETQ TAGNAME STELLA::NULL-STRING)
       (CL:COND
        ((CL:EQ TOKENTYPE KWD-XML-START-PI-TAG)
         (CL:LET* ((SELF-000 (NEW-XML-PROCESSING-INSTRUCTION)))
          (CL:SETF (%XML-PROCESSING-INSTRUCTION.NAME SELF-000)
           (%TOKENIZER-TOKEN.CONTENT TOKENLIST))
          (CL:SETF (%XML-PROCESSING-INSTRUCTION.SURFACE-FORM SELF-000)
           (%TOKENIZER-TOKEN.CONTENT TOKENLIST))
          (CL:SETQ PARSEDTOKEN SELF-000)))
        ((CL:EQ TOKENTYPE KWD-XML-START-DECLARATION-TAG)
         (CL:LET* ((SELF-001 (NEW-XML-DECLARATION)))
          (CL:SETF (%XML-DECLARATION.NAME SELF-001)
           (%TOKENIZER-TOKEN.CONTENT TOKENLIST))
          (CL:SETF (%XML-DECLARATION.SURFACE-FORM SELF-001)
           (%TOKENIZER-TOKEN.CONTENT TOKENLIST))
          (CL:SETQ PARSEDTOKEN SELF-001)))
        ((CL:EQ TOKENTYPE KWD-XML-START-SPECIAL-TAG)
         (CL:LET* ((SELF-002 (NEW-XML-SPECIAL)))
          (CL:SETF (%XML-SPECIAL.NAME SELF-002)
           (%TOKENIZER-TOKEN.CONTENT TOKENLIST))
          (CL:SETF (%XML-SPECIAL.SURFACE-FORM SELF-002)
           (%TOKENIZER-TOKEN.CONTENT TOKENLIST))
          (CL:SETQ PARSEDTOKEN SELF-002)))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
           TOKENTYPE "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
      ((CL:EQ TOKENTYPE KWD-XML-START-TAG-END)
       (CL:IF (CL:NOT (CL:EQ TAGNAME STELLA::NULL-STRING))
        (CL:PROGN
         (CL:SETQ ELEMENT
          (MAKE-XML-ELEMENT-RESPECTING-NAMESPACE TAGNAME
           NAMESPACE-TABLE))
         (CL:SETQ CONSCELL (CL:CONS CL:NIL CL:NIL))
         (CL:SETF (%%VALUE CONSCELL) ELEMENT)
         (CL:SETF (%%REST CONSCELL) PARSEDTREE)
         (CL:SETQ PARSEDTREE CONSCELL)
         (CL:SETQ PARSEDTOKEN
          (PROCESS-ATTRIBUTE-LIST ATTRIBUTELIST ELEMENT
           NAMESPACE-TABLE)))
        (CL:SETQ PARSEDTOKEN
         (CL:IF (CL:EQ ATTRIBUTELIST NIL) NIL
          (REVERSE ATTRIBUTELIST))))
       (CL:SETQ ATTRIBUTELIST NIL))
      ((CL:OR (CL:EQ TOKENTYPE KWD-XML-EMPTY-TAG-END)
        (CL:EQ TOKENTYPE KWD-XML-DATA-TAG-END))
       (CL:IF (CL:NOT (CL:EQ TAGNAME STELLA::NULL-STRING))
        (CL:PROGN
         (CL:SETQ ELEMENT
          (MAKE-XML-ELEMENT-RESPECTING-NAMESPACE TAGNAME
           NAMESPACE-TABLE))
         (CL:SETQ CONSCELL (CL:CONS CL:NIL CL:NIL))
         (CL:SETF (%%VALUE CONSCELL) ELEMENT)
         (CL:SETF (%%REST CONSCELL) PARSEDTREE)
         (CL:SETQ PARSEDTREE CONSCELL)
         (CL:SETQ PARSEDTOKEN
          (PROCESS-ATTRIBUTE-LIST ATTRIBUTELIST ELEMENT
           NAMESPACE-TABLE)))
        (CL:SETQ PARSEDTOKEN
         (CL:IF (CL:EQ ATTRIBUTELIST NIL) NIL
          (REVERSE ATTRIBUTELIST))))
       (CL:SETQ CONSCELL (CL:CONS CL:NIL CL:NIL))
       (CL:SETF (%%VALUE CONSCELL) PARSEDTOKEN)
       (CL:SETF (%%REST CONSCELL) PARSEDTREE)
       (CL:SETQ PARSEDTREE CONSCELL) (CL:SETQ ATTRIBUTELIST NIL)
       (CL:SETQ TAGNAME STELLA::NULL-STRING)
       (CL:COND
        ((CL:EQ PARSEDTREESTACK NIL)
         (CL:SETQ PARSEDTREE (REVERSE PARSEDTREE)) (CL:RETURN))
        (CL:T
         (CL:WHEN (CL:EQ TOKENTYPE KWD-XML-EMPTY-TAG-END)
          (CL:SETQ NAMESPACE-TABLE (%%VALUE NS-STACK))
          (CL:SETQ NS-STACK (%%REST NS-STACK)))
         (CL:LET* ((PARENTTREE PARSEDTREESTACK))
          (CL:SETQ PARSEDTREESTACK (%%REST PARSEDTREESTACK))
          (CL:SETF (%%REST PARENTTREE) (%%VALUE PARENTTREE))
          (FIRST-SETTER PARENTTREE (REVERSE PARSEDTREE))
          (CL:SETQ PARSEDTREE PARENTTREE)
          (CL:SETQ TOKENLIST (%TOKENIZER-TOKEN.NEXT TOKENLIST))
          (CL:GO :CONTINUE)))))
      ((CL:EQ TOKENTYPE KWD-XML-END-TAG)
       (CL:COND
        ((CL:EQ PARSEDTREESTACK NIL)
         (CL:SETQ PARSEDTREE (REVERSE PARSEDTREE)) (CL:RETURN))
        (CL:T (CL:SETQ NAMESPACE-TABLE (%%VALUE NS-STACK))
         (CL:SETQ NS-STACK (%%REST NS-STACK))
         (CL:LET* ((PARENTTREE PARSEDTREESTACK))
          (CL:SETQ PARSEDTREESTACK (%%REST PARSEDTREESTACK))
          (CL:SETF (%%REST PARENTTREE) (%%VALUE PARENTTREE))
          (FIRST-SETTER PARENTTREE (REVERSE PARSEDTREE))
          (CL:SETQ PARSEDTREE PARENTTREE)
          (CL:SETQ TOKENLIST (%TOKENIZER-TOKEN.NEXT TOKENLIST))
          (CL:GO :CONTINUE)))))
      ((CL:EQ TOKENTYPE KWD-XML-CONTENT)
       (CL:SETQ PARSEDTOKEN (%MAKE-STRING-WRAPPER))
       (CL:SETF (%STRING-WRAPPER.WRAPPER-VALUE PARSEDTOKEN)
        (DECODE-XML-STRING DOCTYPE (%TOKENIZER-TOKEN.CONTENT TOKENLIST)
         DOCTYPE-DEFINITION?)))
      ((CL:EQ TOKENTYPE KWD-XML-ATTRIBUTE-NAME)
       (CL:SETQ CONSCELL (CL:CONS CL:NIL CL:NIL))
       (CL:SETF (%%VALUE CONSCELL) TOKENLIST)
       (CL:SETF (%%REST CONSCELL) ATTRIBUTELIST)
       (CL:SETQ ATTRIBUTELIST CONSCELL)
       (CL:WHEN
        (XMLNS-ATTRIBUTE-NAME? (%TOKENIZER-TOKEN.CONTENT TOKENLIST))
        (CL:SETQ XMLNS-NAME
         (DECODE-XML-STRING DOCTYPE
          (%TOKENIZER-TOKEN.CONTENT TOKENLIST) DOCTYPE-DEFINITION?))
        (CL:SETQ TOKENLIST (%TOKENIZER-TOKEN.NEXT TOKENLIST))
        (CL:WHEN
         (CL:NOT
          (CL:EQ (%TOKENIZER-TOKEN.TYPE TOKENLIST)
           KWD-XML-ATTRIBUTE-VALUE))
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
           "Illegal XMLNS syntax, namespace value is `"
           (%TOKENIZER-TOKEN.CONTENT TOKENLIST) "' of type `"
           (%TOKENIZER-TOKEN.TYPE TOKENLIST) "'")
          (CL:ERROR
           (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-001)))))
        (CL:SETQ COLON-POSITION (POSITION XMLNS-NAME #\: 0))
        (CL:LET*
         ((NAMESPACE-VALUE
           (NORMALIZE-ATTRIBUTE-VALUE DOCTYPE
            (%TOKENIZER-TOKEN.CONTENT TOKENLIST) DOCTYPE-DEFINITION?)))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAMESPACE-VALUE))
         (CL:COND
          ((CL:NOT (CL:= COLON-POSITION NULL-INTEGER))
           (CL:SETQ NAMESPACE-TABLE
            (KV-CONS
             (WRAP-STRING
              (SUBSEQUENCE XMLNS-NAME (CL:1+ COLON-POSITION)
               NULL-INTEGER))
             (WRAP-STRING NAMESPACE-VALUE) NAMESPACE-TABLE)))
          ((STRING-EQL? NAMESPACE-VALUE "")
           (CL:SETQ NAMESPACE-TABLE
            (KV-CONS (WRAP-STRING "") NULL NAMESPACE-TABLE)))
          (CL:T
           (CL:SETQ NAMESPACE-TABLE
            (KV-CONS (WRAP-STRING "") (WRAP-STRING NAMESPACE-VALUE)
             NAMESPACE-TABLE))))
         (CL:SETQ PARSEDTOKEN (%MAKE-STRING-WRAPPER))
         (CL:SETF (%STRING-WRAPPER.WRAPPER-VALUE PARSEDTOKEN)
          NAMESPACE-VALUE)
         (CL:SETQ CONSCELL (CL:CONS CL:NIL CL:NIL))
         (CL:SETF (%%VALUE CONSCELL) PARSEDTOKEN)
         (CL:SETF (%%REST CONSCELL) ATTRIBUTELIST)
         (CL:SETQ ATTRIBUTELIST CONSCELL)))
       (CL:SETQ TOKENLIST (%TOKENIZER-TOKEN.NEXT TOKENLIST))
       (CL:GO :CONTINUE))
      ((CL:OR (CL:EQ TOKENTYPE KWD-XML-ATTRIBUTE-VALUE)
        (CL:EQ TOKENTYPE KWD-XML-DECLARATION-TAG-DATA))
       (CL:SETQ PARSEDTOKEN (%MAKE-STRING-WRAPPER))
       (CL:SETF (%STRING-WRAPPER.WRAPPER-VALUE PARSEDTOKEN)
        (NORMALIZE-ATTRIBUTE-VALUE DOCTYPE
         (%TOKENIZER-TOKEN.CONTENT TOKENLIST) DOCTYPE-DEFINITION?))
       (CL:SETQ CONSCELL (CL:CONS CL:NIL CL:NIL))
       (CL:SETF (%%VALUE CONSCELL) PARSEDTOKEN)
       (CL:SETF (%%REST CONSCELL) ATTRIBUTELIST)
       (CL:SETQ ATTRIBUTELIST CONSCELL)
       (CL:SETQ TOKENLIST (%TOKENIZER-TOKEN.NEXT TOKENLIST))
       (CL:GO :CONTINUE))
      ((CL:OR (CL:EQ TOKENTYPE KWD-XML-PI-TAG-DATA)
        (CL:EQ TOKENTYPE KWD-XML-SPECIAL-TAG-DATA)
        (CL:EQ TOKENTYPE KWD-XML-DECLARATION-TAG-MARKUP-DATA))
       (CL:SETQ PARSEDTOKEN (%MAKE-STRING-WRAPPER))
       (CL:SETF (%STRING-WRAPPER.WRAPPER-VALUE PARSEDTOKEN)
        (%TOKENIZER-TOKEN.CONTENT TOKENLIST))
       (CL:SETQ CONSCELL (CL:CONS CL:NIL CL:NIL))
       (CL:SETF (%%VALUE CONSCELL) PARSEDTOKEN)
       (CL:SETF (%%REST CONSCELL) ATTRIBUTELIST)
       (CL:SETQ ATTRIBUTELIST CONSCELL)
       (CL:SETQ TOKENLIST (%TOKENIZER-TOKEN.NEXT TOKENLIST))
       (CL:GO :CONTINUE))
      (CL:T
       (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
         "Illegal XML syntax: `" (%TOKENIZER-TOKEN.CONTENT TOKENLIST)
         "' of type `" TOKENTYPE "'")
        (CL:ERROR
         (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-002))))))
     (CL:COND
      ((CL:NOT (CL:EQ PARSEDTREE NULL))
       (CL:SETQ CONSCELL (CL:CONS CL:NIL CL:NIL))
       (CL:SETF (%%VALUE CONSCELL) PARSEDTOKEN)
       (CL:SETF (%%REST CONSCELL) PARSEDTREE)
       (CL:SETQ PARSEDTREE CONSCELL)
       (CL:SETQ TOKENLIST (%TOKENIZER-TOKEN.NEXT TOKENLIST)))
      (CL:T (CL:RETURN)))
     :CONTINUE))
   (CL:IF (CL:EQ PARSEDTREE NULL)
    (CL:RETURN-FROM XML-TOKEN-LIST-TO-S-EXPRESSION PARSEDTOKEN)
    (CL:RETURN-FROM XML-TOKEN-LIST-TO-S-EXPRESSION PARSEDTREE))))

;;; (DEFUN (READ-XML-EXPRESSION OBJECT BOOLEAN) ...)

(CL:DEFUN READ-XML-EXPRESSION (STREAM START-TAG)
  "Read one balanced XML expression from `stream' and return
its s-expression representation (see `xml-token-list-to-s-expression').  If
`startTagName' is non-`null', skip all tags until a start tag matching `start-tag'
is encountered.  XML namespaces are ignored for outside of the start tag.
Use s-expression representation to specify `start-tag', e.g., '(KIF (:version \"1.0\"))'.
The tag can be an XML element object, a symbol, a string or a cons.  If the tag is a cons
the first element can also be (name namespace) pair.

Return `true' as the second value on EOF.

CHANGE WARNING:  It is anticipated that this function will change to
 a) Properly take XML namespaces into account and
 b) require XML element objects instead of strings as the second argument.
This change will not be backwards-compatible."
  (CL:LET*
   ((ITER (XML-EXPRESSIONS STREAM START-TAG)) (RESULT NULL)
    (EOF? CL:NIL))
   (CL:IF (NEXT? ITER)
    (CL:SETQ RESULT (%XML-EXPRESSION-ITERATOR.VALUE ITER))
    (CL:SETQ EOF? CL:T))
   (CL:WHEN
    (CL:OR (CL:EQ STREAM STANDARD-INPUT)
     (CL:NOT (CL:EQ (%INPUT-STREAM.ECHO-STREAM STREAM) NULL)))
    (EAT-NEXT-CHARACTER-IF-WHITESPACE STREAM))
   (CL:RETURN-FROM READ-XML-EXPRESSION (CL:VALUES RESULT EOF?))))

;;; (DEFUN (READ-XML-EXPRESSIONS CONS) ...)

(CL:DEFUN READ-XML-EXPRESSIONS (FILENAME)
  "Read all of the top-level XML expressions from `filename' and
return them in a list."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  (CL:LET* ((IN NULL))
   (CL:UNWIND-PROTECT
    (CL:PROGN (CL:SETQ IN (OPEN-INPUT-FILE FILENAME))
     (CL:LET* ((VALUE-000 NIL))
      (CL:LET*
       ((ITEM NULL) (ITER-000 (XML-EXPRESSIONS IN NULL))
        (COLLECT-000 NULL))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ ITEM (%XML-EXPRESSION-ITERATOR.VALUE ITER-000))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS ITEM NIL))
          (CL:IF (CL:EQ VALUE-000 NIL) (CL:SETQ VALUE-000 COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ITEM NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
      (CL:LET* ((VALUE-001 VALUE-000))
       (CL:RETURN-FROM READ-XML-EXPRESSIONS VALUE-001))))
    (CL:WHEN (CL:NOT (CL:EQ IN NULL)) (FREE IN)))))

(CL:DEFUN NEW-XML-EXPRESSION-ITERATOR ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-XML-EXPRESSION-ITERATOR))
   (CL:SETF (%XML-EXPRESSION-ITERATOR.FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%XML-EXPRESSION-ITERATOR.VALUE SELF) NULL)
   (CL:SETF (%XML-EXPRESSION-ITERATOR.THE-STREAM SELF) NULL)
   (CL:SETF (%XML-EXPRESSION-ITERATOR.DOCTYPE-ITERATOR? SELF) CL:NIL)
   (CL:SETF (%XML-EXPRESSION-ITERATOR.DOCTYPE SELF) NULL)
   (CL:SETF (%XML-EXPRESSION-ITERATOR.REGION-MATCH-FUNCTION SELF)
    (CL:FUNCTION XML-REGION-MATCHES?))
   (CL:SETF (%XML-EXPRESSION-ITERATOR.REGION-TAG SELF) NULL)
   (CL:RETURN-FROM NEW-XML-EXPRESSION-ITERATOR SELF)))

(CL:DEFMETHOD FREE ((SELF XML-EXPRESSION-ITERATOR))
  (CL:WHEN (TERMINATE-STREAM-ITERATOR? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF XML-EXPRESSION-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-XML-STELLA-XML-EXPRESSION-ITERATOR))

(CL:DEFUN ACCESS-XML-EXPRESSION-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-XML-STELLA-REGION-TAG)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-EXPRESSION-ITERATOR.REGION-TAG SELF) VALUE)
     (CL:SETQ VALUE (%XML-EXPRESSION-ITERATOR.REGION-TAG SELF))))
   ((CL:EQ SLOTNAME SYM-XML-STELLA-REGION-MATCH-FUNCTION)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-EXPRESSION-ITERATOR.REGION-MATCH-FUNCTION SELF)
      (%FUNCTION-CODE-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE
       (%XML-EXPRESSION-ITERATOR.REGION-MATCH-FUNCTION SELF)))))
   ((CL:EQ SLOTNAME SYM-XML-STELLA-DOCTYPE)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-EXPRESSION-ITERATOR.DOCTYPE SELF) VALUE)
     (CL:SETQ VALUE (%XML-EXPRESSION-ITERATOR.DOCTYPE SELF))))
   ((CL:EQ SLOTNAME SYM-XML-STELLA-DOCTYPE-ITERATOR?)
    (CL:IF SETVALUE?
     (CL:SETF (%XML-EXPRESSION-ITERATOR.DOCTYPE-ITERATOR? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%XML-EXPRESSION-ITERATOR.DOCTYPE-ITERATOR? SELF)
       TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "`" SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-XML-EXPRESSION-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF XML-EXPRESSION-ITERATOR))
  (CL:LET*
   ((STREAM (%XML-EXPRESSION-ITERATOR.THE-STREAM SELF))
    (FIRSTITERATION? (%XML-EXPRESSION-ITERATOR.FIRST-ITERATION? SELF))
    (TOKENLIST
     (CL:IF FIRSTITERATION? NULL
      (%TOKENIZER-STREAM-STATE.TOKEN-LIST
       (%INPUT-STREAM.TOKENIZER-STATE STREAM))))
    (REGIONTAG (%XML-EXPRESSION-ITERATOR.REGION-TAG SELF))
    (REGIONTAGNAME
     (CL:IF (CL:NOT (CL:EQ REGIONTAG NULL))
      (%XML-ELEMENT.NAME (%%VALUE REGIONTAG)) STELLA::NULL-STRING))
    (SKIPTOREGION? CL:NIL) (EOF? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING REGIONTAGNAME))
   (CL:WHEN FIRSTITERATION?
    (CL:SETF (%XML-EXPRESSION-ITERATOR.FIRST-ITERATION? SELF) CL:NIL)
    (CL:WHEN (CL:NOT (CL:EQ REGIONTAG NULL))
     (CL:SETQ SKIPTOREGION? CL:T)))
   (CL:LOOP
    (CL:TAGBODY
     (CL:MULTIPLE-VALUE-SETQ (TOKENLIST EOF?)
      (TOKENIZE-XML-EXPRESSION STREAM TOKENLIST REGIONTAGNAME
       SKIPTOREGION?))
     (CL:WHEN EOF?
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ REGIONTAG NULL)) (CL:NOT SKIPTOREGION?))
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
         "EOF encountered before the end of the current `"
         REGIONTAGNAME "' region")
        (CL:ERROR
         (NEW-READ-EXCEPTION (THE-STRING-READER STREAM-000)))))
      (CL:SETF (%XML-EXPRESSION-ITERATOR.VALUE SELF) NULL)
      (CLOSE-STREAM STREAM)
      (CL:SETF (%XML-EXPRESSION-ITERATOR.THE-STREAM SELF) NULL)
      (CL:RETURN-FROM NEXT? CL:NIL))
     (CL:WHEN (CL:EQ TOKENLIST NULL) (CL:SETQ SKIPTOREGION? CL:T)
      (CL:SETQ TOKENLIST
       (%TOKENIZER-STREAM-STATE.TOKEN-LIST
        (%INPUT-STREAM.TOKENIZER-STATE STREAM)))
      (CL:GO :CONTINUE))
     (CL:WHEN FIRSTITERATION?
      (CL:SETF
       (%TOKENIZER-STREAM-STATE.TOKEN-LIST
        (%INPUT-STREAM.TOKENIZER-STATE STREAM))
       TOKENLIST)
      (CL:SETQ FIRSTITERATION? CL:NIL))
     (CL:COND
      ((CL:AND SKIPTOREGION? (CL:NOT (CL:EQ REGIONTAG NULL)))
       (CL:LET* ((LASTTOKEN TOKENLIST) (EMPTYTAG? CL:NIL))
        (CL:LOOP WHILE
         (CL:NOT
          (CL:EQ
           (%TOKENIZER-TOKEN.TYPE (%TOKENIZER-TOKEN.NEXT LASTTOKEN))
           NULL))
         DO (CL:SETQ LASTTOKEN (%TOKENIZER-TOKEN.NEXT LASTTOKEN)))
        (CL:IF
         (CL:EQ (%TOKENIZER-TOKEN.TYPE LASTTOKEN)
          KWD-XML-EMPTY-TAG-END)
         (CL:SETQ EMPTYTAG? CL:T)
         (CL:SETF (%TOKENIZER-TOKEN.TYPE LASTTOKEN)
          KWD-XML-EMPTY-TAG-END))
        (CL:WHEN
         (CL:NOT
          (CL:FUNCALL
           (%XML-EXPRESSION-ITERATOR.REGION-MATCH-FUNCTION SELF)
           (%XML-EXPRESSION-ITERATOR.REGION-TAG SELF)
           (XML-TOKEN-LIST-TO-S-EXPRESSION TOKENLIST
            (%XML-EXPRESSION-ITERATOR.DOCTYPE SELF)
            (%XML-EXPRESSION-ITERATOR.DOCTYPE-ITERATOR? SELF))))
         (CL:SETQ SKIPTOREGION? CL:T) (CL:GO :CONTINUE))
        (CL:SETQ SKIPTOREGION? CL:NIL)
        (CL:WHEN EMPTYTAG? (CL:SETQ REGIONTAG NULL)
         (CL:SETQ REGIONTAGNAME STELLA::NULL-STRING)
         (CL:SETF (%XML-EXPRESSION-ITERATOR.REGION-TAG SELF) NULL))
        (CL:GO :CONTINUE)))
      (CL:T
       (CL:LET*
        ((XML-EXPRESSION
          (XML-TOKEN-LIST-TO-S-EXPRESSION TOKENLIST
           (%XML-EXPRESSION-ITERATOR.DOCTYPE SELF)
           (%XML-EXPRESSION-ITERATOR.DOCTYPE-ITERATOR? SELF))))
        (CL:SETF (%XML-EXPRESSION-ITERATOR.VALUE SELF) XML-EXPRESSION)
        (CL:WHEN
         (CL:AND
          (CL:AND (ISA? XML-EXPRESSION SGT-XML-STELLA-CONS)
           (ISA? (%%VALUE XML-EXPRESSION)
            SGT-XML-STELLA-XML-DECLARATION))
          (STRING-EQL? (%XML-DECLARATION.NAME (%%VALUE XML-EXPRESSION))
           "DOCTYPE"))
         (CL:WHEN
          (CL:NOT (CL:EQ (%XML-EXPRESSION-ITERATOR.DOCTYPE SELF) NULL))
          (CL:WARN
           "Found a DOCTYPE declaration in an XML-EXPRESSION-ITERATOR that already has a doctype!"))
         (CL:SETF (%XML-EXPRESSION-ITERATOR.DOCTYPE SELF)
          (PROCESS-DOCTYPE XML-EXPRESSION))))
       (CL:RETURN-FROM NEXT? CL:T)))
     :CONTINUE))))

;;; (DEFMETHOD (CONSIFY CONS) ...)

(CL:DEFMETHOD CONSIFY ((ITER XML-EXPRESSION-ITERATOR))
  (CL:LET* ((VALUE-000 NIL))
   (CL:LET* ((ITEM NULL) (ITER-000 ITER) (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO
     (CL:SETQ ITEM (%XML-EXPRESSION-ITERATOR.VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS ITEM NIL))
       (CL:IF (CL:EQ VALUE-000 NIL) (CL:SETQ VALUE-000 COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ITEM NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
   (CL:LET* ((VALUE-001 VALUE-000)) (CL:RETURN-FROM CONSIFY VALUE-001))))

;;; (DEFUN (XML-REGION-MATCHES? BOOLEAN) ...)

(CL:DEFUN XML-REGION-MATCHES? (REGIONSPEC REGIONTAG)
  (CL:IF (EQL? (%%VALUE REGIONSPEC) (%%VALUE REGIONTAG))
   (CL:LET*
    ((SPECATTRIBUTES NULL) (TAGATTRIBUTES NULL)
     (SPECATTRIBUTESOURCE (%%VALUE (%%REST REGIONSPEC))))
    (CL:IF
     (CL:AND (CL:NOT (CL:EQ SPECATTRIBUTESOURCE NULL))
      (CL:NOT (CL:EQ SPECATTRIBUTESOURCE NIL)))
     (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
      (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-000)
       (%%VALUE (%%REST REGIONSPEC)))
      (CL:SETQ SPECATTRIBUTES SELF-000))
     (CL:RETURN-FROM XML-REGION-MATCHES? CL:T))
    (CL:LET* ((SELF-001 (NEW-PROPERTY-LIST)))
     (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-001)
      (%%VALUE (%%REST REGIONTAG)))
     (CL:SETQ TAGATTRIBUTES SELF-001))
    (CL:LET*
     ((KEY NULL) (VALUE NULL)
      (ITER-000 (%PROPERTY-LIST.THE-PLIST SPECATTRIBUTES)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ KEY (%%VALUE ITER-000))
      (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
      (CL:WHEN (CL:NOT (EQL? (LOOKUP TAGATTRIBUTES KEY) VALUE))
       (CL:RETURN-FROM XML-REGION-MATCHES? CL:NIL))
      (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
    (CL:RETURN-FROM XML-REGION-MATCHES? CL:T))
   (CL:RETURN-FROM XML-REGION-MATCHES? CL:NIL)))

;;; (DEFUN (COERCE-TO-XML-ELEMENT XML-ELEMENT) ...)

(CL:DEFUN COERCE-TO-XML-ELEMENT (REGIONTAG)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE REGIONTAG)))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-TO-XML-ELEMENT
       (MAKE-XML-ELEMENT (%SYMBOL.SYMBOL-NAME REGIONTAG) ""
        STELLA::NULL-STRING))))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-XML-STELLA-XML-ELEMENT)
     (CL:PROGN (CL:RETURN-FROM COERCE-TO-XML-ELEMENT REGIONTAG)))
    ((SUBTYPE-OF-STRING? TEST-VALUE-001)
     (CL:PROGN
      (CL:RETURN-FROM COERCE-TO-XML-ELEMENT
       (MAKE-XML-ELEMENT (%STRING-WRAPPER.WRAPPER-VALUE REGIONTAG) ""
        STELLA::NULL-STRING))))
    ((CL:EQ TEST-VALUE-001 SGT-XML-STELLA-CONS)
     (CL:PROGN
      (CL:IF (CL:EQ (%%REST REGIONTAG) NIL)
       (CL:RETURN-FROM COERCE-TO-XML-ELEMENT
        (COERCE-TO-XML-ELEMENT (%%VALUE REGIONTAG)))
       (CL:LET*
        ((NAME (%%VALUE REGIONTAG))
         (NAMESPACE (%%VALUE (%%REST REGIONTAG))))
        (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE NAME)))
         (CL:COND
          ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
           (CL:PROGN
            (CL:RETURN-FROM COERCE-TO-XML-ELEMENT
             (MAKE-XML-ELEMENT (%SYMBOL.SYMBOL-NAME NAME) ""
              (%STRING-WRAPPER.WRAPPER-VALUE NAMESPACE)))))
          ((SUBTYPE-OF? TEST-VALUE-000 SGT-XML-STELLA-XML-ELEMENT)
           (CL:PROGN (CL:RETURN-FROM COERCE-TO-XML-ELEMENT NAME)))
          ((SUBTYPE-OF-STRING? TEST-VALUE-000)
           (CL:PROGN
            (CL:RETURN-FROM COERCE-TO-XML-ELEMENT
             (MAKE-XML-ELEMENT (%STRING-WRAPPER.WRAPPER-VALUE NAME) ""
              (%STRING-WRAPPER.WRAPPER-VALUE NAMESPACE)))))
          (CL:T
           (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
             TEST-VALUE-000 "' is not a valid case option")
            (CL:ERROR
             (NEW-STELLA-EXCEPTION
              (THE-STRING-READER STREAM-000)))))))))))
    (CL:T
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
       "`" TEST-VALUE-001 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))

;;; (DEFUN (XML-EXPRESSIONS XML-EXPRESSION-ITERATOR) ...)

(CL:DEFUN XML-EXPRESSIONS (STREAM REGIONTAG)
  "Return an XML-expression-iterator (which see) reading from
`stream'.  `regionTag' can be used to define delimited regions from which
expressions should be considered. Use s-expression representation to specify
`regionTag', e.g., '(KIF (:version \"1.0\"))'.  The tag can be an XML element
object, a symbol, a string or a cons.  If the tag is a cons the first element
can also be (name namespace) pair."
  (CL:LET* ((SELF-000 (NEW-XML-EXPRESSION-ITERATOR)))
   (CL:SETF (%XML-EXPRESSION-ITERATOR.THE-STREAM SELF-000) STREAM)
   (CL:LET* ((ITERATOR SELF-000))
    (CL:WHEN (CL:NOT (CL:EQ REGIONTAG NULL))
     (CL:COND
      ((CL:EQ (SAFE-PRIMARY-TYPE REGIONTAG) SGT-XML-STELLA-CONS)
       (CL:PROGN
        (CL:COND ((CL:EQ REGIONTAG NIL))
         ((CL:EQ (%%REST REGIONTAG) NULL)
          (CL:SETF (%XML-EXPRESSION-ITERATOR.REGION-TAG ITERATOR)
           (CONS (COERCE-TO-XML-ELEMENT (%%VALUE REGIONTAG))
            (CONS NIL NIL))))
         ((CL:EQ (%%REST (%%REST REGIONTAG)) NULL)
          (CL:SETF (%XML-EXPRESSION-ITERATOR.REGION-TAG ITERATOR)
           (CONS (COERCE-TO-XML-ELEMENT (%%VALUE REGIONTAG))
            (CONS (%%VALUE (%%REST REGIONTAG)) NIL))))
         (CL:T
          (CL:SETF (%XML-EXPRESSION-ITERATOR.REGION-TAG ITERATOR)
           (CONS (COERCE-TO-XML-ELEMENT (%%VALUE REGIONTAG))
            (CONS (%%REST REGIONTAG) NIL)))))))
      (CL:T
       (CL:SETF (%XML-EXPRESSION-ITERATOR.REGION-TAG ITERATOR)
        (CONS (COERCE-TO-XML-ELEMENT REGIONTAG) (CONS NIL NIL))))))
    (CL:RETURN-FROM XML-EXPRESSIONS ITERATOR))))

;;; (DEFUN (XML-CDATA? BOOLEAN) ...)

(CL:DEFUN XML-CDATA? (ITEM)
  "Return `true' if `item' is an XML CDATA tag object"
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ITEM) SGT-XML-STELLA-XML-SPECIAL)
    (CL:PROGN
     (CL:RETURN-FROM XML-CDATA?
      (STRING-EQL? (%XML-SPECIAL.NAME ITEM) "CDATA"))))
   (CL:T (CL:RETURN-FROM XML-CDATA? CL:NIL))))

;;; (DEFUN (XML-ELEMENT? BOOLEAN) ...)

(CL:DEFUN XML-ELEMENT? (ITEM)
  "Return `true' if `item' is an XML element object"
  (CL:RETURN-FROM XML-ELEMENT? (ISA? ITEM SGT-XML-STELLA-XML-ELEMENT)))

;;; (DEFUN (XML-ATTRIBUTE? BOOLEAN) ...)

(CL:DEFUN XML-ATTRIBUTE? (ITEM)
  "Return `true' if `item' is an XML attribute object"
  (CL:RETURN-FROM XML-ATTRIBUTE?
   (ISA? ITEM SGT-XML-STELLA-XML-ATTRIBUTE)))

;;; (DEFUN (XML-GLOBAL-ATTRIBUTE? BOOLEAN) ...)

(CL:DEFUN XML-GLOBAL-ATTRIBUTE? (ITEM)
  "Return `true' if `item' is an XML attribute object"
  (CL:RETURN-FROM XML-GLOBAL-ATTRIBUTE?
   (ISA? ITEM SGT-XML-STELLA-XML-GLOBAL-ATTRIBUTE)))

;;; (DEFUN (XML-LOCAL-ATTRIBUTE? BOOLEAN) ...)

(CL:DEFUN XML-LOCAL-ATTRIBUTE? (ITEM)
  "Return `true' if `item' is an XML attribute object"
  (CL:RETURN-FROM XML-LOCAL-ATTRIBUTE?
   (ISA? ITEM SGT-XML-STELLA-XML-LOCAL-ATTRIBUTE)))

;;; (DEFUN (XML-BASE-ATTRIBUTE? BOOLEAN) ...)

(CL:DEFUN XML-BASE-ATTRIBUTE? (ITEM)
  "Return `true' if `item' is an XML attribute object"
  (CL:RETURN-FROM XML-BASE-ATTRIBUTE?
   (CL:AND (ISA? ITEM SGT-XML-STELLA-XML-GLOBAL-ATTRIBUTE)
    (STRING-EQL? "base" (%XML-GLOBAL-ATTRIBUTE.NAME ITEM))
    (STRING-EQL? *XML-URN* (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-URI ITEM)))))

;;; (DEFUN (XML-DECLARATION? BOOLEAN) ...)

(CL:DEFUN XML-DECLARATION? (ITEM)
  "Return `true' if `item' is an XML declaration object"
  (CL:RETURN-FROM XML-DECLARATION?
   (ISA? ITEM SGT-XML-STELLA-XML-DECLARATION)))

;;; (DEFUN (XML-PROCESSING-INSTRUCTION? BOOLEAN) ...)

(CL:DEFUN XML-PROCESSING-INSTRUCTION? (ITEM)
  "Return `true' if `item' is an XML processing instruction object"
  (CL:RETURN-FROM XML-PROCESSING-INSTRUCTION?
   (ISA? ITEM SGT-XML-STELLA-XML-PROCESSING-INSTRUCTION)))

;;; (DEFUN (XML-ELEMENT-FORM? BOOLEAN) ...)

(CL:DEFUN XML-ELEMENT-FORM? (FORM)
  "Return `true' if `form' is a CONS headed by an XML ELEMENT tag"
  (CL:RETURN-FROM XML-ELEMENT-FORM?
   (CL:AND (ISA? FORM SGT-XML-STELLA-CONS)
    (ISA? (%%VALUE FORM) SGT-XML-STELLA-XML-ELEMENT))))

;;; (DEFUN (XML-PROCESSING-INSTRUCTION-FORM? BOOLEAN) ...)

(CL:DEFUN XML-PROCESSING-INSTRUCTION-FORM? (FORM)
  "Return `true' if `form' is a CONS headed by an XML PROCESSING INSTRUCTION tag"
  (CL:RETURN-FROM XML-PROCESSING-INSTRUCTION-FORM?
   (CL:AND (ISA? FORM SGT-XML-STELLA-CONS)
    (ISA? (%%VALUE FORM) SGT-XML-STELLA-XML-PROCESSING-INSTRUCTION))))

;;; (DEFUN (XML-DECLARATION-FORM? BOOLEAN) ...)

(CL:DEFUN XML-DECLARATION-FORM? (FORM)
  "Return `true' if `form' is a CONS headed by an XML DECLARATION tag"
  (CL:RETURN-FROM XML-DECLARATION-FORM?
   (CL:AND (ISA? FORM SGT-XML-STELLA-CONS)
    (ISA? (%%VALUE FORM) SGT-XML-STELLA-XML-DECLARATION))))

;;; (DEFUN (XML-DOCTYPE-FORM? BOOLEAN) ...)

(CL:DEFUN XML-DOCTYPE-FORM? (FORM)
  "Return `true' if `form' is a CONS headed by a DOCTYPE tag"
  (CL:RETURN-FROM XML-DOCTYPE-FORM?
   (CL:AND
    (CL:AND (ISA? FORM SGT-XML-STELLA-CONS)
     (ISA? (%%VALUE FORM) SGT-XML-STELLA-XML-DECLARATION))
    (STRING-EQL? (%XML-DECLARATION.NAME (%%VALUE FORM)) "DOCTYPE"))))

;;; (DEFUN (XML-CDATA-FORM? BOOLEAN) ...)

(CL:DEFUN XML-CDATA-FORM? (FORM)
  "Return `true' if `form' is a CONS headed by a CDATA tag"
  (CL:RETURN-FROM XML-CDATA-FORM?
   (CL:AND (ISA? FORM SGT-XML-STELLA-CONS) (XML-CDATA? (%%VALUE FORM)))))

;;; (DEFUN (GET-XML-TAG XML-ELEMENT) ...)

(CL:DEFUN GET-XML-TAG (EXPRESSION)
  "Return the XML tag object of an XML `expression'."
  (CL:RETURN-FROM GET-XML-TAG (%%VALUE EXPRESSION)))

;;; (DEFUN (GET-XML-ATTRIBUTES CONS) ...)

(CL:DEFUN GET-XML-ATTRIBUTES (EXPRESSION)
  "Return the list of attributes of an XML `expression' (may be empty)."
  (CL:RETURN-FROM GET-XML-ATTRIBUTES (%%VALUE (%%REST EXPRESSION))))

;;; (DEFUN (GET-XML-BASE-ATTRIBUTE-VALUE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  GET-XML-BASE-ATTRIBUTE-VALUE))
(CL:DEFUN GET-XML-BASE-ATTRIBUTE-VALUE (EXPRESSION)
  "Return the last base url attribute in the attribute list of this
element if it exists.  Otherwise NULL."
  (CL:LET*
   ((ATTRIBUTE-LIST (%%VALUE (%%REST EXPRESSION))) (ATTRIBUTE NULL)
    (VALUE STELLA::NULL-STRING)
    (BASE-ATTRIBUTE-VALUE STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE BASE-ATTRIBUTE-VALUE))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ATTRIBUTE-LIST NIL)) DO
    (CL:LET* ((HEAD-000 (%%VALUE ATTRIBUTE-LIST)))
     (CL:SETQ ATTRIBUTE-LIST (%%REST ATTRIBUTE-LIST))
     (CL:SETQ ATTRIBUTE HEAD-000))
    (CL:LET* ((HEAD-001 (%%VALUE ATTRIBUTE-LIST)))
     (CL:SETQ ATTRIBUTE-LIST (%%REST ATTRIBUTE-LIST))
     (CL:SETQ VALUE (%STRING-WRAPPER.WRAPPER-VALUE HEAD-001)))
    (CL:WHEN
     (CL:AND (ISA? ATTRIBUTE SGT-XML-STELLA-XML-GLOBAL-ATTRIBUTE)
      (STRING-EQL? "base" (%XML-GLOBAL-ATTRIBUTE.NAME ATTRIBUTE))
      (STRING-EQL? *XML-URN*
       (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-URI ATTRIBUTE)))
     (CL:SETQ BASE-ATTRIBUTE-VALUE VALUE)))
   (CL:RETURN-FROM GET-XML-BASE-ATTRIBUTE-VALUE BASE-ATTRIBUTE-VALUE)))

;;; (DEFUN (GET-XML-CONTENT CONS) ...)

(CL:DEFUN GET-XML-CONTENT (EXPRESSION)
  "Return the list of content elements of an XML `expression' (may be empty)."
  (CL:RETURN-FROM GET-XML-CONTENT (%%REST (%%REST EXPRESSION))))

;;; (DEFUN (GET-XML-CDATA-CONTENT STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) GET-XML-CDATA-CONTENT))
(CL:DEFUN GET-XML-CDATA-CONTENT (FORM)
  "Return the CDATA content of a CDATA `form'.  Does NOT make sure that `form'
actually is a CDATA form, so bad things can happen if it is given wrong input."
  (CL:RETURN-FROM GET-XML-CDATA-CONTENT
   (UNWRAP-STRING (%%VALUE (%%VALUE (%%REST FORM))))))

;;; (DEFMETHOD (XML-ELEMENT-MATCH? BOOLEAN) ...)

(CL:DEFMETHOD XML-ELEMENT-MATCH? ((TAG XML-ELEMENT) NAME NAMESPACE)
  "Returns `true' if `tag' is an XML element with the name `name'
in namespace `namespace'.  Note that `namespace' is the full URI, not an abbreviation.
Also, `namespace' may be `null', in which case `tag' must not have a namespace
associated with it."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME NAMESPACE))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE CL:SIMPLE-STRING)
  (CL:RETURN-FROM XML-ELEMENT-MATCH?
   (CL:AND (STRING-EQL? (%XML-ELEMENT.NAME TAG) NAME)
    (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI TAG) NAMESPACE))))

;;; (DEFMETHOD (XML-ATTRIBUTE-MATCH? BOOLEAN) ...)

(CL:DEFMETHOD XML-ATTRIBUTE-MATCH? ((ATTRIBUTE XML-ATTRIBUTE) NAME NAMESPACE)
  "Return `true' if `attribute' is an XML attribute with name `name'
in namespace `namespace'.  Note that `namespace' is the full URI, not an
abbreviation.  Also, `namespace' may be `null', in which case `attribute'
must not have a namespace associated with it."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME NAMESPACE))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE CL:SIMPLE-STRING)
  (CL:PROGN (CL:SETQ NAME NAME) (CL:SETQ NAMESPACE NAMESPACE))
  (CL:RETURN-FROM XML-ATTRIBUTE-MATCH? CL:NIL))

;;; (DEFMETHOD (XML-ATTRIBUTE-MATCH? BOOLEAN) ...)

(CL:DEFMETHOD XML-ATTRIBUTE-MATCH? ((ATTRIBUTE XML-GLOBAL-ATTRIBUTE) NAME NAMESPACE)
  "Return `true' if `attribute' is a global  XML attribute with name `name'
in namespace `namespace'.  Note that `namespace' is the full URI, not an
abbreviation.  Also, `namespace' may be `null', in which case `attribute'
must not have a namespace associated with it."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME NAMESPACE))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE CL:SIMPLE-STRING)
  (CL:RETURN-FROM XML-ATTRIBUTE-MATCH?
   (CL:AND (STRING-EQL? (%XML-GLOBAL-ATTRIBUTE.NAME ATTRIBUTE) NAME)
    (STRING-EQL? (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-URI ATTRIBUTE)
     NAMESPACE))))

;;; (DEFMETHOD (XML-ATTRIBUTE-MATCH? BOOLEAN) ...)

(CL:DEFMETHOD XML-ATTRIBUTE-MATCH? ((ATTRIBUTE XML-LOCAL-ATTRIBUTE) NAME NAMESPACE)
  "Return `true' if `attribute' is a local XML attribute with name `name'.
Note that `namespace' must be `null' and that the `attribute's parent element
element is not considered by the match.  To take the parent element into
account use `xml-local-attribute-match?'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME NAMESPACE))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE CL:SIMPLE-STRING)
  (CL:RETURN-FROM XML-ATTRIBUTE-MATCH?
   (CL:AND (CL:EQ NAMESPACE STELLA::NULL-STRING)
    (STRING-EQL? (%XML-LOCAL-ATTRIBUTE.NAME ATTRIBUTE) NAME))))

;;; (DEFUN (XML-GLOBAL-ATTRIBUTE-MATCH? BOOLEAN) ...)

(CL:DEFUN XML-GLOBAL-ATTRIBUTE-MATCH? (ATTRIBUTE NAME NAMESPACE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME NAMESPACE))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE CL:SIMPLE-STRING)
  (CL:RETURN-FROM XML-GLOBAL-ATTRIBUTE-MATCH?
   (CL:AND (STRING-EQL? (%XML-GLOBAL-ATTRIBUTE.NAME ATTRIBUTE) NAME)
    (STRING-EQL? (%XML-GLOBAL-ATTRIBUTE.NAMESPACE-URI ATTRIBUTE)
     NAMESPACE))))

;;; (DEFUN (XML-LOCAL-ATTRIBUTE-MATCH? BOOLEAN) ...)

(CL:DEFUN XML-LOCAL-ATTRIBUTE-MATCH? (ATTRIBUTE NAME ELEMENT-NAME ELEMENT-NAMESPACE)
  "Return true if `attribute' is a local attribute with `name' and whose
parent element matches `element-name' and `element-namespace'."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING NAME ELEMENT-NAME ELEMENT-NAMESPACE))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ELEMENT-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ELEMENT-NAMESPACE CL:SIMPLE-STRING)
  (CL:RETURN-FROM XML-LOCAL-ATTRIBUTE-MATCH?
   (CL:AND (STRING-EQL? (%XML-LOCAL-ATTRIBUTE.NAME ATTRIBUTE) NAME)
    (CL:AND
     (STRING-EQL?
      (%XML-ELEMENT.NAME
       (%XML-LOCAL-ATTRIBUTE.PARENT-ELEMENT ATTRIBUTE))
      ELEMENT-NAME)
     (STRING-EQL?
      (%XML-ELEMENT.NAMESPACE-URI
       (%XML-LOCAL-ATTRIBUTE.PARENT-ELEMENT ATTRIBUTE))
      ELEMENT-NAMESPACE)))))

;;; (DEFUN (XML-LOOKUP-ATTRIBUTE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:T CL:SIMPLE-STRING CL:SIMPLE-STRING)
   CL:SIMPLE-STRING)
  XML-LOOKUP-ATTRIBUTE))
(CL:DEFUN XML-LOOKUP-ATTRIBUTE (ATTRIBUTES NAME NAMESPACE)
  "Find the XML attribute in `attributes' with `name' and `namespace' and
return its value.  Note that it is assumed that all `attributes' come from
the same known tag, hence, the parent elements of any local attributes are
not considered by the lookup."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME NAMESPACE))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NAMESPACE CL:SIMPLE-STRING)
  (CL:LOOP WHILE (CL:NOT (CL:EQ ATTRIBUTES NIL)) DO
   (CL:WHEN (XML-ATTRIBUTE-MATCH? (%%VALUE ATTRIBUTES) NAME NAMESPACE)
    (CL:RETURN-FROM XML-LOOKUP-ATTRIBUTE
     (UNWRAP-STRING (%%VALUE (%%REST ATTRIBUTES)))))
   (CL:SETQ ATTRIBUTES (%%REST (%%REST ATTRIBUTES))))
  (CL:RETURN-FROM XML-LOOKUP-ATTRIBUTE STELLA::NULL-STRING))

;;; (DEFUN (EXPAND-XML-TAG-CASE CONS) ...)

(CL:DEFUN EXPAND-XML-TAG-CASE (ITEM CLAUSES)
  (CL:LET* ((OUTPUT-CLAUSES NIL) (KEY NULL))
   (CL:LET* ((CLAUSE NULL) (ITER-000 CLAUSES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLAUSE (%%VALUE ITER-000)) (CL:SETQ KEY (%%VALUE CLAUSE))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE KEY)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 SGT-XML-STELLA-CONS)
        (CL:PROGN
         (CL:COND
          ((CL:EQ (%%REST KEY) NIL)
           (CL:SETQ OUTPUT-CLAUSES
            (CONS
             (CONS
              (LIST* SYM-XML-STELLA-XML-ELEMENT-MATCH? ITEM
               (CONS (%%VALUE KEY) (CONS SYM-XML-STELLA-NULL NIL)))
              (CONCATENATE (%%REST CLAUSE) NIL))
             OUTPUT-CLAUSES)))
          ((CL:EQ (%%VALUE (%%REST KEY)) KWD-XML-ANY)
           (CL:SETQ OUTPUT-CLAUSES
            (CONS
             (CONS
              (LIST* SYM-XML-STELLA-STRING-EQL?
               (LIST* SYM-XML-STELLA-NAME ITEM NIL) (%%VALUE KEY) NIL)
              (CONCATENATE (%%REST CLAUSE) NIL))
             OUTPUT-CLAUSES)))
          (CL:T
           (CL:SETQ OUTPUT-CLAUSES
            (CONS
             (CONS
              (LIST* SYM-XML-STELLA-XML-ELEMENT-MATCH? ITEM
               (CONS (%%VALUE KEY) (CONS (%%VALUE (%%REST KEY)) NIL)))
              (CONCATENATE (%%REST CLAUSE) NIL))
             OUTPUT-CLAUSES))))))
       ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
        (CL:PROGN
         (CL:IF (CL:EQ KEY SYM-XML-STELLA-OTHERWISE)
          (CL:SETQ OUTPUT-CLAUSES (CONS CLAUSE OUTPUT-CLAUSES))
          (CL:SETQ OUTPUT-CLAUSES
           (CONS
            (CONS
             (LIST* SYM-XML-STELLA-XML-ELEMENT-MATCH? ITEM
              (CONS (WRAP-STRING (%SYMBOL.SYMBOL-NAME KEY))
               (CONS SYM-XML-STELLA-NULL NIL)))
             (CONCATENATE (%%REST CLAUSE) NIL))
            OUTPUT-CLAUSES)))))
       ((SUBTYPE-OF-STRING? TEST-VALUE-000)
        (CL:PROGN
         (CL:SETQ OUTPUT-CLAUSES
          (CONS
           (CONS
            (LIST* SYM-XML-STELLA-XML-ELEMENT-MATCH? ITEM
             (CONS KEY (CONS SYM-XML-STELLA-NULL NIL)))
            (CONCATENATE (%%REST CLAUSE) NIL))
           OUTPUT-CLAUSES))))
       (CL:T
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
          TEST-VALUE-000 "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM EXPAND-XML-TAG-CASE
    (CONS SYM-XML-STELLA-COND
     (CONCATENATE (REVERSE OUTPUT-CLAUSES) NIL)))))

;;; (DEFMACRO XML-TAG-CASE ...)

(CL:DEFUN XML-TAG-CASE (ITEM CLAUSES)
  "A case form for matching `item' against XML element tags.  Each
element of `clauses' should be a clause with the form
  (\"tagname\" ...)     or
  ((\"tagname\" \"namespace-uri\") ...)
The clause heads can optionally be symbols instead of strings.  The key forms the
parameters to the method `xml-element-match?', with a missing namespace argument
passed as NULL.

The namespace argument will be evaluated, so one can use bound variables in
place of a fixed string.   As a special case, if the namespace argument is
:ANY, then the test will be done for a match on the tag name alone."
  (CL:IF (ISA? ITEM SGT-XML-STELLA-SYMBOL)
   (CL:RETURN-FROM XML-TAG-CASE (EXPAND-XML-TAG-CASE ITEM CLAUSES))
   (CL:LET* ((VAR (LOCAL-GENSYM "ITEM")))
    (CL:RETURN-FROM XML-TAG-CASE
     (LIST* SYM-XML-STELLA-LET
      (CONS (CONS VAR (LIST* SYM-XML-STELLA-XML-ELEMENT ITEM NIL)) NIL)
      (EXPAND-XML-TAG-CASE VAR CLAUSES) NIL)))))

;;; (DEFUN PRINT-XML-NON-ELEMENT-ATTRIBUTES ...)

(CL:DEFUN PRINT-XML-NON-ELEMENT-ATTRIBUTES (STREAM ATTRIBUTES)
  (CL:LET* ((LAST-WAS-ATTRIBUTE? CL:NIL))
   (CL:LET* ((ITEM NULL) (ITER-000 ATTRIBUTES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ITEM (%%VALUE ITER-000))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ITEM)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-XML-STELLA-XML-ATTRIBUTE)
        (CL:PROGN
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "
          (%XML-ATTRIBUTE.SURFACE-FORM ITEM))
         (CL:SETQ LAST-WAS-ATTRIBUTE? CL:T)))
       ((SUBTYPE-OF-STRING? TEST-VALUE-000)
        (CL:PROGN
         (CL:IF LAST-WAS-ATTRIBUTE?
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "=")
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "))
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
          (%STRING-WRAPPER.WRAPPER-VALUE ITEM))
         (CL:SETQ LAST-WAS-ATTRIBUTE? CL:NIL)))
       (CL:T
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM
          (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
          TEST-VALUE-000 "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  :VOID)

;;; (DEFUN PRINT-XML-ELEMENT-ATTRIBUTES ...)

(CL:DEFUN PRINT-XML-ELEMENT-ATTRIBUTES (STREAM ATTRIBUTES)
  (CL:LET* ((ITEM NULL) (ITER-000 ATTRIBUTES))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ ITEM (%%VALUE ITER-000))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ITEM)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-XML-STELLA-XML-ATTRIBUTE)
       (CL:PROGN
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " "
         (%XML-ATTRIBUTE.SURFACE-FORM ITEM) "=")))
      ((SUBTYPE-OF-STRING? TEST-VALUE-000)
       (CL:PROGN
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "\"")
        (CL:LET* ((FOUND?-000 CL:NIL))
         (CL:LET*
          ((CH NULL-CHARACTER)
           (VECTOR-000 (%STRING-WRAPPER.WRAPPER-VALUE ITEM))
           (INDEX-000 0)
           (LENGTH-000 (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
           (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
          (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
           (CL:SETQ CH
            (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
              (CL:TYPE CL:FIXNUM POSITION))
             (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
              (CL:THE CL:FIXNUM POSITION))))
           (CL:WHEN (HTML-CHARACTER-NEEDS-QUOTING? CH)
            (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
         (CL:IF FOUND?-000
          (WRITE-HTML-QUOTING-SPECIAL-CHARACTERS
           (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
           (%STRING-WRAPPER.WRAPPER-VALUE ITEM))
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
           (%STRING-WRAPPER.WRAPPER-VALUE ITEM))))
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "\"")))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM
         (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
         TEST-VALUE-000 "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  :VOID)

;;; (DEFUN PRINT-XML-EXPRESSION ...)

(CL:DEFUN PRINT-XML-EXPRESSION (STREAM XML-EXPRESSION INDENT)
  "Prints `xml-expression' on `stream'.  Indentation begins with the
value of `indent'.  If this is the `null' integer, no indentation is
performed.  Otherwise it should normally be specified as 0 (zero) for
top-level calls.

It is assumed that the `xml-expression' is a well-formed CONS-list
representation of an XML  form.  It expects a form like that form
returned by `read-XML-expression'.

Also handles a list of xml forms such as that returned by `XML-expressions'.
In that case, each of the forms is indented by `indent' spaces."
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  #+MCL
  (CL:CHECK-TYPE INDENT CL:FIXNUM)
  (CL:WHEN (ISA? (%%VALUE XML-EXPRESSION) SGT-XML-STELLA-CONS)
   (CL:LET* ((EXP NULL) (ITER-000 XML-EXPRESSION))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXP (%%VALUE ITER-000))
     (PRINT-XML-EXPRESSION STREAM EXP INDENT)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM PRINT-XML-EXPRESSION))
  (CL:LET*
   ((TAG (%%VALUE XML-EXPRESSION))
    (ATTRIBUTES (%%VALUE (%%REST XML-EXPRESSION)))
    (TAGNAME (%XML-OBJECT.SURFACE-FORM TAG))
    (PREVIOUS-ITEM-WAS-STRING? CL:NIL) (IN-CONTENT-FIELD? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TAGNAME))
   (CL:WHEN (CL:NOT (CL:= INDENT NULL-INTEGER))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 INDENT)
      (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
      (CL:SETQ I ITER-001) (CL:SETQ I I)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " ")
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TAG)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-001
       SGT-XML-STELLA-XML-PROCESSING-INSTRUCTION)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "<?"
        TAGNAME)
       (PRINT-XML-NON-ELEMENT-ATTRIBUTES STREAM ATTRIBUTES)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "?>"
        EOL)))
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-XML-STELLA-XML-DECLARATION)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "<!"
        TAGNAME)
       (PRINT-XML-NON-ELEMENT-ATTRIBUTES STREAM ATTRIBUTES)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) ">" EOL)))
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-XML-STELLA-XML-SPECIAL)
      (CL:PROGN
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "<!["
        TAGNAME "[")
       (CL:IF (STRING-EQL? TAGNAME "CDATA")
        (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
         (UNWRAP-STRING (%%VALUE ATTRIBUTES)))
        (PRINT-XML-NON-ELEMENT-ATTRIBUTES STREAM ATTRIBUTES))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "]]>")))
     ((SUBTYPE-OF? TEST-VALUE-001 SGT-XML-STELLA-XML-ELEMENT)
      (CL:PROGN
       (CL:COND
        ((CL:EQ (%%REST XML-EXPRESSION) NIL)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "<"
          TAGNAME "/>" EOL))
        (CL:T
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "<"
          TAGNAME)
         (PRINT-XML-ELEMENT-ATTRIBUTES STREAM
          (%%VALUE (%%REST XML-EXPRESSION)))
         (CL:SETQ PREVIOUS-ITEM-WAS-STRING? CL:NIL)
         (CL:WHEN (CL:NOT (CL:= INDENT NULL-INTEGER))
          (CL:SETQ INDENT (CL:+ INDENT 2)))
         (CL:LET*
          ((ITEM NULL) (ITER-002 (%%REST (%%REST XML-EXPRESSION))))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
           (CL:SETQ ITEM (%%VALUE ITER-002))
           (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ITEM)))
            (CL:COND
             ((CL:EQ TEST-VALUE-000 SGT-XML-STELLA-CONS)
              (CL:PROGN
               (CL:IF (XML-CDATA? (%%VALUE ITEM))
                (CL:PROGN
                 (CL:WHEN (CL:NOT IN-CONTENT-FIELD?)
                  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
                   ">")
                  (CL:SETQ IN-CONTENT-FIELD? CL:T))
                 (PRINT-XML-EXPRESSION STREAM ITEM 0)
                 (CL:SETQ PREVIOUS-ITEM-WAS-STRING? CL:T))
                (CL:PROGN
                 (CL:WHEN (CL:NOT IN-CONTENT-FIELD?)
                  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
                   ">" EOL)
                  (CL:SETQ IN-CONTENT-FIELD? CL:T))
                 (PRINT-XML-EXPRESSION STREAM ITEM INDENT)
                 (CL:SETQ PREVIOUS-ITEM-WAS-STRING? CL:NIL)))))
             ((SUBTYPE-OF-STRING? TEST-VALUE-000)
              (CL:PROGN
               (CL:WHEN (CL:NOT IN-CONTENT-FIELD?)
                (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
                 ">")
                (CL:SETQ IN-CONTENT-FIELD? CL:T))
               (CL:WHEN PREVIOUS-ITEM-WAS-STRING?
                (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
                 " "))
               (CL:LET* ((FOUND?-000 CL:NIL))
                (CL:LET*
                 ((CH NULL-CHARACTER)
                  (VECTOR-000 (%STRING-WRAPPER.WRAPPER-VALUE ITEM))
                  (INDEX-000 0)
                  (LENGTH-000
                   (CL:THE CL:FIXNUM (CL:LENGTH VECTOR-000))))
                 (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VECTOR-000)
                  (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
                 (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
                  (CL:SETQ CH
                   (CL:LET ((SELF VECTOR-000) (POSITION INDEX-000))
                    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
                     (CL:TYPE CL:FIXNUM POSITION))
                    (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
                     (CL:THE CL:FIXNUM POSITION))))
                  (CL:WHEN (HTML-CHARACTER-NEEDS-QUOTING? CH)
                   (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
                  (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
                (CL:IF FOUND?-000
                 (WRITE-HTML-QUOTING-SPECIAL-CHARACTERS
                  (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
                  (%STRING-WRAPPER.WRAPPER-VALUE ITEM))
                 (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
                  (%STRING-WRAPPER.WRAPPER-VALUE ITEM))))
               (CL:SETQ PREVIOUS-ITEM-WAS-STRING? CL:T)))
             (CL:T
              (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
               (%%PRINT-STREAM
                (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
                TEST-VALUE-000 "' is not a valid case option")
               (CL:ERROR
                (NEW-STELLA-EXCEPTION
                 (THE-STRING-READER STREAM-000)))))))
           (CL:SETQ ITER-002 (%%REST ITER-002))))
         (CL:IF IN-CONTENT-FIELD?
          (CL:PROGN
           (CL:WHEN (CL:NOT (CL:= INDENT NULL-INTEGER))
            (CL:SETQ INDENT (CL:- INDENT 2))
            (CL:WHEN (CL:NOT PREVIOUS-ITEM-WAS-STRING?)
             (CL:LET*
              ((I NULL-INTEGER) (ITER-003 1) (UPPER-BOUND-001 INDENT)
               (UNBOUNDED?-001 (CL:= UPPER-BOUND-001 NULL-INTEGER)))
              (CL:DECLARE
               (CL:TYPE CL:FIXNUM I ITER-003 UPPER-BOUND-001))
              (CL:LOOP WHILE
               (CL:OR UNBOUNDED?-001 (CL:<= ITER-003 UPPER-BOUND-001))
               DO (CL:SETQ I ITER-003) (CL:SETQ I I)
               (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
                " ")
               (CL:SETQ ITER-003 (CL:1+ ITER-003))))))
           (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "</"
            TAGNAME ">")
           (CL:WHEN
            (CL:AND (CL:NOT (CL:= INDENT NULL-INTEGER))
             (CL:> INDENT 0))
            (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM)
             EOL)))
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "/>"
           EOL))))))
     (CL:T
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
        "`" TEST-VALUE-001 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
  :VOID)

(CL:DEFUN HELP-STARTUP-XML1 ()
  (CL:PROGN
   (CL:SETQ SGT-XML-STELLA-XML-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-OBJECT" NULL 1))
   (CL:SETQ SYM-XML-STELLA-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAME" NULL 0))
   (CL:SETQ SYM-XML-STELLA-SURFACE-FORM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURFACE-FORM" NULL 0))
   (CL:SETQ SGT-XML-STELLA-XML-ELEMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-ELEMENT" NULL 1))
   (CL:SETQ SYM-XML-STELLA-NAMESPACE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMESPACE-NAME" NULL 0))
   (CL:SETQ SYM-XML-STELLA-NAMESPACE-URI
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMESPACE-URI" NULL 0))
   (CL:SETQ SYM-XML-STELLA-ELEMENT-DICTIONARY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ELEMENT-DICTIONARY" NULL 0))
   (CL:SETQ SGT-XML-STELLA-XML-LOCAL-ATTRIBUTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-LOCAL-ATTRIBUTE" NULL 1))
   (CL:SETQ SYM-XML-STELLA-PARENT-ELEMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT-ELEMENT" NULL 0))
   (CL:SETQ SGT-XML-STELLA-XML-GLOBAL-ATTRIBUTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-GLOBAL-ATTRIBUTE" NULL 1))
   (CL:SETQ SGT-XML-STELLA-XML-PROCESSING-INSTRUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-PROCESSING-INSTRUCTION" NULL
     1))
   (CL:SETQ SYM-XML-STELLA-DATA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DATA" NULL 0))
   (CL:SETQ SGT-XML-STELLA-XML-DECLARATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-DECLARATION" NULL 1))
   (CL:SETQ SGT-XML-STELLA-XML-DOCTYPE-DECLARATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-DOCTYPE-DECLARATION" NULL 1))
   (CL:SETQ SGT-XML-STELLA-XML-SPECIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-SPECIAL" NULL 1))
   (CL:SETQ SGT-XML-STELLA-XML-COMMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-COMMENT" NULL 1))
   (CL:SETQ SGT-XML-STELLA-XML-DOCTYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-DOCTYPE" NULL 1))
   (CL:SETQ SYM-XML-STELLA-ENTITY-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ENTITY-TABLE" NULL 0))
   (CL:SETQ SYM-XML-STELLA-PARAMETER-ENTITY-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETER-ENTITY-TABLE" NULL 0))
   (CL:SETQ SGT-XML-STELLA-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER" NULL 1))
   (CL:SETQ KWD-XML-START
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START" NULL 2))
   (CL:SETQ KWD-XML-INCLUDE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCLUDE" NULL 2))
   (CL:SETQ KWD-XML-SKIP-WHITESPACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKIP-WHITESPACE" NULL 2))
   (CL:SETQ SYM-XML-STELLA-!
    (INTERN-RIGID-SYMBOL-WRT-MODULE "!" NULL 0))
   (CL:SETQ KWD-XML-OPEN-TAG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-TAG" NULL 2))
   (CL:SETQ KWD-XML-EOF (INTERN-RIGID-SYMBOL-WRT-MODULE "EOF" NULL 2))
   (CL:SETQ SYM-XML-STELLA-*
    (INTERN-RIGID-SYMBOL-WRT-MODULE "*" NULL 0))
   (CL:SETQ KWD-XML-OTHERWISE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 2))
   (CL:SETQ KWD-XML-CONTENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTENT" NULL 2))
   (CL:SETQ KWD-XML-START-TAG-END
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START-TAG-END" NULL 2))
   (CL:SETQ KWD-XML-OPEN-END-TAG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-END-TAG" NULL 2))
   (CL:SETQ KWD-XML-OPEN-PI-TAG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-PI-TAG" NULL 2))
   (CL:SETQ KWD-XML-OPEN-DECLARATION-TAG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-DECLARATION-TAG" NULL 2))
   (CL:SETQ KWD-XML-START-TAG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START-TAG" NULL 2))
   (CL:SETQ KWD-XML-OPEN-EMPTY-TAG-END
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-EMPTY-TAG-END" NULL 2))
   (CL:SETQ KWD-XML-SKIP-TO-ATTRIBUTE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKIP-TO-ATTRIBUTE-NAME" NULL 2))
   (CL:SETQ KWD-XML-ANY (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY" NULL 2))
   (CL:SETQ KWD-XML-START-PI-TAG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START-PI-TAG" NULL 2))
   (CL:SETQ KWD-XML-OPEN-PI-TAG-END
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-PI-TAG-END" NULL 2))
   (CL:SETQ KWD-XML-PI-TAG-DATA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PI-TAG-DATA" NULL 2))
   (CL:SETQ KWD-XML-PI-TAG-DATA-OR-END
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PI-TAG-DATA-OR-END" NULL 2))
   (CL:SETQ KWD-XML-EMPTY-TAG-END
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EMPTY-TAG-END" NULL 2))
   (CL:SETQ KWD-XML-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ KWD-XML-END-TAG-END
    (INTERN-RIGID-SYMBOL-WRT-MODULE "END-TAG-END" NULL 2))
   (CL:SETQ KWD-XML-END-TAG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "END-TAG" NULL 2))
   (CL:SETQ KWD-XML-ATTRIBUTE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ATTRIBUTE-NAME" NULL 2))
   (CL:SETQ KWD-XML-SKIP-TO-ATTRIBUTE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKIP-TO-ATTRIBUTE-VALUE" NULL 2))
   (CL:SETQ KWD-XML-SINGLE-QUOTED-ATTRIBUTE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLE-QUOTED-ATTRIBUTE-VALUE"
     NULL 2))
   (CL:SETQ KWD-XML-DOUBLE-QUOTED-ATTRIBUTE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOUBLE-QUOTED-ATTRIBUTE-VALUE"
     NULL 2))
   (CL:SETQ KWD-XML-UNQUOTED-ATTRIBUTE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNQUOTED-ATTRIBUTE-VALUE" NULL 2))
   (CL:SETQ KWD-XML-QUOTED-ATTRIBUTE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTED-ATTRIBUTE-VALUE" NULL 2))
   (CL:SETQ KWD-XML-START-TAG-OR-COMMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START-TAG-OR-COMMENT" NULL 2))
   (CL:SETQ KWD-XML-OPEN-SPECIAL-TAG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OPEN-SPECIAL-TAG" NULL 2))
   (CL:SETQ KWD-XML-START-DECLARATION-TAG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START-DECLARATION-TAG" NULL 2))
   (CL:SETQ KWD-XML-DECLARATION-WHITESPACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DECLARATION-WHITESPACE" NULL 2))
   (CL:SETQ KWD-XML-DECLARATION-TAG-MARKUP-DATA-START
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DECLARATION-TAG-MARKUP-DATA-START"
     NULL 2))
   (CL:SETQ KWD-XML-SINGLE-QUOTED-DECLARATION-TAG-DATA
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "SINGLE-QUOTED-DECLARATION-TAG-DATA" NULL 2))
   (CL:SETQ KWD-XML-DOUBLE-QUOTED-DECLARATION-TAG-DATA
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "DOUBLE-QUOTED-DECLARATION-TAG-DATA" NULL 2))
   (CL:SETQ KWD-XML-DECLARATION-TAG-DATA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DECLARATION-TAG-DATA" NULL 2))
   (CL:SETQ KWD-XML-QUOTED-DECLARATION-TAG-DATA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTED-DECLARATION-TAG-DATA" NULL
     2)))
  :VOID)

(CL:DEFUN HELP-STARTUP-XML2 ()
  (CL:PROGN
   (CL:SETQ KWD-XML-DECLARATION-TAG-MARKUP-DATA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DECLARATION-TAG-MARKUP-DATA" NULL
     2))
   (CL:SETQ KWD-XML-START-SPECIAL-TAG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START-SPECIAL-TAG" NULL 2))
   (CL:SETQ KWD-XML-SPECIAL-TAG-DATA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIAL-TAG-DATA" NULL 2))
   (CL:SETQ KWD-XML-SPECIAL-TAG-DATA-OR-END
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIAL-TAG-DATA-OR-END" NULL 2))
   (CL:SETQ KWD-XML-SPECIAL-TAG-DATA-OR-END2
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIAL-TAG-DATA-OR-END2" NULL 2))
   (CL:SETQ KWD-XML-DATA-TAG-END
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DATA-TAG-END" NULL 2))
   (CL:SETQ KWD-XML-COMMENT-BODY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMENT-BODY" NULL 2))
   (CL:SETQ KWD-XML-END-COMMENT-OR-COMMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "END-COMMENT-OR-COMMENT" NULL 2))
   (CL:SETQ KWD-XML-END-COMMENT-OR-COMMENT2
    (INTERN-RIGID-SYMBOL-WRT-MODULE "END-COMMENT-OR-COMMENT2" NULL 2))
   (CL:SETQ KWD-XML-COMMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMENT" NULL 2))
   (CL:SETQ KWD-XML-ATTRIBUTE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ATTRIBUTE-VALUE" NULL 2))
   (CL:SETQ KWD-XML-WHITE-SPACE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHITE-SPACE" NULL 2))
   (CL:SETQ SGT-XML-STELLA-XML-EXPRESSION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-EXPRESSION-ITERATOR" NULL 1))
   (CL:SETQ SYM-XML-STELLA-REGION-TAG
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REGION-TAG" NULL 0))
   (CL:SETQ SYM-XML-STELLA-REGION-MATCH-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REGION-MATCH-FUNCTION" NULL 0))
   (CL:SETQ SYM-XML-STELLA-DOCTYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCTYPE" NULL 0))
   (CL:SETQ SYM-XML-STELLA-DOCTYPE-ITERATOR?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCTYPE-ITERATOR?" NULL 0))
   (CL:SETQ SGT-XML-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SGT-XML-STELLA-XML-ATTRIBUTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-ATTRIBUTE" NULL 1))
   (CL:SETQ SYM-XML-STELLA-XML-ELEMENT-MATCH?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-ELEMENT-MATCH?" NULL 0))
   (CL:SETQ SYM-XML-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SYM-XML-STELLA-STRING-EQL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-EQL?" NULL 0))
   (CL:SETQ SYM-XML-STELLA-OTHERWISE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 0))
   (CL:SETQ SYM-XML-STELLA-COND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COND" NULL 0))
   (CL:SETQ SGT-XML-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 1))
   (CL:SETQ SYM-XML-STELLA-LET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
   (CL:SETQ SYM-XML-STELLA-XML-ELEMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-ELEMENT" NULL 0))
   (CL:SETQ SYM-XML-STELLA-STARTUP-XML
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-XML" NULL 0))
   (CL:SETQ SYM-XML-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-XML3 ()
  (CL:PROGN
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "XML-OBJECT"
       "(DEFCLASS XML-OBJECT (STANDARD-OBJECT) :PUBLIC-SLOTS ((NAME :TYPE STRING) (SURFACE-FORM :TYPE STRING)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-XML-OBJECT))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-XML-OBJECT-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "XML-ELEMENT"
       "(DEFCLASS XML-ELEMENT (XML-OBJECT) :PUBLIC-SLOTS ((NAMESPACE-NAME :TYPE STRING) (NAMESPACE-URI :TYPE STRING) (ELEMENT-DICTIONARY :TYPE (KEY-VALUE-LIST OF STRING-WRAPPER XML-ATTRIBUTE))) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"<\" (SURFACE-FORM SELF) \">\"))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-XML-ELEMENT))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-XML-ELEMENT-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "XML-ATTRIBUTE"
       "(DEFCLASS XML-ATTRIBUTE (XML-OBJECT) :ABSTRACT? TRUE :PUBLIC-SLOTS ((NAME :TYPE STRING) (SURFACE-FORM :TYPE STRING)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"<\" (SURFACE-FORM SELF) \">\"))")))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-XML-ATTRIBUTE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "XML-LOCAL-ATTRIBUTE"
       "(DEFCLASS XML-LOCAL-ATTRIBUTE (XML-ATTRIBUTE) :PUBLIC-SLOTS ((PARENT-ELEMENT :TYPE XML-ELEMENT)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-XML-LOCAL-ATTRIBUTE))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-XML-LOCAL-ATTRIBUTE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "XML-GLOBAL-ATTRIBUTE"
       "(DEFCLASS XML-GLOBAL-ATTRIBUTE (XML-ATTRIBUTE) :PUBLIC-SLOTS ((NAMESPACE-NAME :TYPE STRING) (NAMESPACE-URI :TYPE STRING)))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-XML-GLOBAL-ATTRIBUTE))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-XML-GLOBAL-ATTRIBUTE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "XML-PROCESSING-INSTRUCTION"
       "(DEFCLASS XML-PROCESSING-INSTRUCTION (XML-OBJECT) :PUBLIC-SLOTS ((DATA :TYPE STRING)) :PRINT-FORM (IF (NULL? (DATA SELF)) (PRINT-NATIVE-STREAM STREAM \"<?\" (SURFACE-FORM SELF) \">\") (PRINT-NATIVE-STREAM STREAM \"<?\" (SURFACE-FORM SELF) \" \" (DATA SELF) \">\")))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-XML-PROCESSING-INSTRUCTION))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-XML-PROCESSING-INSTRUCTION-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "XML-DECLARATION"
       "(DEFCLASS XML-DECLARATION (XML-OBJECT) :PUBLIC-SLOTS ((DATA :TYPE STRING)) :PRINT-FORM (IF (NULL? (DATA SELF)) (PRINT-NATIVE-STREAM STREAM \"<!\" (SURFACE-FORM SELF) \">\") (PRINT-NATIVE-STREAM STREAM \"<!\" (SURFACE-FORM SELF) \" \" (DATA SELF) \">\")))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-XML-DECLARATION))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-XML-DECLARATION-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "XML-DOCTYPE-DECLARATION"
       "(DEFCLASS XML-DOCTYPE-DECLARATION (XML-DECLARATION) :PRINT-FORM (IF (NULL? (DATA SELF)) (PRINT-NATIVE-STREAM STREAM \"<!\" (SURFACE-FORM SELF) \">\") (PRINT-NATIVE-STREAM STREAM \"<!\" (SURFACE-FORM SELF) \" ...>\")))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-XML-DOCTYPE-DECLARATION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "XML-SPECIAL"
       "(DEFCLASS XML-SPECIAL (XML-OBJECT) :PUBLIC-SLOTS ((DATA :TYPE STRING)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"<!\" (SURFACE-FORM SELF) \">\"))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-XML-SPECIAL))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-XML-SPECIAL-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "XML-COMMENT"
       "(DEFCLASS XML-COMMENT (XML-OBJECT) :PRINT-FORM (IF (NULL? (SURFACE-FORM SELF)) (PRINT-NATIVE-STREAM STREAM \"<!-- -->\") (PRINT-NATIVE-STREAM STREAM \"<!-- \" (LENGTH (SURFACE-FORM SELF)) \" chars -->\")))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-XML-COMMENT)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "XML-DOCTYPE"
       "(DEFCLASS XML-DOCTYPE (STANDARD-OBJECT) :PUBLIC-SLOTS ((NAME :TYPE STRING) (ENTITY-TABLE :TYPE (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER) :INITIALLY (NEW KEY-VALUE-LIST)) (PARAMETER-ENTITY-TABLE :TYPE (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER) :INITIALLY (NEW KEY-VALUE-LIST))) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"<!DOCTYPE \" (NAME SELF) \">\"))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-XML-DOCTYPE))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-XML-DOCTYPE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "XML-EXPRESSION-ITERATOR"
       "(DEFCLASS XML-EXPRESSION-ITERATOR (STREAM-ITERATOR) :DOCUMENTATION \"Iterator that yields XML expressions from an input stream.
If the value of `region-tag' is non-`null', only XML expressions enclosed within
matching region tags will be returned (there can be multiple such regions).
What is a match is determined by `region-match-function'.  Usually, region tags
will/should be at the top level, but this is not necessarily so and also not
enforced by the iterator.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :PUBLIC? TRUE :SLOTS ((REGION-TAG :TYPE CONS) (REGION-MATCH-FUNCTION :TYPE FUNCTION-CODE :INITIALLY (THE-CODE :FUNCTION XML-REGION-MATCHES?)) (DOCTYPE :TYPE XML-DOCTYPE) (DOCTYPE-ITERATOR? :TYPE BOOLEAN :INITIALLY FALSE :DOCUMENTATION \"Set to `true' when iterating over a DTD definition.\")))")))
    (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-XML-EXPRESSION-ITERATOR))
    (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-XML-EXPRESSION-ITERATOR-SLOT-VALUE))))
  :VOID)

(CL:DEFUN HELP-STARTUP-XML4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "RESET-XML-HASH-TABLES"
    "(DEFUN RESET-XML-HASH-TABLES () :PUBLIC? TRUE :DOCUMENTATION \"Resets Hashtables used for interning XML elements and global
attribute objects.  This will allow garbage collection of no-longer used
objects, but will also mean that newly parsed xml elements and global attributes
will not be eq? to already existing ones with the same name.\")"
    (CL:FUNCTION RESET-XML-HASH-TABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-NAMESPACE-TABLE"
    "(DEFUN (MAKE-NAMESPACE-TABLE (KV-CONS OF STRING-WRAPPER STRING-WRAPPER)) ())"
    (CL:FUNCTION MAKE-NAMESPACE-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-XML-CDATA-FORM"
    "(DEFUN (MAKE-XML-CDATA-FORM CONS) ((THE-DATA STRING)))"
    (CL:FUNCTION MAKE-XML-CDATA-FORM) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-XMLNS-ATTRIBUTE"
    "(DEFUN (MAKE-XMLNS-ATTRIBUTE XML-ATTRIBUTE) ((NAME STRING)))"
    (CL:FUNCTION MAKE-XMLNS-ATTRIBUTE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-XML-ELEMENT-INTERNAL"
    "(DEFUN (MAKE-XML-ELEMENT-INTERNAL XML-ELEMENT) ((NAME STRING) (NAMESPACE-NAME STRING) (NAMESPACE STRING) (SURFACE-FORM STRING)))"
    (CL:FUNCTION MAKE-XML-ELEMENT-INTERNAL) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-XML-ELEMENT"
    "(DEFUN (MAKE-XML-ELEMENT XML-ELEMENT) ((NAME STRING) (NAMESPACE-NAME STRING) (NAMESPACE STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Creates and interns an XML element object `name' using `namespace-name'
to refer to  `namespace'.  If `namespace' is `null', then the element will
be interned in the null namespace.   `namespace' must otherwise be a URI.\")"
    (CL:FUNCTION MAKE-XML-ELEMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-XML-ELEMENT-RESPECTING-NAMESPACE"
    "(DEFUN (MAKE-XML-ELEMENT-RESPECTING-NAMESPACE XML-ELEMENT) ((NAME STRING) (NAMESPACE-TABLE (KV-CONS OF STRING-WRAPPER STRING-WRAPPER))))"
    (CL:FUNCTION MAKE-XML-ELEMENT-RESPECTING-NAMESPACE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-XML-GLOBAL-ATTRIBUTE-INTERNAL"
    "(DEFUN (MAKE-XML-GLOBAL-ATTRIBUTE-INTERNAL XML-GLOBAL-ATTRIBUTE) ((NAME STRING) (NAMESPACE-NAME STRING) (NAMESPACE-URI STRING) (SURFACE-FORM STRING)))"
    (CL:FUNCTION MAKE-XML-GLOBAL-ATTRIBUTE-INTERNAL) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-XML-GLOBAL-ATTRIBUTE"
    "(DEFUN (MAKE-XML-GLOBAL-ATTRIBUTE XML-GLOBAL-ATTRIBUTE) ((NAME STRING) (NAMESPACE-NAME STRING) (NAMESPACE STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Creates and interns an XML global attribute object with `name' using 
`namespace-name' to refer to  `namespace'.  `namespace'must be a URI.\")"
    (CL:FUNCTION MAKE-XML-GLOBAL-ATTRIBUTE) NULL)
   (DEFINE-FUNCTION-OBJECT
    "MAKE-XML-GLOBAL-ATTRIBUTE-RESPECTING-NAMESPACE"
    "(DEFUN (MAKE-XML-GLOBAL-ATTRIBUTE-RESPECTING-NAMESPACE XML-GLOBAL-ATTRIBUTE) ((NAME STRING) (NAMESPACE-NAME STRING) (SURFACE-FORM STRING) (NAMESPACE-TABLE (KV-CONS OF STRING-WRAPPER STRING-WRAPPER))))"
    (CL:FUNCTION MAKE-XML-GLOBAL-ATTRIBUTE-RESPECTING-NAMESPACE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-XML-LOCAL-ATTRIBUTE"
    "(DEFUN (MAKE-XML-LOCAL-ATTRIBUTE XML-LOCAL-ATTRIBUTE) ((NAME STRING) (ELEMENT XML-ELEMENT)) :PUBLIC? TRUE :DOCUMENTATION \"Make an XML-LOCAL-ATTRIBUTE named `name' associated with `element'\")"
    (CL:FUNCTION MAKE-XML-LOCAL-ATTRIBUTE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-XML-ATTRIBUTE-RESPECTING-NAMESPACE"
    "(DEFUN (MAKE-XML-ATTRIBUTE-RESPECTING-NAMESPACE XML-ATTRIBUTE) ((NAME STRING) (ELEMENT XML-ELEMENT) (NAMESPACE-TABLE (KV-CONS OF STRING-WRAPPER STRING-WRAPPER))))"
    (CL:FUNCTION MAKE-XML-ATTRIBUTE-RESPECTING-NAMESPACE) NULL)
   (DEFINE-FUNCTION-OBJECT "XMLNS-ATTRIBUTE?"
    "(DEFUN (XMLNS-ATTRIBUTE? BOOLEAN) ((ATTRIBUTE OBJECT)))"
    (CL:FUNCTION XMLNS-ATTRIBUTE?) NULL)
   (DEFINE-FUNCTION-OBJECT "XMLNS-ATTRIBUTE-NAME?"
    "(DEFUN (XMLNS-ATTRIBUTE-NAME? BOOLEAN) ((NAME STRING)))"
    (CL:FUNCTION XMLNS-ATTRIBUTE-NAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTRACT-XMLNS-NAME"
    "(DEFUN (EXTRACT-XMLNS-NAME STRING) ((KEYNAME STRING)))"
    (CL:FUNCTION EXTRACT-XMLNS-NAME) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-XML-REFERENCE"
    "(DEFUN ADD-XML-REFERENCE ((NAME STRING) (SUBSTITUTION STRING) (TABLE (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER))) :GLOBALLY-INLINE? TRUE (INSERT-AT TABLE NAME SUBSTITUTION))"
    (CL:FUNCTION ADD-XML-REFERENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-XML-ENTITY-TABLE"
    "(DEFUN (MAKE-XML-ENTITY-TABLE (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER)) ())"
    (CL:FUNCTION MAKE-XML-ENTITY-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "DECODE-XML-CHAR-REF"
    "(DEFUN (DECODE-XML-CHAR-REF STRING) ((DIGITS STRING)))"
    (CL:FUNCTION DECODE-XML-CHAR-REF) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERNAL-DTD-DEFINITION?"
    "(DEFUN (INTERNAL-DTD-DEFINITION? BOOLEAN) ((DEFINITION STRING)) :PUBLIC? FALSE)"
    (CL:FUNCTION INTERNAL-DTD-DEFINITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-DOCTYPE-DEFINITION"
    "(DEFUN (GET-DOCTYPE-DEFINITION INPUT-STREAM) ((DOCTYPE CONS)) :PUBLIC? FALSE)"
    (CL:FUNCTION GET-DOCTYPE-DEFINITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTERNAL-ID-HEAD?"
    "(DEFUN (EXTERNAL-ID-HEAD? BOOLEAN) ((ATTRIBUTE OBJECT)) :PUBLIC? FALSE :DOCUMENTATION \"Checks to see if this `attribute' is the literal marking either
a PUBLIC or SYSTEM literal for an XML Elternal ID.  (See 4.2.2)\")"
    (CL:FUNCTION EXTERNAL-ID-HEAD?) NULL)
   (DEFINE-FUNCTION-OBJECT "DECODE-XML-ENTITY-REF"
    "(DEFUN (DECODE-XML-ENTITY-REF STRING) ((DOCTYPE XML-DOCTYPE) (NAME STRING) (PE-REFERENCE-ALLOWED? BOOLEAN)))"
    (CL:FUNCTION DECODE-XML-ENTITY-REF) NULL)
   (DEFINE-FUNCTION-OBJECT "DECODE-XML-PARAMETER-ENTITY-REF"
    "(DEFUN (DECODE-XML-PARAMETER-ENTITY-REF STRING) ((DOCTYPE XML-DOCTYPE) (NAME STRING) (PE-REFERENCE-ALLOWED? BOOLEAN)))"
    (CL:FUNCTION DECODE-XML-PARAMETER-ENTITY-REF) NULL)
   (DEFINE-FUNCTION-OBJECT "DECODE-XML-REFERENCE"
    "(DEFUN (DECODE-XML-REFERENCE STRING) ((DOCTYPE XML-DOCTYPE) (REFERENCE STRING) (PE-REFERENCE-ALLOWED? BOOLEAN)))"
    (CL:FUNCTION DECODE-XML-REFERENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-REFERENCE-START"
    "(DEFUN (FIND-REFERENCE-START INTEGER) ((INPUT STRING) (START INTEGER) (END INTEGER)))"
    (CL:FUNCTION FIND-REFERENCE-START) NULL)
   (DEFINE-FUNCTION-OBJECT "DECODE-XML-STRING"
    "(DEFUN (DECODE-XML-STRING STRING) ((DOCTYPE XML-DOCTYPE) (INPUT STRING) (PE-REFERENCE-ALLOWED? BOOLEAN)))"
    (CL:FUNCTION DECODE-XML-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "NORMALIZE-ATTRIBUTE-VALUE"
    "(DEFUN (NORMALIZE-ATTRIBUTE-VALUE STRING) ((DOCTYPE XML-DOCTYPE) (INPUT STRING) (PE-REFERENCE-ALLOWED? BOOLEAN)))"
    (CL:FUNCTION NORMALIZE-ATTRIBUTE-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "PROCESS-DOCTYPE"
    "(DEFUN (PROCESS-DOCTYPE XML-DOCTYPE) ((DOCTYPE-DECLARATION CONS)) :PUBLIC? TRUE :DOCUMENTATION \"Takes an S-Expression representing a doctype and processes into
a DOCTYPE object.\")" (CL:FUNCTION PROCESS-DOCTYPE) NULL)
   (DEFINE-FUNCTION-OBJECT
    "GET-XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE"
    "(DEFUN (GET-XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE TOKENIZER-TABLE) ())"
    (CL:FUNCTION GET-XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-XML-TOKENIZER-TABLE"
    "(DEFUN (GET-XML-TOKENIZER-TABLE TOKENIZER-TABLE) ())"
    (CL:FUNCTION GET-XML-TOKENIZER-TABLE) NULL)
   (DEFINE-FUNCTION-OBJECT "TOKENIZE-XML-EXPRESSION"
    "(DEFUN (TOKENIZE-XML-EXPRESSION TOKENIZER-TOKEN BOOLEAN) ((STREAM INPUT-STREAM) (TOKENLIST TOKENIZER-TOKEN) (REGIONTAGNAME STRING) (SKIPTOREGION? BOOLEAN)))"
    (CL:FUNCTION TOKENIZE-XML-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "PROCESS-ATTRIBUTE-LIST"
    "(DEFUN (PROCESS-ATTRIBUTE-LIST CONS) ((REVERSEATTRIBUTELIST CONS) (ELEMENT XML-ELEMENT) (NAMESPACE-TABLE (KV-CONS OF STRING-WRAPPER STRING-WRAPPER))))"
    (CL:FUNCTION PROCESS-ATTRIBUTE-LIST) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-TOKEN-LIST-TO-S-EXPRESSION"
    "(DEFUN (XML-TOKEN-LIST-TO-S-EXPRESSION OBJECT) ((TOKENLIST TOKENIZER-TOKEN) (DOCTYPE XML-DOCTYPE) (DOCTYPE-DEFINITION? BOOLEAN)) :DOCUMENTATION \"Convert the XML `tokenList' (using `doctype' for guidance) into a
representative s-expression and return the result.    The `doctype' argument is
currently only used for expansion of entity references.  It can be 'null'.  The
flag `doctype-definition?' should be true only when processing the DTD definition
of a DOCTYPE tag, since it enables substitution of parameter entity values.

Every XML tag is represented as a cons-list starting with the tag as its header,
followed by a possibly empty list of keyword value pairs representing tag attributes,
followed by a possibly empty list of content expressions which might themselves
be XML expressions.  For example, the expression

    <a a1=v1 a2='v2'> foo <b a3=v3/> bar </a>

becomes

   (<a> (<a1> \\\"v1\\\" <a2> \\\"v2\\\") \\\"foo\\\" (<b> (<a3> \\\"v3\\\")) \\\"bar\\\")

when represented as an s-expression.  The tag names are subtypes of XML-OBJECT
such as XML-ELEMENT, XML-LOCAL-ATTRIBUTE, XML-GLOBAL-ATTRIBUTE, etc.
?, ! and [ prefixed tags are encoded as their own subtypes of XML-OBJECT, namely
XML-PROCESSING-INSTRUCTION, XML-DECLARATION, XML-SPECIAL, XML-COMMENT, etc.
CDATA is an XML-SPECIAL tag with a name of CDATA.

The name is available using class accessors.\" :PUBLIC? TRUE)"
    (CL:FUNCTION XML-TOKEN-LIST-TO-S-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "READ-XML-EXPRESSION"
    "(DEFUN (READ-XML-EXPRESSION OBJECT BOOLEAN) ((STREAM INPUT-STREAM) (START-TAG OBJECT)) :DOCUMENTATION \"Read one balanced XML expression from `stream' and return
its s-expression representation (see `xml-token-list-to-s-expression').  If
`startTagName' is non-`null', skip all tags until a start tag matching `start-tag'
is encountered.  XML namespaces are ignored for outside of the start tag.
Use s-expression representation to specify `start-tag', e.g., '(KIF (:version \\\"1.0\\\"))'.
The tag can be an XML element object, a symbol, a string or a cons.  If the tag is a cons
the first element can also be (name namespace) pair.

Return `true' as the second value on EOF.

CHANGE WARNING:  It is anticipated that this function will change to
 a) Properly take XML namespaces into account and
 b) require XML element objects instead of strings as the second argument.
This change will not be backwards-compatible.\" :PUBLIC? TRUE)"
    (CL:FUNCTION READ-XML-EXPRESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "READ-XML-EXPRESSIONS"
    "(DEFUN (READ-XML-EXPRESSIONS CONS) ((FILENAME STRING)) :DOCUMENTATION \"Read all of the top-level XML expressions from `filename' and
return them in a list.\")" (CL:FUNCTION READ-XML-EXPRESSIONS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF XML-EXPRESSION-ITERATOR)) :PUBLIC? TRUE)"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONSIFY CONS) ((ITER XML-EXPRESSION-ITERATOR)))"
    (CL:FUNCTION CONSIFY) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-REGION-MATCHES?"
    "(DEFUN (XML-REGION-MATCHES? BOOLEAN) ((REGIONSPEC CONS) (REGIONTAG CONS)))"
    (CL:FUNCTION XML-REGION-MATCHES?) NULL)
   (DEFINE-FUNCTION-OBJECT "COERCE-TO-XML-ELEMENT"
    "(DEFUN (COERCE-TO-XML-ELEMENT XML-ELEMENT) ((REGIONTAG OBJECT)))"
    (CL:FUNCTION COERCE-TO-XML-ELEMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-EXPRESSIONS"
    "(DEFUN (XML-EXPRESSIONS XML-EXPRESSION-ITERATOR) ((STREAM INPUT-STREAM) (REGIONTAG OBJECT)) :DOCUMENTATION \"Return an XML-expression-iterator (which see) reading from
`stream'.  `regionTag' can be used to define delimited regions from which
expressions should be considered. Use s-expression representation to specify
`regionTag', e.g., '(KIF (:version \\\"1.0\\\"))'.  The tag can be an XML element
object, a symbol, a string or a cons.  If the tag is a cons the first element
can also be (name namespace) pair.\" :PUBLIC? TRUE)"
    (CL:FUNCTION XML-EXPRESSIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-CDATA?"
    "(DEFUN (XML-CDATA? BOOLEAN) ((ITEM OBJECT)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if `item' is an XML CDATA tag object\")"
    (CL:FUNCTION XML-CDATA?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-ELEMENT?"
    "(DEFUN (XML-ELEMENT? BOOLEAN) ((ITEM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `item' is an XML element object\" (RETURN (ISA? ITEM @XML-ELEMENT)))"
    (CL:FUNCTION XML-ELEMENT?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-ATTRIBUTE?"
    "(DEFUN (XML-ATTRIBUTE? BOOLEAN) ((ITEM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `item' is an XML attribute object\" (RETURN (ISA? ITEM @XML-ATTRIBUTE)))"
    (CL:FUNCTION XML-ATTRIBUTE?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-GLOBAL-ATTRIBUTE?"
    "(DEFUN (XML-GLOBAL-ATTRIBUTE? BOOLEAN) ((ITEM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `item' is an XML attribute object\" (RETURN (ISA? ITEM @XML-GLOBAL-ATTRIBUTE)))"
    (CL:FUNCTION XML-GLOBAL-ATTRIBUTE?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-LOCAL-ATTRIBUTE?"
    "(DEFUN (XML-LOCAL-ATTRIBUTE? BOOLEAN) ((ITEM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `item' is an XML attribute object\" (RETURN (ISA? ITEM @XML-LOCAL-ATTRIBUTE)))"
    (CL:FUNCTION XML-LOCAL-ATTRIBUTE?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-BASE-ATTRIBUTE?"
    "(DEFUN (XML-BASE-ATTRIBUTE? BOOLEAN) ((ITEM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `item' is an XML attribute object\" (RETURN (AND (XML-GLOBAL-ATTRIBUTE? ITEM) (STRING-EQL? \"base\" (NAME (CAST ITEM XML-GLOBAL-ATTRIBUTE))) (STRING-EQL? *XML-URN* (NAMESPACE-URI (CAST ITEM XML-GLOBAL-ATTRIBUTE))))))"
    (CL:FUNCTION XML-BASE-ATTRIBUTE?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-DECLARATION?"
    "(DEFUN (XML-DECLARATION? BOOLEAN) ((ITEM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `item' is an XML declaration object\" (RETURN (ISA? ITEM @XML-DECLARATION)))"
    (CL:FUNCTION XML-DECLARATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-PROCESSING-INSTRUCTION?"
    "(DEFUN (XML-PROCESSING-INSTRUCTION? BOOLEAN) ((ITEM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `item' is an XML processing instruction object\" (RETURN (ISA? ITEM @XML-PROCESSING-INSTRUCTION)))"
    (CL:FUNCTION XML-PROCESSING-INSTRUCTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-ELEMENT-FORM?"
    "(DEFUN (XML-ELEMENT-FORM? BOOLEAN) ((FORM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `form' is a CONS headed by an XML ELEMENT tag\" (RETURN (AND (ISA? FORM @CONS) (XML-ELEMENT? (FIRST (CAST FORM CONS))))))"
    (CL:FUNCTION XML-ELEMENT-FORM?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-PROCESSING-INSTRUCTION-FORM?"
    "(DEFUN (XML-PROCESSING-INSTRUCTION-FORM? BOOLEAN) ((FORM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `form' is a CONS headed by an XML PROCESSING INSTRUCTION tag\" (RETURN (AND (ISA? FORM @CONS) (XML-PROCESSING-INSTRUCTION? (FIRST (CAST FORM CONS))))))"
    (CL:FUNCTION XML-PROCESSING-INSTRUCTION-FORM?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-DECLARATION-FORM?"
    "(DEFUN (XML-DECLARATION-FORM? BOOLEAN) ((FORM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `form' is a CONS headed by an XML DECLARATION tag\" (RETURN (AND (ISA? FORM @CONS) (XML-DECLARATION? (FIRST (CAST FORM CONS))))))"
    (CL:FUNCTION XML-DECLARATION-FORM?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-DOCTYPE-FORM?"
    "(DEFUN (XML-DOCTYPE-FORM? BOOLEAN) ((FORM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `form' is a CONS headed by a DOCTYPE tag\" (RETURN (AND (XML-DECLARATION-FORM? FORM) (STRING-EQL? (NAME (CAST (FIRST (CAST FORM CONS)) XML-DECLARATION)) \"DOCTYPE\"))))"
    (CL:FUNCTION XML-DOCTYPE-FORM?) NULL)
   (DEFINE-FUNCTION-OBJECT "XML-CDATA-FORM?"
    "(DEFUN (XML-CDATA-FORM? BOOLEAN) ((FORM OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return `true' if `form' is a CONS headed by a CDATA tag\" (RETURN (AND (ISA? FORM @CONS) (XML-CDATA? (FIRST (CAST FORM CONS))))))"
    (CL:FUNCTION XML-CDATA-FORM?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-XML-TAG"
    "(DEFUN (GET-XML-TAG XML-ELEMENT) ((EXPRESSION CONS)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the XML tag object of an XML `expression'.\" (RETURN (FIRST EXPRESSION)))"
    (CL:FUNCTION GET-XML-TAG) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-XML-ATTRIBUTES"
    "(DEFUN (GET-XML-ATTRIBUTES CONS) ((EXPRESSION CONS)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the list of attributes of an XML `expression' (may be empty).\" (RETURN (SECOND EXPRESSION)))"
    (CL:FUNCTION GET-XML-ATTRIBUTES) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-XML-BASE-ATTRIBUTE-VALUE"
    "(DEFUN (GET-XML-BASE-ATTRIBUTE-VALUE STRING) ((EXPRESSION CONS)) :PUBLIC? TRUE :DOCUMENTATION \"Return the last base url attribute in the attribute list of this
element if it exists.  Otherwise NULL.\")"
    (CL:FUNCTION GET-XML-BASE-ATTRIBUTE-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-XML-CONTENT"
    "(DEFUN (GET-XML-CONTENT CONS) ((EXPRESSION CONS)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the list of content elements of an XML `expression' (may be empty).\" (RETURN (REST (REST EXPRESSION))))"
    (CL:FUNCTION GET-XML-CONTENT) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-XML-CDATA-CONTENT"
    "(DEFUN (GET-XML-CDATA-CONTENT STRING) ((FORM CONS)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return the CDATA content of a CDATA `form'.  Does NOT make sure that `form'
actually is a CDATA form, so bad things can happen if it is given wrong input.\" (RETURN (UNWRAP-STRING (FIRST (CAST (SECOND FORM) CONS)))))"
    (CL:FUNCTION GET-XML-CDATA-CONTENT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (XML-ELEMENT-MATCH? BOOLEAN) ((TAG XML-ELEMENT) (NAME STRING) (NAMESPACE STRING)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Returns `true' if `tag' is an XML element with the name `name'
in namespace `namespace'.  Note that `namespace' is the full URI, not an abbreviation.
Also, `namespace' may be `null', in which case `tag' must not have a namespace
associated with it.\" (RETURN (AND (EQL? (NAME TAG) NAME) (EQL? (NAMESPACE-URI TAG) NAMESPACE))))"
    (CL:FUNCTION XML-ELEMENT-MATCH?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (XML-ATTRIBUTE-MATCH? BOOLEAN) ((ATTRIBUTE XML-ATTRIBUTE) (NAME STRING) (NAMESPACE STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if `attribute' is an XML attribute with name `name'
in namespace `namespace'.  Note that `namespace' is the full URI, not an
abbreviation.  Also, `namespace' may be `null', in which case `attribute'
must not have a namespace associated with it.\")"
    (CL:FUNCTION XML-ATTRIBUTE-MATCH?) NULL))
  :VOID)

(CL:DEFUN STARTUP-XML ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-XML1)
    (HELP-STARTUP-XML2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *XML-ELEMENT-NULL-NAMESPACE-TABLE*
     (NEW-STRING-HASH-TABLE))
    (CL:SETQ *XML-ELEMENT-HASH-TABLE* (NEW-STRING-HASH-TABLE))
    (CL:SETQ *XML-GLOBAL-ATTRIBUTE-HASH-TABLE* (NEW-STRING-HASH-TABLE))
    (CL:SETQ *XML-BASE-ENTITY-TABLE* (MAKE-XML-ENTITY-TABLE))
    (CL:SETQ *XML-TOKENIZER-TABLE-DEFINITION*
     (LIST*
      (LIST* KWD-XML-START KWD-XML-INCLUDE KWD-XML-SKIP-WHITESPACE NIL)
      (LIST* KWD-XML-SKIP-WHITESPACE SYM-XML-STELLA-!
       (LIST* (WRAP-CHARACTER #\ ) (WRAP-CHARACTER #\Tab)
        (WRAP-CHARACTER #\Linefeed) (WRAP-CHARACTER #\Return) NIL)
       KWD-XML-SKIP-WHITESPACE SYM-XML-STELLA-! (WRAP-STRING "<")
       KWD-XML-OPEN-TAG KWD-XML-EOF KWD-XML-EOF SYM-XML-STELLA-*
       KWD-XML-OTHERWISE KWD-XML-CONTENT NIL)
      (LIST* KWD-XML-CONTENT SYM-XML-STELLA-! (WRAP-STRING "<")
       KWD-XML-OPEN-TAG KWD-XML-EOF KWD-XML-EOF KWD-XML-OTHERWISE
       KWD-XML-CONTENT NIL)
      (LIST* KWD-XML-OPEN-TAG SYM-XML-STELLA-* (WRAP-STRING ">")
       KWD-XML-START-TAG-END SYM-XML-STELLA-! (WRAP-STRING "/")
       KWD-XML-OPEN-END-TAG (WRAP-STRING "?") KWD-XML-OPEN-PI-TAG
       (WRAP-STRING "!") KWD-XML-OPEN-DECLARATION-TAG
       (LIST* (WRAP-CHARACTER #\ ) (WRAP-CHARACTER #\Tab)
        (WRAP-CHARACTER #\Linefeed) (WRAP-CHARACTER #\Return) NIL)
       KWD-XML-OPEN-TAG SYM-XML-STELLA-* KWD-XML-OTHERWISE
       KWD-XML-START-TAG NIL)
      (LIST* KWD-XML-START-TAG SYM-XML-STELLA-* (WRAP-STRING ">")
       KWD-XML-START-TAG-END SYM-XML-STELLA-! (WRAP-STRING "/")
       KWD-XML-OPEN-EMPTY-TAG-END SYM-XML-STELLA-!
       (LIST* (WRAP-CHARACTER #\ ) (WRAP-CHARACTER #\Tab)
        (WRAP-CHARACTER #\Linefeed) (WRAP-CHARACTER #\Return) NIL)
       KWD-XML-SKIP-TO-ATTRIBUTE-NAME KWD-XML-OTHERWISE
       KWD-XML-START-TAG NIL)
      (LIST* KWD-XML-OPEN-PI-TAG SYM-XML-STELLA-* KWD-XML-ANY
       KWD-XML-START-PI-TAG NIL)
      (LIST* KWD-XML-START-PI-TAG SYM-XML-STELLA-! (WRAP-STRING "?")
       KWD-XML-OPEN-PI-TAG-END SYM-XML-STELLA-*
       (LIST* (WRAP-CHARACTER #\ ) (WRAP-CHARACTER #\Tab)
        (WRAP-CHARACTER #\Linefeed) (WRAP-CHARACTER #\Return) NIL)
       KWD-XML-PI-TAG-DATA KWD-XML-OTHERWISE KWD-XML-START-PI-TAG NIL)
      (LIST* KWD-XML-PI-TAG-DATA (WRAP-STRING "?")
       (LIST* KWD-XML-PI-TAG-DATA-OR-END KWD-XML-PI-TAG-DATA NIL)
       KWD-XML-OTHERWISE KWD-XML-PI-TAG-DATA NIL)
      (LIST* KWD-XML-PI-TAG-DATA-OR-END SYM-XML-STELLA-*
       (WRAP-STRING ">") KWD-XML-EMPTY-TAG-END KWD-XML-OTHERWISE
       KWD-XML-PI-TAG-DATA NIL)
      (LIST* KWD-XML-OPEN-PI-TAG-END SYM-XML-STELLA-* (WRAP-STRING ">")
       KWD-XML-EMPTY-TAG-END KWD-XML-OTHERWISE KWD-XML-ERROR NIL)
      (LIST* KWD-XML-OPEN-END-TAG SYM-XML-STELLA-! (WRAP-STRING ">")
       KWD-XML-END-TAG-END SYM-XML-STELLA-* KWD-XML-OTHERWISE
       KWD-XML-END-TAG NIL)
      (LIST* KWD-XML-END-TAG SYM-XML-STELLA-! (WRAP-STRING ">")
       KWD-XML-END-TAG-END KWD-XML-OTHERWISE KWD-XML-END-TAG NIL)
      (LIST* KWD-XML-SKIP-TO-ATTRIBUTE-NAME SYM-XML-STELLA-*
       (WRAP-STRING ">") KWD-XML-START-TAG-END SYM-XML-STELLA-!
       (WRAP-STRING "/") KWD-XML-OPEN-EMPTY-TAG-END SYM-XML-STELLA-!
       (LIST* (WRAP-CHARACTER #\ ) (WRAP-CHARACTER #\Tab)
        (WRAP-CHARACTER #\Linefeed) (WRAP-CHARACTER #\Return) NIL)
       KWD-XML-SKIP-TO-ATTRIBUTE-NAME SYM-XML-STELLA-*
       KWD-XML-OTHERWISE KWD-XML-ATTRIBUTE-NAME NIL)
      (LIST* KWD-XML-ATTRIBUTE-NAME SYM-XML-STELLA-* (WRAP-STRING ">")
       KWD-XML-START-TAG-END SYM-XML-STELLA-! (WRAP-STRING "/")
       KWD-XML-OPEN-EMPTY-TAG-END SYM-XML-STELLA-!
       (LIST* (WRAP-CHARACTER #\=) (WRAP-CHARACTER #\ )
        (WRAP-CHARACTER #\Tab) (WRAP-CHARACTER #\Linefeed)
        (WRAP-CHARACTER #\Return) NIL)
       KWD-XML-SKIP-TO-ATTRIBUTE-VALUE KWD-XML-OTHERWISE
       KWD-XML-ATTRIBUTE-NAME NIL)
      (LIST* KWD-XML-SKIP-TO-ATTRIBUTE-VALUE SYM-XML-STELLA-*
       (WRAP-STRING ">") KWD-XML-START-TAG-END SYM-XML-STELLA-!
       (WRAP-STRING "/") KWD-XML-OPEN-EMPTY-TAG-END
       (LIST* (WRAP-CHARACTER #\=) (WRAP-CHARACTER #\ )
        (WRAP-CHARACTER #\Tab) (WRAP-CHARACTER #\Linefeed)
        (WRAP-CHARACTER #\Return) NIL)
       KWD-XML-SKIP-TO-ATTRIBUTE-VALUE SYM-XML-STELLA-*
       (WRAP-STRING "'") KWD-XML-SINGLE-QUOTED-ATTRIBUTE-VALUE
       SYM-XML-STELLA-* (WRAP-STRING "\"")
       KWD-XML-DOUBLE-QUOTED-ATTRIBUTE-VALUE SYM-XML-STELLA-*
       KWD-XML-OTHERWISE KWD-XML-UNQUOTED-ATTRIBUTE-VALUE NIL)
      (LIST* KWD-XML-SINGLE-QUOTED-ATTRIBUTE-VALUE (WRAP-STRING "'")
       KWD-XML-QUOTED-ATTRIBUTE-VALUE KWD-XML-OTHERWISE
       KWD-XML-SINGLE-QUOTED-ATTRIBUTE-VALUE NIL)
      (LIST* KWD-XML-DOUBLE-QUOTED-ATTRIBUTE-VALUE (WRAP-STRING "\"")
       KWD-XML-QUOTED-ATTRIBUTE-VALUE KWD-XML-OTHERWISE
       KWD-XML-DOUBLE-QUOTED-ATTRIBUTE-VALUE NIL)
      (LIST* KWD-XML-QUOTED-ATTRIBUTE-VALUE KWD-XML-INCLUDE
       KWD-XML-SKIP-TO-ATTRIBUTE-NAME NIL)
      (LIST* KWD-XML-UNQUOTED-ATTRIBUTE-VALUE SYM-XML-STELLA-*
       (WRAP-STRING ">") KWD-XML-START-TAG-END SYM-XML-STELLA-!
       (WRAP-STRING "/") KWD-XML-OPEN-EMPTY-TAG-END SYM-XML-STELLA-!
       (LIST* (WRAP-CHARACTER #\ ) (WRAP-CHARACTER #\Tab)
        (WRAP-CHARACTER #\Linefeed) (WRAP-CHARACTER #\Return) NIL)
       KWD-XML-SKIP-TO-ATTRIBUTE-NAME KWD-XML-OTHERWISE
       KWD-XML-UNQUOTED-ATTRIBUTE-VALUE NIL)
      (LIST* KWD-XML-OPEN-DECLARATION-TAG (WRAP-STRING "-")
       KWD-XML-START-TAG-OR-COMMENT (WRAP-STRING "[")
       KWD-XML-OPEN-SPECIAL-TAG SYM-XML-STELLA-* KWD-XML-OTHERWISE
       KWD-XML-START-DECLARATION-TAG NIL)
      (LIST* KWD-XML-START-DECLARATION-TAG SYM-XML-STELLA-*
       (WRAP-STRING ">") KWD-XML-EMPTY-TAG-END SYM-XML-STELLA-!
       (LIST* (WRAP-CHARACTER #\ ) (WRAP-CHARACTER #\Tab)
        (WRAP-CHARACTER #\Linefeed) (WRAP-CHARACTER #\Return) NIL)
       KWD-XML-DECLARATION-WHITESPACE KWD-XML-OTHERWISE
       KWD-XML-START-DECLARATION-TAG NIL)
      (LIST* KWD-XML-DECLARATION-WHITESPACE SYM-XML-STELLA-!
       (LIST* (WRAP-CHARACTER #\ ) (WRAP-CHARACTER #\Tab)
        (WRAP-CHARACTER #\Linefeed) (WRAP-CHARACTER #\Return) NIL)
       KWD-XML-DECLARATION-WHITESPACE SYM-XML-STELLA-*
       (WRAP-STRING ">") KWD-XML-EMPTY-TAG-END SYM-XML-STELLA-*
       (WRAP-STRING "[") KWD-XML-DECLARATION-TAG-MARKUP-DATA-START
       SYM-XML-STELLA-* (WRAP-STRING "'")
       KWD-XML-SINGLE-QUOTED-DECLARATION-TAG-DATA SYM-XML-STELLA-*
       (WRAP-STRING "\"") KWD-XML-DOUBLE-QUOTED-DECLARATION-TAG-DATA
       SYM-XML-STELLA-* KWD-XML-OTHERWISE KWD-XML-DECLARATION-TAG-DATA
       NIL)
      (LIST* KWD-XML-DECLARATION-TAG-DATA SYM-XML-STELLA-!
       (LIST* (WRAP-CHARACTER #\ ) (WRAP-CHARACTER #\Tab)
        (WRAP-CHARACTER #\Linefeed) (WRAP-CHARACTER #\Return) NIL)
       KWD-XML-DECLARATION-WHITESPACE SYM-XML-STELLA-*
       (WRAP-STRING ">") KWD-XML-EMPTY-TAG-END SYM-XML-STELLA-*
       (WRAP-STRING "[") KWD-XML-DECLARATION-TAG-MARKUP-DATA-START
       (WRAP-STRING "'") KWD-XML-SINGLE-QUOTED-DECLARATION-TAG-DATA
       (WRAP-STRING "\"") KWD-XML-DOUBLE-QUOTED-DECLARATION-TAG-DATA
       KWD-XML-OTHERWISE KWD-XML-DECLARATION-TAG-DATA NIL)
      (LIST* KWD-XML-SINGLE-QUOTED-DECLARATION-TAG-DATA
       (WRAP-STRING "'") KWD-XML-QUOTED-DECLARATION-TAG-DATA
       KWD-XML-OTHERWISE KWD-XML-SINGLE-QUOTED-DECLARATION-TAG-DATA
       NIL)
      (LIST* KWD-XML-DOUBLE-QUOTED-DECLARATION-TAG-DATA
       (WRAP-STRING "\"") KWD-XML-QUOTED-DECLARATION-TAG-DATA
       KWD-XML-OTHERWISE KWD-XML-DOUBLE-QUOTED-DECLARATION-TAG-DATA
       NIL)
      (LIST* KWD-XML-QUOTED-DECLARATION-TAG-DATA KWD-XML-INCLUDE
       KWD-XML-DECLARATION-WHITESPACE NIL)
      (LIST* KWD-XML-DECLARATION-TAG-MARKUP-DATA-START
       (WRAP-STRING "]") KWD-XML-DECLARATION-TAG-MARKUP-DATA
       KWD-XML-OTHERWISE KWD-XML-DECLARATION-TAG-MARKUP-DATA-START NIL)
      (LIST* KWD-XML-DECLARATION-TAG-MARKUP-DATA SYM-XML-STELLA-*
       (WRAP-STRING ">") KWD-XML-EMPTY-TAG-END KWD-XML-OTHERWISE
       KWD-XML-ERROR NIL)
      (LIST* KWD-XML-OPEN-SPECIAL-TAG SYM-XML-STELLA-* KWD-XML-ANY
       KWD-XML-START-SPECIAL-TAG NIL)
      (LIST* KWD-XML-START-SPECIAL-TAG SYM-XML-STELLA-*
       (WRAP-STRING "[") KWD-XML-SPECIAL-TAG-DATA KWD-XML-OTHERWISE
       KWD-XML-START-SPECIAL-TAG NIL)
      (LIST* KWD-XML-SPECIAL-TAG-DATA (WRAP-STRING "]")
       KWD-XML-SPECIAL-TAG-DATA-OR-END KWD-XML-OTHERWISE
       KWD-XML-SPECIAL-TAG-DATA NIL)
      (LIST* KWD-XML-SPECIAL-TAG-DATA-OR-END (WRAP-STRING "]")
       (LIST* KWD-XML-SPECIAL-TAG-DATA-OR-END2 KWD-XML-SPECIAL-TAG-DATA
        NIL)
       KWD-XML-OTHERWISE KWD-XML-SPECIAL-TAG-DATA NIL)
      (LIST* KWD-XML-SPECIAL-TAG-DATA-OR-END2 SYM-XML-STELLA-*
       (WRAP-STRING ">") KWD-XML-DATA-TAG-END KWD-XML-OTHERWISE
       KWD-XML-SPECIAL-TAG-DATA NIL)
      (LIST* KWD-XML-START-TAG-OR-COMMENT (WRAP-STRING "-")
       KWD-XML-COMMENT-BODY SYM-XML-STELLA-* KWD-XML-OTHERWISE
       KWD-XML-START-TAG NIL)
      (LIST* KWD-XML-COMMENT-BODY (WRAP-STRING "-")
       KWD-XML-END-COMMENT-OR-COMMENT KWD-XML-OTHERWISE
       KWD-XML-COMMENT-BODY NIL)
      (LIST* KWD-XML-END-COMMENT-OR-COMMENT (WRAP-STRING "-")
       KWD-XML-END-COMMENT-OR-COMMENT2 KWD-XML-OTHERWISE
       KWD-XML-COMMENT-BODY NIL)
      (LIST* KWD-XML-END-COMMENT-OR-COMMENT2 (WRAP-STRING ">")
       KWD-XML-COMMENT KWD-XML-OTHERWISE KWD-XML-ERROR NIL)
      (LIST* KWD-XML-COMMENT KWD-XML-INCLUDE KWD-XML-START NIL)
      (LIST* KWD-XML-START-TAG-END KWD-XML-INCLUDE KWD-XML-START NIL)
      (LIST* KWD-XML-DATA-TAG-END KWD-XML-INCLUDE KWD-XML-START NIL)
      (LIST* KWD-XML-END-TAG-END KWD-XML-INCLUDE KWD-XML-START NIL)
      (LIST* KWD-XML-OPEN-EMPTY-TAG-END SYM-XML-STELLA-*
       (WRAP-STRING ">") KWD-XML-EMPTY-TAG-END KWD-XML-OTHERWISE
       KWD-XML-ERROR NIL)
      (LIST* KWD-XML-EMPTY-TAG-END KWD-XML-INCLUDE KWD-XML-START NIL)
      (LIST* KWD-XML-ERROR KWD-XML-INCLUDE KWD-XML-START NIL) NIL)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5) (HELP-STARTUP-XML3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-XML4)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (XML-ATTRIBUTE-MATCH? BOOLEAN) ((ATTRIBUTE XML-GLOBAL-ATTRIBUTE) (NAME STRING) (NAMESPACE STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if `attribute' is a global  XML attribute with name `name'
in namespace `namespace'.  Note that `namespace' is the full URI, not an
abbreviation.  Also, `namespace' may be `null', in which case `attribute'
must not have a namespace associated with it.\")"
     (CL:FUNCTION XML-ATTRIBUTE-MATCH?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (XML-ATTRIBUTE-MATCH? BOOLEAN) ((ATTRIBUTE XML-LOCAL-ATTRIBUTE) (NAME STRING) (NAMESPACE STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return `true' if `attribute' is a local XML attribute with name `name'.
Note that `namespace' must be `null' and that the `attribute's parent element
element is not considered by the match.  To take the parent element into
account use `xml-local-attribute-match?'.\")"
     (CL:FUNCTION XML-ATTRIBUTE-MATCH?) NULL)
    (DEFINE-FUNCTION-OBJECT "XML-GLOBAL-ATTRIBUTE-MATCH?"
     "(DEFUN (XML-GLOBAL-ATTRIBUTE-MATCH? BOOLEAN) ((ATTRIBUTE XML-GLOBAL-ATTRIBUTE) (NAME STRING) (NAMESPACE STRING)) :GLOBALLY-INLINE? TRUE (RETURN (AND (STRING-EQL? (NAME ATTRIBUTE) NAME) (EQL? (NAMESPACE-URI ATTRIBUTE) NAMESPACE))))"
     (CL:FUNCTION XML-GLOBAL-ATTRIBUTE-MATCH?) NULL)
    (DEFINE-FUNCTION-OBJECT "XML-LOCAL-ATTRIBUTE-MATCH?"
     "(DEFUN (XML-LOCAL-ATTRIBUTE-MATCH? BOOLEAN) ((ATTRIBUTE XML-LOCAL-ATTRIBUTE) (NAME STRING) (ELEMENT-NAME STRING) (ELEMENT-NAMESPACE STRING)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE :DOCUMENTATION \"Return true if `attribute' is a local attribute with `name' and whose
parent element matches `element-name' and `element-namespace'.\" (RETURN (AND (STRING-EQL? (NAME ATTRIBUTE) NAME) (XML-ELEMENT-MATCH? (PARENT-ELEMENT ATTRIBUTE) ELEMENT-NAME ELEMENT-NAMESPACE))))"
     (CL:FUNCTION XML-LOCAL-ATTRIBUTE-MATCH?) NULL)
    (DEFINE-FUNCTION-OBJECT "XML-LOOKUP-ATTRIBUTE"
     "(DEFUN (XML-LOOKUP-ATTRIBUTE STRING) ((ATTRIBUTES CONS) (NAME STRING) (NAMESPACE STRING)) :DOCUMENTATION \"Find the XML attribute in `attributes' with `name' and `namespace' and
return its value.  Note that it is assumed that all `attributes' come from
the same known tag, hence, the parent elements of any local attributes are
not considered by the lookup.\" :PUBLIC? TRUE)"
     (CL:FUNCTION XML-LOOKUP-ATTRIBUTE) NULL)
    (DEFINE-FUNCTION-OBJECT "EXPAND-XML-TAG-CASE"
     "(DEFUN (EXPAND-XML-TAG-CASE CONS) ((ITEM SYMBOL) (CLAUSES (CONS OF CONS))))"
     (CL:FUNCTION EXPAND-XML-TAG-CASE) NULL)
    (DEFINE-FUNCTION-OBJECT "XML-TAG-CASE"
     "(DEFUN XML-TAG-CASE ((ITEM OBJECT) |&BODY| (CLAUSES CONS)) :TYPE OBJECT :MACRO? TRUE :PUBLIC? TRUE :DOCUMENTATION \"A case form for matching `item' against XML element tags.  Each
element of `clauses' should be a clause with the form
  (\\\"tagname\\\" ...)     or
  ((\\\"tagname\\\" \\\"namespace-uri\\\") ...)
The clause heads can optionally be symbols instead of strings.  The key forms the
parameters to the method `xml-element-match?', with a missing namespace argument
passed as NULL.

The namespace argument will be evaluated, so one can use bound variables in
place of a fixed string.   As a special case, if the namespace argument is
:ANY, then the test will be done for a match on the tag name alone.\")"
     (CL:FUNCTION XML-TAG-CASE) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-XML-NON-ELEMENT-ATTRIBUTES"
     "(DEFUN PRINT-XML-NON-ELEMENT-ATTRIBUTES ((STREAM OUTPUT-STREAM) (ATTRIBUTES CONS)))"
     (CL:FUNCTION PRINT-XML-NON-ELEMENT-ATTRIBUTES) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-XML-ELEMENT-ATTRIBUTES"
     "(DEFUN PRINT-XML-ELEMENT-ATTRIBUTES ((STREAM OUTPUT-STREAM) (ATTRIBUTES CONS)))"
     (CL:FUNCTION PRINT-XML-ELEMENT-ATTRIBUTES) NULL)
    (DEFINE-FUNCTION-OBJECT "PRINT-XML-EXPRESSION"
     "(DEFUN PRINT-XML-EXPRESSION ((STREAM OUTPUT-STREAM) (XML-EXPRESSION CONS) (INDENT INTEGER)) :DOCUMENTATION \"Prints `xml-expression' on `stream'.  Indentation begins with the
value of `indent'.  If this is the `null' integer, no indentation is
performed.  Otherwise it should normally be specified as 0 (zero) for
top-level calls.

It is assumed that the `xml-expression' is a well-formed CONS-list
representation of an XML  form.  It expects a form like that form
returned by `read-XML-expression'.

Also handles a list of xml forms such as that returned by `XML-expressions'.
In that case, each of the forms is indented by `indent' spaces.\" :PUBLIC? TRUE)"
     (CL:FUNCTION PRINT-XML-EXPRESSION) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-XML"
     "(DEFUN STARTUP-XML () :PUBLIC? TRUE)" (CL:FUNCTION STARTUP-XML)
     NULL)
    (CL:LET* ((FUNCTION (LOOKUP-FUNCTION SYM-XML-STELLA-STARTUP-XML)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-XML-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupXml") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT *XML-URN* STRING \"http://www.w3.org/XML/1998/namespaces\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT *HTML-V4-0-URN* STRING \"http://www.w3.org/TR/REC-html40\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *XML-ELEMENT-NULL-NAMESPACE-TABLE* (STRING-HASH-TABLE OF STRING XML-ELEMENT) (NEW (STRING-HASH-TABLE OF STRING XML-ELEMENT)) :DOCUMENTATION \"Hash Table for interning XML elements that don't appear in any namespace.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *XML-ELEMENT-HASH-TABLE* (STRING-HASH-TABLE OF STRING (STRING-HASH-TABLE OF STRING XML-ELEMENT)) (NEW (STRING-HASH-TABLE OF STRING (STRING-HASH-TABLE OF STRING XML-ELEMENT))) :DOCUMENTATION \"Hash Table mapping URI's (for namespaces) to a Hash Table
for interning XML elements.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *XML-GLOBAL-ATTRIBUTE-HASH-TABLE* (STRING-HASH-TABLE OF STRING (STRING-HASH-TABLE OF STRING XML-ATTRIBUTE)) (NEW (STRING-HASH-TABLE OF STRING (STRING-HASH-TABLE OF STRING XML-ATTRIBUTE))) :DOCUMENTATION \"Hash Table mapping URI's (for namespaces) to a Hash Table
for interning XML global attributes.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *XML-BASE-ENTITY-TABLE* (KEY-VALUE-LIST OF STRING-WRAPPER STRING-WRAPPER) (MAKE-XML-ENTITY-TABLE))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *XML-TOKENIZER-TABLE-DEFINITION* CONS (BQUOTE ((:START :INCLUDE :SKIP-WHITESPACE) (:SKIP-WHITESPACE ! (#\\  #\\Tab #\\Linefeed #\\Return) :SKIP-WHITESPACE ! \"<\" :OPEN-TAG :EOF :EOF * :OTHERWISE :CONTENT) (:CONTENT ! \"<\" :OPEN-TAG :EOF :EOF :OTHERWISE :CONTENT) (:OPEN-TAG * \">\" :START-TAG-END ! \"/\" :OPEN-END-TAG \"?\" :OPEN-PI-TAG \"!\" :OPEN-DECLARATION-TAG (#\\  #\\Tab #\\Linefeed #\\Return) :OPEN-TAG * :OTHERWISE :START-TAG) (:START-TAG * \">\" :START-TAG-END ! \"/\" :OPEN-EMPTY-TAG-END ! (#\\  #\\Tab #\\Linefeed #\\Return) :SKIP-TO-ATTRIBUTE-NAME :OTHERWISE :START-TAG) (:OPEN-PI-TAG * :ANY :START-PI-TAG) (:START-PI-TAG ! \"?\" :OPEN-PI-TAG-END * (#\\  #\\Tab #\\Linefeed #\\Return) :PI-TAG-DATA :OTHERWISE :START-PI-TAG) (:PI-TAG-DATA \"?\" (:PI-TAG-DATA-OR-END :PI-TAG-DATA) :OTHERWISE :PI-TAG-DATA) (:PI-TAG-DATA-OR-END * \">\" :EMPTY-TAG-END :OTHERWISE :PI-TAG-DATA) (:OPEN-PI-TAG-END * \">\" :EMPTY-TAG-END :OTHERWISE :ERROR) (:OPEN-END-TAG ! \">\" :END-TAG-END * :OTHERWISE :END-TAG) (:END-TAG ! \">\" :END-TAG-END :OTHERWISE :END-TAG) (:SKIP-TO-ATTRIBUTE-NAME * \">\" :START-TAG-END ! \"/\" :OPEN-EMPTY-TAG-END ! (#\\  #\\Tab #\\Linefeed #\\Return) :SKIP-TO-ATTRIBUTE-NAME * :OTHERWISE :ATTRIBUTE-NAME) (:ATTRIBUTE-NAME * \">\" :START-TAG-END ! \"/\" :OPEN-EMPTY-TAG-END ! (#\\= #\\  #\\Tab #\\Linefeed #\\Return) :SKIP-TO-ATTRIBUTE-VALUE :OTHERWISE :ATTRIBUTE-NAME) (:SKIP-TO-ATTRIBUTE-VALUE * \">\" :START-TAG-END ! \"/\" :OPEN-EMPTY-TAG-END (#\\= #\\  #\\Tab #\\Linefeed #\\Return) :SKIP-TO-ATTRIBUTE-VALUE * \"'\" :SINGLE-QUOTED-ATTRIBUTE-VALUE * \"\\\"\" :DOUBLE-QUOTED-ATTRIBUTE-VALUE * :OTHERWISE :UNQUOTED-ATTRIBUTE-VALUE) (:SINGLE-QUOTED-ATTRIBUTE-VALUE \"'\" :QUOTED-ATTRIBUTE-VALUE :OTHERWISE :SINGLE-QUOTED-ATTRIBUTE-VALUE) (:DOUBLE-QUOTED-ATTRIBUTE-VALUE \"\\\"\" :QUOTED-ATTRIBUTE-VALUE :OTHERWISE :DOUBLE-QUOTED-ATTRIBUTE-VALUE) (:QUOTED-ATTRIBUTE-VALUE :INCLUDE :SKIP-TO-ATTRIBUTE-NAME) (:UNQUOTED-ATTRIBUTE-VALUE * \">\" :START-TAG-END ! \"/\" :OPEN-EMPTY-TAG-END ! (#\\  #\\Tab #\\Linefeed #\\Return) :SKIP-TO-ATTRIBUTE-NAME :OTHERWISE :UNQUOTED-ATTRIBUTE-VALUE) (:OPEN-DECLARATION-TAG \"-\" :START-TAG-OR-COMMENT \"[\" :OPEN-SPECIAL-TAG * :OTHERWISE :START-DECLARATION-TAG) (:START-DECLARATION-TAG * \">\" :EMPTY-TAG-END ! (#\\  #\\Tab #\\Linefeed #\\Return) :DECLARATION-WHITESPACE :OTHERWISE :START-DECLARATION-TAG) (:DECLARATION-WHITESPACE ! (#\\  #\\Tab #\\Linefeed #\\Return) :DECLARATION-WHITESPACE * \">\" :EMPTY-TAG-END * \"[\" :DECLARATION-TAG-MARKUP-DATA-START * \"'\" :SINGLE-QUOTED-DECLARATION-TAG-DATA * \"\\\"\" :DOUBLE-QUOTED-DECLARATION-TAG-DATA * :OTHERWISE :DECLARATION-TAG-DATA) (:DECLARATION-TAG-DATA ! (#\\  #\\Tab #\\Linefeed #\\Return) :DECLARATION-WHITESPACE * \">\" :EMPTY-TAG-END * \"[\" :DECLARATION-TAG-MARKUP-DATA-START \"'\" :SINGLE-QUOTED-DECLARATION-TAG-DATA \"\\\"\" :DOUBLE-QUOTED-DECLARATION-TAG-DATA :OTHERWISE :DECLARATION-TAG-DATA) (:SINGLE-QUOTED-DECLARATION-TAG-DATA \"'\" :QUOTED-DECLARATION-TAG-DATA :OTHERWISE :SINGLE-QUOTED-DECLARATION-TAG-DATA) (:DOUBLE-QUOTED-DECLARATION-TAG-DATA \"\\\"\" :QUOTED-DECLARATION-TAG-DATA :OTHERWISE :DOUBLE-QUOTED-DECLARATION-TAG-DATA) (:QUOTED-DECLARATION-TAG-DATA :INCLUDE :DECLARATION-WHITESPACE) (:DECLARATION-TAG-MARKUP-DATA-START \"]\" :DECLARATION-TAG-MARKUP-DATA :OTHERWISE :DECLARATION-TAG-MARKUP-DATA-START) (:DECLARATION-TAG-MARKUP-DATA * \">\" :EMPTY-TAG-END :OTHERWISE :ERROR) (:OPEN-SPECIAL-TAG * :ANY :START-SPECIAL-TAG) (:START-SPECIAL-TAG * \"[\" :SPECIAL-TAG-DATA :OTHERWISE :START-SPECIAL-TAG) (:SPECIAL-TAG-DATA \"]\" :SPECIAL-TAG-DATA-OR-END :OTHERWISE :SPECIAL-TAG-DATA) (:SPECIAL-TAG-DATA-OR-END \"]\" (:SPECIAL-TAG-DATA-OR-END2 :SPECIAL-TAG-DATA) :OTHERWISE :SPECIAL-TAG-DATA) (:SPECIAL-TAG-DATA-OR-END2 * \">\" :DATA-TAG-END :OTHERWISE :SPECIAL-TAG-DATA) (:START-TAG-OR-COMMENT \"-\" :COMMENT-BODY * :OTHERWISE :START-TAG) (:COMMENT-BODY \"-\" :END-COMMENT-OR-COMMENT :OTHERWISE :COMMENT-BODY) (:END-COMMENT-OR-COMMENT \"-\" :END-COMMENT-OR-COMMENT2 :OTHERWISE :COMMENT-BODY) (:END-COMMENT-OR-COMMENT2 \">\" :COMMENT :OTHERWISE :ERROR) (:COMMENT :INCLUDE :START) (:START-TAG-END :INCLUDE :START) (:DATA-TAG-END :INCLUDE :START) (:END-TAG-END :INCLUDE :START) (:OPEN-EMPTY-TAG-END * \">\" :EMPTY-TAG-END :OTHERWISE :ERROR) (:EMPTY-TAG-END :INCLUDE :START) (:ERROR :INCLUDE :START))))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *XML-TOKENIZER-TABLE* TOKENIZER-TABLE NULL)")
    (CL:SETQ *XML-TOKENIZER-TABLE*
     (PARSE-TOKENIZER-DEFINITION *XML-TOKENIZER-TABLE-DEFINITION*))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *XML-PRESERVE-ALL-WHITESPACE?* BOOLEAN FALSE :DOCUMENTATION \"If true, all whitespace between tags (newlines, trailing WP, etc.)
will be preserved.  This is a kludge to allow us to read certain `illegal' XML files
where this whitespace is significant but not appropriately encoded.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *XML-WHITESPACE-PRESERVING-TOKENIZER-TABLE* TOKENIZER-TABLE NULL)")))
  :VOID)
