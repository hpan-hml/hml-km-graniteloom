;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; foreach.slisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2014      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-FOREACH-STELLA-AS NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-COMMA NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-DO NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-COLLECT NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-VOID NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-PREFIX-FOREACH NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-IN NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-X NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-NIL NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-WHERE NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-INTO NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-COLLECT-INTO NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-FOREACH NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-EXISTS NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-FORALL NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-SOME NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-INTERVAL NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-INTEGER-INTERVAL NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-CONS NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-UNKNOWN NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-ABSTRACT-ITERATOR NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-ALLOCATE-ITERATOR NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-FALSE NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-ARGUMENT-LIST NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-STRING NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-MUTABLE-STRING NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-VECTOR NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-SEQUENCE-MIXIN NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-THE-ARRAY NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-LIST NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-THE-CONS-LIST NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-KEY-VALUE-LIST NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-KV-CONS NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-THE-KV-LIST NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-PROPERTY-LIST NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-THE-PLIST NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-KEY NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-VALUE NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-SETQ NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-REST NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-NOT NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-NIL? NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-DEFINED? NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-NEXT? NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-NULL NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-ANY-VALUE NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-ANY-KEY NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-NULL-INTEGER NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-INTEGER NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-NUMBER-WRAPPER NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-BOOLEAN NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-NULL? NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-++ NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-TRUE NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-<= NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-OR NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-1- NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-- NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-< NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-LENGTH NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-CHARACTER NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-NTH NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-ARGUMENT-LIST-ITERATOR NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-SYS-CALL-METHOD NULL)
(CL:DEFVAR SGT-FOREACH-STELLA-LITERAL NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-ON NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-AND NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-IF NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-PROGN NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-CONS NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-EMPTY? NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-SETF NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-ADD-CONS-TO-END-OF-CONS-LIST NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-COND NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-CONS? NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-OTHERWISE NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-WHEN NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-SYS-FOREACH NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-VRLET NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-BREAK NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-ALWAYS NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-STARTUP-FOREACH NULL)
(CL:DEFVAR SYM-FOREACH-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* NULL-INTEGER *METHODBEINGWALKED*
  ONE-WRAPPER *SPECIALVARIABLESTACK* STANDARD-ERROR EOL NIL))

;;; (DEFUN (EXTRACT-ONE-IN-CLAUSE CONS CONS) ...)

(CL:DEFUN EXTRACT-ONE-IN-CLAUSE (TAIL)
  (CL:LET*
   ((VARIABLE (%%VALUE TAIL)) (OPERATOR (%%VALUE (%%REST TAIL)))
    (CLAUSE TAIL))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CL:OR (SYMBOL? VARIABLE) (CONS? VARIABLE))
      (MEMBER? (GET-QUOTED-TREE "((IN ON ISA) \"/STELLA\")" "/STELLA")
       OPERATOR)
      (CL:NOT (CL:EQ (%%VALUE (%%REST (%%REST TAIL))) NULL))))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal syntax where 'IN', 'ON', or 'ISA' clause expected:"
       EOL "   `" (DE-UGLIFY-PARSE-TREE TAIL) "'." EOL)))
    (CL:RETURN-FROM EXTRACT-ONE-IN-CLAUSE (CL:VALUES NULL NIL)))
   (FIRST-SETTER CLAUSE OPERATOR) (SECOND-SETTER CLAUSE VARIABLE)
   (CL:SETQ TAIL (%%REST (%%REST (%%REST TAIL))))
   (CL:SETF (%%REST (%%REST (%%REST CLAUSE))) NIL)
   (CL:RETURN-FROM EXTRACT-ONE-IN-CLAUSE (CL:VALUES CLAUSE TAIL))))

;;; (DEFUN (EXTRACT-ONE-GENERATOR-TERM CONS CONS) ...)

(CL:DEFUN EXTRACT-ONE-GENERATOR-TERM (TAIL)
  (CL:LET* ((INCLAUSE NULL) (RESIDUE NULL) (PARALLELTERMS NULL))
   (CL:MULTIPLE-VALUE-SETQ (INCLAUSE RESIDUE)
    (EXTRACT-ONE-IN-CLAUSE TAIL))
   (CL:WHEN (CL:NOT (CL:EQ (%%VALUE RESIDUE) SYM-FOREACH-STELLA-AS))
    (CL:RETURN-FROM EXTRACT-ONE-GENERATOR-TERM
     (CL:VALUES INCLAUSE RESIDUE)))
   (CL:SETQ PARALLELTERMS
    (CONS INCLAUSE (CONS SYM-FOREACH-STELLA-AS NIL)))
   (CL:LOOP WHILE (CL:EQ (%%VALUE RESIDUE) SYM-FOREACH-STELLA-AS) DO
    (CL:SETQ RESIDUE (%%REST RESIDUE))
    (CL:MULTIPLE-VALUE-SETQ (INCLAUSE RESIDUE)
     (EXTRACT-ONE-IN-CLAUSE RESIDUE))
    (CL:SETQ PARALLELTERMS (CONS INCLAUSE PARALLELTERMS)))
   (CL:RETURN-FROM EXTRACT-ONE-GENERATOR-TERM
    (CL:VALUES (REVERSE PARALLELTERMS) RESIDUE))))

;;; (DEFUN (EXTRACT-GENERATORS-CLAUSE CONS CONS) ...)

(CL:DEFUN EXTRACT-GENERATORS-CLAUSE (TAIL)
  (CL:LET*
   ((GENERATORTERM NULL) (RESIDUE NULL) (GENERATORSCLAUSE NULL))
   (CL:MULTIPLE-VALUE-SETQ (GENERATORTERM RESIDUE)
    (EXTRACT-ONE-GENERATOR-TERM TAIL))
   (CL:WHEN (CL:NOT (CL:EQ (%%VALUE RESIDUE) SYM-FOREACH-STELLA-COMMA))
    (CL:RETURN-FROM EXTRACT-GENERATORS-CLAUSE
     (CL:VALUES GENERATORTERM RESIDUE)))
   (CL:SETQ GENERATORSCLAUSE
    (CONS GENERATORTERM (CONS SYM-FOREACH-STELLA-COMMA NIL)))
   (CL:LOOP WHILE (CL:EQ (%%VALUE RESIDUE) SYM-FOREACH-STELLA-COMMA) DO
    (CL:MULTIPLE-VALUE-SETQ (GENERATORTERM RESIDUE)
     (EXTRACT-ONE-GENERATOR-TERM (%%REST RESIDUE)))
    (CL:SETQ GENERATORSCLAUSE (CONS GENERATORTERM GENERATORSCLAUSE)))
   (CL:RETURN-FROM EXTRACT-GENERATORS-CLAUSE
    (CL:VALUES (REVERSE GENERATORSCLAUSE) RESIDUE))))

;;; (DEFUN (EXTRACT-OPTION-AND-RESIDUE OBJECT CONS) ...)

(CL:DEFUN EXTRACT-OPTION-AND-RESIDUE (OPTION TAIL)
  (CL:WHEN (CL:NOT (CL:EQ (%%VALUE TAIL) OPTION))
   (CL:RETURN-FROM EXTRACT-OPTION-AND-RESIDUE (CL:VALUES NULL TAIL)))
  (CL:LET* ((ARGUMENT NULL) (RESIDUE NULL))
   (CL:SETQ ARGUMENT (%%VALUE (%%REST TAIL)))
   (CL:SETQ RESIDUE (%%REST (%%REST TAIL)))
   (CL:RETURN-FROM EXTRACT-OPTION-AND-RESIDUE
    (CL:VALUES ARGUMENT RESIDUE))))

;;; (DEFUN (EXTRACT-DO-CLAUSE CONS CONS) ...)

(CL:DEFUN EXTRACT-DO-CLAUSE (TAIL)
  (CL:WHEN (CL:NOT (CL:EQ (%%VALUE TAIL) SYM-FOREACH-STELLA-DO))
   (CL:RETURN-FROM EXTRACT-DO-CLAUSE (CL:VALUES NULL TAIL)))
  (CL:LET* ((DOCLAUSE TAIL) (LASTDOCONS NULL))
   (CL:SETQ TAIL (%%REST TAIL))
   (CL:LOOP WHILE
    (CL:AND (CL:NOT (CL:EQ TAIL NIL))
     (CL:NOT (CL:EQ (%%VALUE TAIL) SYM-FOREACH-STELLA-COLLECT)))
    DO (CL:SETQ LASTDOCONS TAIL) (CL:SETQ TAIL (%%REST TAIL)))
   (CL:IF (CL:EQ LASTDOCONS NULL)
    (CL:PROGN
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Missing arguments to DO separator." EOL)))
     (CL:SETF (%%REST DOCLAUSE)
      (CONS-LIST
       (WALK-DONT-CALL-ME-TREE NIL SGT-FOREACH-STELLA-VOID))))
    (CL:SETF (%%REST LASTDOCONS) NIL))
   (CL:RETURN-FROM EXTRACT-DO-CLAUSE (CL:VALUES DOCLAUSE TAIL))))

;;; (DEFUN (FOREACH-TO-PREFIX-FOREACH-TREE CONS) ...)

(CL:DEFUN FOREACH-TO-PREFIX-FOREACH-TREE (FOREACHTREE)
  (CL:LET*
   ((GENERATORSCLAUSE NULL) (FILTERCLAUSE NULL) (DOCLAUSE NULL)
    (COLLECTCLAUSE NULL) (INTOCLAUSE NULL)
    (RESIDUE (%%REST FOREACHTREE)) (OTREE NULL))
   (CL:MULTIPLE-VALUE-SETQ (GENERATORSCLAUSE RESIDUE)
    (EXTRACT-GENERATORS-CLAUSE RESIDUE))
   (CL:WHEN (CL:EQ GENERATORSCLAUSE NULL)
    (CL:RETURN-FROM FOREACH-TO-PREFIX-FOREACH-TREE
     (LIST* SYM-FOREACH-STELLA-PREFIX-FOREACH
      (LIST* SYM-FOREACH-STELLA-IN SYM-FOREACH-STELLA-X
       SYM-FOREACH-STELLA-NIL NIL)
      (LIST* SYM-FOREACH-STELLA-DO
       (WALK-DONT-CALL-ME-TREE OTREE SGT-FOREACH-STELLA-VOID) NIL)
      NIL)))
   (CL:MULTIPLE-VALUE-SETQ (FILTERCLAUSE RESIDUE)
    (EXTRACT-OPTION-AND-RESIDUE SYM-FOREACH-STELLA-WHERE RESIDUE))
   (CL:WHEN (CL:NOT (CL:EQ FILTERCLAUSE NULL))
    (CL:SETQ FILTERCLAUSE
     (LIST* SYM-FOREACH-STELLA-WHERE FILTERCLAUSE NIL)))
   (CL:MULTIPLE-VALUE-SETQ (DOCLAUSE RESIDUE)
    (EXTRACT-DO-CLAUSE RESIDUE))
   (CL:MULTIPLE-VALUE-SETQ (COLLECTCLAUSE RESIDUE)
    (EXTRACT-OPTION-AND-RESIDUE SYM-FOREACH-STELLA-COLLECT RESIDUE))
   (CL:MULTIPLE-VALUE-SETQ (INTOCLAUSE RESIDUE)
    (EXTRACT-OPTION-AND-RESIDUE SYM-FOREACH-STELLA-INTO RESIDUE))
   (CL:WHEN
    (CL:OR (CL:NOT (CL:EQ COLLECTCLAUSE NULL))
     (CL:NOT (CL:EQ INTOCLAUSE NULL)))
    (CL:SETQ COLLECTCLAUSE
     (LIST* SYM-FOREACH-STELLA-COLLECT-INTO COLLECTCLAUSE
      (CONS INTOCLAUSE NIL))))
   (CL:SETQ OTREE
    (LIST* SYM-FOREACH-STELLA-PREFIX-FOREACH GENERATORSCLAUSE
     (CONCATENATE
      (CL:IF (CL:NOT (CL:EQ FILTERCLAUSE NULL)) (CONS FILTERCLAUSE NIL)
       NIL)
      (CONCATENATE
       (CL:IF (CL:NOT (CL:EQ DOCLAUSE NULL)) (CONS DOCLAUSE NIL) NIL)
       (CONCATENATE
        (CL:IF (CL:NOT (CL:EQ COLLECTCLAUSE NULL))
         (CONS COLLECTCLAUSE NIL) NIL)
        NIL)))))
   (CL:WHEN
    (CL:OR
     (CL:AND (CL:NOT (CL:EQ COLLECTCLAUSE NULL))
      (CL:EQ INTOCLAUSE NULL))
     (CL:AND (CL:NOT (CL:EQ INTOCLAUSE NULL))
      (CL:EQ COLLECTCLAUSE NULL)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Missing COLLECT or INTO clause in." EOL)))
    (CL:RETURN-FROM FOREACH-TO-PREFIX-FOREACH-TREE
     (LIST* SYM-FOREACH-STELLA-PREFIX-FOREACH
      (LIST* SYM-FOREACH-STELLA-IN SYM-FOREACH-STELLA-X
       SYM-FOREACH-STELLA-NIL NIL)
      (LIST* SYM-FOREACH-STELLA-DO
       (WALK-DONT-CALL-ME-TREE OTREE SGT-FOREACH-STELLA-VOID) NIL)
      NIL)))
   (CL:WHEN (CL:NOT (CL:EQ RESIDUE NIL))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Extra expressions at the end of foreach statement: `"
       (DE-UGLIFY-PARSE-TREE RESIDUE) "'." EOL)))
    (CL:RETURN-FROM FOREACH-TO-PREFIX-FOREACH-TREE
     (LIST* SYM-FOREACH-STELLA-PREFIX-FOREACH
      (LIST* SYM-FOREACH-STELLA-IN SYM-FOREACH-STELLA-X
       SYM-FOREACH-STELLA-NIL NIL)
      (LIST* SYM-FOREACH-STELLA-DO
       (WALK-DONT-CALL-ME-TREE OTREE SGT-FOREACH-STELLA-VOID) NIL)
      NIL)))
   (CL:RETURN-FROM FOREACH-TO-PREFIX-FOREACH-TREE OTREE)))

;;; (DEFUN (WALK-FOREACH-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-FOREACH-TREE (TREE)
  (CL:LET* ((*NOFSPECIALSATLOOPENTRY* (LENGTH *SPECIALVARIABLESTACK*)))
   (CL:DECLARE (CL:SPECIAL *NOFSPECIALSATLOOPENTRY*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM *NOFSPECIALSATLOOPENTRY*))
   (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SYM-FOREACH-STELLA-FOREACH)
      (CL:RETURN-FROM WALK-FOREACH-TREE
       (WALK-PREFIX-FOREACH-TREE
        (FOREACH-TO-PREFIX-FOREACH-TREE TREE))))
     ((CL:EQ TEST-VALUE-000 SYM-FOREACH-STELLA-EXISTS)
      (CL:RETURN-FROM WALK-FOREACH-TREE (WALK-EXISTS-TREE TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-FOREACH-STELLA-FORALL)
      (CL:RETURN-FROM WALK-FOREACH-TREE (WALK-FORALL-TREE TREE)))
     ((CL:EQ TEST-VALUE-000 SYM-FOREACH-STELLA-SOME)
      (CL:RETURN-FROM WALK-FOREACH-TREE (WALK-SOME-TREE TREE)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
        "`" TEST-VALUE-000 "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

;;; (DEFUN (WALK-COLLECTION-TREE OBJECT TYPE-SPEC) ...)

(CL:DEFUN WALK-COLLECTION-TREE (TREE DONTOPTIMIZE?)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-FOREACH-STELLA-CONS)
    (CL:PROGN
     (CL:WHEN
      (CL:AND (CL:NOT DONTOPTIMIZE?)
       (CL:EQ (%%VALUE TREE) SYM-FOREACH-STELLA-INTERVAL)
       (CL:= (LENGTH TREE) 3))
      (CL:RETURN-FROM WALK-COLLECTION-TREE
       (CL:VALUES TREE SGT-FOREACH-STELLA-INTEGER-INTERVAL)))))
   (CL:T))
  (CL:LET* ((OTREE NULL) (OTYPE NULL))
   (CL:MULTIPLE-VALUE-SETQ (OTREE OTYPE)
    (WALK-EXPRESSION-TREE TREE SGT-FOREACH-STELLA-UNKNOWN
     SYM-FOREACH-STELLA-FOREACH CL:NIL))
   (CL:RETURN-FROM WALK-COLLECTION-TREE (SYS-TREE OTREE OTYPE))))

;;; (DEFUN (YIELD-IN-CURSOR-CLAUSES CONS CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-IN-CURSOR-CLAUSES (INTREE DONTOPTIMIZE?)
  (CL:LET*
   ((VARTREE (%%VALUE (%%REST INTREE))) (KEYVAR NULL) (VALUEVAR NULL)
    (COLLECTIONBASETYPE NULL))
   (CL:LET* ((COLLECTIONTREE NULL) (COLLECTIONTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ (COLLECTIONTREE COLLECTIONTYPE)
     (WALK-COLLECTION-TREE (%%VALUE (%%REST (%%REST INTREE)))
      DONTOPTIMIZE?))
    (THIRD-SETTER INTREE NULL)
    (CL:SETQ COLLECTIONBASETYPE
     (TYPE-SPEC-TO-BASE-TYPE COLLECTIONTYPE))
    (CL:WHEN
     (CL:AND DONTOPTIMIZE?
      (CL:NOT
       (SAFE-SUBTYPE-OF? COLLECTIONBASETYPE
        SGT-FOREACH-STELLA-ABSTRACT-ITERATOR)))
     (CL:MULTIPLE-VALUE-SETQ (COLLECTIONTREE COLLECTIONTYPE)
      (WALK-COLLECTION-TREE
       (LIST* SYM-FOREACH-STELLA-ALLOCATE-ITERATOR COLLECTIONTREE NIL)
       CL:T))
     (CL:SETQ COLLECTIONBASETYPE
      (TYPE-SPEC-TO-BASE-TYPE COLLECTIONTYPE)))
    (CL:COND
     ((CL:EQ (SAFE-PRIMARY-TYPE VARTREE) SGT-FOREACH-STELLA-CONS)
      (CL:PROGN
       (CL:WHEN (CL:NOT (CL:= (LENGTH VARTREE) 2))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
           EOL " Illegal number of variables in IN clause: `"
           (DE-UGLIFY-PARSE-TREE INTREE) "'." EOL)))
        (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES
         (CL:VALUES NIL NIL NIL SYM-FOREACH-STELLA-FALSE)))
       (CL:SETQ KEYVAR (%%VALUE VARTREE))
       (CL:SETQ VALUEVAR (%%VALUE (%%REST VARTREE)))))
     (CL:T (CL:SETQ VALUEVAR VARTREE)))
    (CL:COND
     ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-INTEGER-INTERVAL)
      (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES
       (YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL COLLECTIONTREE
        COLLECTIONTYPE KEYVAR VALUEVAR)))
     ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-ARGUMENT-LIST)
      (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES
       (YIELD-IN-CURSOR-CLAUSES-FOR-ARGUMENT-LIST COLLECTIONTREE
        COLLECTIONTYPE KEYVAR VALUEVAR)))
     (CL:T
      (CL:IF (USE-VECTOR-STYLE-ITERATION? COLLECTIONBASETYPE)
       (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES
        (YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR COLLECTIONTREE
         COLLECTIONTYPE KEYVAR VALUEVAR))
       (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES
        (YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION COLLECTIONTREE
         COLLECTIONTYPE KEYVAR VALUEVAR))))))))

;;; (DEFUN (USE-VECTOR-STYLE-ITERATION? BOOLEAN) ...)

(CL:DEFUN USE-VECTOR-STYLE-ITERATION? (COLLECTIONTYPE)
  (CL:RETURN-FROM USE-VECTOR-STYLE-ITERATION?
   (CL:OR (CL:EQ COLLECTIONTYPE SGT-FOREACH-STELLA-STRING)
    (CL:EQ COLLECTIONTYPE SGT-FOREACH-STELLA-MUTABLE-STRING)
    (SAFE-SUBTYPE-OF? COLLECTIONTYPE SGT-FOREACH-STELLA-VECTOR)
    (CL:AND
     (SAFE-SUBTYPE-OF? COLLECTIONTYPE
      SGT-FOREACH-STELLA-SEQUENCE-MIXIN)
     (CL:NOT
      (CL:EQ
       (LOOKUP-SLOT (%SURROGATE.SURROGATE-VALUE COLLECTIONTYPE)
        SYM-FOREACH-STELLA-THE-ARRAY)
       NULL))))))

;;; (DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION CONS CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION (COLLECTIONTREE COLLECTIONTYPE KEYVAR VALUEVAR)
  (CL:LET*
   ((COLLECTIONBASETYPE (TYPE-SPEC-TO-BASE-TYPE COLLECTIONTYPE))
    (ITERATORVAR (LOCAL-GENSYM "ITER")) (ITERATORCLAUSES NIL)
    (VALUECLAUSES NIL) (CONTINUATIONTEST NULL) (KEYTREE NIL)
    (VALUETREE NIL) (BUMPTREES NIL))
   (CL:COND
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-LIST)
     (CL:SETQ ITERATORCLAUSES
      (CONS
       (CONS ITERATORVAR
        (LIST* SGT-FOREACH-STELLA-CONS
         (LIST* SYM-FOREACH-STELLA-THE-CONS-LIST COLLECTIONTREE NIL)
         NIL))
       NIL))
     (CL:SETQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-CONS))
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-KEY-VALUE-LIST)
     (CL:SETQ ITERATORCLAUSES
      (CONS
       (CONS ITERATORVAR
        (LIST* SGT-FOREACH-STELLA-KV-CONS
         (LIST* SYM-FOREACH-STELLA-THE-KV-LIST COLLECTIONTREE NIL)
         NIL))
       NIL))
     (CL:SETQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-KV-CONS))
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-PROPERTY-LIST)
     (CL:SETQ ITERATORCLAUSES
      (CONS
       (CONS ITERATORVAR
        (LIST* SGT-FOREACH-STELLA-CONS
         (LIST* SYM-FOREACH-STELLA-THE-PLIST COLLECTIONTREE NIL) NIL))
       NIL)))
    ((CL:OR (CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-CONS)
      (CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-KV-CONS))
     (CL:SETQ ITERATORCLAUSES
      (CONS
       (CONS ITERATORVAR
        (CONS COLLECTIONBASETYPE (CONS COLLECTIONTREE NIL)))
       NIL)))
    (CL:T
     (CL:WHEN
      (CL:NOT
       (SAFE-SUBTYPE-OF? COLLECTIONBASETYPE
        SGT-FOREACH-STELLA-ABSTRACT-ITERATOR))
      (CL:SETQ COLLECTIONTREE
       (LIST* SYM-FOREACH-STELLA-ALLOCATE-ITERATOR COLLECTIONTREE
        NIL)))
     (CL:SETQ ITERATORCLAUSES
      (CONS
       (CONS ITERATORVAR
        (LIST* SGT-FOREACH-STELLA-ABSTRACT-ITERATOR COLLECTIONTREE
         NIL))
       NIL))
     (CL:SETQ COLLECTIONBASETYPE
      SGT-FOREACH-STELLA-ABSTRACT-ITERATOR)))
   (CL:WHEN (CL:NOT (CL:EQ KEYVAR NULL))
    (CL:SETQ KEYTREE (LIST* SYM-FOREACH-STELLA-KEY ITERATORVAR NIL)))
   (CL:SETQ VALUETREE (LIST* SYM-FOREACH-STELLA-VALUE ITERATORVAR NIL))
   (CL:COND
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-CONS)
     (CL:SETQ BUMPTREES
      (CONS
       (LIST* SYM-FOREACH-STELLA-SETQ ITERATORVAR
        (CONS (LIST* SYM-FOREACH-STELLA-REST ITERATORVAR NIL) NIL))
       NIL))
     (CL:SETQ CONTINUATIONTEST
      (LIST* SYM-FOREACH-STELLA-NOT
       (LIST* SYM-FOREACH-STELLA-NIL? ITERATORVAR NIL) NIL)))
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-KV-CONS)
     (CL:SETQ BUMPTREES
      (CONS
       (LIST* SYM-FOREACH-STELLA-SETQ ITERATORVAR
        (CONS (LIST* SYM-FOREACH-STELLA-REST ITERATORVAR NIL) NIL))
       NIL))
     (CL:SETQ CONTINUATIONTEST
      (LIST* SYM-FOREACH-STELLA-DEFINED? ITERATORVAR NIL)))
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-PROPERTY-LIST)
     (CL:WHEN (CL:NOT (CL:EQ KEYVAR NULL))
      (CL:SETQ KEYTREE
       (LIST* SYM-FOREACH-STELLA-VALUE ITERATORVAR NIL)))
     (CL:SETQ VALUETREE
      (LIST* SYM-FOREACH-STELLA-VALUE
       (LIST* SYM-FOREACH-STELLA-REST ITERATORVAR NIL) NIL))
     (CL:SETQ BUMPTREES
      (CONS
       (LIST* SYM-FOREACH-STELLA-SETQ ITERATORVAR
        (CONS
         (LIST* SYM-FOREACH-STELLA-REST
          (LIST* SYM-FOREACH-STELLA-REST ITERATORVAR NIL) NIL)
         NIL))
       NIL))
     (CL:SETQ CONTINUATIONTEST
      (LIST* SYM-FOREACH-STELLA-NOT
       (LIST* SYM-FOREACH-STELLA-NIL? ITERATORVAR NIL) NIL)))
    ((CL:EQ COLLECTIONBASETYPE SGT-FOREACH-STELLA-ABSTRACT-ITERATOR)
     (CL:SETQ BUMPTREES NIL)
     (CL:SETQ CONTINUATIONTEST
      (LIST* SYM-FOREACH-STELLA-NEXT? ITERATORVAR NIL)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" COLLECTIONBASETYPE "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:SETQ ITERATORCLAUSES
    (CONS
     (CONS VALUEVAR
      (CONS
       (EXTRACT-PARAMETER-TYPE COLLECTIONTYPE
        SYM-FOREACH-STELLA-ANY-VALUE)
       (CONS SYM-FOREACH-STELLA-NULL NIL)))
     ITERATORCLAUSES))
   (CL:SETQ VALUECLAUSES
    (CONS (LIST* SYM-FOREACH-STELLA-SETQ VALUEVAR (CONS VALUETREE NIL))
     VALUECLAUSES))
   (CL:WHEN (CL:NOT (CL:EQ KEYVAR NULL))
    (CL:LET* ((KEYTYPE NULL) (PARAMETEREXISTS? CL:NIL))
     (CL:MULTIPLE-VALUE-SETQ (KEYTYPE PARAMETEREXISTS?)
      (EXTRACT-PARAMETER-TYPE COLLECTIONTYPE
       SYM-FOREACH-STELLA-ANY-KEY))
     (CL:COND
      (PARAMETEREXISTS?
       (CL:SETQ ITERATORCLAUSES
        (CONS
         (CONS KEYVAR
          (CONS KEYTYPE (CONS SYM-FOREACH-STELLA-NULL NIL)))
         ITERATORCLAUSES))
       (CL:SETQ VALUECLAUSES
        (CONS (LIST* SYM-FOREACH-STELLA-SETQ KEYVAR (CONS KEYTREE NIL))
         VALUECLAUSES)))
      (CL:T
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
          EOL
          " Illegal key variable specified for keyless collection `"
          (DE-UGLIFY-PARSE-TREE COLLECTIONTYPE) "'." EOL)))
       (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION
        (CL:VALUES NIL NIL NIL SYM-FOREACH-STELLA-FALSE))))))
   (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION
    (CL:VALUES ITERATORCLAUSES VALUECLAUSES BUMPTREES
     CONTINUATIONTEST))))

;;; (DEFGLOBAL *AGGRESSIVELY-OPTIMIZE-INTERVAL-FOREACH?* ...)

(CL:DEFVAR *AGGRESSIVELY-OPTIMIZE-INTERVAL-FOREACH?* CL:NIL)

;;; (DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL CONS CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL (COLLECTIONTREE COLLECTIONTYPE KEYVAR VALUEVAR)
  (CL:WHEN (CL:NOT (CL:EQ KEYVAR NULL))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " Illegal key variable specified for INTEGER-INTERVAL." EOL)))
   (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL
    (CL:VALUES NIL NIL NIL SYM-FOREACH-STELLA-FALSE)))
  (CL:WHEN *AGGRESSIVELY-OPTIMIZE-INTERVAL-FOREACH?*
   (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL
    (YIELD-OPTIMIZED-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL
     COLLECTIONTREE COLLECTIONTYPE KEYVAR VALUEVAR)))
  (CL:LET*
   ((UPPERBOUND (%%VALUE (%%REST (%%REST COLLECTIONTREE))))
    (KNOWNUNBOUNDED?
     (CL:OR (CL:EQ UPPERBOUND SYM-FOREACH-STELLA-NULL)
      (CL:EQ UPPERBOUND SYM-FOREACH-STELLA-NULL-INTEGER)))
    (KNOWNBOUNDED?
     (CL:AND (CL:NOT KNOWNUNBOUNDED?)
      (CL:OR
       (ISA?
        (WALK-EXPRESSION-TREE (COPY-CONS-TREE UPPERBOUND)
         SGT-FOREACH-STELLA-INTEGER SYM-FOREACH-STELLA-FOREACH CL:NIL)
        SGT-FOREACH-STELLA-NUMBER-WRAPPER)
       (CL:AND (CONS? UPPERBOUND)
        (MEMBER?
         (GET-QUOTED-TREE "((+ - * / 1+ 1- ++ -- LENGTH) \"/STELLA\")"
          "/STELLA")
         (%%VALUE UPPERBOUND))))))
    (ITERATORVAR (LOCAL-GENSYM "ITER"))
    (UPPERBOUNDVAR
     (CL:IF KNOWNUNBOUNDED? NULL (LOCAL-GENSYM "UPPER-BOUND")))
    (UNBOUNDEDVAR
     (CL:IF (CL:OR KNOWNUNBOUNDED? KNOWNBOUNDED?) NULL
      (LOCAL-GENSYM "UNBOUNDED?"))))
   (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL
    (CL:VALUES
     (LIST*
      (CONS VALUEVAR
       (LIST* SGT-FOREACH-STELLA-INTEGER SYM-FOREACH-STELLA-NULL NIL))
      (CONS ITERATORVAR
       (LIST* SGT-FOREACH-STELLA-INTEGER
        (%%VALUE (%%REST COLLECTIONTREE)) NIL))
      (CONCATENATE
       (CL:IF KNOWNUNBOUNDED? NIL
        (CONS
         (CONS UPPERBOUNDVAR
          (LIST* SGT-FOREACH-STELLA-INTEGER UPPERBOUND NIL))
         NIL))
       (CONCATENATE
        (CL:IF (CL:OR KNOWNUNBOUNDED? KNOWNBOUNDED?) NIL
         (CONS
          (CONS UNBOUNDEDVAR
           (LIST* SGT-FOREACH-STELLA-BOOLEAN
            (LIST* SYM-FOREACH-STELLA-NULL? UPPERBOUNDVAR NIL) NIL))
          NIL))
        NIL)))
     (CONS
      (LIST* SYM-FOREACH-STELLA-SETQ VALUEVAR (CONS ITERATORVAR NIL))
      NIL)
     (CONS (LIST* SYM-FOREACH-STELLA-++ ITERATORVAR NIL) NIL)
     (CL:IF KNOWNUNBOUNDED? SYM-FOREACH-STELLA-TRUE
      (CL:IF KNOWNBOUNDED?
       (LIST* SYM-FOREACH-STELLA-<= ITERATORVAR
        (CONS UPPERBOUNDVAR NIL))
       (LIST* SYM-FOREACH-STELLA-OR UNBOUNDEDVAR
        (CONS
         (LIST* SYM-FOREACH-STELLA-<= ITERATORVAR
          (CONS UPPERBOUNDVAR NIL))
         NIL))))))))

;;; (DEFUN (YIELD-OPTIMIZED-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL CONS CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-OPTIMIZED-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL (COLLECTIONTREE COLLECTIONTYPE KEYVAR VALUEVAR)
  (CL:PROGN (CL:SETQ COLLECTIONTYPE COLLECTIONTYPE)
   (CL:SETQ KEYVAR KEYVAR))
  (CL:LET*
   ((UPPERBOUND (%%VALUE (%%REST (%%REST COLLECTIONTREE))))
    (UNBOUNDED?
     (CL:OR (CL:EQ UPPERBOUND SYM-FOREACH-STELLA-NULL)
      (CL:EQ UPPERBOUND SYM-FOREACH-STELLA-NULL-INTEGER)))
    (ITERATORVAR VALUEVAR) (UPPERBOUNDVAR NULL)
    (TESTOPERATOR SYM-FOREACH-STELLA-<=))
   (CL:WHEN (CL:NOT UNBOUNDED?)
    (CL:WHEN (CONS? UPPERBOUND)
     (CL:LET* ((UB UPPERBOUND))
      (CL:WHEN
       (CL:OR (CL:EQ (%%VALUE UB) SYM-FOREACH-STELLA-1-)
        (CL:AND (CL:EQ (%%VALUE UB) SYM-FOREACH-STELLA--)
         (EQL? (%%VALUE (%%REST UB)) ONE-WRAPPER)
         (CL:EQ (%%REST (%%REST (%%REST UB))) NIL)))
       (CL:SETQ UPPERBOUND (%%VALUE (%%REST UB)))
       (CL:SETQ TESTOPERATOR SYM-FOREACH-STELLA-<))))
    (CL:SETQ UPPERBOUND
     (SYS-TREE
      (WALK-EXPRESSION-TREE UPPERBOUND SGT-FOREACH-STELLA-INTEGER
       SYM-FOREACH-STELLA-FOREACH CL:NIL)
      SGT-FOREACH-STELLA-INTEGER))
    (CL:WHEN (CL:NOT (ATOMIC-EXPRESSION? UPPERBOUND))
     (CL:SETQ UPPERBOUNDVAR (LOCAL-GENSYM "UPPER-BOUND"))))
   (CL:RETURN-FROM
    YIELD-OPTIMIZED-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL
    (CL:VALUES
     (CONS
      (CONS ITERATORVAR
       (LIST* SGT-FOREACH-STELLA-INTEGER
        (%%VALUE (%%REST COLLECTIONTREE)) NIL))
      (CONCATENATE
       (CL:IF (CL:NOT (CL:EQ UPPERBOUNDVAR NULL))
        (CONS
         (CONS UPPERBOUNDVAR
          (LIST* SGT-FOREACH-STELLA-INTEGER UPPERBOUND NIL))
         NIL)
        NIL)
       NIL))
     NIL (CONS (LIST* SYM-FOREACH-STELLA-++ ITERATORVAR NIL) NIL)
     (CL:IF UNBOUNDED? SYM-FOREACH-STELLA-TRUE
      (CONS TESTOPERATOR
       (CONS ITERATORVAR
        (CONS
         (CL:IF (CL:NOT (CL:EQ UPPERBOUNDVAR NULL)) UPPERBOUNDVAR
          UPPERBOUND)
         NIL))))))))

;;; (DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR CONS CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR (COLLECTIONTREE COLLECTIONTYPE KEYVAR VALUEVAR)
  (CL:WHEN (CL:NOT (CL:EQ KEYVAR NULL))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " Illegal key variable specified for `"
      (DE-UGLIFY-PARSE-TREE COLLECTIONTYPE) "'." EOL)))
   (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR
    (CL:VALUES NIL NIL NIL SYM-FOREACH-STELLA-FALSE)))
  (CL:LET*
   ((VECTORVAR (LOCAL-GENSYM "VECTOR"))
    (INDEXVAR (LOCAL-GENSYM "INDEX"))
    (LENGTHVAR (LOCAL-GENSYM "LENGTH")))
   (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR
    (CL:VALUES
     (LIST*
      (CONS VALUEVAR
       (CONS
        (CL:IF
         (CL:OR (CL:EQ COLLECTIONTYPE SGT-FOREACH-STELLA-STRING)
          (CL:EQ COLLECTIONTYPE SGT-FOREACH-STELLA-MUTABLE-STRING))
         SGT-FOREACH-STELLA-CHARACTER
         (EXTRACT-PARAMETER-TYPE COLLECTIONTYPE
          SYM-FOREACH-STELLA-ANY-VALUE))
        (CONS SYM-FOREACH-STELLA-NULL NIL)))
      (CONS VECTORVAR (CONS COLLECTIONTYPE (CONS COLLECTIONTREE NIL)))
      (CONS INDEXVAR
       (LIST* SGT-FOREACH-STELLA-INTEGER (WRAP-INTEGER 0) NIL))
      (CONS LENGTHVAR
       (LIST* SGT-FOREACH-STELLA-INTEGER
        (LIST* SYM-FOREACH-STELLA-LENGTH VECTORVAR NIL) NIL))
      NIL)
     (CONS
      (LIST* SYM-FOREACH-STELLA-SETQ VALUEVAR
       (CONS
        (LIST* SYM-FOREACH-STELLA-NTH VECTORVAR (CONS INDEXVAR NIL))
        NIL))
      NIL)
     (CONS (LIST* SYM-FOREACH-STELLA-++ INDEXVAR NIL) NIL)
     (LIST* SYM-FOREACH-STELLA-< INDEXVAR (CONS LENGTHVAR NIL))))))

;;; (DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-ARGUMENT-LIST CONS CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-IN-CURSOR-CLAUSES-FOR-ARGUMENT-LIST (COLLECTIONTREE COLLECTIONTYPE KEYVAR VALUEVAR)
  (CL:WHEN (CL:NOT (CL:EQ KEYVAR NULL))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (SIGNAL-TRANSLATION-ERROR)
    (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
     (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
      " Illegal key variable specified for `"
      (DE-UGLIFY-PARSE-TREE COLLECTIONTYPE) "'." EOL)))
   (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES-FOR-ARGUMENT-LIST
    (CL:VALUES NIL NIL NIL SYM-FOREACH-STELLA-FALSE)))
  (CL:WHEN
   (CL:NOT (PASS-VARIABLE-ARGUMENTS-AS-LIST? *METHODBEINGWALKED*))
   (CL:LET* ((SELF-000 (NEW-PARAMETRIC-TYPE-SPECIFIER)))
    (CL:SETF (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-BASE-TYPE SELF-000)
     SGT-FOREACH-STELLA-ARGUMENT-LIST-ITERATOR)
    (CL:SETF
     (%PARAMETRIC-TYPE-SPECIFIER.SPECIFIER-PARAMETER-TYPES SELF-000)
     (LIST
      (EXTRACT-PARAMETER-TYPE COLLECTIONTYPE
       SYM-FOREACH-STELLA-ANY-VALUE)))
    (CL:LET* ((ITERATORTYPE SELF-000))
     (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES-FOR-ARGUMENT-LIST
      (YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION
       (SYS-TREE
        (LIST* SYM-FOREACH-STELLA-SYS-CALL-METHOD
         SGT-FOREACH-STELLA-ARGUMENT-LIST-ITERATOR
         SYM-FOREACH-STELLA-ALLOCATE-ITERATOR
         (WALK-WITHOUT-TYPE-TREE COLLECTIONTREE) NIL)
        ITERATORTYPE)
       ITERATORTYPE KEYVAR VALUEVAR)))))
  (CL:LET*
   ((LISTIFIEDTYPE
     (YIELD-LISTIFIED-VARIABLE-ARGUMENTS-TYPE *METHODBEINGWALKED*))
    (ELEMENTTYPE
     (EXTRACT-PARAMETER-TYPE COLLECTIONTYPE
      SYM-FOREACH-STELLA-ANY-VALUE)))
   (CL:LET*
    ((ITERATORCLAUSES NULL) (VALUECLAUSES NULL) (BUMPCLAUSES NULL)
     (CONTINUATIONTEST NULL))
    (CL:MULTIPLE-VALUE-SETQ
     (ITERATORCLAUSES VALUECLAUSES BUMPCLAUSES CONTINUATIONTEST)
     (YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION
      (SYS-TREE COLLECTIONTREE LISTIFIEDTYPE) LISTIFIEDTYPE KEYVAR
      VALUEVAR))
    (CL:WHEN (SUB-TYPE-SPEC-OF? ELEMENTTYPE SGT-FOREACH-STELLA-LITERAL)
     (CL:LET* ((CLAUSE NULL) (ITER-000 ITERATORCLAUSES))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ CLAUSE (%%VALUE ITER-000))
       (CL:WHEN (CL:EQ (%%VALUE CLAUSE) VALUEVAR)
        (SECOND-SETTER CLAUSE ELEMENTTYPE) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:RETURN-FROM YIELD-IN-CURSOR-CLAUSES-FOR-ARGUMENT-LIST
     (CL:VALUES ITERATORCLAUSES VALUECLAUSES BUMPCLAUSES
      CONTINUATIONTEST)))))

;;; (DEFUN (YIELD-ON-CURSOR-CLAUSES CONS CONS CONS OBJECT) ...)

(CL:DEFUN YIELD-ON-CURSOR-CLAUSES (ONTREE)
  (CL:LET* ((ITERATORVAR (%%VALUE (%%REST ONTREE))))
   (CL:WHEN (CL:NOT (SYMBOL? ITERATORVAR))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (SIGNAL-TRANSLATION-ERROR)
     (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
      (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR) EOL
       " Illegal ON clause with non-atomic variable: `"
       (DE-UGLIFY-PARSE-TREE ONTREE) "'." EOL)))
    (CL:RETURN-FROM YIELD-ON-CURSOR-CLAUSES
     (CL:VALUES NIL NIL NIL SYM-FOREACH-STELLA-FALSE)))
   (CL:LET* ((COLLECTIONTREE NULL) (COLLECTIONTYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ (COLLECTIONTREE COLLECTIONTYPE)
     (WALK-COLLECTION-TREE (%%VALUE (%%REST (%%REST ONTREE))) CL:T))
    (CL:WHEN
     (SUB-TYPE-SPEC-OF? COLLECTIONTYPE
      SGT-FOREACH-STELLA-ARGUMENT-LIST)
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " ON iteration not supported for ARGUMENT-LISTs: `"
        (DE-UGLIFY-PARSE-TREE ONTREE) "'." EOL)))
     (CL:RETURN-FROM YIELD-ON-CURSOR-CLAUSES
      (CL:VALUES NIL NIL NIL SYM-FOREACH-STELLA-FALSE)))
    (THIRD-SETTER ONTREE NULL)
    (CL:WHEN
     (CL:NOT
      (SAFE-SUBTYPE-OF? (TYPE-SPEC-TO-BASE-TYPE COLLECTIONTYPE)
       SGT-FOREACH-STELLA-ABSTRACT-ITERATOR))
     (CL:SETQ COLLECTIONTREE
      (LIST* SYM-FOREACH-STELLA-ALLOCATE-ITERATOR COLLECTIONTREE NIL)))
    (CL:RETURN-FROM YIELD-ON-CURSOR-CLAUSES
     (CL:VALUES
      (CONS
       (CONS ITERATORVAR
        (LIST* SGT-FOREACH-STELLA-ABSTRACT-ITERATOR COLLECTIONTREE
         NIL))
       NIL)
      NIL NIL (LIST* SYM-FOREACH-STELLA-NEXT? ITERATORVAR NIL))))))

;;; (DEFUN (COLLECT-CURSOR-CLAUSES CONS CONS CONS OBJECT) ...)

(CL:DEFUN COLLECT-CURSOR-CLAUSES (CURSORSTREE DONTOPTIMIZE?)
  (CL:LET* ((TEST-VALUE-000 (%%VALUE CURSORSTREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SYM-FOREACH-STELLA-IN)
     (CL:RETURN-FROM COLLECT-CURSOR-CLAUSES
      (YIELD-IN-CURSOR-CLAUSES CURSORSTREE DONTOPTIMIZE?)))
    ((CL:EQ TEST-VALUE-000 SYM-FOREACH-STELLA-ON)
     (CL:RETURN-FROM COLLECT-CURSOR-CLAUSES
      (YIELD-ON-CURSOR-CLAUSES CURSORSTREE)))
    ((CL:EQ TEST-VALUE-000 SYM-FOREACH-STELLA-AS)
     (CL:LET*
      ((ALLITERATORCLAUSES NIL) (ALLVALUECLAUSES NIL)
       (ALLBUMPCLAUSES NIL) (CONTINUATIONTESTS NIL))
      (CL:LET* ((CLAUSE NULL) (ITER-000 (%%REST CURSORSTREE)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ CLAUSE (%%VALUE ITER-000))
        (CL:LET*
         ((ITERATORCLAUSES NULL) (VALUECLAUSES NULL) (BUMPCLAUSES NULL)
          (CONTINUATIONTEST NULL))
         (CL:MULTIPLE-VALUE-SETQ
          (ITERATORCLAUSES VALUECLAUSES BUMPCLAUSES CONTINUATIONTEST)
          (COLLECT-CURSOR-CLAUSES CLAUSE DONTOPTIMIZE?))
         (CL:SETQ ALLITERATORCLAUSES
          (CONCATENATE ALLITERATORCLAUSES ITERATORCLAUSES))
         (CL:SETQ ALLVALUECLAUSES
          (CONCATENATE ALLVALUECLAUSES VALUECLAUSES))
         (CL:SETQ ALLBUMPCLAUSES
          (CONCATENATE ALLBUMPCLAUSES BUMPCLAUSES))
         (CL:SETQ CONTINUATIONTESTS
          (CONS CONTINUATIONTEST CONTINUATIONTESTS)))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:RETURN-FROM COLLECT-CURSOR-CLAUSES
       (CL:VALUES ALLITERATORCLAUSES ALLVALUECLAUSES ALLBUMPCLAUSES
        (CL:IF (CL:= (LENGTH CONTINUATIONTESTS) 1)
         (%%VALUE CONTINUATIONTESTS)
         (CONS SYM-FOREACH-STELLA-AND
          (CONCATENATE
           (REMOVE (REVERSE CONTINUATIONTESTS) SYM-FOREACH-STELLA-TRUE)
           NIL)))))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
       "`" TEST-VALUE-000 "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (WALK-CURSORS-TREE CONS CONS CONS OBJECT) ...)

(CL:DEFUN WALK-CURSORS-TREE (CURSORSTREE DONTOPTIMIZE?)
  (CL:LET*
   ((ITERATORCLAUSES NULL) (VALUECLAUSES NULL) (BUMPCLAUSES NULL)
    (CONTINUATIONTEST NULL))
   (CL:MULTIPLE-VALUE-SETQ
    (ITERATORCLAUSES VALUECLAUSES BUMPCLAUSES CONTINUATIONTEST)
    (COLLECT-CURSOR-CLAUSES CURSORSTREE DONTOPTIMIZE?))
   (CL:LET* ((CLAUSE NULL) (ITER-000 ITERATORCLAUSES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLAUSE (%%VALUE ITER-000))
     (CL:LET* ((ITERATORTREE NULL) (ITERATORTYPE NULL))
      (CL:MULTIPLE-VALUE-SETQ (ITERATORTREE ITERATORTYPE)
       (WALK-EXPRESSION-TREE (%%VALUE (%%REST (%%REST CLAUSE)))
        (%%VALUE (%%REST CLAUSE)) SYM-FOREACH-STELLA-FOREACH CL:NIL))
      (SECOND-SETTER CLAUSE ITERATORTYPE)
      (THIRD-SETTER CLAUSE
       (COERCE-A-TREE ITERATORTREE ITERATORTYPE ITERATORTYPE)))
     (PUSH-VARIABLE-BINDING (%%VALUE CLAUSE) (%%VALUE (%%REST CLAUSE)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ VALUECLAUSES (WALK-LIST-OF-TREES VALUECLAUSES))
   (CL:SETQ BUMPCLAUSES (WALK-LIST-OF-TREES BUMPCLAUSES))
   (CL:SETQ CONTINUATIONTEST (WALK-WITHOUT-TYPE-TREE CONTINUATIONTEST))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 1)
     (UPPER-BOUND-000 (LENGTH ITERATORCLAUSES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-001) (CL:SETQ I I) (POP-VARIABLE-BINDING)
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:RETURN-FROM WALK-CURSORS-TREE
    (CL:VALUES ITERATORCLAUSES VALUECLAUSES BUMPCLAUSES
     CONTINUATIONTEST))))

;;; (DEFUN (YIELD-COLLECT-INTO-LIST-CODE CONS) ...)

(CL:DEFUN YIELD-COLLECT-INTO-LIST-CODE (COLLECTVARIABLE INTOVARIABLE COLLECTTREE)
  (CL:RETURN-FROM YIELD-COLLECT-INTO-LIST-CODE
   (CONS
    (LIST* SYM-FOREACH-STELLA-IF
     (LIST* SYM-FOREACH-STELLA-NULL? COLLECTVARIABLE NIL)
     (LIST* SYM-FOREACH-STELLA-PROGN
      (LIST* SYM-FOREACH-STELLA-SETQ COLLECTVARIABLE
       (CONS
        (LIST* SYM-FOREACH-STELLA-CONS COLLECTTREE
         (CONS SYM-FOREACH-STELLA-NIL NIL))
        NIL))
      (LIST* SYM-FOREACH-STELLA-IF
       (LIST* SYM-FOREACH-STELLA-EMPTY?
        (LIST* SYM-FOREACH-STELLA-THE-CONS-LIST INTOVARIABLE NIL) NIL)
       (LIST* SYM-FOREACH-STELLA-SETF
        (LIST* SYM-FOREACH-STELLA-THE-CONS-LIST INTOVARIABLE NIL)
        COLLECTVARIABLE NIL)
       (LIST* SYM-FOREACH-STELLA-ADD-CONS-TO-END-OF-CONS-LIST
        (LIST* SYM-FOREACH-STELLA-THE-CONS-LIST INTOVARIABLE NIL)
        COLLECTVARIABLE NIL)
       NIL)
      NIL)
     (LIST* SYM-FOREACH-STELLA-PROGN
      (LIST* SYM-FOREACH-STELLA-SETF
       (LIST* SYM-FOREACH-STELLA-REST COLLECTVARIABLE NIL)
       (LIST* SYM-FOREACH-STELLA-CONS (COPY-CONS-TREE COLLECTTREE)
        (CONS SYM-FOREACH-STELLA-NIL NIL))
       NIL)
      (LIST* SYM-FOREACH-STELLA-SETQ COLLECTVARIABLE
       (CONS (LIST* SYM-FOREACH-STELLA-REST COLLECTVARIABLE NIL) NIL))
      NIL)
     NIL)
    NIL)))

;;; (DEFUN (YIELD-COLLECT-INTO-CONS-CODE CONS) ...)

(CL:DEFUN YIELD-COLLECT-INTO-CONS-CODE (COLLECTVARIABLE INTOVARIABLE COLLECTTREE)
  (CL:RETURN-FROM YIELD-COLLECT-INTO-CONS-CODE
   (CONS
    (LIST* SYM-FOREACH-STELLA-IF
     (LIST* SYM-FOREACH-STELLA-NULL? COLLECTVARIABLE NIL)
     (LIST* SYM-FOREACH-STELLA-PROGN
      (LIST* SYM-FOREACH-STELLA-SETQ COLLECTVARIABLE
       (CONS
        (LIST* SYM-FOREACH-STELLA-CONS COLLECTTREE
         (CONS SYM-FOREACH-STELLA-NIL NIL))
        NIL))
      (LIST* SYM-FOREACH-STELLA-IF
       (LIST* SYM-FOREACH-STELLA-NIL? INTOVARIABLE NIL)
       (LIST* SYM-FOREACH-STELLA-SETQ INTOVARIABLE
        (CONS COLLECTVARIABLE NIL))
       (LIST* SYM-FOREACH-STELLA-ADD-CONS-TO-END-OF-CONS-LIST
        INTOVARIABLE (CONS COLLECTVARIABLE NIL))
       NIL)
      NIL)
     (LIST* SYM-FOREACH-STELLA-PROGN
      (LIST* SYM-FOREACH-STELLA-SETF
       (LIST* SYM-FOREACH-STELLA-REST COLLECTVARIABLE NIL)
       (LIST* SYM-FOREACH-STELLA-CONS (COPY-CONS-TREE COLLECTTREE)
        (CONS SYM-FOREACH-STELLA-NIL NIL))
       NIL)
      (LIST* SYM-FOREACH-STELLA-SETQ COLLECTVARIABLE
       (CONS (LIST* SYM-FOREACH-STELLA-REST COLLECTVARIABLE NIL) NIL))
      NIL)
     NIL)
    NIL)))

;;; (DEFUN (YIELD-COLLECT-CODE CONS) ...)

(CL:DEFUN YIELD-COLLECT-CODE (COLLECTVARIABLE INTOVARIABLE COLLECTTREE)
  (CL:LET*
   ((INTOVARIABLETYPE
     (TYPE-SPEC-TO-BASE-TYPE (LOOKUP-VARIABLE-TYPE INTOVARIABLE))))
   (CL:COND
    ((SUBTYPE-OF? INTOVARIABLETYPE SGT-FOREACH-STELLA-LIST)
     (CL:RETURN-FROM YIELD-COLLECT-CODE
      (YIELD-COLLECT-INTO-LIST-CODE COLLECTVARIABLE INTOVARIABLE
       COLLECTTREE)))
    ((SUBTYPE-OF? INTOVARIABLETYPE SGT-FOREACH-STELLA-CONS)
     (CL:RETURN-FROM YIELD-COLLECT-CODE
      (YIELD-COLLECT-INTO-CONS-CODE COLLECTVARIABLE INTOVARIABLE
       COLLECTTREE)))
    ((CL:EQ INTOVARIABLETYPE SGT-FOREACH-STELLA-UNKNOWN)
     (CL:RETURN-FROM YIELD-COLLECT-CODE
      (CONS
       (LIST* SYM-FOREACH-STELLA-IF
        (LIST* SYM-FOREACH-STELLA-NULL? COLLECTVARIABLE NIL)
        (LIST* SYM-FOREACH-STELLA-PROGN
         (LIST* SYM-FOREACH-STELLA-SETQ COLLECTVARIABLE
          (CONS
           (LIST* SYM-FOREACH-STELLA-CONS COLLECTTREE
            (CONS SYM-FOREACH-STELLA-NIL NIL))
           NIL))
         (LIST* SYM-FOREACH-STELLA-COND
          (LIST* (LIST* SYM-FOREACH-STELLA-NIL? INTOVARIABLE NIL)
           (LIST* SYM-FOREACH-STELLA-SETQ INTOVARIABLE
            (CONS COLLECTVARIABLE NIL))
           NIL)
          (LIST* (LIST* SYM-FOREACH-STELLA-CONS? INTOVARIABLE NIL)
           (LIST* SYM-FOREACH-STELLA-ADD-CONS-TO-END-OF-CONS-LIST
            INTOVARIABLE (CONS COLLECTVARIABLE NIL))
           NIL)
          (LIST* SYM-FOREACH-STELLA-OTHERWISE
           (LIST* SYM-FOREACH-STELLA-IF
            (LIST* SYM-FOREACH-STELLA-EMPTY?
             (LIST* SYM-FOREACH-STELLA-THE-CONS-LIST INTOVARIABLE NIL)
             NIL)
            (LIST* SYM-FOREACH-STELLA-SETF
             (LIST* SYM-FOREACH-STELLA-THE-CONS-LIST INTOVARIABLE NIL)
             COLLECTVARIABLE NIL)
            (LIST* SYM-FOREACH-STELLA-ADD-CONS-TO-END-OF-CONS-LIST
             (LIST* SYM-FOREACH-STELLA-THE-CONS-LIST INTOVARIABLE NIL)
             COLLECTVARIABLE NIL)
            NIL)
           NIL)
          NIL)
         NIL)
        (LIST* SYM-FOREACH-STELLA-PROGN
         (LIST* SYM-FOREACH-STELLA-SETF
          (LIST* SYM-FOREACH-STELLA-REST COLLECTVARIABLE NIL)
          (LIST* SYM-FOREACH-STELLA-CONS (COPY-CONS-TREE COLLECTTREE)
           (CONS SYM-FOREACH-STELLA-NIL NIL))
          NIL)
         (LIST* SYM-FOREACH-STELLA-SETQ COLLECTVARIABLE
          (CONS (LIST* SYM-FOREACH-STELLA-REST COLLECTVARIABLE NIL)
           NIL))
         NIL)
        NIL)
       NIL)))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
        EOL " Can't collect into a datatype other than LIST or CONS.."
        EOL)))
     (CL:RETURN-FROM YIELD-COLLECT-CODE
      (WALK-DONT-CALL-ME-TREE COLLECTTREE SGT-FOREACH-STELLA-VOID))))))

;;; (DEFUN (WALK-PREFIX-COLLECT-INTO-TREE CONS CONS) ...)

(CL:DEFUN WALK-PREFIX-COLLECT-INTO-TREE (COLLECTINTOTREE ITERATORS DOCODE)
  (CL:LET*
   ((COLLECTTREE (%%VALUE (%%REST COLLECTINTOTREE)))
    (INTOTREE (%%VALUE (%%REST (%%REST COLLECTINTOTREE))))
    (COLLECTVARIABLE (LOCAL-GENSYM "COLLECT"))
    (COLLECTINTOBINDINGS
     (CONS
      (CONS COLLECTVARIABLE
       (LIST* SGT-FOREACH-STELLA-CONS SYM-FOREACH-STELLA-NULL NIL))
      NIL))
    (COLLECTCODE NULL) (INTOVARIABLE NULL) (INTOVARIABLETYPE NULL))
   (CL:IF (SYMBOL? INTOTREE)
    (CL:PROGN (CL:SETQ INTOVARIABLE INTOTREE)
     (CL:SETQ COLLECTCODE
      (YIELD-COLLECT-CODE COLLECTVARIABLE INTOVARIABLE COLLECTTREE)))
    (CL:PROGN
     (CL:LET* ((D NULL) (ITER-000 ITERATORS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ D (%%VALUE ITER-000))
       (PUSH-VARIABLE-BINDING (%%VALUE D) (%%VALUE (%%REST D)))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:MULTIPLE-VALUE-SETQ (INTOTREE INTOVARIABLETYPE)
      (WALK-EXPRESSION-TREE INTOTREE NULL SYM-FOREACH-STELLA-FOREACH
       CL:NIL))
     (CL:LET* ((D NULL) (ITER-001 ITERATORS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ D (%%VALUE ITER-001)) (CL:SETQ D D)
       (POP-VARIABLE-BINDING) (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETQ INTOVARIABLE (LOCAL-GENSYM "INTO"))
     (CL:SETQ COLLECTINTOBINDINGS
      (CONS (CONS-LIST INTOVARIABLE INTOVARIABLETYPE INTOTREE)
       COLLECTINTOBINDINGS))
     (PUSH-VARIABLE-BINDING INTOVARIABLE INTOVARIABLETYPE)
     (CL:SETQ COLLECTCODE
      (YIELD-COLLECT-CODE COLLECTVARIABLE INTOVARIABLE COLLECTTREE))
     (POP-VARIABLE-BINDING)))
   (CL:RETURN-FROM WALK-PREFIX-COLLECT-INTO-TREE
    (CL:VALUES (CONCATENATE ITERATORS COLLECTINTOBINDINGS)
     (CONCATENATE DOCODE COLLECTCODE)))))

;;; (DEFUN (WRAP-WHERE-TEST CONS) ...)

(CL:DEFUN WRAP-WHERE-TEST (WHERETEST ACTIONS)
  (CL:IF (CL:NOT (CL:EQ WHERETEST NULL))
   (CL:RETURN-FROM WRAP-WHERE-TEST
    (CONS
     (LIST* SYM-FOREACH-STELLA-WHEN WHERETEST
      (CONCATENATE ACTIONS NIL))
     NIL))
   (CL:RETURN-FROM WRAP-WHERE-TEST ACTIONS)))

;;; (DEFUN (WALK-PREFIX-FOREACH-BODY CONS) ...)

(CL:DEFUN WALK-PREFIX-FOREACH-BODY (ITERATORCLAUSES WHERETEST DOACTIONS)
  (CL:LET* ((OTREE NULL))
   (CL:LET* ((C NULL) (ITER-000 ITERATORCLAUSES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ C (%%VALUE ITER-000))
     (PUSH-VARIABLE-BINDING (%%VALUE C) (%%VALUE (%%REST C)))
     (FIRST-SETTER C (TRUE-VARIABLE-NAME (%%VALUE C)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ OTREE
    (WALK-LIST-OF-TREES (WRAP-WHERE-TEST WHERETEST DOACTIONS)))
   (CL:LET* ((C NULL) (ITER-001 ITERATORCLAUSES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ C (%%VALUE ITER-001)) (CL:SETQ C C)
     (POP-VARIABLE-BINDING) (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:RETURN-FROM WALK-PREFIX-FOREACH-BODY OTREE)))

;;; (DEFUN (WALK-PREFIX-FOREACH-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-PREFIX-FOREACH-TREE (TREE)
  (CL:LET*
   ((TAIL NULL) (ITERATORCLAUSES NULL) (VALUECLAUSES NULL)
    (BUMPCLAUSES NULL) (CONTINUATIONTEST NULL) (WHERETEST NULL)
    (DOACTIONS NIL))
   (CL:MULTIPLE-VALUE-SETQ
    (ITERATORCLAUSES VALUECLAUSES BUMPCLAUSES CONTINUATIONTEST)
    (WALK-CURSORS-TREE (%%VALUE (%%REST TREE)) CL:NIL))
   (CL:SETQ TAIL (%%REST (%%REST TREE)))
   (CL:WHEN (CL:EQ (%%VALUE (%%VALUE TAIL)) SYM-FOREACH-STELLA-WHERE)
    (CL:SETQ WHERETEST (%%VALUE (%%REST (%%VALUE TAIL))))
    (CL:SETQ TAIL (%%REST TAIL)))
   (CL:WHEN (CL:EQ (%%VALUE (%%VALUE TAIL)) SYM-FOREACH-STELLA-DO)
    (CL:SETQ DOACTIONS (%%REST (%%VALUE TAIL)))
    (CL:SETQ TAIL (%%REST TAIL)))
   (CL:WHEN (CL:NOT (CL:EQ TAIL NIL))
    (CL:MULTIPLE-VALUE-SETQ (ITERATORCLAUSES DOACTIONS)
     (WALK-PREFIX-COLLECT-INTO-TREE (%%VALUE TAIL) ITERATORCLAUSES
      DOACTIONS)))
   (CL:RETURN-FROM WALK-PREFIX-FOREACH-TREE
    (CL:VALUES
     (LIST* SYM-FOREACH-STELLA-SYS-FOREACH ITERATORCLAUSES
      (CONS VALUECLAUSES
       (CONS BUMPCLAUSES
        (CONS CONTINUATIONTEST
         (CONCATENATE
          (WALK-PREFIX-FOREACH-BODY ITERATORCLAUSES WHERETEST
           DOACTIONS)
          NIL)))))
     SGT-FOREACH-STELLA-VOID))))

;;; (DEFUN (WALK-EXISTS-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-EXISTS-TREE (TREE)
  (CL:LET*
   ((FOUND? (LOCAL-GENSYM "FOUND?"))
    (OTREE
     (LIST* SYM-FOREACH-STELLA-VRLET
      (CONS (CONS FOUND? (CONS SYM-FOREACH-STELLA-FALSE NIL)) NIL)
      (CONS SYM-FOREACH-STELLA-FOREACH
       (CONCATENATE (%%REST TREE)
        (LIST* SYM-FOREACH-STELLA-DO
         (LIST* SYM-FOREACH-STELLA-SETQ FOUND?
          (CONS SYM-FOREACH-STELLA-TRUE NIL))
         (CONS SYM-FOREACH-STELLA-BREAK NIL) NIL)))
      FOUND? NIL)))
   (CL:RETURN-FROM WALK-EXISTS-TREE (WALK-A-CONS-TREE OTREE))))

;;; (DEFUN (WALK-FORALL-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-FORALL-TREE (TREE)
  (CL:LET*
   ((ALWAYS? (LOCAL-GENSYM "ALWAYS?")) (ITERATORSANDWHERE NIL)
    (ALWAYSTEST NIL) (PRECURSOR NIL) (CURSOR TREE))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
    (CL:WHEN (CL:EQ (%%VALUE CURSOR) SYM-FOREACH-STELLA-ALWAYS)
     (CL:SETQ ALWAYSTEST (%%VALUE (%%REST CURSOR)))
     (CL:SETF (%%REST PRECURSOR) NIL) (CL:RETURN))
    (CL:SETQ PRECURSOR CURSOR) (CL:SETQ CURSOR (%%REST CURSOR)))
   (CL:SETQ ITERATORSANDWHERE (%%REST TREE))
   (CL:RETURN-FROM WALK-FORALL-TREE
    (CL:VALUES
     (LIST* SYM-FOREACH-STELLA-VRLET
      (CONS (CONS ALWAYS? (CONS SYM-FOREACH-STELLA-TRUE NIL)) NIL)
      (CONS SYM-FOREACH-STELLA-FOREACH
       (CONCATENATE ITERATORSANDWHERE
        (LIST* SYM-FOREACH-STELLA-DO
         (LIST* SYM-FOREACH-STELLA-WHEN
          (LIST* SYM-FOREACH-STELLA-NOT ALWAYSTEST NIL)
          (LIST* SYM-FOREACH-STELLA-SETQ ALWAYS?
           (CONS SYM-FOREACH-STELLA-FALSE NIL))
          (CONS SYM-FOREACH-STELLA-BREAK NIL) NIL)
         NIL)))
      ALWAYS? NIL)
     SGT-FOREACH-STELLA-BOOLEAN))))

;;; (DEFUN (WALK-SOME-TREE CONS TYPE-SPEC) ...)

(CL:DEFUN WALK-SOME-TREE (TREE)
  (CL:LET*
   ((VALUEVAR (LOCAL-GENSYM "VALUE"))
    (ITERATIONVAR (%%VALUE (%%REST TREE))) (OTREE NULL))
   (CL:LET* ((SEQUENCEREF NULL) (SEQUENCETYPE NULL))
    (CL:MULTIPLE-VALUE-SETQ (SEQUENCEREF SEQUENCETYPE)
     (WALK-A-TREE (FOURTH TREE)))
    (FOURTH-SETTER TREE SEQUENCEREF)
    (CL:SETQ OTREE
     (LIST* SYM-FOREACH-STELLA-VRLET
      (CONS
       (CONS VALUEVAR
        (CONS
         (EXTRACT-PARAMETER-TYPE SEQUENCETYPE
          SYM-FOREACH-STELLA-ANY-VALUE)
         (CONS SYM-FOREACH-STELLA-NULL NIL)))
       NIL)
      (CONS SYM-FOREACH-STELLA-FOREACH
       (CONCATENATE (%%REST TREE)
        (LIST* SYM-FOREACH-STELLA-DO
         (LIST* SYM-FOREACH-STELLA-SETQ VALUEVAR
          (CONS ITERATIONVAR NIL))
         (CONS SYM-FOREACH-STELLA-BREAK NIL) NIL)))
      VALUEVAR NIL))
    (CL:RETURN-FROM WALK-SOME-TREE (WALK-A-CONS-TREE OTREE)))))

(CL:DEFUN HELP-STARTUP-FOREACH1 ()
  (CL:PROGN
   (CL:SETQ SYM-FOREACH-STELLA-AS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AS" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-COMMA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMA" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-DO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DO" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-COLLECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT" NULL 0))
   (CL:SETQ SGT-FOREACH-STELLA-VOID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
   (CL:SETQ SYM-FOREACH-STELLA-PREFIX-FOREACH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREFIX-FOREACH" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-IN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-X
    (INTERN-RIGID-SYMBOL-WRT-MODULE "X" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-NIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-WHERE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHERE" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-INTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTO" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-COLLECT-INTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-FOREACH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FOREACH" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-SOME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SOME" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-INTERVAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL" NULL 0))
   (CL:SETQ SGT-FOREACH-STELLA-INTEGER-INTERVAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-INTERVAL" NULL 1))
   (CL:SETQ SGT-FOREACH-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SGT-FOREACH-STELLA-UNKNOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 1))
   (CL:SETQ SGT-FOREACH-STELLA-ABSTRACT-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT-ITERATOR" NULL 1))
   (CL:SETQ SYM-FOREACH-STELLA-ALLOCATE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATE-ITERATOR" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ SGT-FOREACH-STELLA-ARGUMENT-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-LIST" NULL 1))
   (CL:SETQ SGT-FOREACH-STELLA-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING" NULL 1))
   (CL:SETQ SGT-FOREACH-STELLA-MUTABLE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING" NULL 1))
   (CL:SETQ SGT-FOREACH-STELLA-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 1))
   (CL:SETQ SGT-FOREACH-STELLA-SEQUENCE-MIXIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SEQUENCE-MIXIN" NULL 1))
   (CL:SETQ SYM-FOREACH-STELLA-THE-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ARRAY" NULL 0))
   (CL:SETQ SGT-FOREACH-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
   (CL:SETQ SYM-FOREACH-STELLA-THE-CONS-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CONS-LIST" NULL 0))
   (CL:SETQ SGT-FOREACH-STELLA-KEY-VALUE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST" NULL 1))
   (CL:SETQ SGT-FOREACH-STELLA-KV-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KV-CONS" NULL 1))
   (CL:SETQ SYM-FOREACH-STELLA-THE-KV-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-KV-LIST" NULL 0))
   (CL:SETQ SGT-FOREACH-STELLA-PROPERTY-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY-LIST" NULL 1))
   (CL:SETQ SYM-FOREACH-STELLA-THE-PLIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-PLIST" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-REST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REST" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-NIL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL?" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-DEFINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-NEXT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEXT?" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-ANY-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY-VALUE" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-ANY-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANY-KEY" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-NULL-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-INTEGER" NULL 0))
   (CL:SETQ SGT-FOREACH-STELLA-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER" NULL 1))
   (CL:SETQ SGT-FOREACH-STELLA-NUMBER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER" NULL 1))
   (CL:SETQ SGT-FOREACH-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ SYM-FOREACH-STELLA-NULL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL?" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-++
    (INTERN-RIGID-SYMBOL-WRT-MODULE "++" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-<=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<=" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-1-
    (INTERN-RIGID-SYMBOL-WRT-MODULE "1-" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA--
    (INTERN-RIGID-SYMBOL-WRT-MODULE "-" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-<
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<" NULL 0))
   (CL:SETQ SYM-FOREACH-STELLA-LENGTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LENGTH" NULL 0)))
  :VOID)

(CL:DEFUN STARTUP-FOREACH ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-FOREACH1)
    (CL:SETQ SGT-FOREACH-STELLA-CHARACTER
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER" NULL 1))
    (CL:SETQ SYM-FOREACH-STELLA-NTH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "NTH" NULL 0))
    (CL:SETQ SGT-FOREACH-STELLA-ARGUMENT-LIST-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-LIST-ITERATOR" NULL 1))
    (CL:SETQ SYM-FOREACH-STELLA-SYS-CALL-METHOD
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-CALL-METHOD" NULL 0))
    (CL:SETQ SGT-FOREACH-STELLA-LITERAL
     (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL" NULL 1))
    (CL:SETQ SYM-FOREACH-STELLA-ON
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ON" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-AND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-IF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-PROGN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-EMPTY?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "EMPTY?" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-SETF
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SETF" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-ADD-CONS-TO-END-OF-CONS-LIST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-CONS-TO-END-OF-CONS-LIST"
      NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-COND
     (INTERN-RIGID-SYMBOL-WRT-MODULE "COND" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-CONS?
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS?" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-OTHERWISE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "OTHERWISE" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-WHEN
     (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-SYS-FOREACH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SYS-FOREACH" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-VRLET
     (INTERN-RIGID-SYMBOL-WRT-MODULE "VRLET" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-BREAK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "BREAK" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-ALWAYS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ALWAYS" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-STARTUP-FOREACH
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-FOREACH" NULL 0))
    (CL:SETQ SYM-FOREACH-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL
      0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-ONE-IN-CLAUSE"
     "(DEFUN (EXTRACT-ONE-IN-CLAUSE CONS CONS) ((TAIL CONS)))"
     (CL:FUNCTION EXTRACT-ONE-IN-CLAUSE) NULL)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-ONE-GENERATOR-TERM"
     "(DEFUN (EXTRACT-ONE-GENERATOR-TERM CONS CONS) ((TAIL CONS)))"
     (CL:FUNCTION EXTRACT-ONE-GENERATOR-TERM) NULL)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-GENERATORS-CLAUSE"
     "(DEFUN (EXTRACT-GENERATORS-CLAUSE CONS CONS) ((TAIL CONS)) :PUBLIC? TRUE)"
     (CL:FUNCTION EXTRACT-GENERATORS-CLAUSE) NULL)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-OPTION-AND-RESIDUE"
     "(DEFUN (EXTRACT-OPTION-AND-RESIDUE OBJECT CONS) ((OPTION SYMBOL) (TAIL CONS)) :PUBLIC? TRUE)"
     (CL:FUNCTION EXTRACT-OPTION-AND-RESIDUE) NULL)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-DO-CLAUSE"
     "(DEFUN (EXTRACT-DO-CLAUSE CONS CONS) ((TAIL CONS)))"
     (CL:FUNCTION EXTRACT-DO-CLAUSE) NULL)
    (DEFINE-FUNCTION-OBJECT "FOREACH-TO-PREFIX-FOREACH-TREE"
     "(DEFUN (FOREACH-TO-PREFIX-FOREACH-TREE CONS) ((FOREACHTREE CONS)))"
     (CL:FUNCTION FOREACH-TO-PREFIX-FOREACH-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "WALK-FOREACH-TREE"
     "(DEFUN (WALK-FOREACH-TREE CONS TYPE-SPEC) ((TREE CONS)))"
     (CL:FUNCTION WALK-FOREACH-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "WALK-COLLECTION-TREE"
     "(DEFUN (WALK-COLLECTION-TREE OBJECT TYPE-SPEC) ((TREE OBJECT) (DONTOPTIMIZE? BOOLEAN)))"
     (CL:FUNCTION WALK-COLLECTION-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-IN-CURSOR-CLAUSES"
     "(DEFUN (YIELD-IN-CURSOR-CLAUSES CONS CONS CONS OBJECT) ((INTREE CONS) (DONTOPTIMIZE? BOOLEAN)))"
     (CL:FUNCTION YIELD-IN-CURSOR-CLAUSES) NULL)
    (DEFINE-FUNCTION-OBJECT "USE-VECTOR-STYLE-ITERATION?"
     "(DEFUN (USE-VECTOR-STYLE-ITERATION? BOOLEAN) ((COLLECTIONTYPE TYPE)))"
     (CL:FUNCTION USE-VECTOR-STYLE-ITERATION?) NULL)
    (DEFINE-FUNCTION-OBJECT
     "YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION"
     "(DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION CONS CONS CONS OBJECT) ((COLLECTIONTREE OBJECT) (COLLECTIONTYPE TYPE-SPEC) (KEYVAR SYMBOL) (VALUEVAR SYMBOL)))"
     (CL:FUNCTION YIELD-IN-CURSOR-CLAUSES-FOR-GENERAL-COLLECTION) NULL)
    (DEFINE-FUNCTION-OBJECT
     "YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL"
     "(DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL CONS CONS CONS OBJECT) ((COLLECTIONTREE CONS) (COLLECTIONTYPE TYPE-SPEC) (KEYVAR SYMBOL) (VALUEVAR SYMBOL)))"
     (CL:FUNCTION YIELD-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL) NULL)
    (DEFINE-FUNCTION-OBJECT
     "YIELD-OPTIMIZED-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL"
     "(DEFUN (YIELD-OPTIMIZED-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL CONS CONS CONS OBJECT) ((COLLECTIONTREE CONS) (COLLECTIONTYPE TYPE-SPEC) (KEYVAR SYMBOL) (VALUEVAR SYMBOL)))"
     (CL:FUNCTION
      YIELD-OPTIMIZED-IN-CURSOR-CLAUSES-FOR-INTEGER-INTERVAL)
     NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR"
     "(DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR CONS CONS CONS OBJECT) ((COLLECTIONTREE OBJECT) (COLLECTIONTYPE TYPE-SPEC) (KEYVAR SYMBOL) (VALUEVAR SYMBOL)))"
     (CL:FUNCTION YIELD-IN-CURSOR-CLAUSES-FOR-VECTOR) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-IN-CURSOR-CLAUSES-FOR-ARGUMENT-LIST"
     "(DEFUN (YIELD-IN-CURSOR-CLAUSES-FOR-ARGUMENT-LIST CONS CONS CONS OBJECT) ((COLLECTIONTREE OBJECT) (COLLECTIONTYPE TYPE-SPEC) (KEYVAR SYMBOL) (VALUEVAR SYMBOL)))"
     (CL:FUNCTION YIELD-IN-CURSOR-CLAUSES-FOR-ARGUMENT-LIST) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-ON-CURSOR-CLAUSES"
     "(DEFUN (YIELD-ON-CURSOR-CLAUSES CONS CONS CONS OBJECT) ((ONTREE CONS)))"
     (CL:FUNCTION YIELD-ON-CURSOR-CLAUSES) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-CURSOR-CLAUSES"
     "(DEFUN (COLLECT-CURSOR-CLAUSES CONS CONS CONS OBJECT) ((CURSORSTREE CONS) (DONTOPTIMIZE? BOOLEAN)))"
     (CL:FUNCTION COLLECT-CURSOR-CLAUSES) NULL)
    (DEFINE-FUNCTION-OBJECT "WALK-CURSORS-TREE"
     "(DEFUN (WALK-CURSORS-TREE CONS CONS CONS OBJECT) ((CURSORSTREE CONS) (DONTOPTIMIZE? BOOLEAN)))"
     (CL:FUNCTION WALK-CURSORS-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-COLLECT-INTO-LIST-CODE"
     "(DEFUN (YIELD-COLLECT-INTO-LIST-CODE CONS) ((COLLECTVARIABLE SYMBOL) (INTOVARIABLE OBJECT) (COLLECTTREE OBJECT)))"
     (CL:FUNCTION YIELD-COLLECT-INTO-LIST-CODE) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-COLLECT-INTO-CONS-CODE"
     "(DEFUN (YIELD-COLLECT-INTO-CONS-CODE CONS) ((COLLECTVARIABLE SYMBOL) (INTOVARIABLE OBJECT) (COLLECTTREE OBJECT)))"
     (CL:FUNCTION YIELD-COLLECT-INTO-CONS-CODE) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-COLLECT-CODE"
     "(DEFUN (YIELD-COLLECT-CODE CONS) ((COLLECTVARIABLE SYMBOL) (INTOVARIABLE OBJECT) (COLLECTTREE OBJECT)))"
     (CL:FUNCTION YIELD-COLLECT-CODE) NULL)
    (DEFINE-FUNCTION-OBJECT "WALK-PREFIX-COLLECT-INTO-TREE"
     "(DEFUN (WALK-PREFIX-COLLECT-INTO-TREE CONS CONS) ((COLLECTINTOTREE CONS) (ITERATORS (CONS OF CONS)) (DOCODE CONS)))"
     (CL:FUNCTION WALK-PREFIX-COLLECT-INTO-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "WRAP-WHERE-TEST"
     "(DEFUN (WRAP-WHERE-TEST CONS) ((WHERETEST OBJECT) (ACTIONS CONS)))"
     (CL:FUNCTION WRAP-WHERE-TEST) NULL)
    (DEFINE-FUNCTION-OBJECT "WALK-PREFIX-FOREACH-BODY"
     "(DEFUN (WALK-PREFIX-FOREACH-BODY CONS) ((ITERATORCLAUSES CONS) (WHERETEST OBJECT) (DOACTIONS CONS)))"
     (CL:FUNCTION WALK-PREFIX-FOREACH-BODY) NULL)
    (DEFINE-FUNCTION-OBJECT "WALK-PREFIX-FOREACH-TREE"
     "(DEFUN (WALK-PREFIX-FOREACH-TREE CONS TYPE-SPEC) ((TREE CONS)))"
     (CL:FUNCTION WALK-PREFIX-FOREACH-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "WALK-EXISTS-TREE"
     "(DEFUN (WALK-EXISTS-TREE CONS TYPE-SPEC) ((TREE CONS)))"
     (CL:FUNCTION WALK-EXISTS-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "WALK-FORALL-TREE"
     "(DEFUN (WALK-FORALL-TREE CONS TYPE-SPEC) ((TREE CONS)))"
     (CL:FUNCTION WALK-FORALL-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "WALK-SOME-TREE"
     "(DEFUN (WALK-SOME-TREE CONS TYPE-SPEC) ((TREE CONS)))"
     (CL:FUNCTION WALK-SOME-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-FOREACH"
     "(DEFUN STARTUP-FOREACH () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-FOREACH) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-FOREACH-STELLA-STARTUP-FOREACH)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-FOREACH-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupForeach") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *AGGRESSIVELY-OPTIMIZE-INTERVAL-FOREACH?* BOOLEAN FALSE)")))
  :VOID)
