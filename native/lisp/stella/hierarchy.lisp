;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; hierarchy.lisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2014      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-HIERARCHY-STELLA-TYPE-SPEC NULL)
(CL:DEFVAR *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* CL:NIL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-REFERENCE-COUNT NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-BAD? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DELETED-OBJECT? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FIRST-ITERATION? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-OBJECT-ITERATOR NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-CONS-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CONS-ITERATOR-CURSOR NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-LIST-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-LIST-ITERATOR-CURSOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-LIST-ITERATOR-COLLECTION NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-DESTRUCTIVE-LIST-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-THE-CONS-LIST NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-ALL-PURPOSE-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-KEY NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ITERATOR-NEXT-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ITERATOR-FILTER-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ITERATOR-EMPTY-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ITERATOR-NESTED-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ITERATOR-CONS-LIST NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ITERATOR-OBJECT NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ITERATOR-SECOND-OBJECT NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ITERATOR-INTEGER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ITERATOR-SECOND-INTEGER NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-TYPES-TO-CLASSES-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ITERATOR-CURSOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-OBJECT-DICTIONARY-ITERATOR NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-PROPERTY-LIST-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PLIST-ITERATOR-CURSOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PLIST-ITERATOR-COLLECTION NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-KV-LIST-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-THE-KV-LIST NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-KV-LIST-ITERATOR-CURSOR NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-INTEGER-INTERVAL-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-INTERVAL-CURSOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-LOWER-BOUND NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-UPPER-BOUND NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-REVERSE-INTEGER-INTERVAL-ITERATOR NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-STRING-ITERATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-THE-STRING NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CURSOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-END NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-OBJECT-COLLECTION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-OBJECT-SEQUENCE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-LIST NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-SET NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-CLASS-EXTENSION NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-CONS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VALUE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-REST NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-OBJECT-TO-OBJECT-DICTIONARY NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-PROPERTY-LIST NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-THE-PLIST NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-KV-CONS NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-KEY-VALUE-LIST NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-RECYCLE-LIST NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-RECYCLE-LIST-OF NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-RECYCLED-ITEMS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-LIST-OF-RECYCLED-ITEMS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ALL-ITEMS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-UNUSED-ITEMS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CURRENT-LENGTH NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ITEM-SIZE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-THE-STELLA-HASH-TABLE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-HASH-TABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-OBJECT-TO-OBJECT-HASH-TABLE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-INTEGER-HASH-TABLE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-FLOAT-HASH-TABLE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-STRING-HASH-TABLE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-STRING-TO-INTEGER-HASH-TABLE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-VECTOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ARRAY-SIZE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-EXTENSIBLE-VECTOR NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-EXTENSIBLE-SYMBOL-ARRAY NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-TOP-SYMBOL-OFFSET NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-POTENTIAL-FREE-SYMBOL-OFFSET NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-VECTOR-SEQUENCE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SEQUENCE-LENGTH NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-CUSTOM-VECTOR-SEQUENCE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-RESIZE-FACTOR NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-BOOLEAN-VECTOR NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-INTEGER-VECTOR NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-ACTIVE-LIST NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-ACTIVE-SET NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-DEMON NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEMON-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEMON-ACTION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEMON-CLASS-REFS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEMON-SLOT-REFS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEMON-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEMON-METHOD NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEMON-DOCUMENTATION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEMON-GUARD? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEMON-ALL? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEMON-INHERIT? NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-KEYWORD-KEY-VALUE-LIST NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SYMBOL-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SYMBOL-ID NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-INTERNED-IN NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-SYMBOL NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SYMBOL-SLOT-OFFSET NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SYMBOL-VALUE-AND-PLIST NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-SURROGATE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SURROGATE-VALUE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SURROGATE-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-TYPE-CLASS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-TYPE-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOTREF-SLOT NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOTREF NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-KEYWORD NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-KEYWORD-NAME NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-TRANSIENT-SYMBOL NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PROJECTS-ONTO NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PROJECTED-FROM NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PROPERTIES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ABSTRACT? NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-CLASS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-STORED-ACTIVE? NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-ACTIVE-OBJECT NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-CREATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-INITIALIZER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-TERMINATOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-DESTRUCTOR NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-PARAMETERS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-INITIAL-VALUE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-EXTENSION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-CL-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-CPP-NATIVE-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-JAVA-NATIVE-TYPE NULL)
(CL:DEFVAR *HARDWIRED-CLASS-ARITY-ON-CLASS* NULL-INTEGER)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *HARDWIRED-CLASS-ARITY-ON-CLASS*))
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-CL-STRUCT-SLOTS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-RECYCLE-METHOD NULL)
(CL:DEFVAR KWD-HIERARCHY-NONE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-REQUIRED-SLOT-NAMES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-CONSTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-DESTRUCTOR-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-KEY NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-SYNONYMS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CL-STRUCT? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-MIXIN? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-ARITY NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-DIRECT-SUPERS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-DIRECT-SUBS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-ALL-SUPER-CLASSES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-ALL-SLOTS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-LOCAL-SLOTS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-SLOT-AND-METHOD-CACHE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-ABSTRACT? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-MIXIN? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-COLLECTION? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-CL-STRUCT? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-PUBLIC? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-FINALIZED? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-SLOTS-FINALIZED? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-CONSTRUCTOR-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-SLOT-ACCESSOR-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-MARKED? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-TAXONOMY-NODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-DOCUMENTATION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLASS-PRINT-FORM NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PRINT-FORM NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-DIRECT-EQUIVALENT NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-HOME-MODULE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-RENAMES NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-COLLECTION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-CLOSURE-ASSUMPTION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-DIRECT-SUPERS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-DIRECT-SUBS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-OWNER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-BASE-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-SLOTREF NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-PUBLIC? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-RENAMED? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-EXTERNAL? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-MARKED? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-DOCUMENTATION NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-STORAGE-SLOT NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-ALLOCATION NULL)
(CL:DEFVAR KWD-HIERARCHY-INSTANCE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-DEFAULT-EXPRESSION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-READER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-WRITER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-GUARD-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-DEMONS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-REQUIRED? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-COMPONENT? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-READ-ONLY? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-HARDWIRED? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-CONTEXT-SENSITIVE? NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-METHOD-SLOT NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-PARAMETER-DIRECTIONS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-INLINED-FUNCTIONS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-EVALUATE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-SETTER? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-PARAMETER-NAMES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-PARAMETER-TYPE-SPECIFIERS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-RETURN-TYPE-SPECIFIERS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FUNCTION-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-FUNCTION? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-DOCUMENTATION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-AUXILIARY? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-STORAGE-SLOT NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SLOT-AUXILIARY? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-STORAGE-SLOT NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FUNCTION NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-PARAMETRIC-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SPECIFIER-BASE-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SPECIFIER-PARAMETER-TYPES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SPECIFIER-DIMENSIONS NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-ANCHORED-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SPECIFIER-PARAMETER-NAME NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-TABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-TUPLE-DOMAINS NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-GLOBAL-VARIABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-HOME-MODULE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-TYPE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-SPECIAL? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-CONSTANT? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-PUBLIC? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-AUXILIARY? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-GET-VALUE-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-SET-VALUE-CODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-VALUE-STACK NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-DOCUMENTATION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-VARIABLE-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-QUOTED-EXPRESSION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-QUOTATION-TABLE-OFFSET NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SURROGATE-VALUE-INVERSE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-WORLD-NAME NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-MODULE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-WORLD NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CHILD-CONTEXTS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-BASE-MODULE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ALL-SUPER-CONTEXTS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CONTEXT-NUMBER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-MODULE-LISP-PACKAGE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-MODULE-CPP-PACKAGE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SHADOWED-SURROGATES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-JAVA-PACKAGE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CLEARABLE? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PROTECT-SURROGATES? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PARENT-MODULES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NICKNAMES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-USES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-USED-BY NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-REQUIRES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CASE-SENSITIVE? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-MODULE-FULL-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-MODULE-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-MODULE-STRINGIFIED-SOURCE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-STRINGIFIED-OPTIONS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CARDINAL-MODULE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SYMBOL-OFFSET-TABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SURROGATE-OFFSET-TABLE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-STRICT-INFERENCE-CACHE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEFAULT-INFERENCE-CACHE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PROTOTYPE-INFERENCE-CACHE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PARENT-CONTEXT NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-CS-VALUE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-INTERVAL NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-TAXONOMY-NODE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NATIVE-OBJECT NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-LABEL NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-INTERVALS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-INITIAL-INTERVAL NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FIRST-INTERVAL-LOWER-BOUND NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FIRST-INTERVAL-UPPER-BOUND NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PARENTS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CHILDREN NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-TOTAL-ANCESTORS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-TREE-CHILDREN NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-MARKER NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-TAXONOMY-GRAPH NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-RENUMBER-IF-OUT-OF-NUMBERS? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-RENUMBER-RATIO NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-INCREMENTAL-MODE? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-LARGEST-POSTORDER-NUMBER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NUMBER-OF-NODES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NUMBER-OF-FOREIGN-INTERVAL-NODES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ROOTS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-BROKEN-LINKS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ADDED-LINKS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-REMOVED-LINKS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FILE-NAME NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-INTEGER-WRAPPER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-WRAPPER-VALUE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NULL-INTEGER NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-LONG-INTEGER-WRAPPER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NULL-LONG-INTEGER NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-FLOAT-WRAPPER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NULL-FLOAT NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-STRING-WRAPPER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NULL-STRING NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-MUTABLE-STRING-WRAPPER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NULL-MUTABLE-STRING NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-CHARACTER-WRAPPER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NULL-CHARACTER NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-BOOLEAN-WRAPPER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-TRUE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FALSE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-METHOD-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-VERBATIM-STRING-WRAPPER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-THREE-VALUED-BOOLEAN NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-SYSTEM-DEFINITION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NAME NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DIRECTORY NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FILES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-LISP-ONLY-FILES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-CPP-ONLY-FILES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-JAVA-ONLY-FILES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DATA-FILES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PREPROCESSED-FILES NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-REQUIRED-SYSTEMS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-LOADED? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-UP-TO-DATE? NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-SOURCE-ROOT-DIRECTORY NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-NATIVE-ROOT-DIRECTORY NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-BINARY-ROOT-DIRECTORY NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-BANNER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-COPYRIGHT-HEADER NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-PRODUCTION-SETTINGS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-DEVELOPMENT-SETTINGS NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FINALIZATION-FUNCTION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-STATE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-OUTPUT-STREAM NULL)
(CL:DEFVAR KWD-HIERARCHY-LINE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-INPUT-STREAM NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-ECHO-STREAM NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-TOKENIZER-STATE NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-BUFFERING-SCHEME NULL)
(CL:DEFVAR KWD-HIERARCHY-CREATE NULL)
(CL:DEFVAR KWD-HIERARCHY-SUPERSEDE NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-OUTPUT-FILE-STREAM NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FILENAME NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-IF-EXISTS-ACTION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-IF-NOT-EXISTS-ACTION NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FILE-OUTPUT-STREAM NULL)
(CL:DEFVAR KWD-HIERARCHY-BLOCK NULL)
(CL:DEFVAR KWD-HIERARCHY-ERROR NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-INPUT-FILE-STREAM NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-FILE-INPUT-STREAM NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-OUTPUT-STRING-STREAM NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-STRING-OUTPUT-STREAM NULL)
(CL:DEFVAR SGT-HIERARCHY-STELLA-INPUT-STRING-STREAM NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-STRING-INPUT-STREAM NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-STARTUP-HIERARCHY NULL)
(CL:DEFVAR SYM-HIERARCHY-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* *MODULE* NULL-LONG-INTEGER
  *PRINTREADABLY?* *HARDWIRED-CLASS-ARITY-ON-CLASS*
  *JAVA-STELLA-PACKAGE-MAPPING* NULL-STRING-WRAPPER NIL-LIST
  *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* *CONTEXT* NULL-FLOAT
  NULL-CHARACTER NIL TRUE-WRAPPER FALSE-WRAPPER NULL-INTEGER))

;;; (DEFCLASS OBJECT ...)

(CL:DEFCLASS OBJECT (CLSYS-ROOT-OBJECT)
  ()
  (:DOCUMENTATION
   "A reflective object that can participate in dynamically-typed
contexts.  Either a STANDARD-OBJECT or a WRAPPER or a GENERIC-OBJECT.
Also, either an OBJECT-WITH-INHERITED-TYPE or an OBJECT-WITH-OWN-TYPE."))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF OBJECT))
  "Returns the primary type of `self'.
Gets defined automatically for every non-abstract subclass of OBJECT."
  (CL:RETURN-FROM PRIMARY-TYPE NULL))

(%%DEFCONSMETHOD HOME-MODULE ((SELF OBJECT))
  "Return the home module of `self'."
  (CL:RETURN-FROM HOME-MODULE NULL))

(%%DEFCONSMETHOD DELETED? ((SELF OBJECT))
  "Default `deleted?' method which always returns FALSE.  Objects
that inherit DYNAMIC-SLOTS-MIXIN also inherit the dynamically-allocated slot
`deleted-object?' which is read/writable with specializations of this method."
  (CL:RETURN-FROM DELETED? CL:NIL))

(%%DEFCONSMETHOD INCREMENT-REFERENCE-COUNT ((SELF OBJECT))
  :VOID)

(%%DEFCONSMETHOD DECREMENT-REFERENCE-COUNT ((SELF OBJECT))
  :VOID)

(CL:DEFMETHOD PRINT-OBJECT ((SELF OBJECT) STREAM)
  (%%PRINT-STREAM STREAM "|i|" (PRIMARY-TYPE SELF))
  :VOID)

;;; (DEFCLASS STANDARD-OBJECT ...)

(CL:DEFCLASS STANDARD-OBJECT (OBJECT)
  ()
  (:DOCUMENTATION
   "Object that used to find its type stored in a :class slot.
By reimplementing `primary-type' as a method, the justification for this
class went away, but we'll keep it for now to keep things working."))

;;; (DEFCLASS REFERENCE-COUNT-OBJECT ...)

(CL:DEFCLASS REFERENCE-COUNT-OBJECT (OBJECT)
  ((REFERENCE-COUNT :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %REFERENCE-COUNT))
  (:DOCUMENTATION
   "A reference count objects contains a slot `reference-count' 
that is incremented whenever the object is assigned to a slot, and decremented
whenever it is deassigned from a slot."))

(CL:DEFMETHOD INCREMENT-REFERENCE-COUNT ((SELF REFERENCE-COUNT-OBJECT))
  (CL:SETF (%REFERENCE-COUNT SELF) (CL:1+ (%REFERENCE-COUNT SELF)))
  :VOID)

(CL:DEFMETHOD DECREMENT-REFERENCE-COUNT ((SELF REFERENCE-COUNT-OBJECT))
  (CL:SETF (%REFERENCE-COUNT SELF) (CL:1- (%REFERENCE-COUNT SELF)))
  :VOID)

(CL:DEFUN ACCESS-REFERENCE-COUNT-OBJECT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-REFERENCE-COUNT)
    (CL:IF SETVALUE?
     (CL:SETF (%REFERENCE-COUNT SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%REFERENCE-COUNT SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-REFERENCE-COUNT-OBJECT-SLOT-VALUE VALUE))

;;; (DEFCLASS CONTEXT-SENSITIVE-OBJECT ...)

(CL:DEFCLASS CONTEXT-SENSITIVE-OBJECT (STANDARD-OBJECT)
  ((HOME-CONTEXT :ALLOCATION :INSTANCE :ACCESSOR %HOME-CONTEXT))
  (:DOCUMENTATION
   "Context sensitive objects inherit a slot `home-context'
that enables context-dependent access machinery to determine the
visibility of objects from modules."))

(CL:DEFMETHOD HOME-MODULE ((SELF CONTEXT-SENSITIVE-OBJECT))
  (CL:LET* ((CONTEXT (%HOME-CONTEXT SELF)))
   (CL:IF (CL:NOT (CL:EQ CONTEXT NULL))
    (CL:RETURN-FROM HOME-MODULE (%BASE-MODULE CONTEXT))
    (CL:RETURN-FROM HOME-MODULE NULL))))

;;; (DEFCLASS ACTIVE-OBJECT ...)

(CL:DEFCLASS ACTIVE-OBJECT (CONTEXT-SENSITIVE-OBJECT)
  ((DYNAMIC-SLOTS :ALLOCATION :INSTANCE :ACCESSOR %DYNAMIC-SLOTS))
  (:DOCUMENTATION
   "Active objects call class and slot triggers in response
to instance creation/destruction and slot updates.  They include internal
storage slots needed for class extensions, dynamic storage, and home context."))

(CL:DEFMETHOD BAD? ((SELF ACTIVE-OBJECT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-BAD? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:RETURN-FROM BAD? FALSE-WRAPPER)
    (CL:RETURN-FROM BAD? ANSWER))))

(CL:DEFUN ACCESS-ACTIVE-OBJECT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-ACTIVE-OBJECT-SLOT-VALUE VALUE))

(CL:DEFMETHOD DELETED? ((SELF ACTIVE-OBJECT))
  (CL:LET*
   ((DELETED?
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-DELETED-OBJECT? NULL)))
   (CL:IF (CL:NOT (CL:EQ DELETED? NULL))
    (CL:RETURN-FROM DELETED?
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN DELETED?))
    (CL:RETURN-FROM DELETED? CL:NIL))))

(CL:DEFMETHOD DELETED?-SETTER ((SELF ACTIVE-OBJECT) VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-HIERARCHY-STELLA-DELETED-OBJECT?
   (CL:IF VALUE TRUE-WRAPPER FALSE-WRAPPER) NULL)
  (CL:RETURN-FROM DELETED?-SETTER VALUE))

;;; (DEFCLASS ABSTRACT-ITERATOR ...)

(CL:DEFCLASS ABSTRACT-ITERATOR (STANDARD-OBJECT)
  ((FIRST-ITERATION? :ALLOCATION :INSTANCE :ACCESSOR %FIRST-ITERATION?))
  (:DOCUMENTATION
   "Instances of ABSTRACT-ITERATOR support iteration over collections."))

(CL:DEFMETHOD NEXT? ((SELF ABSTRACT-ITERATOR))
  (CL:RETURN-FROM NEXT? CL:NIL))

(CL:DEFUN ACCESS-ABSTRACT-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-FIRST-ITERATION?)
    (CL:IF SETVALUE?
     (CL:SETF (%FIRST-ITERATION? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%FIRST-ITERATION? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-ABSTRACT-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFCLASS ITERATOR ...)

(CL:DEFCLASS ITERATOR (ABSTRACT-ITERATOR)
  ((VALUE :DOCUMENTATION "The current value of this iterator"
    :ALLOCATION :INSTANCE :ACCESSOR %VALUE))
  (:DOCUMENTATION "Instances of ITERATOR support iteration over 
collections of OBJECTs."))

;;; (DEFCLASS CONS-ITERATOR ...)

(CL:DEFCLASS CONS-ITERATOR (ITERATOR)
  ((CONS-ITERATOR-CURSOR :ALLOCATION :INSTANCE :ACCESSOR
    %CONS-ITERATOR-CURSOR))
  (:DOCUMENTATION "Iterator class for the class CONS."))

(CL:DEFUN NEW-CONS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CONS-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%CONS-ITERATOR-CURSOR SELF) NULL)
   (CL:RETURN-FROM NEW-CONS-ITERATOR SELF)))

(CL:DEFMETHOD FREE ((SELF CONS-ITERATOR))
  (CL:WHEN (TERMINATE-CONS-ITERATOR? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CONS-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-CONS-ITERATOR))

(CL:DEFUN ACCESS-CONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CONS-ITERATOR-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%CONS-ITERATOR-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%CONS-ITERATOR-CURSOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-CONS-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFCLASS LIST-ITERATOR ...)

(CL:DEFCLASS LIST-ITERATOR (ITERATOR)
  ((LIST-ITERATOR-CURSOR :ALLOCATION :INSTANCE :ACCESSOR
    %LIST-ITERATOR-CURSOR)
   (LIST-ITERATOR-COLLECTION :ALLOCATION :INSTANCE :ACCESSOR
    %LIST-ITERATOR-COLLECTION))
  (:DOCUMENTATION "Iterator class for the collection LIST."))

(CL:DEFUN NEW-LIST-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LIST-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%LIST-ITERATOR-COLLECTION SELF) NULL)
   (CL:SETF (%LIST-ITERATOR-CURSOR SELF) NULL)
   (CL:RETURN-FROM NEW-LIST-ITERATOR SELF)))

(CL:DEFMETHOD FREE ((SELF LIST-ITERATOR))
  (CL:WHEN (TERMINATE-LIST-ITERATOR? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LIST-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-LIST-ITERATOR))

(CL:DEFUN ACCESS-LIST-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-LIST-ITERATOR-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%LIST-ITERATOR-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%LIST-ITERATOR-CURSOR SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-LIST-ITERATOR-COLLECTION)
    (CL:IF SETVALUE? (CL:SETF (%LIST-ITERATOR-COLLECTION SELF) VALUE)
     (CL:SETQ VALUE (%LIST-ITERATOR-COLLECTION SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-LIST-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFCLASS DESTRUCTIVE-LIST-ITERATOR ...)

(CL:DEFCLASS DESTRUCTIVE-LIST-ITERATOR (ITERATOR)
  ((THE-CONS-LIST :ALLOCATION :INSTANCE :ACCESSOR %THE-CONS-LIST)
   (LIST-ITERATOR-CURSOR :ALLOCATION :INSTANCE :ACCESSOR
    %LIST-ITERATOR-CURSOR))
  (:DOCUMENTATION "An iterator that contains a cons list.  Iterates over
the stored list, and destroys it when the iterator is free'd."))

(CL:DEFUN NEW-DESTRUCTIVE-LIST-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE DESTRUCTIVE-LIST-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%LIST-ITERATOR-CURSOR SELF) NULL)
   (CL:SETF (%THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-DESTRUCTIVE-LIST-ITERATOR SELF)))

(CL:DEFMETHOD FREE ((SELF DESTRUCTIVE-LIST-ITERATOR))
  (CL:WHEN (TERMINATE-DESTRUCTIVE-LIST-ITERATOR? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DESTRUCTIVE-LIST-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-DESTRUCTIVE-LIST-ITERATOR))

(CL:DEFUN ACCESS-DESTRUCTIVE-LIST-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-THE-CONS-LIST)
    (CL:IF SETVALUE? (CL:SETF (%THE-CONS-LIST SELF) VALUE)
     (CL:SETQ VALUE (%THE-CONS-LIST SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-LIST-ITERATOR-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%LIST-ITERATOR-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%LIST-ITERATOR-CURSOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-DESTRUCTIVE-LIST-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFCLASS ALL-PURPOSE-ITERATOR ...)

(CL:DEFCLASS ALL-PURPOSE-ITERATOR (ITERATOR)
  ((KEY :ALLOCATION :INSTANCE :ACCESSOR %KEY)
   (ITERATOR-NEXT-CODE :ALLOCATION :INSTANCE :ACCESSOR
    %ITERATOR-NEXT-CODE)
   (ITERATOR-FILTER-CODE :ALLOCATION :INSTANCE :ACCESSOR
    %ITERATOR-FILTER-CODE)
   (ITERATOR-EMPTY-CODE :ALLOCATION :INSTANCE :ACCESSOR
    %ITERATOR-EMPTY-CODE)
   (ITERATOR-NESTED-ITERATOR :ALLOCATION :INSTANCE :ACCESSOR
    %ITERATOR-NESTED-ITERATOR)
   (ITERATOR-CONS-LIST :ALLOCATION :INSTANCE :ACCESSOR
    %ITERATOR-CONS-LIST)
   (ITERATOR-OBJECT :ALLOCATION :INSTANCE :ACCESSOR %ITERATOR-OBJECT)
   (ITERATOR-SECOND-OBJECT :ALLOCATION :INSTANCE :ACCESSOR
    %ITERATOR-SECOND-OBJECT)
   (ITERATOR-INTEGER :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %ITERATOR-INTEGER)
   (ITERATOR-SECOND-INTEGER :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %ITERATOR-SECOND-INTEGER))
  (:DOCUMENTATION "The all-purpose iterator works by storing a `next?'
function within itself during iterator allocation.  The method
`ALL-PURPOSE-ITERAOR.next?' funcalls the stored `next?' function.
An assortment of storage slots are provided for constructing different
kinds of iterators."))

(CL:DEFUN NEW-ALL-PURPOSE-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE ALL-PURPOSE-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%ITERATOR-SECOND-INTEGER SELF) NULL-INTEGER)
   (CL:SETF (%ITERATOR-INTEGER SELF) NULL-INTEGER)
   (CL:SETF (%ITERATOR-SECOND-OBJECT SELF) NULL)
   (CL:SETF (%ITERATOR-OBJECT SELF) NULL)
   (CL:SETF (%ITERATOR-CONS-LIST SELF) NULL)
   (CL:SETF (%ITERATOR-NESTED-ITERATOR SELF) NULL)
   (CL:SETF (%ITERATOR-EMPTY-CODE SELF) NULL)
   (CL:SETF (%ITERATOR-FILTER-CODE SELF) NULL)
   (CL:SETF (%ITERATOR-NEXT-CODE SELF) NULL) (CL:SETF (%KEY SELF) NULL)
   (CL:RETURN-FROM NEW-ALL-PURPOSE-ITERATOR SELF)))

(CL:DEFMETHOD FREE ((SELF ALL-PURPOSE-ITERATOR))
  (CL:WHEN (TERMINATE-ALL-PURPOSE-ITERATOR? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ALL-PURPOSE-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-ALL-PURPOSE-ITERATOR))

(CL:DEFUN ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-KEY)
    (CL:IF SETVALUE? (CL:SETF (%KEY SELF) VALUE)
     (CL:SETQ VALUE (%KEY SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ITERATOR-NEXT-CODE)
    (CL:IF SETVALUE?
     (CL:SETF (%ITERATOR-NEXT-CODE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FUNCTION-CODE (%ITERATOR-NEXT-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ITERATOR-FILTER-CODE)
    (CL:IF SETVALUE?
     (CL:SETF (%ITERATOR-FILTER-CODE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE (%ITERATOR-FILTER-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ITERATOR-EMPTY-CODE)
    (CL:IF SETVALUE?
     (CL:SETF (%ITERATOR-EMPTY-CODE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FUNCTION-CODE (%ITERATOR-EMPTY-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ITERATOR-NESTED-ITERATOR)
    (CL:IF SETVALUE? (CL:SETF (%ITERATOR-NESTED-ITERATOR SELF) VALUE)
     (CL:SETQ VALUE (%ITERATOR-NESTED-ITERATOR SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ITERATOR-CONS-LIST)
    (CL:IF SETVALUE? (CL:SETF (%ITERATOR-CONS-LIST SELF) VALUE)
     (CL:SETQ VALUE (%ITERATOR-CONS-LIST SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ITERATOR-OBJECT)
    (CL:IF SETVALUE? (CL:SETF (%ITERATOR-OBJECT SELF) VALUE)
     (CL:SETQ VALUE (%ITERATOR-OBJECT SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ITERATOR-SECOND-OBJECT)
    (CL:IF SETVALUE? (CL:SETF (%ITERATOR-SECOND-OBJECT SELF) VALUE)
     (CL:SETQ VALUE (%ITERATOR-SECOND-OBJECT SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ITERATOR-INTEGER)
    (CL:IF SETVALUE?
     (CL:SETF (%ITERATOR-INTEGER SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%ITERATOR-INTEGER SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ITERATOR-SECOND-INTEGER)
    (CL:IF SETVALUE?
     (CL:SETF (%ITERATOR-SECOND-INTEGER SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%ITERATOR-SECOND-INTEGER SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFCLASS TYPES-TO-CLASSES-ITERATOR ...)

(CL:DEFCLASS TYPES-TO-CLASSES-ITERATOR (ITERATOR)
  ((ITERATOR-CURSOR :ALLOCATION :INSTANCE :ACCESSOR %ITERATOR-CURSOR))
  (:DOCUMENTATION "Iterator that returns a class for each type
in a cons list of types."))

(CL:DEFUN NEW-TYPES-TO-CLASSES-ITERATOR (ITERATOR-CURSOR)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE TYPES-TO-CLASSES-ITERATOR)))
   (CL:SETF (%ITERATOR-CURSOR SELF) ITERATOR-CURSOR)
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:RETURN-FROM NEW-TYPES-TO-CLASSES-ITERATOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TYPES-TO-CLASSES-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-TYPES-TO-CLASSES-ITERATOR))

(CL:DEFMETHOD NEXT? ((SELF TYPES-TO-CLASSES-ITERATOR))
  (CL:IF (%FIRST-ITERATION? SELF)
   (CL:SETF (%FIRST-ITERATION? SELF) CL:NIL)
   (CL:SETF (%ITERATOR-CURSOR SELF) (%%REST (%ITERATOR-CURSOR SELF))))
  (CL:COND
   ((CL:NOT (CL:EQ (%ITERATOR-CURSOR SELF) NIL))
    (CL:SETF (%VALUE SELF)
     (%SURROGATE-VALUE (%%VALUE (%ITERATOR-CURSOR SELF))))
    (CL:RETURN-FROM NEXT? CL:T))
   (CL:T (CL:RETURN-FROM NEXT? CL:NIL))))

(CL:DEFUN ACCESS-TYPES-TO-CLASSES-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ITERATOR-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%ITERATOR-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%ITERATOR-CURSOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-TYPES-TO-CLASSES-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFCLASS ABSTRACT-DICTIONARY-ITERATOR ...)

(CL:DEFCLASS ABSTRACT-DICTIONARY-ITERATOR (ABSTRACT-ITERATOR)
  ()
  (:DOCUMENTATION
   "Instances of ABSTRACT-DICTIONARY-ITERATOR support iteration
over dictionaries."))

;;; (DEFCLASS DICTIONARY-ITERATOR ...)

(CL:DEFCLASS DICTIONARY-ITERATOR (ABSTRACT-DICTIONARY-ITERATOR)
  ((KEY :ALLOCATION :INSTANCE :ACCESSOR %KEY)
   (VALUE :DOCUMENTATION "The current value of this iterator"
    :ALLOCATION :INSTANCE :ACCESSOR %VALUE))
  (:DOCUMENTATION "Instances of DICTIONARY-ITERATOR support iteration
over dictionaries with keys and values of type OBJECT."))

(CL:DEFMETHOD VALUE-SETTER ((SELF DICTIONARY-ITERATOR) VALUE)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
    "DICTIONARY-ITERATOR.value-setter not implemented on `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

(CL:DEFMETHOD KEY-SETTER ((SELF DICTIONARY-ITERATOR) KEY)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
    "DICTIONARY-ITERATOR.key-setter not implemented on `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFCLASS PROPERTY-LIST-ITERATOR ...)

(CL:DEFCLASS PROPERTY-LIST-ITERATOR (DICTIONARY-ITERATOR)
  ((PLIST-ITERATOR-CURSOR :ALLOCATION :INSTANCE :ACCESSOR
    %PLIST-ITERATOR-CURSOR)
   (PLIST-ITERATOR-COLLECTION :ALLOCATION :INSTANCE :ACCESSOR
    %PLIST-ITERATOR-COLLECTION))
  (:DOCUMENTATION "Iterator class for the collection PROPERTY-LIST."))

(CL:DEFUN NEW-PROPERTY-LIST-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PROPERTY-LIST-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%KEY SELF) NULL)
   (CL:SETF (%PLIST-ITERATOR-COLLECTION SELF) NULL)
   (CL:SETF (%PLIST-ITERATOR-CURSOR SELF) NULL)
   (CL:RETURN-FROM NEW-PROPERTY-LIST-ITERATOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROPERTY-LIST-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-PROPERTY-LIST-ITERATOR))

(CL:DEFUN ACCESS-PROPERTY-LIST-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PLIST-ITERATOR-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%PLIST-ITERATOR-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%PLIST-ITERATOR-CURSOR SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PLIST-ITERATOR-COLLECTION)
    (CL:IF SETVALUE? (CL:SETF (%PLIST-ITERATOR-COLLECTION SELF) VALUE)
     (CL:SETQ VALUE (%PLIST-ITERATOR-COLLECTION SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-PROPERTY-LIST-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFCLASS KV-LIST-ITERATOR ...)

(CL:DEFCLASS KV-LIST-ITERATOR (DICTIONARY-ITERATOR)
  ((THE-KV-LIST :ALLOCATION :INSTANCE :ACCESSOR %THE-KV-LIST)
   (KV-LIST-ITERATOR-CURSOR :ALLOCATION :INSTANCE :ACCESSOR
    %KV-LIST-ITERATOR-CURSOR)))

(CL:DEFUN NEW-KV-LIST-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE KV-LIST-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%KEY SELF) NULL)
   (CL:SETF (%KV-LIST-ITERATOR-CURSOR SELF) NULL)
   (CL:SETF (%THE-KV-LIST SELF) NULL)
   (CL:RETURN-FROM NEW-KV-LIST-ITERATOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KV-LIST-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-KV-LIST-ITERATOR))

(CL:DEFUN ACCESS-KV-LIST-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-THE-KV-LIST)
    (CL:IF SETVALUE? (CL:SETF (%THE-KV-LIST SELF) VALUE)
     (CL:SETQ VALUE (%THE-KV-LIST SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-KV-LIST-ITERATOR-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%KV-LIST-ITERATOR-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%KV-LIST-ITERATOR-CURSOR SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-KV-LIST-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFCLASS INTERVAL-ITERATOR ...)

(CL:DEFCLASS INTERVAL-ITERATOR (ABSTRACT-ITERATOR)
  ()
  (:DOCUMENTATION
   "An iterator that specifies a (possibly infinite) range of
values.  Supports `member?' test as well as iteration methods."))

;;; (DEFCLASS INTEGER-INTERVAL-ITERATOR ...)

(CL:DEFCLASS INTEGER-INTERVAL-ITERATOR (INTERVAL-ITERATOR)
  ((INTERVAL-CURSOR :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %INTERVAL-CURSOR)
   (LOWER-BOUND :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %LOWER-BOUND)
   (UPPER-BOUND :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %UPPER-BOUND)
   (VALUE :DOCUMENTATION "The current value of this iterator"
    :ALLOCATION :INSTANCE :ACCESSOR %VALUE)))

(CL:DEFUN NEW-INTEGER-INTERVAL-ITERATOR (LOWER-BOUND UPPER-BOUND)
  (CL:DECLARE (CL:TYPE CL:FIXNUM LOWER-BOUND UPPER-BOUND))
  #+MCL
  (CL:CHECK-TYPE LOWER-BOUND CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE UPPER-BOUND CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE INTEGER-INTERVAL-ITERATOR)))
   (CL:SETF (%LOWER-BOUND SELF) LOWER-BOUND)
   (CL:SETF (%UPPER-BOUND SELF) UPPER-BOUND)
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%VALUE SELF) NULL-INTEGER)
   (CL:SETF (%INTERVAL-CURSOR SELF) NULL-INTEGER)
   (INITIALIZE-INTEGER-INTERVAL-ITERATOR SELF)
   (CL:RETURN-FROM NEW-INTEGER-INTERVAL-ITERATOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTEGER-INTERVAL-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-INTEGER-INTERVAL-ITERATOR))

(CL:DEFUN ACCESS-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-INTERVAL-CURSOR)
    (CL:IF SETVALUE?
     (CL:SETF (%INTERVAL-CURSOR SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%INTERVAL-CURSOR SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-LOWER-BOUND)
    (CL:IF SETVALUE?
     (CL:SETF (%LOWER-BOUND SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%LOWER-BOUND SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-UPPER-BOUND)
    (CL:IF SETVALUE?
     (CL:SETF (%UPPER-BOUND SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%UPPER-BOUND SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFCLASS REVERSE-INTEGER-INTERVAL-ITERATOR ...)

(CL:DEFCLASS REVERSE-INTEGER-INTERVAL-ITERATOR (INTERVAL-ITERATOR)
  ((INTERVAL-CURSOR :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %INTERVAL-CURSOR)
   (LOWER-BOUND :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %LOWER-BOUND)
   (UPPER-BOUND :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %UPPER-BOUND)
   (VALUE :DOCUMENTATION "The current value of this iterator"
    :ALLOCATION :INSTANCE :ACCESSOR %VALUE)))

(CL:DEFUN NEW-REVERSE-INTEGER-INTERVAL-ITERATOR (LOWER-BOUND UPPER-BOUND)
  (CL:DECLARE (CL:TYPE CL:FIXNUM LOWER-BOUND UPPER-BOUND))
  #+MCL
  (CL:CHECK-TYPE LOWER-BOUND CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE UPPER-BOUND CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE REVERSE-INTEGER-INTERVAL-ITERATOR)))
   (CL:SETF (%LOWER-BOUND SELF) LOWER-BOUND)
   (CL:SETF (%UPPER-BOUND SELF) UPPER-BOUND)
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%VALUE SELF) NULL-INTEGER)
   (CL:SETF (%INTERVAL-CURSOR SELF) NULL-INTEGER)
   (INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR SELF)
   (CL:RETURN-FROM NEW-REVERSE-INTEGER-INTERVAL-ITERATOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF REVERSE-INTEGER-INTERVAL-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-REVERSE-INTEGER-INTERVAL-ITERATOR))

(CL:DEFUN ACCESS-REVERSE-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-INTERVAL-CURSOR)
    (CL:IF SETVALUE?
     (CL:SETF (%INTERVAL-CURSOR SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%INTERVAL-CURSOR SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-LOWER-BOUND)
    (CL:IF SETVALUE?
     (CL:SETF (%LOWER-BOUND SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%LOWER-BOUND SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-UPPER-BOUND)
    (CL:IF SETVALUE?
     (CL:SETF (%UPPER-BOUND SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%UPPER-BOUND SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-REVERSE-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE
   VALUE))

;;; (DEFCLASS STRING-ITERATOR ...)

(CL:DEFCLASS STRING-ITERATOR (ABSTRACT-ITERATOR)
  ((THE-STRING :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %THE-STRING)
   (CURSOR :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %CURSOR)
   (END :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %END)
   (VALUE :DOCUMENTATION "The current value of this iterator"
    :ALLOCATION :INSTANCE :ACCESSOR %VALUE))
  (:DOCUMENTATION "Iterator that yields characters from a string."))

(CL:DEFUN NEW-STRING-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STRING-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T)
   (CL:SETF (%VALUE SELF) NULL-CHARACTER)
   (CL:SETF (%END SELF) NULL-INTEGER)
   (CL:SETF (%CURSOR SELF) NULL-INTEGER)
   (CL:SETF (%THE-STRING SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-STRING-ITERATOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STRING-ITERATOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-STRING-ITERATOR))

(CL:DEFUN ACCESS-STRING-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-THE-STRING)
    (CL:IF SETVALUE?
     (CL:SETF (%THE-STRING SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%THE-STRING SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%CURSOR SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%CURSOR SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-END)
    (CL:IF SETVALUE? (CL:SETF (%END SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%END SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-STRING-ITERATOR-SLOT-VALUE VALUE))

;;; (DEFCLASS ABSTRACT-COLLECTION ...)

(CL:DEFCLASS ABSTRACT-COLLECTION (STANDARD-OBJECT)
  ())

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF ABSTRACT-COLLECTION))
  (CL:RETURN-FROM ALLOCATE-ITERATOR NULL))

(CL:DEFMETHOD LENGTH ((SELF ABSTRACT-COLLECTION))
  (CL:RETURN-FROM LENGTH NULL-INTEGER))

;;; (DEFCLASS COLLECTION ...)

(CL:DEFCLASS COLLECTION (ABSTRACT-COLLECTION)
  ())

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF COLLECTION))
  (CL:RETURN-FROM ALLOCATE-ITERATOR NULL))

(CL:DEFMETHOD LENGTH ((SELF COLLECTION))
  (CL:RETURN-FROM LENGTH NULL-INTEGER))

(CL:DEFMETHOD INSERT ((SELF COLLECTION) VALUE)
  (CL:SETQ VALUE VALUE)
  (CL:RETURN-FROM INSERT)
  :VOID)

(CL:DEFMETHOD REMOVE ((SELF COLLECTION) VALUE)
  (CL:SETQ VALUE VALUE)
  (CL:RETURN-FROM REMOVE NULL))

;;; (DEFCLASS SEQUENCE ...)

(CL:DEFCLASS SEQUENCE (COLLECTION)
  ())

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF SEQUENCE))
  (CL:RETURN-FROM ALLOCATE-ITERATOR NULL))

(CL:DEFMETHOD LENGTH ((SEQUENCE SEQUENCE))
  (CL:RETURN-FROM LENGTH NULL-INTEGER))

;;; (DEFCLASS LIST ...)

(CL:DEFCLASS LIST (SEQUENCE)
  ((THE-CONS-LIST :ALLOCATION :INSTANCE :ACCESSOR %THE-CONS-LIST)))

(CL:DEFUN NEW-LIST ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LIST)))
   (CL:SETF (%THE-CONS-LIST SELF) NIL) (CL:RETURN-FROM NEW-LIST SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LIST))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-LIST))

(CL:DEFUN ACCESS-LIST-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-THE-CONS-LIST)
    (CL:IF SETVALUE? (CL:SETF (%THE-CONS-LIST SELF) VALUE)
     (CL:SETQ VALUE (%THE-CONS-LIST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-LIST-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF LIST) STREAM)
  (CL:PROGN (%%PRINT-STREAM STREAM "|l|")
   (PRINT-CONS (%THE-CONS-LIST SELF) STREAM "(" ")"))
  :VOID)

;;; (DEFCLASS SET ...)

(CL:DEFCLASS SET (LIST)
  ())

(CL:DEFUN NEW-SET ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SET)))
   (CL:SETF (%THE-CONS-LIST SELF) NIL) (CL:RETURN-FROM NEW-SET SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SET))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-SET))

(CL:DEFMETHOD PRINT-OBJECT ((SELF SET) STREAM)
  (CL:PROGN (%%PRINT-STREAM STREAM "|s|")
   (PRINT-CONS (%THE-CONS-LIST SELF) STREAM "(" ")"))
  :VOID)

;;; (DEFCLASS CLASS-EXTENSION ...)

(CL:DEFCLASS CLASS-EXTENSION (LIST)
  ())

(CL:DEFUN NEW-CLASS-EXTENSION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CLASS-EXTENSION)))
   (CL:SETF (%THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-CLASS-EXTENSION SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CLASS-EXTENSION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-CLASS-EXTENSION))

;;; (DEFCLASS CONS ...)

(CL:DEFCLASS CONS (STANDARD-OBJECT)
  ((VALUE :ALLOCATION :INSTANCE :ACCESSOR %VALUE)
   (REST :ALLOCATION :INSTANCE :ACCESSOR %REST)))

(CL:DEFUN NEW-CONS ()
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (CL:CONS CL:NIL CL:NIL))
   (CL:SETF (%%REST SELF) NIL) (CL:SETF (%%VALUE SELF) NULL)
   (CL:RETURN-FROM NEW-CONS SELF)))

(%%DEFCONSMETHOD PRIMARY-TYPE ((SELF CL:CONS))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-CONS))

(CL:DEFUN ACCESS-CONS-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%%VALUE SELF) VALUE)
     (CL:SETQ VALUE (%%VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-REST)
    (CL:IF SETVALUE? (CL:SETF (%%REST SELF) VALUE)
     (CL:SETQ VALUE (%%REST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-CONS-SLOT-VALUE VALUE))

;;; (DEFCLASS ABSTRACT-DICTIONARY ...)

(CL:DEFCLASS ABSTRACT-DICTIONARY (ABSTRACT-COLLECTION)
  ())

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF ABSTRACT-DICTIONARY))
  (CL:RETURN-FROM ALLOCATE-ITERATOR NULL))

;;; (DEFCLASS DICTIONARY ...)

(CL:DEFCLASS DICTIONARY (ABSTRACT-DICTIONARY)
  ())

(CL:DEFMETHOD ALLOCATE-ITERATOR ((SELF DICTIONARY))
  (CL:RETURN-FROM ALLOCATE-ITERATOR NULL))

(CL:DEFMETHOD LOOKUP ((SELF DICTIONARY) KEY)
  (CL:SETQ KEY KEY)
  (CL:RETURN-FROM LOOKUP NULL))

(CL:DEFMETHOD INSERT-AT ((SELF DICTIONARY) KEY VALUE)
  (CL:PROGN (CL:SETQ KEY KEY) (CL:SETQ VALUE VALUE))
  (CL:RETURN-FROM INSERT-AT)
  :VOID)

;;; (DEFCLASS PROPERTY-LIST ...)

(CL:DEFCLASS PROPERTY-LIST (DICTIONARY)
  ((THE-PLIST :ALLOCATION :INSTANCE :ACCESSOR %THE-PLIST)))

(CL:DEFUN NEW-PROPERTY-LIST ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PROPERTY-LIST)))
   (CL:SETF (%THE-PLIST SELF) NIL)
   (CL:RETURN-FROM NEW-PROPERTY-LIST SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROPERTY-LIST))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-PROPERTY-LIST))

(CL:DEFUN ACCESS-PROPERTY-LIST-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-THE-PLIST)
    (CL:IF SETVALUE? (CL:SETF (%THE-PLIST SELF) VALUE)
     (CL:SETQ VALUE (%THE-PLIST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-PROPERTY-LIST-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF PROPERTY-LIST) STREAM)
  (CL:PROGN (%%PRINT-STREAM STREAM "|pl|")
   (PRINT-CONS (%THE-PLIST SELF) STREAM "(" ")"))
  :VOID)

;;; (DEFCLASS KV-CONS ...)

(CL:DEFCLASS KV-CONS (STANDARD-OBJECT)
  ((KEY :ALLOCATION :INSTANCE :ACCESSOR %KEY)
   (VALUE :ALLOCATION :INSTANCE :ACCESSOR %VALUE)
   (REST :ALLOCATION :INSTANCE :ACCESSOR %REST)))

(CL:DEFUN NEW-KV-CONS ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE KV-CONS)))
   (CL:SETF (%REST SELF) NULL) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%KEY SELF) NULL) (CL:RETURN-FROM NEW-KV-CONS SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KV-CONS))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-KV-CONS))

(CL:DEFUN ACCESS-KV-CONS-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-KEY)
    (CL:IF SETVALUE? (CL:SETF (%KEY SELF) VALUE)
     (CL:SETQ VALUE (%KEY SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%VALUE SELF) VALUE)
     (CL:SETQ VALUE (%VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-REST)
    (CL:IF SETVALUE? (CL:SETF (%REST SELF) VALUE)
     (CL:SETQ VALUE (%REST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-KV-CONS-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF KV-CONS) STREAM)
  (%%PRINT-STREAM STREAM "<" (%KEY SELF) "," (%VALUE SELF) ">")
  :VOID)

;;; (DEFCLASS KEY-VALUE-LIST ...)

(CL:DEFCLASS KEY-VALUE-LIST (DICTIONARY)
  ((THE-KV-LIST :ALLOCATION :INSTANCE :ACCESSOR %THE-KV-LIST)))

(CL:DEFUN NEW-KEY-VALUE-LIST ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE KEY-VALUE-LIST)))
   (CL:SETF (%THE-KV-LIST SELF) NULL)
   (CL:RETURN-FROM NEW-KEY-VALUE-LIST SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KEY-VALUE-LIST))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-KEY-VALUE-LIST))

(CL:DEFUN ACCESS-KEY-VALUE-LIST-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-THE-KV-LIST)
    (CL:IF SETVALUE? (CL:SETF (%THE-KV-LIST SELF) VALUE)
     (CL:SETQ VALUE (%THE-KV-LIST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-KEY-VALUE-LIST-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF KEY-VALUE-LIST) STREAM)
  (PRINT-KEY-VALUE-LIST SELF STREAM)
  :VOID)

;;; (DEFCLASS RECYCLE-LIST ...)

(CL:DEFCLASS RECYCLE-LIST (SEQUENCE)
  ((RECYCLE-LIST-OF :ALLOCATION :INSTANCE :ACCESSOR %RECYCLE-LIST-OF)
   (RECYCLED-ITEMS :ALLOCATION :INSTANCE :ACCESSOR %RECYCLED-ITEMS)
   (LIST-OF-RECYCLED-ITEMS :ALLOCATION :INSTANCE :ACCESSOR
    %LIST-OF-RECYCLED-ITEMS)
   (ALL-ITEMS :ALLOCATION :INSTANCE :ACCESSOR %ALL-ITEMS)
   (UNUSED-ITEMS :ALLOCATION :INSTANCE :ACCESSOR %UNUSED-ITEMS)
   (CURRENT-LENGTH :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %CURRENT-LENGTH)
   (ITEM-SIZE :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %ITEM-SIZE)))

(CL:DEFUN NEW-RECYCLE-LIST ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE RECYCLE-LIST)))
   (CL:SETF (%ITEM-SIZE SELF) NULL-INTEGER)
   (CL:SETF (%CURRENT-LENGTH SELF) 0)
   (CL:SETF (%UNUSED-ITEMS SELF) NULL) (CL:SETF (%ALL-ITEMS SELF) NULL)
   (CL:SETF (%LIST-OF-RECYCLED-ITEMS SELF) (MAKE-NON-RECYCLED-LIST))
   (CL:SETF (%RECYCLED-ITEMS SELF) NULL)
   (CL:SETF (%RECYCLE-LIST-OF SELF) NULL)
   (CL:RETURN-FROM NEW-RECYCLE-LIST SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF RECYCLE-LIST))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-RECYCLE-LIST))

(CL:DEFUN ACCESS-RECYCLE-LIST-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-RECYCLE-LIST-OF)
    (CL:IF SETVALUE? (CL:SETF (%RECYCLE-LIST-OF SELF) VALUE)
     (CL:SETQ VALUE (%RECYCLE-LIST-OF SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-RECYCLED-ITEMS)
    (CL:IF SETVALUE? (CL:SETF (%RECYCLED-ITEMS SELF) VALUE)
     (CL:SETQ VALUE (%RECYCLED-ITEMS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-LIST-OF-RECYCLED-ITEMS)
    (CL:IF SETVALUE? (CL:SETF (%LIST-OF-RECYCLED-ITEMS SELF) VALUE)
     (CL:SETQ VALUE (%LIST-OF-RECYCLED-ITEMS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ALL-ITEMS)
    (CL:IF SETVALUE? (CL:SETF (%ALL-ITEMS SELF) VALUE)
     (CL:SETQ VALUE (%ALL-ITEMS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-UNUSED-ITEMS)
    (CL:IF SETVALUE? (CL:SETF (%UNUSED-ITEMS SELF) VALUE)
     (CL:SETQ VALUE (%UNUSED-ITEMS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CURRENT-LENGTH)
    (CL:IF SETVALUE?
     (CL:SETF (%CURRENT-LENGTH SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%CURRENT-LENGTH SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ITEM-SIZE)
    (CL:IF SETVALUE? (CL:SETF (%ITEM-SIZE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%ITEM-SIZE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-RECYCLE-LIST-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF RECYCLE-LIST) STREAM)
  (CL:IF (CL:NOT (CL:EQ (%RECYCLE-LIST-OF SELF) NULL))
   (%%PRINT-STREAM STREAM "|i|[RECYCLE-LIST OF " (%CURRENT-LENGTH SELF)
    " " (%RECYCLE-LIST-OF SELF) "'s]")
   (%%PRINT-STREAM STREAM "|i|@RECYCLE-LIST"))
  :VOID)

;;; (DEFCLASS ABSTRACT-HASH-TABLE ...)

(CL:DEFCLASS ABSTRACT-HASH-TABLE (ABSTRACT-DICTIONARY)
  ((THE-HASH-TABLE :ALLOCATION :INSTANCE :ACCESSOR %THE-HASH-TABLE)
   (THE-STELLA-HASH-TABLE :ALLOCATION :INSTANCE :ACCESSOR
    %THE-STELLA-HASH-TABLE)))

(CL:DEFUN ACCESS-ABSTRACT-HASH-TABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-THE-STELLA-HASH-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%THE-STELLA-HASH-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%THE-STELLA-HASH-TABLE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-ABSTRACT-HASH-TABLE-SLOT-VALUE VALUE))

;;; (DEFCLASS HASH-TABLE ...)

(CL:DEFCLASS HASH-TABLE (ABSTRACT-HASH-TABLE)
  ())

(CL:DEFUN NEW-HASH-TABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE HASH-TABLE)))
   (CL:SETF (%THE-STELLA-HASH-TABLE SELF) NULL)
   (CL:SETF (%THE-HASH-TABLE SELF) NULL) (INITIALIZE-HASH-TABLE SELF)
   (CL:RETURN-FROM NEW-HASH-TABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-HASH-TABLE))

;;; (DEFCLASS INTEGER-HASH-TABLE ...)

(CL:DEFCLASS INTEGER-HASH-TABLE (ABSTRACT-HASH-TABLE)
  ())

(CL:DEFUN NEW-INTEGER-HASH-TABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INTEGER-HASH-TABLE)))
   (CL:SETF (%THE-STELLA-HASH-TABLE SELF) NULL)
   (CL:SETF (%THE-HASH-TABLE SELF) NULL) (INITIALIZE-HASH-TABLE SELF)
   (CL:RETURN-FROM NEW-INTEGER-HASH-TABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTEGER-HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-INTEGER-HASH-TABLE))

;;; (DEFCLASS FLOAT-HASH-TABLE ...)

(CL:DEFCLASS FLOAT-HASH-TABLE (ABSTRACT-HASH-TABLE)
  ())

(CL:DEFUN NEW-FLOAT-HASH-TABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FLOAT-HASH-TABLE)))
   (CL:SETF (%THE-STELLA-HASH-TABLE SELF) NULL)
   (CL:SETF (%THE-HASH-TABLE SELF) NULL) (INITIALIZE-HASH-TABLE SELF)
   (CL:RETURN-FROM NEW-FLOAT-HASH-TABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FLOAT-HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-FLOAT-HASH-TABLE))

;;; (DEFCLASS STRING-HASH-TABLE ...)

(CL:DEFCLASS STRING-HASH-TABLE (ABSTRACT-HASH-TABLE)
  ())

(CL:DEFUN NEW-STRING-HASH-TABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STRING-HASH-TABLE)))
   (CL:SETF (%THE-STELLA-HASH-TABLE SELF) NULL)
   (CL:SETF (%THE-HASH-TABLE SELF) NULL) (INITIALIZE-HASH-TABLE SELF)
   (CL:RETURN-FROM NEW-STRING-HASH-TABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STRING-HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-STRING-HASH-TABLE))

;;; (DEFCLASS STRING-TO-INTEGER-HASH-TABLE ...)

(CL:DEFCLASS STRING-TO-INTEGER-HASH-TABLE (ABSTRACT-HASH-TABLE)
  ())

(CL:DEFUN NEW-STRING-TO-INTEGER-HASH-TABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE STRING-TO-INTEGER-HASH-TABLE)))
   (CL:SETF (%THE-STELLA-HASH-TABLE SELF) NULL)
   (CL:SETF (%THE-HASH-TABLE SELF) NULL) (INITIALIZE-HASH-TABLE SELF)
   (CL:RETURN-FROM NEW-STRING-TO-INTEGER-HASH-TABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STRING-TO-INTEGER-HASH-TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-STRING-TO-INTEGER-HASH-TABLE))

;;; (DEFCLASS VECTOR ...)

(CL:DEFCLASS VECTOR (SEQUENCE)
  ((ARRAY-SIZE :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %ARRAY-SIZE)
   (THE-ARRAY :TYPE CL:SIMPLE-VECTOR :INITFORM
    STELLA::NULL-NATIVE-VECTOR :ALLOCATION :INSTANCE :ACCESSOR
    %THE-ARRAY)))

(CL:DEFUN NEW-VECTOR (ARRAY-SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARRAY-SIZE))
  #+MCL
  (CL:CHECK-TYPE ARRAY-SIZE CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE VECTOR)))
   (CL:SETF (%ARRAY-SIZE SELF) ARRAY-SIZE)
   (CL:SETF (%THE-ARRAY SELF) STELLA::NULL-NATIVE-VECTOR)
   (INITIALIZE-VECTOR SELF) (CL:RETURN-FROM NEW-VECTOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF VECTOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-VECTOR))

(CL:DEFUN ACCESS-VECTOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ARRAY-SIZE)
    (CL:IF SETVALUE?
     (CL:SETF (%ARRAY-SIZE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%ARRAY-SIZE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-VECTOR-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF VECTOR) STREAM)
  (PRINT-VECTOR SELF STREAM)
  :VOID)

;;; (DEFCLASS EXTENSIBLE-VECTOR ...)

(CL:DEFCLASS EXTENSIBLE-VECTOR (VECTOR)
  ())

(CL:DEFUN NEW-EXTENSIBLE-VECTOR (ARRAY-SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARRAY-SIZE))
  #+MCL
  (CL:CHECK-TYPE ARRAY-SIZE CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE EXTENSIBLE-VECTOR)))
   (CL:SETF (%ARRAY-SIZE SELF) ARRAY-SIZE)
   (CL:SETF (%THE-ARRAY SELF) STELLA::NULL-NATIVE-VECTOR)
   (INITIALIZE-VECTOR SELF) (CL:RETURN-FROM NEW-EXTENSIBLE-VECTOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF EXTENSIBLE-VECTOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-EXTENSIBLE-VECTOR))

;;; (DEFCLASS EXTENSIBLE-SYMBOL-ARRAY ...)

(CL:DEFCLASS EXTENSIBLE-SYMBOL-ARRAY (EXTENSIBLE-VECTOR)
  ((TOP-SYMBOL-OFFSET :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %TOP-SYMBOL-OFFSET)
   (POTENTIAL-FREE-SYMBOL-OFFSET :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %POTENTIAL-FREE-SYMBOL-OFFSET))
  (:DOCUMENTATION "Self-extending array with methods for storing and
accessing symbols within it."))

(CL:DEFUN NEW-EXTENSIBLE-SYMBOL-ARRAY (ARRAY-SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARRAY-SIZE))
  #+MCL
  (CL:CHECK-TYPE ARRAY-SIZE CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE EXTENSIBLE-SYMBOL-ARRAY)))
   (CL:SETF (%ARRAY-SIZE SELF) ARRAY-SIZE)
   (CL:SETF (%THE-ARRAY SELF) STELLA::NULL-NATIVE-VECTOR)
   (CL:SETF (%POTENTIAL-FREE-SYMBOL-OFFSET SELF) 0)
   (CL:SETF (%TOP-SYMBOL-OFFSET SELF) -1) (INITIALIZE-VECTOR SELF)
   (CL:RETURN-FROM NEW-EXTENSIBLE-SYMBOL-ARRAY SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF EXTENSIBLE-SYMBOL-ARRAY))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-EXTENSIBLE-SYMBOL-ARRAY))

(CL:DEFUN ACCESS-EXTENSIBLE-SYMBOL-ARRAY-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-TOP-SYMBOL-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%TOP-SYMBOL-OFFSET SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%TOP-SYMBOL-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-POTENTIAL-FREE-SYMBOL-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%POTENTIAL-FREE-SYMBOL-OFFSET SELF)
      (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%POTENTIAL-FREE-SYMBOL-OFFSET SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-EXTENSIBLE-SYMBOL-ARRAY-SLOT-VALUE VALUE))

;;; (DEFCLASS VECTOR-SEQUENCE ...)

(CL:DEFCLASS VECTOR-SEQUENCE (VECTOR)
  ((SEQUENCE-LENGTH :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %SEQUENCE-LENGTH))
  (:DOCUMENTATION
   "Extensible sequence implemented by a vector.  Whenever we run
out of room, we grow the sequence by a factor of two.  Note that this keeps the
average insertion cost per element constant.  This is generally preferable over
linked lists unless we need within-list insertions or removals, since it uses
less space and has better cache locality."))

(CL:DEFUN NEW-VECTOR-SEQUENCE (ARRAY-SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARRAY-SIZE))
  #+MCL
  (CL:CHECK-TYPE ARRAY-SIZE CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE VECTOR-SEQUENCE)))
   (CL:SETF (%ARRAY-SIZE SELF) ARRAY-SIZE)
   (CL:SETF (%THE-ARRAY SELF) STELLA::NULL-NATIVE-VECTOR)
   (CL:SETF (%SEQUENCE-LENGTH SELF) 0) (INITIALIZE-VECTOR SELF)
   (CL:RETURN-FROM NEW-VECTOR-SEQUENCE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF VECTOR-SEQUENCE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-VECTOR-SEQUENCE))

(CL:DEFUN ACCESS-VECTOR-SEQUENCE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SEQUENCE-LENGTH)
    (CL:IF SETVALUE?
     (CL:SETF (%SEQUENCE-LENGTH SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%SEQUENCE-LENGTH SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-VECTOR-SEQUENCE-SLOT-VALUE VALUE))

;;; (DEFCLASS CUSTOM-VECTOR-SEQUENCE ...)

(CL:DEFCLASS CUSTOM-VECTOR-SEQUENCE (VECTOR-SEQUENCE)
  ((RESIZE-FACTOR :TYPE CL:DOUBLE-FLOAT :INITFORM NULL-FLOAT
    :ALLOCATION :INSTANCE :ACCESSOR %RESIZE-FACTOR))
  (:DOCUMENTATION
   "VECTOR-SEQUENCE (which see) with a customizable resize factor.
The resize factor needs to be > 1."))

(CL:DEFUN NEW-CUSTOM-VECTOR-SEQUENCE (ARRAY-SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARRAY-SIZE))
  #+MCL
  (CL:CHECK-TYPE ARRAY-SIZE CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CUSTOM-VECTOR-SEQUENCE)))
   (CL:SETF (%ARRAY-SIZE SELF) ARRAY-SIZE)
   (CL:SETF (%THE-ARRAY SELF) STELLA::NULL-NATIVE-VECTOR)
   (CL:SETF (%SEQUENCE-LENGTH SELF) 0)
   (CL:SETF (%RESIZE-FACTOR SELF) 2.0d0) (INITIALIZE-VECTOR SELF)
   (CL:RETURN-FROM NEW-CUSTOM-VECTOR-SEQUENCE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CUSTOM-VECTOR-SEQUENCE))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-CUSTOM-VECTOR-SEQUENCE))

(CL:DEFUN ACCESS-CUSTOM-VECTOR-SEQUENCE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-RESIZE-FACTOR)
    (CL:IF SETVALUE?
     (CL:SETF (%RESIZE-FACTOR SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%RESIZE-FACTOR SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-CUSTOM-VECTOR-SEQUENCE-SLOT-VALUE VALUE))

;;; (DEFCLASS BOOLEAN-VECTOR ...)

(CL:DEFCLASS BOOLEAN-VECTOR (VECTOR)
  ())

(CL:DEFUN NEW-BOOLEAN-VECTOR (ARRAY-SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARRAY-SIZE))
  #+MCL
  (CL:CHECK-TYPE ARRAY-SIZE CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE BOOLEAN-VECTOR)))
   (CL:SETF (%ARRAY-SIZE SELF) ARRAY-SIZE)
   (CL:SETF (%THE-ARRAY SELF) STELLA::NULL-NATIVE-VECTOR)
   (INITIALIZE-VECTOR SELF) (CL:RETURN-FROM NEW-BOOLEAN-VECTOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BOOLEAN-VECTOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-BOOLEAN-VECTOR))

;;; (DEFCLASS INTEGER-VECTOR ...)

(CL:DEFCLASS INTEGER-VECTOR (VECTOR)
  ())

(CL:DEFUN NEW-INTEGER-VECTOR (ARRAY-SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARRAY-SIZE))
  #+MCL
  (CL:CHECK-TYPE ARRAY-SIZE CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INTEGER-VECTOR)))
   (CL:SETF (%ARRAY-SIZE SELF) ARRAY-SIZE)
   (CL:SETF (%THE-ARRAY SELF) STELLA::NULL-NATIVE-VECTOR)
   (INITIALIZE-VECTOR SELF) (CL:RETURN-FROM NEW-INTEGER-VECTOR SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTEGER-VECTOR))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-INTEGER-VECTOR))

;;; (DEFCLASS ACTIVE-LIST ...)

(CL:DEFCLASS ACTIVE-LIST (LIST)
  ((ACTIVE-SLOT :ALLOCATION :INSTANCE :ACCESSOR %ACTIVE-SLOT)
   (OWNER-INSTANCE :ALLOCATION :INSTANCE :ACCESSOR %OWNER-INSTANCE)))

(CL:DEFUN NEW-ACTIVE-LIST ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE ACTIVE-LIST)))
   (CL:SETF (%OWNER-INSTANCE SELF) NULL)
   (CL:SETF (%ACTIVE-SLOT SELF) NULL)
   (CL:SETF (%THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-ACTIVE-LIST SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ACTIVE-LIST))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-ACTIVE-LIST))

;;; (DEFCLASS ACTIVE-SET ...)

(CL:DEFCLASS ACTIVE-SET (LIST)
  ((ACTIVE-SLOT :ALLOCATION :INSTANCE :ACCESSOR %ACTIVE-SLOT)
   (OWNER-INSTANCE :ALLOCATION :INSTANCE :ACCESSOR %OWNER-INSTANCE)))

(CL:DEFUN NEW-ACTIVE-SET ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE ACTIVE-SET)))
   (CL:SETF (%OWNER-INSTANCE SELF) NULL)
   (CL:SETF (%ACTIVE-SLOT SELF) NULL)
   (CL:SETF (%THE-CONS-LIST SELF) NIL)
   (CL:RETURN-FROM NEW-ACTIVE-SET SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ACTIVE-SET))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-ACTIVE-SET))

;;; (DEFCLASS DEMON ...)

(CL:DEFCLASS DEMON (STANDARD-OBJECT)
  ((DEMON-NAME :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %DEMON-NAME)
   (DEMON-ACTION :ALLOCATION :INSTANCE :ACCESSOR %DEMON-ACTION)
   (DEMON-CLASS-REFS :ALLOCATION :INSTANCE :ACCESSOR %DEMON-CLASS-REFS)
   (DEMON-SLOT-REFS :ALLOCATION :INSTANCE :ACCESSOR %DEMON-SLOT-REFS)
   (DEMON-CODE :ALLOCATION :INSTANCE :ACCESSOR %DEMON-CODE)
   (DEMON-METHOD :ALLOCATION :INSTANCE :ACCESSOR %DEMON-METHOD)
   (DEMON-DOCUMENTATION :TYPE CL:SIMPLE-STRING :INITFORM
    STELLA::NULL-STRING :ALLOCATION :INSTANCE :ACCESSOR
    %DEMON-DOCUMENTATION)
   (DEMON-GUARD? :ALLOCATION :INSTANCE :ACCESSOR %DEMON-GUARD?)
   (DEMON-ALL? :ALLOCATION :INSTANCE :ACCESSOR %DEMON-ALL?)
   (DEMON-INHERIT? :ALLOCATION :INSTANCE :ACCESSOR %DEMON-INHERIT?)))

(CL:DEFUN NEW-DEMON ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE DEMON)))
   (CL:SETF (%DEMON-INHERIT? SELF) CL:NIL)
   (CL:SETF (%DEMON-ALL? SELF) CL:NIL)
   (CL:SETF (%DEMON-GUARD? SELF) CL:NIL)
   (CL:SETF (%DEMON-DOCUMENTATION SELF) STELLA::NULL-STRING)
   (CL:SETF (%DEMON-METHOD SELF) NULL)
   (CL:SETF (%DEMON-CODE SELF) NULL)
   (CL:SETF (%DEMON-SLOT-REFS SELF) (NEW-LIST))
   (CL:SETF (%DEMON-CLASS-REFS SELF) (NEW-LIST))
   (CL:SETF (%DEMON-ACTION SELF) NULL)
   (CL:SETF (%DEMON-NAME SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-DEMON SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DEMON))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-DEMON))

(CL:DEFUN ACCESS-DEMON-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEMON-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%DEMON-NAME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%DEMON-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEMON-ACTION)
    (CL:IF SETVALUE? (CL:SETF (%DEMON-ACTION SELF) VALUE)
     (CL:SETQ VALUE (%DEMON-ACTION SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEMON-CLASS-REFS)
    (CL:IF SETVALUE? (CL:SETF (%DEMON-CLASS-REFS SELF) VALUE)
     (CL:SETQ VALUE (%DEMON-CLASS-REFS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEMON-SLOT-REFS)
    (CL:IF SETVALUE? (CL:SETF (%DEMON-SLOT-REFS SELF) VALUE)
     (CL:SETQ VALUE (%DEMON-SLOT-REFS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEMON-CODE)
    (CL:IF SETVALUE?
     (CL:SETF (%DEMON-CODE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FUNCTION-CODE (%DEMON-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEMON-METHOD)
    (CL:IF SETVALUE? (CL:SETF (%DEMON-METHOD SELF) VALUE)
     (CL:SETQ VALUE (%DEMON-METHOD SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEMON-DOCUMENTATION)
    (CL:IF SETVALUE?
     (CL:SETF (%DEMON-DOCUMENTATION SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%DEMON-DOCUMENTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEMON-GUARD?)
    (CL:IF SETVALUE?
     (CL:SETF (%DEMON-GUARD? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%DEMON-GUARD? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEMON-ALL?)
    (CL:IF SETVALUE?
     (CL:SETF (%DEMON-ALL? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%DEMON-ALL? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEMON-INHERIT?)
    (CL:IF SETVALUE?
     (CL:SETF (%DEMON-INHERIT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%DEMON-INHERIT? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-DEMON-SLOT-VALUE VALUE))

;;; (DEFCLASS KEYWORD-KEY-VALUE-LIST ...)

(CL:DEFCLASS KEYWORD-KEY-VALUE-LIST (KEY-VALUE-LIST)
  ())

(CL:DEFUN NEW-KEYWORD-KEY-VALUE-LIST ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE KEYWORD-KEY-VALUE-LIST)))
   (CL:SETF (%THE-KV-LIST SELF) NULL)
   (CL:RETURN-FROM NEW-KEYWORD-KEY-VALUE-LIST SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KEYWORD-KEY-VALUE-LIST))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-KEYWORD-KEY-VALUE-LIST))

;;; (DEFCLASS GENERALIZED-SYMBOL ...)

(CL:DEFCLASS GENERALIZED-SYMBOL (CONTEXT-SENSITIVE-OBJECT)
  ((SYMBOL-NAME :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %SYMBOL-NAME)
   (SYMBOL-ID :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %SYMBOL-ID)))

(CL:DEFUN ACCESS-GENERALIZED-SYMBOL-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SYMBOL-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%SYMBOL-NAME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%SYMBOL-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SYMBOL-ID)
    (CL:IF SETVALUE? (CL:SETF (%SYMBOL-ID SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%SYMBOL-ID SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-INTERNED-IN)
    (CL:IF SETVALUE? (CL:SETF (%HOME-CONTEXT SELF) VALUE)
     (CL:SETQ VALUE (%HOME-CONTEXT SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-GENERALIZED-SYMBOL-SLOT-VALUE VALUE))

;;; (DEFCLASS SYMBOL ...)

(CL:DEFCLASS SYMBOL (GENERALIZED-SYMBOL)
  ((SYMBOL-SLOT-OFFSET :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %SYMBOL-SLOT-OFFSET)
   (SYMBOL-VALUE-AND-PLIST :ALLOCATION :INSTANCE :ACCESSOR
    %SYMBOL-VALUE-AND-PLIST)))

(CL:DEFUN NEW-SYMBOL (SYMBOL-NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYMBOL-NAME))
  #+MCL
  (CL:CHECK-TYPE SYMBOL-NAME CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SYMBOL)))
   (CL:SETF (%SYMBOL-NAME SELF) SYMBOL-NAME)
   (CL:SETF (%HOME-CONTEXT SELF) *CONTEXT*)
   (CL:SETF (%SYMBOL-ID SELF) NULL-INTEGER)
   (CL:SETF (%SYMBOL-VALUE-AND-PLIST SELF) NIL)
   (CL:SETF (%SYMBOL-SLOT-OFFSET SELF) NULL-INTEGER)
   (CL:RETURN-FROM NEW-SYMBOL SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SYMBOL))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-SYMBOL))

(CL:DEFUN ACCESS-SYMBOL-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SYMBOL-SLOT-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%SYMBOL-SLOT-OFFSET SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%SYMBOL-SLOT-OFFSET SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SYMBOL-VALUE-AND-PLIST)
    (CL:IF SETVALUE? (CL:SETF (%SYMBOL-VALUE-AND-PLIST SELF) VALUE)
     (CL:SETQ VALUE (%SYMBOL-VALUE-AND-PLIST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-SYMBOL-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF SYMBOL) STREAM)
  (PRINT-SYMBOL SELF STREAM)
  :VOID)

;;; (DEFCLASS SURROGATE ...)

(CL:DEFCLASS SURROGATE (GENERALIZED-SYMBOL)
  ((SURROGATE-VALUE :ALLOCATION :INSTANCE :ACCESSOR %SURROGATE-VALUE))
  (:DOCUMENTATION "Rigid surrogate."))

(CL:DEFUN NEW-SURROGATE (SYMBOL-NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYMBOL-NAME))
  #+MCL
  (CL:CHECK-TYPE SYMBOL-NAME CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SURROGATE)))
   (CL:SETF (%SYMBOL-NAME SELF) SYMBOL-NAME)
   (CL:SETF (%HOME-CONTEXT SELF) *CONTEXT*)
   (CL:SETF (%SYMBOL-ID SELF) NULL-INTEGER)
   (CL:SETF (%SURROGATE-VALUE SELF) NULL)
   (CL:RETURN-FROM NEW-SURROGATE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SURROGATE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-SURROGATE))

(CL:DEFUN ACCESS-SURROGATE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SURROGATE-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%SURROGATE-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%SURROGATE-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SURROGATE-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%SYMBOL-NAME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%SYMBOL-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-TYPE-CLASS)
    (CL:IF SETVALUE? (CL:SETF (%SURROGATE-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%SURROGATE-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-TYPE-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%SYMBOL-NAME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%SYMBOL-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOTREF-SLOT)
    (CL:IF SETVALUE? (CL:SETF (%SURROGATE-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%SURROGATE-VALUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-SURROGATE-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF SURROGATE) STREAM)
  (PRINT-SURROGATE SELF STREAM)
  :VOID)

;;; (DEFCLASS KEYWORD ...)

(CL:DEFCLASS KEYWORD (GENERALIZED-SYMBOL)
  ())

(CL:DEFUN NEW-KEYWORD (SYMBOL-NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYMBOL-NAME))
  #+MCL
  (CL:CHECK-TYPE SYMBOL-NAME CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE KEYWORD)))
   (CL:SETF (%SYMBOL-NAME SELF) SYMBOL-NAME)
   (CL:SETF (%HOME-CONTEXT SELF) *CONTEXT*)
   (CL:SETF (%SYMBOL-ID SELF) NULL-INTEGER)
   (CL:RETURN-FROM NEW-KEYWORD SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF KEYWORD))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-KEYWORD))

(CL:DEFUN ACCESS-KEYWORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-KEYWORD-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%SYMBOL-NAME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%SYMBOL-NAME SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-KEYWORD-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF KEYWORD) STREAM)
  (PRINT-KEYWORD SELF STREAM)
  :VOID)

;;; (DEFCLASS TRANSIENT-SYMBOL ...)

(CL:DEFCLASS TRANSIENT-SYMBOL (SYMBOL)
  ())

(CL:DEFUN NEW-TRANSIENT-SYMBOL (SYMBOL-NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SYMBOL-NAME))
  #+MCL
  (CL:CHECK-TYPE SYMBOL-NAME CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSIENT-SYMBOL)))
   (CL:SETF (%SYMBOL-NAME SELF) SYMBOL-NAME)
   (CL:SETF (%HOME-CONTEXT SELF) *CONTEXT*)
   (CL:SETF (%SYMBOL-ID SELF) NULL-INTEGER)
   (CL:SETF (%SYMBOL-VALUE-AND-PLIST SELF) NIL)
   (CL:SETF (%SYMBOL-SLOT-OFFSET SELF) NULL-INTEGER)
   (CL:RETURN-FROM NEW-TRANSIENT-SYMBOL SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSIENT-SYMBOL))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-TRANSIENT-SYMBOL))

(CL:DEFMETHOD TRANSIENT? ((SELF TRANSIENT-SYMBOL))
  (CL:RETURN-FROM TRANSIENT? *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN*))

;;; (DEFCLASS MAPPABLE-OBJECT ...)

(CL:DEFCLASS MAPPABLE-OBJECT (STANDARD-OBJECT)
  ((DYNAMIC-SLOTS :ALLOCATION :INSTANCE :ACCESSOR %DYNAMIC-SLOTS))
  (:DOCUMENTATION
   "The class MAPPABLE-OBJECT enables the definition of projections
from a Stella class, slot, global variable, etc. onto a corresponding native
entity."))

(CL:DEFMETHOD PROJECTS-ONTO ((SELF MAPPABLE-OBJECT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-PROJECTS-ONTO NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:RETURN-FROM PROJECTS-ONTO NIL-LIST)
    (CL:RETURN-FROM PROJECTS-ONTO ANSWER))))

(CL:DEFMETHOD PROJECTED-FROM ((SELF MAPPABLE-OBJECT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-PROJECTED-FROM NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:RETURN-FROM PROJECTED-FROM NIL-LIST)
    (CL:RETURN-FROM PROJECTED-FROM ANSWER))))

(CL:DEFMETHOD BAD? ((SELF MAPPABLE-OBJECT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-BAD? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:RETURN-FROM BAD? FALSE-WRAPPER)
    (CL:RETURN-FROM BAD? ANSWER))))

(CL:DEFUN ACCESS-MAPPABLE-OBJECT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PROJECTS-ONTO)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-PROJECTS-ONTO VALUE NULL)
     (CL:SETQ VALUE (PROJECTS-ONTO SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PROJECTED-FROM)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-PROJECTED-FROM VALUE NULL)
     (CL:SETQ VALUE (PROJECTED-FROM SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-MAPPABLE-OBJECT-SLOT-VALUE VALUE))

(CL:DEFMETHOD DELETED? ((SELF MAPPABLE-OBJECT))
  (CL:LET*
   ((DELETED?
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-DELETED-OBJECT? NULL)))
   (CL:IF (CL:NOT (CL:EQ DELETED? NULL))
    (CL:RETURN-FROM DELETED?
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN DELETED?))
    (CL:RETURN-FROM DELETED? CL:NIL))))

(CL:DEFMETHOD DELETED?-SETTER ((SELF MAPPABLE-OBJECT) VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-HIERARCHY-STELLA-DELETED-OBJECT?
   (CL:IF VALUE TRUE-WRAPPER FALSE-WRAPPER) NULL)
  (CL:RETURN-FROM DELETED?-SETTER VALUE))

;;; (DEFCLASS RELATION ...)

(CL:DEFCLASS RELATION (MAPPABLE-OBJECT)
  ((ABSTRACT? :ALLOCATION :INSTANCE :ACCESSOR %ABSTRACT?)))

(CL:DEFMETHOD NAME ((SELF RELATION))
  (CL:RETURN-FROM NAME STELLA::NULL-STRING))

(CL:DEFMETHOD HOME-MODULE ((SELF RELATION))
  (CL:RETURN-FROM HOME-MODULE NULL))

(CL:DEFMETHOD ARITY ((SELF RELATION))
  (CL:RETURN-FROM ARITY NULL-INTEGER))

(CL:DEFMETHOD PUBLIC? ((SELF RELATION))
  (CL:RETURN-FROM PUBLIC? CL:NIL))

(CL:DEFMETHOD DIRECT-SUPERS ((SELF RELATION))
  (CL:RETURN-FROM DIRECT-SUPERS NULL))

(CL:DEFMETHOD ALL-SUPERS ((SELF RELATION))
  (CL:RETURN-FROM ALL-SUPERS NULL))

(CL:DEFMETHOD SLOTS ((SELF RELATION))
  (CL:RETURN-FROM SLOTS NULL))

(CL:DEFMETHOD PROPERTIES ((SELF RELATION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-PROPERTIES NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:RETURN-FROM PROPERTIES NIL-LIST)
    (CL:RETURN-FROM PROPERTIES ANSWER))))

(CL:DEFUN ACCESS-RELATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ABSTRACT?)
    (CL:IF SETVALUE?
     (CL:SETF (%ABSTRACT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%ABSTRACT? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PROPERTIES)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-PROPERTIES VALUE NULL)
     (CL:SETQ VALUE (PROPERTIES SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-RELATION-SLOT-VALUE VALUE))

;;; (DEFCLASS CLASS ...)

(CL:DEFCLASS CLASS (RELATION)
  ((CL-STRUCT? :ALLOCATION :INSTANCE :ACCESSOR %CL-STRUCT?)
   (MIXIN? :ALLOCATION :INSTANCE :ACCESSOR %MIXIN?)
   (CLASS-TYPE :ALLOCATION :INSTANCE :ACCESSOR %CLASS-TYPE)
   (CLASS-DIRECT-SUPERS :ALLOCATION :INSTANCE :ACCESSOR
    %CLASS-DIRECT-SUPERS)
   (CLASS-DIRECT-SUBS :ALLOCATION :INSTANCE :ACCESSOR
    %CLASS-DIRECT-SUBS)
   (CLASS-ALL-SUPER-CLASSES :ALLOCATION :INSTANCE :ACCESSOR
    %CLASS-ALL-SUPER-CLASSES)
   (CLASS-ALL-SLOTS :ALLOCATION :INSTANCE :ACCESSOR %CLASS-ALL-SLOTS)
   (CLASS-LOCAL-SLOTS :ALLOCATION :INSTANCE :ACCESSOR
    %CLASS-LOCAL-SLOTS)
   (CLASS-SLOT-AND-METHOD-CACHE :ALLOCATION :INSTANCE :ACCESSOR
    %CLASS-SLOT-AND-METHOD-CACHE)
   (CLASS-COLLECTION? :ALLOCATION :INSTANCE :ACCESSOR
    %CLASS-COLLECTION?)
   (CLASS-PUBLIC? :ALLOCATION :INSTANCE :ACCESSOR %CLASS-PUBLIC?)
   (CLASS-FINALIZED? :ALLOCATION :INSTANCE :ACCESSOR %CLASS-FINALIZED?)
   (CLASS-SLOTS-FINALIZED? :ALLOCATION :INSTANCE :ACCESSOR
    %CLASS-SLOTS-FINALIZED?)
   (CLASS-STRINGIFIED-SOURCE :TYPE CL:SIMPLE-STRING :INITFORM
    STELLA::NULL-STRING :ALLOCATION :INSTANCE :ACCESSOR
    %CLASS-STRINGIFIED-SOURCE)
   (CLASS-CONSTRUCTOR-CODE :ALLOCATION :INSTANCE :ACCESSOR
    %CLASS-CONSTRUCTOR-CODE)
   (CLASS-SLOT-ACCESSOR-CODE :ALLOCATION :INSTANCE :ACCESSOR
    %CLASS-SLOT-ACCESSOR-CODE)
   (CLASS-MARKED? :ALLOCATION :INSTANCE :ACCESSOR %CLASS-MARKED?)
   (CLASS-TAXONOMY-NODE :ALLOCATION :INSTANCE :ACCESSOR
    %CLASS-TAXONOMY-NODE)))

(CL:DEFUN NEW-CLASS ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CLASS)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%CLASS-TAXONOMY-NODE SELF) NULL)
   (CL:SETF (%CLASS-MARKED? SELF) CL:NIL)
   (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE SELF) NULL)
   (CL:SETF (%CLASS-CONSTRUCTOR-CODE SELF) NULL)
   (CL:SETF (%CLASS-STRINGIFIED-SOURCE SELF) STELLA::NULL-STRING)
   (CL:SETF (%CLASS-SLOTS-FINALIZED? SELF) CL:NIL)
   (CL:SETF (%CLASS-FINALIZED? SELF) CL:NIL)
   (CL:SETF (%CLASS-PUBLIC? SELF) CL:T)
   (CL:SETF (%CL-STRUCT? SELF) CL:NIL)
   (CL:SETF (%CLASS-COLLECTION? SELF) CL:NIL)
   (CL:SETF (%MIXIN? SELF) CL:NIL) (CL:SETF (%ABSTRACT? SELF) CL:NIL)
   (CL:SETF (%CLASS-SLOT-AND-METHOD-CACHE SELF) NULL)
   (CL:SETF (%CLASS-LOCAL-SLOTS SELF) NULL)
   (CL:SETF (%CLASS-ALL-SLOTS SELF) NULL)
   (CL:SETF (%CLASS-ALL-SUPER-CLASSES SELF) NIL)
   (CL:SETF (%CLASS-DIRECT-SUBS SELF) (NEW-LIST))
   (CL:SETF (%CLASS-DIRECT-SUPERS SELF) (NEW-LIST))
   (CL:SETF (%CLASS-TYPE SELF) NULL) (CL:RETURN-FROM NEW-CLASS SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CLASS))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-CLASS))

(CL:DEFMETHOD NAME ((SELF CLASS))
  (CL:RETURN-FROM NAME (%SYMBOL-NAME (%CLASS-TYPE SELF))))

(CL:DEFMETHOD HOME-MODULE ((SELF CLASS))
  (CL:RETURN-FROM HOME-MODULE (%HOME-CONTEXT (%CLASS-TYPE SELF))))

(CL:DEFMETHOD ARITY ((SELF CLASS))
  (CL:RETURN-FROM ARITY 1))

(CL:DEFMETHOD PUBLIC? ((SELF CLASS))
  (CL:RETURN-FROM PUBLIC? (%CLASS-PUBLIC? SELF)))

(CL:DEFMETHOD ACTIVE? ((SELF CLASS))
  (CL:RETURN-FROM ACTIVE?
   (CL:OR
    (CL:AND
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-HIERARCHY-STELLA-STORED-ACTIVE? NULL)
       NULL))
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-HIERARCHY-STELLA-STORED-ACTIVE? NULL)))
    (SUBTYPE-OF? (%CLASS-TYPE SELF)
     SGT-HIERARCHY-STELLA-ACTIVE-OBJECT))))

(CL:DEFMETHOD CREATOR ((SELF CLASS))
  (CL:RETURN-FROM CREATOR
   (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
    SYM-HIERARCHY-STELLA-CLASS-CREATOR NULL)))

(CL:DEFMETHOD INITIALIZER ((SELF CLASS))
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
      SYM-HIERARCHY-STELLA-CLASS-INITIALIZER NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM INITIALIZER VALUE))
    (CL:SETQ CURSOR (%%VALUE (%CLASS-ALL-SUPER-CLASSES CURSOR)))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-CLASS-INITIALIZER NULL))
     (CL:RETURN-FROM INITIALIZER NULL)))))

(CL:DEFMETHOD TERMINATOR ((SELF CLASS))
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
      SYM-HIERARCHY-STELLA-CLASS-TERMINATOR NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM TERMINATOR VALUE))
    (CL:SETQ CURSOR (%%VALUE (%CLASS-ALL-SUPER-CLASSES CURSOR)))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-CLASS-TERMINATOR NULL))
     (CL:RETURN-FROM TERMINATOR NULL)))))

(CL:DEFMETHOD DESTRUCTOR ((SELF CLASS))
  (CL:RETURN-FROM DESTRUCTOR
   (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
    SYM-HIERARCHY-STELLA-CLASS-DESTRUCTOR NULL)))

(CL:DEFMETHOD REQUIRED-SLOTS ((SELF CLASS))
  "Returns a list of names of required slots for `self'."
  (CL:RETURN-FROM REQUIRED-SLOTS (CLASS-REQUIRED-SLOT-NAMES SELF)))

(CL:DEFMETHOD PARAMETERS ((SELF CLASS))
  "Returns the list of parameters names of `self'."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
      SYM-HIERARCHY-STELLA-CLASS-PARAMETERS NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM PARAMETERS VALUE))
    (CL:SETQ CURSOR (%%VALUE (%CLASS-ALL-SUPER-CLASSES CURSOR)))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-CLASS-PARAMETERS NULL))
     (CL:RETURN-FROM PARAMETERS NIL-LIST)))))

(CL:DEFMETHOD INITIAL-VALUE ((SELF CLASS))
  "Return an initial value for the class `self'."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
      SYM-HIERARCHY-STELLA-CLASS-INITIAL-VALUE NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM INITIAL-VALUE VALUE))
    (CL:SETQ CURSOR (%%VALUE (%CLASS-ALL-SUPER-CLASSES CURSOR)))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-CLASS-INITIAL-VALUE NULL))
     (CL:RETURN-FROM INITIAL-VALUE NULL)))))

(CL:DEFMETHOD EXTENSION ((SELF CLASS))
  "Return the nearest class extension that records instances
of the class `self'."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
      SYM-HIERARCHY-STELLA-CLASS-EXTENSION NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM EXTENSION VALUE))
    (CL:SETQ CURSOR (%%VALUE (%CLASS-ALL-SUPER-CLASSES CURSOR)))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-CLASS-EXTENSION NULL))
     (CL:RETURN-FROM EXTENSION NULL)))))

(CL:DEFMETHOD CL-NATIVE-TYPE ((SELF CLASS))
  (CL:RETURN-FROM CL-NATIVE-TYPE
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-HIERARCHY-STELLA-CLASS-CL-NATIVE-TYPE NULL-STRING-WRAPPER))))

(CL:DEFMETHOD CPP-NATIVE-TYPE ((SELF CLASS))
  (CL:RETURN-FROM CPP-NATIVE-TYPE
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-HIERARCHY-STELLA-CLASS-CPP-NATIVE-TYPE NULL-STRING-WRAPPER))))

(CL:DEFMETHOD IDL-NATIVE-TYPE ((SELF CLASS))
  (CL:RETURN-FROM IDL-NATIVE-TYPE
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-HIERARCHY-STELLA-CLASS-CPP-NATIVE-TYPE NULL-STRING-WRAPPER))))

(CL:DEFMETHOD JAVA-NATIVE-TYPE ((SELF CLASS))
  (CL:LET*
   ((NATIVETYPE
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-HIERARCHY-STELLA-CLASS-JAVA-NATIVE-TYPE
       NULL-STRING-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NATIVETYPE))
   (CL:IF (CL:NOT (CL:EQ NATIVETYPE STELLA::NULL-STRING))
    (CL:RETURN-FROM JAVA-NATIVE-TYPE
     (SUBSTITUTE-TEMPLATE-VARIABLES-IN-STRING NATIVETYPE
      *JAVA-STELLA-PACKAGE-MAPPING*))
    (CL:RETURN-FROM JAVA-NATIVE-TYPE STELLA::NULL-STRING))))

(CL:DEFMETHOD CLASS-ARITY ((SELF CLASS))
  (CL:RETURN-FROM CLASS-ARITY *HARDWIRED-CLASS-ARITY-ON-CLASS*))

(CL:DEFMETHOD CLASS-CL-STRUCT-SLOTS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-CL-STRUCT-SLOTS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-CL-STRUCT-SLOTS NIL-LIST)
    (CL:RETURN-FROM CLASS-CL-STRUCT-SLOTS ANSWER))))

(CL:DEFMETHOD CLASS-RECYCLE-METHOD ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-RECYCLE-METHOD NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-RECYCLE-METHOD KWD-HIERARCHY-NONE)
    (CL:RETURN-FROM CLASS-RECYCLE-METHOD ANSWER))))

(CL:DEFMETHOD CLASS-PARAMETERS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-PARAMETERS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-PARAMETERS NIL-LIST)
    (CL:RETURN-FROM CLASS-PARAMETERS ANSWER))))

(CL:DEFMETHOD CLASS-REQUIRED-SLOT-NAMES ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-REQUIRED-SLOT-NAMES NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-REQUIRED-SLOT-NAMES NIL-LIST)
    (CL:RETURN-FROM CLASS-REQUIRED-SLOT-NAMES ANSWER))))

(CL:DEFMETHOD CLASS-GUARD-CONSTRUCTOR-DEMONS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-GUARD-CONSTRUCTOR-DEMONS NIL-LIST)
    (CL:RETURN-FROM CLASS-GUARD-CONSTRUCTOR-DEMONS ANSWER))))

(CL:DEFMETHOD CLASS-CONSTRUCTOR-DEMONS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-CONSTRUCTOR-DEMONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-CONSTRUCTOR-DEMONS NIL-LIST)
    (CL:RETURN-FROM CLASS-CONSTRUCTOR-DEMONS ANSWER))))

(CL:DEFMETHOD CLASS-GUARD-DESTRUCTOR-DEMONS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-GUARD-DESTRUCTOR-DEMONS NIL-LIST)
    (CL:RETURN-FROM CLASS-GUARD-DESTRUCTOR-DEMONS ANSWER))))

(CL:DEFMETHOD CLASS-DESTRUCTOR-DEMONS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-DESTRUCTOR-DEMONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM CLASS-DESTRUCTOR-DEMONS NIL-LIST)
    (CL:RETURN-FROM CLASS-DESTRUCTOR-DEMONS ANSWER))))

(CL:DEFMETHOD CLASS-KEY ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-KEY NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:RETURN-FROM CLASS-KEY NIL-LIST)
    (CL:RETURN-FROM CLASS-KEY ANSWER))))

(CL:DEFMETHOD CLASS-SYNONYMS ((SELF CLASS))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-SYNONYMS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:RETURN-FROM CLASS-SYNONYMS NIL-LIST)
    (CL:RETURN-FROM CLASS-SYNONYMS ANSWER))))

(CL:DEFUN ACCESS-CLASS-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CL-STRUCT?)
    (CL:IF SETVALUE?
     (CL:SETF (%CL-STRUCT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CL-STRUCT? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-MIXIN?)
    (CL:IF SETVALUE?
     (CL:SETF (%MIXIN? SELF) (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%MIXIN? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-TYPE)
    (CL:IF SETVALUE? (CL:SETF (%CLASS-TYPE SELF) VALUE)
     (CL:SETQ VALUE (%CLASS-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-ARITY)
    (CL:SETQ VALUE (WRAP-INTEGER (CLASS-ARITY SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-DIRECT-SUPERS)
    (CL:IF SETVALUE? (CL:SETF (%CLASS-DIRECT-SUPERS SELF) VALUE)
     (CL:SETQ VALUE (%CLASS-DIRECT-SUPERS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-DIRECT-SUBS)
    (CL:IF SETVALUE? (CL:SETF (%CLASS-DIRECT-SUBS SELF) VALUE)
     (CL:SETQ VALUE (%CLASS-DIRECT-SUBS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-ALL-SUPER-CLASSES)
    (CL:IF SETVALUE? (CL:SETF (%CLASS-ALL-SUPER-CLASSES SELF) VALUE)
     (CL:SETQ VALUE (%CLASS-ALL-SUPER-CLASSES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-ALL-SLOTS)
    (CL:IF SETVALUE? (CL:SETF (%CLASS-ALL-SLOTS SELF) VALUE)
     (CL:SETQ VALUE (%CLASS-ALL-SLOTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-LOCAL-SLOTS)
    (CL:IF SETVALUE? (CL:SETF (%CLASS-LOCAL-SLOTS SELF) VALUE)
     (CL:SETQ VALUE (%CLASS-LOCAL-SLOTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-SLOT-AND-METHOD-CACHE)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASS-SLOT-AND-METHOD-CACHE SELF) VALUE)
     (CL:SETQ VALUE (%CLASS-SLOT-AND-METHOD-CACHE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-ABSTRACT?)
    (CL:IF SETVALUE?
     (CL:SETF (%ABSTRACT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%ABSTRACT? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-MIXIN?)
    (CL:IF SETVALUE?
     (CL:SETF (%MIXIN? SELF) (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%MIXIN? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-COLLECTION?)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASS-COLLECTION? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CLASS-COLLECTION? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-CL-STRUCT?)
    (CL:IF SETVALUE?
     (CL:SETF (%CL-STRUCT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CL-STRUCT? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-CL-STRUCT-SLOTS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-CL-STRUCT-SLOTS VALUE NULL)
     (CL:SETQ VALUE (CLASS-CL-STRUCT-SLOTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-PUBLIC?)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASS-PUBLIC? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CLASS-PUBLIC? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-RECYCLE-METHOD)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-RECYCLE-METHOD VALUE NULL)
     (CL:SETQ VALUE (CLASS-RECYCLE-METHOD SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-FINALIZED?)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASS-FINALIZED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CLASS-FINALIZED? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-SLOTS-FINALIZED?)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASS-SLOTS-FINALIZED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CLASS-SLOTS-FINALIZED? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-STRINGIFIED-SOURCE)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASS-STRINGIFIED-SOURCE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%CLASS-STRINGIFIED-SOURCE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-PARAMETERS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-PARAMETERS VALUE NULL)
     (CL:SETQ VALUE (CLASS-PARAMETERS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-CONSTRUCTOR-CODE)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE (%CLASS-CONSTRUCTOR-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-SLOT-ACCESSOR-CODE)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE (%CLASS-SLOT-ACCESSOR-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-REQUIRED-SLOT-NAMES)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-REQUIRED-SLOT-NAMES VALUE NULL)
     (CL:SETQ VALUE (CLASS-REQUIRED-SLOT-NAMES SELF))))
   ((CL:EQ SLOTNAME
     SYM-HIERARCHY-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS VALUE NULL)
     (CL:SETQ VALUE (CLASS-GUARD-CONSTRUCTOR-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-CONSTRUCTOR-DEMONS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-CONSTRUCTOR-DEMONS VALUE NULL)
     (CL:SETQ VALUE (CLASS-CONSTRUCTOR-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS VALUE NULL)
     (CL:SETQ VALUE (CLASS-GUARD-DESTRUCTOR-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-DESTRUCTOR-DEMONS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-DESTRUCTOR-DEMONS VALUE NULL)
     (CL:SETQ VALUE (CLASS-DESTRUCTOR-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-KEY)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-KEY VALUE NULL)
     (CL:SETQ VALUE (CLASS-KEY SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-SYNONYMS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLASS-SYNONYMS VALUE NULL)
     (CL:SETQ VALUE (CLASS-SYNONYMS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-MARKED?)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASS-MARKED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CLASS-MARKED? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-TAXONOMY-NODE)
    (CL:IF SETVALUE? (CL:SETF (%CLASS-TAXONOMY-NODE SELF) VALUE)
     (CL:SETQ VALUE (%CLASS-TAXONOMY-NODE SELF))))
   (CL:T
    (CL:COND
     ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-DOCUMENTATION)
      (CL:SETQ SLOTNAME SYM-HIERARCHY-STELLA-DOCUMENTATION))
     ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLASS-PRINT-FORM)
      (CL:SETQ SLOTNAME SYM-HIERARCHY-STELLA-PRINT-FORM))
     (CL:T))
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-CLASS-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF CLASS) STREAM)
  (%%PRINT-STREAM STREAM "|C|"
   (CL:IF (CL:NOT (CL:EQ (%CLASS-TYPE SELF) NULL))
    (RELATIVE-NAME (CLASS-SYMBOL SELF) CL:NIL) "??"))
  :VOID)

;;; (DEFCLASS POLYMORPHIC-RELATION ...)

(CL:DEFCLASS POLYMORPHIC-RELATION (RELATION)
  ((SLOT-DIRECT-EQUIVALENT :ALLOCATION :INSTANCE :ACCESSOR
    %SLOT-DIRECT-EQUIVALENT)))

(CL:DEFMETHOD OWNER ((SELF POLYMORPHIC-RELATION))
  (CL:RETURN-FROM OWNER NULL))

(CL:DEFMETHOD RENAMES ((SELF POLYMORPHIC-RELATION))
  (CL:RETURN-FROM RENAMES NULL))

(CL:DEFMETHOD ACTIVE? ((SELF POLYMORPHIC-RELATION))
  "True if `self' or a superslot of `self' is marked active."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
      SYM-HIERARCHY-STELLA-STORED-ACTIVE? NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM ACTIVE?
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE)))
    (CL:SETQ CURSOR (%SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-STORED-ACTIVE? NULL))
     (CL:RETURN-FROM ACTIVE? CL:NIL)))))

(CL:DEFUN ACCESS-POLYMORPHIC-RELATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-DIRECT-EQUIVALENT)
    (CL:IF SETVALUE? (CL:SETF (%SLOT-DIRECT-EQUIVALENT SELF) VALUE)
     (CL:SETQ VALUE (%SLOT-DIRECT-EQUIVALENT SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-POLYMORPHIC-RELATION-SLOT-VALUE VALUE))

;;; (DEFCLASS SLOT ...)

(CL:DEFCLASS SLOT (POLYMORPHIC-RELATION)
  ((SLOT-NAME :ALLOCATION :INSTANCE :ACCESSOR %SLOT-NAME)
   (SLOT-OWNER :ALLOCATION :INSTANCE :ACCESSOR %SLOT-OWNER)
   (SLOT-BASE-TYPE :ALLOCATION :INSTANCE :ACCESSOR %SLOT-BASE-TYPE)
   (SLOT-SLOTREF :ALLOCATION :INSTANCE :ACCESSOR %SLOT-SLOTREF)
   (SLOT-PUBLIC? :ALLOCATION :INSTANCE :ACCESSOR %SLOT-PUBLIC?)
   (SLOT-RENAMED? :ALLOCATION :INSTANCE :ACCESSOR %SLOT-RENAMED?)
   (SLOT-EXTERNAL? :ALLOCATION :INSTANCE :ACCESSOR %SLOT-EXTERNAL?)
   (SLOT-MARKED? :ALLOCATION :INSTANCE :ACCESSOR %SLOT-MARKED?)))

(CL:DEFMETHOD NAME ((SELF SLOT))
  (CL:RETURN-FROM NAME (%SYMBOL-NAME (%SLOT-NAME SELF))))

(CL:DEFMETHOD TYPE ((SELF SLOT))
  "The type of a storage slot is its base type."
  (CL:LET* ((CURSOR SELF) (VALUE (%SLOT-BASE-TYPE CURSOR)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM TYPE VALUE))
    (CL:SETQ CURSOR (%SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE (%SLOT-BASE-TYPE CURSOR))
     (CL:RETURN-FROM TYPE NULL)))))

(CL:DEFMETHOD TYPE-SPECIFIER ((SELF SLOT))
  "If `self' has a complex type return its
type specifier, otherwise, return `type' of `self'."
  (CL:LET*
   ((TSPEC
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-TYPE-SPECIFIER NULL)))
   (CL:RETURN-FROM TYPE-SPECIFIER
    (CL:IF (CL:NOT (CL:EQ TSPEC NULL)) TSPEC (TYPE SELF)))))

(CL:DEFMETHOD OWNER ((SELF SLOT))
  (CL:RETURN-FROM OWNER (%SLOT-OWNER SELF)))

(CL:DEFMETHOD HOME-MODULE ((SELF SLOT))
  (CL:LET*
   ((MODULE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-HOME-MODULE NULL)))
   (CL:IF (CL:NOT (CL:EQ MODULE NULL))
    (CL:RETURN-FROM HOME-MODULE MODULE)
    (CL:RETURN-FROM HOME-MODULE (%HOME-CONTEXT (%SLOT-NAME SELF))))))

(CL:DEFMETHOD RENAMES ((SELF SLOT))
  (CL:RETURN-FROM RENAMES
   (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
    SYM-HIERARCHY-STELLA-SLOT-RENAMES NULL)))

(CL:DEFMETHOD COLLECTION-VALUED? ((SELF SLOT))
  "True if slot values are collections."
  (CL:RETURN-FROM COLLECTION-VALUED?
   (SUBTYPE-OF? (%SLOT-BASE-TYPE SELF) SGT-HIERARCHY-STELLA-COLLECTION)))

(CL:DEFMETHOD CLOSURE-ASSUMPTION ((SELF SLOT))
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
      SYM-HIERARCHY-STELLA-SLOT-CLOSURE-ASSUMPTION NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM CLOSURE-ASSUMPTION VALUE))
    (CL:SETQ CURSOR (%SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-SLOT-CLOSURE-ASSUMPTION NULL))
     (CL:RETURN-FROM CLOSURE-ASSUMPTION NULL)))))

(CL:DEFMETHOD SLOT-DIRECT-SUPERS ((SELF SLOT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-DIRECT-SUPERS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SLOT-DIRECT-SUPERS NIL-LIST)
    (CL:RETURN-FROM SLOT-DIRECT-SUPERS ANSWER))))

(CL:DEFMETHOD SLOT-DIRECT-SUBS ((SELF SLOT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-DIRECT-SUBS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SLOT-DIRECT-SUBS NIL-LIST)
    (CL:RETURN-FROM SLOT-DIRECT-SUBS ANSWER))))

(CL:DEFUN ACCESS-SLOT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-NAME)
    (CL:IF SETVALUE? (CL:SETF (%SLOT-NAME SELF) VALUE)
     (CL:SETQ VALUE (%SLOT-NAME SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-OWNER)
    (CL:IF SETVALUE? (CL:SETF (%SLOT-OWNER SELF) VALUE)
     (CL:SETQ VALUE (%SLOT-OWNER SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-BASE-TYPE)
    (CL:IF SETVALUE? (CL:SETF (%SLOT-BASE-TYPE SELF) VALUE)
     (CL:SETQ VALUE (%SLOT-BASE-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-SLOTREF)
    (CL:IF SETVALUE? (CL:SETF (%SLOT-SLOTREF SELF) VALUE)
     (CL:SETQ VALUE (%SLOT-SLOTREF SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-DIRECT-SUPERS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-DIRECT-SUPERS VALUE NULL)
     (CL:SETQ VALUE (SLOT-DIRECT-SUPERS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-DIRECT-SUBS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-DIRECT-SUBS VALUE NULL)
     (CL:SETQ VALUE (SLOT-DIRECT-SUBS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-PUBLIC?)
    (CL:IF SETVALUE?
     (CL:SETF (%SLOT-PUBLIC? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%SLOT-PUBLIC? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-RENAMED?)
    (CL:IF SETVALUE?
     (CL:SETF (%SLOT-RENAMED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%SLOT-RENAMED? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-EXTERNAL?)
    (CL:IF SETVALUE?
     (CL:SETF (%SLOT-EXTERNAL? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%SLOT-EXTERNAL? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-MARKED?)
    (CL:IF SETVALUE?
     (CL:SETF (%SLOT-MARKED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%SLOT-MARKED? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:COND
     ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-DOCUMENTATION)
      (CL:SETQ SLOTNAME SYM-HIERARCHY-STELLA-DOCUMENTATION))
     (CL:T))
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-SLOT-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF SLOT) STREAM)
  (%%PRINT-STREAM STREAM "|S|" (%SYMBOL-NAME (%SLOT-OWNER SELF)) "."
   (%SYMBOL-NAME (%SLOT-NAME SELF)))
  :VOID)

;;; (DEFCLASS STORAGE-SLOT ...)

(CL:DEFCLASS STORAGE-SLOT (SLOT)
  ((SLOT-REQUIRED? :ALLOCATION :INSTANCE :ACCESSOR %SLOT-REQUIRED?)
   (SLOT-COMPONENT? :ALLOCATION :INSTANCE :ACCESSOR %SLOT-COMPONENT?)
   (SLOT-READ-ONLY? :ALLOCATION :INSTANCE :ACCESSOR %SLOT-READ-ONLY?)
   (SLOT-HARDWIRED? :ALLOCATION :INSTANCE :ACCESSOR %SLOT-HARDWIRED?)
   (SLOT-CONTEXT-SENSITIVE? :ALLOCATION :INSTANCE :ACCESSOR
    %SLOT-CONTEXT-SENSITIVE?)))

(CL:DEFUN NEW-STORAGE-SLOT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STORAGE-SLOT)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%ABSTRACT? SELF) CL:NIL)
   (CL:SETF (%SLOT-DIRECT-EQUIVALENT SELF) NULL)
   (CL:SETF (%SLOT-MARKED? SELF) CL:NIL)
   (CL:SETF (%SLOT-EXTERNAL? SELF) CL:NIL)
   (CL:SETF (%SLOT-RENAMED? SELF) CL:NIL)
   (CL:SETF (%SLOT-PUBLIC? SELF) CL:T)
   (CL:SETF (%SLOT-SLOTREF SELF) NULL)
   (CL:SETF (%SLOT-BASE-TYPE SELF) NULL)
   (CL:SETF (%SLOT-OWNER SELF) NULL) (CL:SETF (%SLOT-NAME SELF) NULL)
   (CL:SETF (%SLOT-CONTEXT-SENSITIVE? SELF) CL:NIL)
   (CL:SETF (%SLOT-HARDWIRED? SELF) CL:NIL)
   (CL:SETF (%SLOT-READ-ONLY? SELF) CL:NIL)
   (CL:SETF (%SLOT-COMPONENT? SELF) CL:NIL)
   (CL:SETF (%SLOT-REQUIRED? SELF) CL:NIL)
   (CL:RETURN-FROM NEW-STORAGE-SLOT SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-STORAGE-SLOT))

(CL:DEFMETHOD ALLOCATION ((SELF STORAGE-SLOT))
  "Return the most specific :allocation facet, or
:instance if all inherited values are NULL."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
      SYM-HIERARCHY-STELLA-SLOT-ALLOCATION NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM ALLOCATION VALUE))
    (CL:SETQ CURSOR (%SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-SLOT-ALLOCATION NULL))
     (CL:RETURN-FROM ALLOCATION KWD-HIERARCHY-INSTANCE)))))

(CL:DEFMETHOD DEFAULT-FORM ((SELF STORAGE-SLOT))
  "Returns the current value of default expression when the
slot has not been assigned a value."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
      SYM-HIERARCHY-STELLA-SLOT-DEFAULT-EXPRESSION NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
     (CL:RETURN-FROM DEFAULT-FORM VALUE))
    (CL:SETQ CURSOR (%SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-SLOT-DEFAULT-EXPRESSION NULL))
     (CL:RETURN-FROM DEFAULT-FORM NULL)))))

(CL:DEFMETHOD REQUIRED? ((SELF STORAGE-SLOT))
  "True if a value must be assigned to this slot at
creation time."
  (CL:LET* ((CURSOR SELF) (VALUE (%SLOT-REQUIRED? CURSOR)))
   (CL:LOOP (CL:WHEN VALUE (CL:RETURN-FROM REQUIRED? VALUE))
    (CL:SETQ CURSOR (%SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE (%SLOT-REQUIRED? CURSOR))
     (CL:RETURN-FROM REQUIRED? CL:NIL)))))

(CL:DEFMETHOD COMPONENT? ((SELF STORAGE-SLOT))
  "True if fillers of this slot are components of the
owner slot, and therefore should be deleted if the owner is deleted."
  (CL:LET* ((CURSOR SELF) (VALUE (%SLOT-COMPONENT? CURSOR)))
   (CL:LOOP (CL:WHEN VALUE (CL:RETURN-FROM COMPONENT? VALUE))
    (CL:SETQ CURSOR (%SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE (%SLOT-COMPONENT? CURSOR))
     (CL:RETURN-FROM COMPONENT? CL:NIL)))))

(CL:DEFMETHOD READER ((SELF STORAGE-SLOT))
  "Name of a method called to read the value of the slot
`self'."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
      SYM-HIERARCHY-STELLA-SLOT-READER NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM READER VALUE))
    (CL:SETQ CURSOR (%SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-SLOT-READER NULL))
     (CL:RETURN-FROM READER NULL)))))

(CL:DEFMETHOD WRITER ((SELF STORAGE-SLOT))
  "Name of a method called to write the value of the slot
`self'."
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
      SYM-HIERARCHY-STELLA-SLOT-WRITER NULL)))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE NULL)) (CL:RETURN-FROM WRITER VALUE))
    (CL:SETQ CURSOR (%SLOT-DIRECT-EQUIVALENT CURSOR))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-SLOT-WRITER NULL))
     (CL:RETURN-FROM WRITER NULL)))))

(CL:DEFMETHOD SLOT-ALLOCATION ((SELF STORAGE-SLOT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-ALLOCATION NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SLOT-ALLOCATION KWD-HIERARCHY-INSTANCE)
    (CL:RETURN-FROM SLOT-ALLOCATION ANSWER))))

(CL:DEFMETHOD SLOT-GUARD-DEMONS ((SELF STORAGE-SLOT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-GUARD-DEMONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SLOT-GUARD-DEMONS NIL-LIST)
    (CL:RETURN-FROM SLOT-GUARD-DEMONS ANSWER))))

(CL:DEFMETHOD SLOT-DEMONS ((SELF STORAGE-SLOT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-DEMONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:RETURN-FROM SLOT-DEMONS NIL-LIST)
    (CL:RETURN-FROM SLOT-DEMONS ANSWER))))

(CL:DEFUN ACCESS-STORAGE-SLOT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-ALLOCATION)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-ALLOCATION VALUE NULL)
     (CL:SETQ VALUE (SLOT-ALLOCATION SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-GUARD-DEMONS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-GUARD-DEMONS VALUE NULL)
     (CL:SETQ VALUE (SLOT-GUARD-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-DEMONS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SLOT-DEMONS VALUE NULL)
     (CL:SETQ VALUE (SLOT-DEMONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-REQUIRED?)
    (CL:IF SETVALUE?
     (CL:SETF (%SLOT-REQUIRED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%SLOT-REQUIRED? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-COMPONENT?)
    (CL:IF SETVALUE?
     (CL:SETF (%SLOT-COMPONENT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%SLOT-COMPONENT? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-READ-ONLY?)
    (CL:IF SETVALUE?
     (CL:SETF (%SLOT-READ-ONLY? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%SLOT-READ-ONLY? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-HARDWIRED?)
    (CL:IF SETVALUE?
     (CL:SETF (%SLOT-HARDWIRED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%SLOT-HARDWIRED? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-CONTEXT-SENSITIVE?)
    (CL:IF SETVALUE?
     (CL:SETF (%SLOT-CONTEXT-SENSITIVE? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%SLOT-CONTEXT-SENSITIVE? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-STORAGE-SLOT-SLOT-VALUE VALUE))

;;; (DEFCLASS METHOD-SLOT ...)

(CL:DEFCLASS METHOD-SLOT (SLOT)
  ((METHOD-SETTER? :ALLOCATION :INSTANCE :ACCESSOR %METHOD-SETTER?)
   (METHOD-PARAMETER-NAMES :ALLOCATION :INSTANCE :ACCESSOR
    %METHOD-PARAMETER-NAMES)
   (METHOD-PARAMETER-TYPE-SPECIFIERS :ALLOCATION :INSTANCE :ACCESSOR
    %METHOD-PARAMETER-TYPE-SPECIFIERS)
   (METHOD-RETURN-TYPE-SPECIFIERS :ALLOCATION :INSTANCE :ACCESSOR
    %METHOD-RETURN-TYPE-SPECIFIERS)
   (METHOD-STRINGIFIED-SOURCE :TYPE CL:SIMPLE-STRING :INITFORM
    STELLA::NULL-STRING :ALLOCATION :INSTANCE :ACCESSOR
    %METHOD-STRINGIFIED-SOURCE)
   (METHOD-CODE :ALLOCATION :INSTANCE :ACCESSOR %METHOD-CODE)
   (FUNCTION-CODE :ALLOCATION :INSTANCE :ACCESSOR %FUNCTION-CODE)
   (METHOD-FUNCTION? :ALLOCATION :INSTANCE :ACCESSOR %METHOD-FUNCTION?)))

(CL:DEFUN NEW-METHOD-SLOT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE METHOD-SLOT)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%ABSTRACT? SELF) CL:NIL)
   (CL:SETF (%SLOT-DIRECT-EQUIVALENT SELF) NULL)
   (CL:SETF (%SLOT-MARKED? SELF) CL:NIL)
   (CL:SETF (%SLOT-EXTERNAL? SELF) CL:NIL)
   (CL:SETF (%SLOT-RENAMED? SELF) CL:NIL)
   (CL:SETF (%SLOT-PUBLIC? SELF) CL:T)
   (CL:SETF (%SLOT-SLOTREF SELF) NULL)
   (CL:SETF (%SLOT-BASE-TYPE SELF) NULL)
   (CL:SETF (%SLOT-OWNER SELF) NULL) (CL:SETF (%SLOT-NAME SELF) NULL)
   (CL:SETF (%METHOD-FUNCTION? SELF) CL:NIL)
   (CL:SETF (%FUNCTION-CODE SELF) NULL)
   (CL:SETF (%METHOD-CODE SELF) NULL)
   (CL:SETF (%METHOD-STRINGIFIED-SOURCE SELF) STELLA::NULL-STRING)
   (CL:SETF (%METHOD-RETURN-TYPE-SPECIFIERS SELF) NULL)
   (CL:SETF (%METHOD-PARAMETER-TYPE-SPECIFIERS SELF) NULL)
   (CL:SETF (%METHOD-PARAMETER-NAMES SELF) NULL)
   (CL:SETF (%METHOD-SETTER? SELF) CL:NIL)
   (CL:RETURN-FROM NEW-METHOD-SLOT SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF METHOD-SLOT))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-METHOD-SLOT))

(CL:DEFMETHOD SETTER? ((SELF METHOD-SLOT))
  (CL:RETURN-FROM SETTER? (%METHOD-SETTER? SELF)))

(CL:DEFMETHOD METHOD-PARAMETER-NAMES ((SELF METHOD-SLOT))
  (CL:LET* ((ANSWER (%METHOD-PARAMETER-NAMES SELF)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM METHOD-PARAMETER-NAMES NIL-LIST)
    (CL:RETURN-FROM METHOD-PARAMETER-NAMES ANSWER))))

(CL:DEFMETHOD METHOD-PARAMETER-TYPE-SPECIFIERS ((SELF METHOD-SLOT))
  (CL:LET* ((ANSWER (%METHOD-PARAMETER-TYPE-SPECIFIERS SELF)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM METHOD-PARAMETER-TYPE-SPECIFIERS NIL-LIST)
    (CL:RETURN-FROM METHOD-PARAMETER-TYPE-SPECIFIERS ANSWER))))

(CL:DEFMETHOD METHOD-PARAMETER-DIRECTIONS ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-METHOD-PARAMETER-DIRECTIONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM METHOD-PARAMETER-DIRECTIONS NIL-LIST)
    (CL:RETURN-FROM METHOD-PARAMETER-DIRECTIONS ANSWER))))

(CL:DEFMETHOD METHOD-RETURN-TYPE-SPECIFIERS ((SELF METHOD-SLOT))
  (CL:LET* ((ANSWER (%METHOD-RETURN-TYPE-SPECIFIERS SELF)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM METHOD-RETURN-TYPE-SPECIFIERS NIL-LIST)
    (CL:RETURN-FROM METHOD-RETURN-TYPE-SPECIFIERS ANSWER))))

(CL:DEFMETHOD METHOD-INLINED-FUNCTIONS ((SELF METHOD-SLOT))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-METHOD-INLINED-FUNCTIONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM METHOD-INLINED-FUNCTIONS NIL-LIST)
    (CL:RETURN-FROM METHOD-INLINED-FUNCTIONS ANSWER))))

(CL:DEFMETHOD METHOD-EVALUATE-ARGUMENTS? ((SELF METHOD-SLOT))
  (CL:RETURN-FROM METHOD-EVALUATE-ARGUMENTS?
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-HIERARCHY-STELLA-METHOD-EVALUATE-ARGUMENTS? TRUE-WRAPPER))))

(CL:DEFUN ACCESS-METHOD-SLOT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-SETTER?)
    (CL:IF SETVALUE?
     (CL:SETF (%METHOD-SETTER? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%METHOD-SETTER? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-PARAMETER-NAMES)
    (CL:IF SETVALUE? (CL:SETF (%METHOD-PARAMETER-NAMES SELF) VALUE)
     (CL:SETQ VALUE (METHOD-PARAMETER-NAMES SELF))))
   ((CL:EQ SLOTNAME
     SYM-HIERARCHY-STELLA-METHOD-PARAMETER-TYPE-SPECIFIERS)
    (CL:IF SETVALUE?
     (CL:SETF (%METHOD-PARAMETER-TYPE-SPECIFIERS SELF) VALUE)
     (CL:SETQ VALUE (METHOD-PARAMETER-TYPE-SPECIFIERS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-PARAMETER-DIRECTIONS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-METHOD-PARAMETER-DIRECTIONS VALUE NULL)
     (CL:SETQ VALUE (METHOD-PARAMETER-DIRECTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-RETURN-TYPE-SPECIFIERS)
    (CL:IF SETVALUE?
     (CL:SETF (%METHOD-RETURN-TYPE-SPECIFIERS SELF) VALUE)
     (CL:SETQ VALUE (METHOD-RETURN-TYPE-SPECIFIERS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-STRINGIFIED-SOURCE)
    (CL:IF SETVALUE?
     (CL:SETF (%METHOD-STRINGIFIED-SOURCE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%METHOD-STRINGIFIED-SOURCE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-CODE)
    (CL:IF SETVALUE?
     (CL:SETF (%METHOD-CODE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-METHOD-CODE (%METHOD-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-FUNCTION-CODE)
    (CL:IF SETVALUE?
     (CL:SETF (%FUNCTION-CODE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FUNCTION-CODE (%FUNCTION-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-FUNCTION?)
    (CL:IF SETVALUE?
     (CL:SETF (%METHOD-FUNCTION? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%METHOD-FUNCTION? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-INLINED-FUNCTIONS)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-METHOD-INLINED-FUNCTIONS VALUE NULL)
     (CL:SETQ VALUE (METHOD-INLINED-FUNCTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-EVALUATE-ARGUMENTS?)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-METHOD-EVALUATE-ARGUMENTS?
      (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE) TRUE-WRAPPER
       FALSE-WRAPPER)
      FALSE-WRAPPER)
     (CL:SETQ VALUE
      (CL:IF (METHOD-EVALUATE-ARGUMENTS? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   (CL:T
    (CL:COND
     ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-DOCUMENTATION)
      (CL:SETQ SLOTNAME SYM-HIERARCHY-STELLA-DOCUMENTATION))
     ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-AUXILIARY?)
      (CL:SETQ SLOTNAME SYM-HIERARCHY-STELLA-SLOT-AUXILIARY?))
     ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-METHOD-STORAGE-SLOT)
      (CL:SETQ SLOTNAME SYM-HIERARCHY-STELLA-STORAGE-SLOT))
     (CL:T))
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-METHOD-SLOT-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF METHOD-SLOT) STREAM)
  (CL:IF (%METHOD-FUNCTION? SELF)
   (%%PRINT-STREAM STREAM "|F|" (%SYMBOL-NAME (%SLOT-NAME SELF)))
   (%%PRINT-STREAM STREAM "|M|" (%SYMBOL-NAME (%SLOT-OWNER SELF)) "."
    (%SYMBOL-NAME (%SLOT-NAME SELF))))
  :VOID)

;;; (DEFCLASS COMPOUND-TYPE-SPECIFIER ...)

(CL:DEFCLASS COMPOUND-TYPE-SPECIFIER (STANDARD-OBJECT)
  ())

(CL:DEFMETHOD PRINT-OBJECT ((SELF COMPOUND-TYPE-SPECIFIER) STREAM)
  (%%PRINT-STREAM STREAM "|TS|" (YIELD-TYPE-SPEC-TREE SELF))
  :VOID)

;;; (DEFCLASS PARAMETRIC-TYPE-SPECIFIER ...)

(CL:DEFCLASS PARAMETRIC-TYPE-SPECIFIER (COMPOUND-TYPE-SPECIFIER)
  ((SPECIFIER-BASE-TYPE :ALLOCATION :INSTANCE :ACCESSOR
    %SPECIFIER-BASE-TYPE)
   (SPECIFIER-PARAMETER-TYPES :ALLOCATION :INSTANCE :ACCESSOR
    %SPECIFIER-PARAMETER-TYPES)
   (SPECIFIER-DIMENSIONS :ALLOCATION :INSTANCE :ACCESSOR
    %SPECIFIER-DIMENSIONS)))

(CL:DEFUN NEW-PARAMETRIC-TYPE-SPECIFIER ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE PARAMETRIC-TYPE-SPECIFIER)))
   (CL:SETF (%SPECIFIER-DIMENSIONS SELF) NULL)
   (CL:SETF (%SPECIFIER-PARAMETER-TYPES SELF) (NEW-LIST))
   (CL:SETF (%SPECIFIER-BASE-TYPE SELF) NULL)
   (CL:RETURN-FROM NEW-PARAMETRIC-TYPE-SPECIFIER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PARAMETRIC-TYPE-SPECIFIER))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-PARAMETRIC-TYPE-SPECIFIER))

(CL:DEFUN ACCESS-PARAMETRIC-TYPE-SPECIFIER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SPECIFIER-BASE-TYPE)
    (CL:IF SETVALUE? (CL:SETF (%SPECIFIER-BASE-TYPE SELF) VALUE)
     (CL:SETQ VALUE (%SPECIFIER-BASE-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SPECIFIER-PARAMETER-TYPES)
    (CL:IF SETVALUE? (CL:SETF (%SPECIFIER-PARAMETER-TYPES SELF) VALUE)
     (CL:SETQ VALUE (%SPECIFIER-PARAMETER-TYPES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SPECIFIER-DIMENSIONS)
    (CL:IF SETVALUE? (CL:SETF (%SPECIFIER-DIMENSIONS SELF) VALUE)
     (CL:SETQ VALUE (%SPECIFIER-DIMENSIONS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-PARAMETRIC-TYPE-SPECIFIER-SLOT-VALUE VALUE))

;;; (DEFCLASS ANCHORED-TYPE-SPECIFIER ...)

(CL:DEFCLASS ANCHORED-TYPE-SPECIFIER (COMPOUND-TYPE-SPECIFIER)
  ((SPECIFIER-PARAMETER-NAME :ALLOCATION :INSTANCE :ACCESSOR
    %SPECIFIER-PARAMETER-NAME)))

(CL:DEFUN NEW-ANCHORED-TYPE-SPECIFIER ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE ANCHORED-TYPE-SPECIFIER)))
   (CL:SETF (%SPECIFIER-PARAMETER-NAME SELF) NULL)
   (CL:RETURN-FROM NEW-ANCHORED-TYPE-SPECIFIER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ANCHORED-TYPE-SPECIFIER))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-ANCHORED-TYPE-SPECIFIER))

(CL:DEFUN ACCESS-ANCHORED-TYPE-SPECIFIER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SPECIFIER-PARAMETER-NAME)
    (CL:IF SETVALUE? (CL:SETF (%SPECIFIER-PARAMETER-NAME SELF) VALUE)
     (CL:SETQ VALUE (%SPECIFIER-PARAMETER-NAME SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-ANCHORED-TYPE-SPECIFIER-SLOT-VALUE VALUE))

;;; (DEFCLASS TABLE ...)

(CL:DEFCLASS TABLE (SLOT)
  ((TUPLE-DOMAINS :ALLOCATION :INSTANCE :ACCESSOR %TUPLE-DOMAINS)))

(CL:DEFUN NEW-TABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TABLE)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%ABSTRACT? SELF) CL:NIL)
   (CL:SETF (%SLOT-DIRECT-EQUIVALENT SELF) NULL)
   (CL:SETF (%SLOT-MARKED? SELF) CL:NIL)
   (CL:SETF (%SLOT-EXTERNAL? SELF) CL:NIL)
   (CL:SETF (%SLOT-RENAMED? SELF) CL:NIL)
   (CL:SETF (%SLOT-PUBLIC? SELF) CL:T)
   (CL:SETF (%SLOT-SLOTREF SELF) NULL)
   (CL:SETF (%SLOT-BASE-TYPE SELF) NULL)
   (CL:SETF (%SLOT-OWNER SELF) NULL) (CL:SETF (%SLOT-NAME SELF) NULL)
   (CL:SETF (%TUPLE-DOMAINS SELF) NULL) (CL:RETURN-FROM NEW-TABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-TABLE))

(CL:DEFUN ACCESS-TABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-TUPLE-DOMAINS)
    (CL:IF SETVALUE? (CL:SETF (%TUPLE-DOMAINS SELF) VALUE)
     (CL:SETQ VALUE (%TUPLE-DOMAINS SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-TABLE-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF TABLE) STREAM)
  (%%PRINT-STREAM STREAM "|T|" (%SYMBOL-NAME (%SLOT-NAME SELF)))
  :VOID)

;;; (DEFCLASS GLOBAL-VARIABLE ...)

(CL:DEFCLASS GLOBAL-VARIABLE (MAPPABLE-OBJECT)
  ((DOCUMENTATION :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %DOCUMENTATION)
   (VARIABLE-NAME :ALLOCATION :INSTANCE :ACCESSOR %VARIABLE-NAME)
   (VARIABLE-TYPE :ALLOCATION :INSTANCE :ACCESSOR %VARIABLE-TYPE)
   (VARIABLE-SPECIAL? :ALLOCATION :INSTANCE :ACCESSOR
    %VARIABLE-SPECIAL?)
   (VARIABLE-CONSTANT? :ALLOCATION :INSTANCE :ACCESSOR
    %VARIABLE-CONSTANT?)
   (VARIABLE-PUBLIC? :ALLOCATION :INSTANCE :ACCESSOR %VARIABLE-PUBLIC?)
   (VARIABLE-AUXILIARY? :ALLOCATION :INSTANCE :ACCESSOR
    %VARIABLE-AUXILIARY?)
   (VARIABLE-GET-VALUE-CODE :ALLOCATION :INSTANCE :ACCESSOR
    %VARIABLE-GET-VALUE-CODE)
   (VARIABLE-SET-VALUE-CODE :ALLOCATION :INSTANCE :ACCESSOR
    %VARIABLE-SET-VALUE-CODE)
   (VARIABLE-VALUE-STACK :ALLOCATION :INSTANCE :ACCESSOR
    %VARIABLE-VALUE-STACK)
   (VARIABLE-STRINGIFIED-SOURCE :TYPE CL:SIMPLE-STRING :INITFORM
    STELLA::NULL-STRING :ALLOCATION :INSTANCE :ACCESSOR
    %VARIABLE-STRINGIFIED-SOURCE)))

(CL:DEFUN NEW-GLOBAL-VARIABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE GLOBAL-VARIABLE)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%VARIABLE-STRINGIFIED-SOURCE SELF) STELLA::NULL-STRING)
   (CL:SETF (%DOCUMENTATION SELF) STELLA::NULL-STRING)
   (CL:SETF (%VARIABLE-VALUE-STACK SELF) NULL)
   (CL:SETF (%VARIABLE-SET-VALUE-CODE SELF) NULL)
   (CL:SETF (%VARIABLE-GET-VALUE-CODE SELF) NULL)
   (CL:SETF (%VARIABLE-AUXILIARY? SELF) CL:NIL)
   (CL:SETF (%VARIABLE-PUBLIC? SELF) CL:T)
   (CL:SETF (%VARIABLE-CONSTANT? SELF) CL:NIL)
   (CL:SETF (%VARIABLE-SPECIAL? SELF) CL:NIL)
   (CL:SETF (%VARIABLE-TYPE SELF) NULL)
   (CL:SETF (%VARIABLE-NAME SELF) NULL)
   (CL:RETURN-FROM NEW-GLOBAL-VARIABLE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF GLOBAL-VARIABLE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-GLOBAL-VARIABLE))

(CL:DEFMETHOD NAME ((SELF GLOBAL-VARIABLE))
  (CL:RETURN-FROM NAME (%SYMBOL-NAME (%VARIABLE-NAME SELF))))

(CL:DEFMETHOD TYPE ((SELF GLOBAL-VARIABLE))
  (CL:RETURN-FROM TYPE (%VARIABLE-TYPE SELF)))

(CL:DEFMETHOD HOME-MODULE ((SELF GLOBAL-VARIABLE))
  (CL:LET*
   ((MODULE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-VARIABLE-HOME-MODULE NULL)))
   (CL:IF (CL:NOT (CL:EQ MODULE NULL))
    (CL:RETURN-FROM HOME-MODULE MODULE)
    (CL:RETURN-FROM HOME-MODULE (%HOME-CONTEXT (%VARIABLE-NAME SELF))))))

(CL:DEFUN ACCESS-GLOBAL-VARIABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DOCUMENTATION)
    (CL:IF SETVALUE?
     (CL:SETF (%DOCUMENTATION SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%DOCUMENTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VARIABLE-NAME)
    (CL:IF SETVALUE? (CL:SETF (%VARIABLE-NAME SELF) VALUE)
     (CL:SETQ VALUE (%VARIABLE-NAME SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VARIABLE-TYPE)
    (CL:IF SETVALUE? (CL:SETF (%VARIABLE-TYPE SELF) VALUE)
     (CL:SETQ VALUE (%VARIABLE-TYPE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VARIABLE-SPECIAL?)
    (CL:IF SETVALUE?
     (CL:SETF (%VARIABLE-SPECIAL? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%VARIABLE-SPECIAL? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VARIABLE-CONSTANT?)
    (CL:IF SETVALUE?
     (CL:SETF (%VARIABLE-CONSTANT? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%VARIABLE-CONSTANT? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VARIABLE-PUBLIC?)
    (CL:IF SETVALUE?
     (CL:SETF (%VARIABLE-PUBLIC? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%VARIABLE-PUBLIC? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VARIABLE-AUXILIARY?)
    (CL:IF SETVALUE?
     (CL:SETF (%VARIABLE-AUXILIARY? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%VARIABLE-AUXILIARY? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VARIABLE-GET-VALUE-CODE)
    (CL:IF SETVALUE?
     (CL:SETF (%VARIABLE-GET-VALUE-CODE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE (%VARIABLE-GET-VALUE-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VARIABLE-SET-VALUE-CODE)
    (CL:IF SETVALUE?
     (CL:SETF (%VARIABLE-SET-VALUE-CODE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE (%VARIABLE-SET-VALUE-CODE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VARIABLE-VALUE-STACK)
    (CL:IF SETVALUE? (CL:SETF (%VARIABLE-VALUE-STACK SELF) VALUE)
     (CL:SETQ VALUE (%VARIABLE-VALUE-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VARIABLE-DOCUMENTATION)
    (CL:IF SETVALUE?
     (CL:SETF (%DOCUMENTATION SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%DOCUMENTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-VARIABLE-STRINGIFIED-SOURCE)
    (CL:IF SETVALUE?
     (CL:SETF (%VARIABLE-STRINGIFIED-SOURCE SELF)
      (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-STRING (%VARIABLE-STRINGIFIED-SOURCE SELF)))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-GLOBAL-VARIABLE-SLOT-VALUE VALUE))

;;; (DEFCLASS QUOTED-EXPRESSION ...)

(CL:DEFCLASS QUOTED-EXPRESSION (STANDARD-OBJECT)
  ((QUOTATION-TABLE-OFFSET :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %QUOTATION-TABLE-OFFSET)))

(CL:DEFUN NEW-QUOTED-EXPRESSION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE QUOTED-EXPRESSION)))
   (CL:SETF (%QUOTATION-TABLE-OFFSET SELF) NULL-INTEGER)
   (CL:RETURN-FROM NEW-QUOTED-EXPRESSION SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF QUOTED-EXPRESSION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-QUOTED-EXPRESSION))

(CL:DEFUN ACCESS-QUOTED-EXPRESSION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-QUOTATION-TABLE-OFFSET)
    (CL:IF SETVALUE?
     (CL:SETF (%QUOTATION-TABLE-OFFSET SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%QUOTATION-TABLE-OFFSET SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-QUOTED-EXPRESSION-SLOT-VALUE VALUE))

;;; (DEFCLASS VOID ...)

(CL:DEFCLASS VOID (CLSYS-ROOT-OBJECT)
  ())

;;; (DEFCLASS UNKNOWN ...)

(CL:DEFCLASS UNKNOWN (CLSYS-ROOT-OBJECT)
  ())

;;; (DEFCLASS THING ...)

(CL:DEFCLASS THING (STANDARD-OBJECT)
  ((SURROGATE-VALUE-INVERSE :ALLOCATION :INSTANCE :ACCESSOR
    %SURROGATE-VALUE-INVERSE)
   (DYNAMIC-SLOTS :ALLOCATION :INSTANCE :ACCESSOR %DYNAMIC-SLOTS))
  (:DOCUMENTATION "Defines a class that must be inherited by any
class that participates in the PowerLoom side of things."))

(CL:DEFMETHOD BAD? ((SELF THING))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-BAD? NULL)))
   (CL:IF (CL:EQ ANSWER NULL) (CL:RETURN-FROM BAD? FALSE-WRAPPER)
    (CL:RETURN-FROM BAD? ANSWER))))

(CL:DEFUN ACCESS-THING-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SURROGATE-VALUE-INVERSE)
    (CL:IF SETVALUE? (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) VALUE)
     (CL:SETQ VALUE (%SURROGATE-VALUE-INVERSE SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-THING-SLOT-VALUE VALUE))

(CL:DEFMETHOD DELETED? ((SELF THING))
  (CL:LET*
   ((DELETED?
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-DELETED-OBJECT? NULL)))
   (CL:IF (CL:NOT (CL:EQ DELETED? NULL))
    (CL:RETURN-FROM DELETED?
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN DELETED?))
    (CL:RETURN-FROM DELETED? CL:NIL))))

(CL:DEFMETHOD DELETED?-SETTER ((SELF THING) VALUE)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-HIERARCHY-STELLA-DELETED-OBJECT?
   (CL:IF VALUE TRUE-WRAPPER FALSE-WRAPPER) NULL)
  (CL:RETURN-FROM DELETED?-SETTER VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF THING) STREAM)
  (CL:IF (CL:NOT (CL:EQ (%SURROGATE-VALUE-INVERSE SELF) NULL))
   (%%PRINT-STREAM STREAM "|i|"
    (%SYMBOL-NAME (%SURROGATE-VALUE-INVERSE SELF)))
   (%%PRINT-STREAM STREAM "|i|" (PRIMARY-TYPE SELF)))
  :VOID)

;;; (DEFCLASS CONTEXT ...)

(CL:DEFCLASS CONTEXT (THING)
  ((CHILD-CONTEXTS :ALLOCATION :INSTANCE :ACCESSOR %CHILD-CONTEXTS)
   (BASE-MODULE :ALLOCATION :INSTANCE :ACCESSOR %BASE-MODULE)
   (ALL-SUPER-CONTEXTS :ALLOCATION :INSTANCE :ACCESSOR
    %ALL-SUPER-CONTEXTS)
   (CONTEXT-NUMBER :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %CONTEXT-NUMBER)))

(CL:DEFMETHOD CONTEXT-NAME ((SELF CONTEXT))
  (CL:LET* ((AUX SELF))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE AUX)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-HIERARCHY-STELLA-MODULE)
      (CL:PROGN (CL:RETURN-FROM CONTEXT-NAME (%MODULE-NAME AUX))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-HIERARCHY-STELLA-WORLD)
      (CL:PROGN
       (CL:RETURN-FROM CONTEXT-NAME
        (%WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS AUX)
          SYM-HIERARCHY-STELLA-WORLD-NAME NULL-STRING-WRAPPER)))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

(CL:DEFMETHOD HOME-MODULE ((SELF CONTEXT))
  (CL:RETURN-FROM HOME-MODULE (%BASE-MODULE SELF)))

(CL:DEFUN ACCESS-CONTEXT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CHILD-CONTEXTS)
    (CL:IF SETVALUE? (CL:SETF (%CHILD-CONTEXTS SELF) VALUE)
     (CL:SETQ VALUE (%CHILD-CONTEXTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-BASE-MODULE)
    (CL:IF SETVALUE? (CL:SETF (%BASE-MODULE SELF) VALUE)
     (CL:SETQ VALUE (%BASE-MODULE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ALL-SUPER-CONTEXTS)
    (CL:IF SETVALUE? (CL:SETF (%ALL-SUPER-CONTEXTS SELF) VALUE)
     (CL:SETQ VALUE (%ALL-SUPER-CONTEXTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CONTEXT-NUMBER)
    (CL:IF SETVALUE?
     (CL:SETF (%CONTEXT-NUMBER SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%CONTEXT-NUMBER SELF)))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-CONTEXT-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF CONTEXT) STREAM)
  (PRINT-CONTEXT SELF STREAM)
  :VOID)

;;; (DEFCLASS MODULE ...)

(CL:DEFCLASS MODULE (CONTEXT)
  ((PARENT-MODULES :ALLOCATION :INSTANCE :ACCESSOR %PARENT-MODULES)
   (DOCUMENTATION :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %DOCUMENTATION)
   (NICKNAMES :ALLOCATION :INSTANCE :ACCESSOR %NICKNAMES)
   (USES :ALLOCATION :INSTANCE :ACCESSOR %USES)
   (USED-BY :ALLOCATION :INSTANCE :ACCESSOR %USED-BY)
   (REQUIRES :ALLOCATION :INSTANCE :ACCESSOR %REQUIRES)
   (CASE-SENSITIVE? :ALLOCATION :INSTANCE :ACCESSOR %CASE-SENSITIVE?)
   (MODULE-FULL-NAME :TYPE CL:SIMPLE-STRING :INITFORM
    STELLA::NULL-STRING :ALLOCATION :INSTANCE :ACCESSOR
    %MODULE-FULL-NAME)
   (MODULE-NAME :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %MODULE-NAME)
   (MODULE-STRINGIFIED-SOURCE :TYPE CL:SIMPLE-STRING :INITFORM
    STELLA::NULL-STRING :ALLOCATION :INSTANCE :ACCESSOR
    %MODULE-STRINGIFIED-SOURCE)
   (STRINGIFIED-OPTIONS :TYPE CL:SIMPLE-STRING :INITFORM
    STELLA::NULL-STRING :ALLOCATION :INSTANCE :ACCESSOR
    %STRINGIFIED-OPTIONS)
   (CARDINAL-MODULE :ALLOCATION :INSTANCE :ACCESSOR %CARDINAL-MODULE)
   (SYMBOL-OFFSET-TABLE :ALLOCATION :INSTANCE :ACCESSOR
    %SYMBOL-OFFSET-TABLE)
   (SURROGATE-OFFSET-TABLE :ALLOCATION :INSTANCE :ACCESSOR
    %SURROGATE-OFFSET-TABLE)
   (STRICT-INFERENCE-CACHE :ALLOCATION :INSTANCE :ACCESSOR
    %STRICT-INFERENCE-CACHE)
   (DEFAULT-INFERENCE-CACHE :ALLOCATION :INSTANCE :ACCESSOR
    %DEFAULT-INFERENCE-CACHE)
   (PROTOTYPE-INFERENCE-CACHE :ALLOCATION :INSTANCE :ACCESSOR
    %PROTOTYPE-INFERENCE-CACHE)))

(CL:DEFUN NEW-MODULE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE MODULE)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%CONTEXT-NUMBER SELF) NULL-INTEGER)
   (CL:SETF (%ALL-SUPER-CONTEXTS SELF) NULL)
   (CL:SETF (%BASE-MODULE SELF) NULL)
   (CL:SETF (%CHILD-CONTEXTS SELF) (NEW-LIST))
   (CL:SETF (%PROTOTYPE-INFERENCE-CACHE SELF) NULL)
   (CL:SETF (%DEFAULT-INFERENCE-CACHE SELF) NULL)
   (CL:SETF (%STRICT-INFERENCE-CACHE SELF) NULL)
   (CL:SETF (%SURROGATE-OFFSET-TABLE SELF) NULL)
   (CL:SETF (%SYMBOL-OFFSET-TABLE SELF) NULL)
   (CL:SETF (%CARDINAL-MODULE SELF) NULL)
   (CL:SETF (%STRINGIFIED-OPTIONS SELF) STELLA::NULL-STRING)
   (CL:SETF (%MODULE-STRINGIFIED-SOURCE SELF) STELLA::NULL-STRING)
   (CL:SETF (%MODULE-NAME SELF) STELLA::NULL-STRING)
   (CL:SETF (%MODULE-FULL-NAME SELF) STELLA::NULL-STRING)
   (CL:SETF (%CASE-SENSITIVE? SELF) CL:NIL)
   (CL:SETF (%REQUIRES SELF) NULL) (CL:SETF (%USED-BY SELF) (NEW-LIST))
   (CL:SETF (%USES SELF) (NEW-LIST)) (CL:SETF (%NICKNAMES SELF) NULL)
   (CL:SETF (%DOCUMENTATION SELF) STELLA::NULL-STRING)
   (CL:SETF (%PARENT-MODULES SELF) (NEW-LIST))
   (CL:RETURN-FROM NEW-MODULE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF MODULE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-MODULE))

(CL:DEFMETHOD NAME ((SELF MODULE))
  (CL:RETURN-FROM NAME (%MODULE-NAME SELF)))

(CL:DEFMETHOD PARENT-MODULE ((SELF MODULE))
  (CL:RETURN-FROM PARENT-MODULE (POP (PARENT-CONTEXTS SELF))))

(CL:DEFMETHOD LISP-PACKAGE ((SELF MODULE))
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-MODULE-LISP-PACKAGE NULL-STRING-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE STELLA::NULL-STRING))
     (CL:RETURN-FROM LISP-PACKAGE VALUE))
    (CL:SETQ CURSOR (FIRST (%PARENT-MODULES CURSOR)))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (%WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
        SYM-HIERARCHY-STELLA-MODULE-LISP-PACKAGE NULL-STRING-WRAPPER)))
     (CL:RETURN-FROM LISP-PACKAGE "STELLA")))))

(CL:DEFMETHOD CPP-PACKAGE ((SELF MODULE))
  (CL:LET*
   ((CURSOR SELF)
    (VALUE
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
       SYM-HIERARCHY-STELLA-MODULE-CPP-PACKAGE NULL-STRING-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
   (CL:LOOP
    (CL:WHEN (CL:NOT (CL:EQ VALUE STELLA::NULL-STRING))
     (CL:RETURN-FROM CPP-PACKAGE VALUE))
    (CL:SETQ CURSOR (FIRST (%PARENT-MODULES CURSOR)))
    (CL:IF (CL:NOT (CL:EQ CURSOR NULL))
     (CL:SETQ VALUE
      (%WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CURSOR)
        SYM-HIERARCHY-STELLA-MODULE-CPP-PACKAGE NULL-STRING-WRAPPER)))
     (CL:RETURN-FROM CPP-PACKAGE "stella")))))

(CL:DEFMETHOD SHADOWED-SURROGATES ((SELF MODULE))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SHADOWED-SURROGATES NULL)))
   (CL:IF (CL:EQ ANSWER NULL)
    (CL:RETURN-FROM SHADOWED-SURROGATES NIL-LIST)
    (CL:RETURN-FROM SHADOWED-SURROGATES ANSWER))))

(CL:DEFMETHOD MODULE-LISP-PACKAGE ((SELF MODULE))
  (CL:LET*
   ((ANSWER
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-HIERARCHY-STELLA-MODULE-LISP-PACKAGE NULL-STRING-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING ANSWER))
   (CL:IF (CL:EQ ANSWER STELLA::NULL-STRING)
    (CL:RETURN-FROM MODULE-LISP-PACKAGE "STELLA")
    (CL:RETURN-FROM MODULE-LISP-PACKAGE ANSWER))))

(CL:DEFMETHOD MODULE-CPP-PACKAGE ((SELF MODULE))
  (CL:LET*
   ((ANSWER
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-HIERARCHY-STELLA-MODULE-CPP-PACKAGE NULL-STRING-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING ANSWER))
   (CL:IF (CL:EQ ANSWER STELLA::NULL-STRING)
    (CL:RETURN-FROM MODULE-CPP-PACKAGE "stella")
    (CL:RETURN-FROM MODULE-CPP-PACKAGE ANSWER))))

(CL:DEFMETHOD JAVA-PACKAGE ((SELF MODULE))
  (CL:LET*
   ((ANSWER
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-HIERARCHY-STELLA-JAVA-PACKAGE NULL-STRING-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING ANSWER))
   (CL:IF (CL:EQ ANSWER STELLA::NULL-STRING)
    (CL:RETURN-FROM JAVA-PACKAGE STELLA::NULL-STRING)
    (CL:RETURN-FROM JAVA-PACKAGE ANSWER))))

(CL:DEFMETHOD CLEARABLE? ((SELF MODULE))
  (CL:RETURN-FROM CLEARABLE?
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-HIERARCHY-STELLA-CLEARABLE? TRUE-WRAPPER))))

(CL:DEFMETHOD PROTECT-SURROGATES? ((SELF MODULE))
  (CL:RETURN-FROM PROTECT-SURROGATES?
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-HIERARCHY-STELLA-PROTECT-SURROGATES? TRUE-WRAPPER))))

(CL:DEFUN ACCESS-MODULE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PARENT-MODULES)
    (CL:IF SETVALUE? (CL:SETF (%PARENT-MODULES SELF) VALUE)
     (CL:SETQ VALUE (%PARENT-MODULES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DOCUMENTATION)
    (CL:IF SETVALUE?
     (CL:SETF (%DOCUMENTATION SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%DOCUMENTATION SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-NICKNAMES)
    (CL:IF SETVALUE? (CL:SETF (%NICKNAMES SELF) VALUE)
     (CL:SETQ VALUE (%NICKNAMES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-USES)
    (CL:IF SETVALUE? (CL:SETF (%USES SELF) VALUE)
     (CL:SETQ VALUE (%USES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-USED-BY)
    (CL:IF SETVALUE? (CL:SETF (%USED-BY SELF) VALUE)
     (CL:SETQ VALUE (%USED-BY SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SHADOWED-SURROGATES)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-SHADOWED-SURROGATES VALUE NULL)
     (CL:SETQ VALUE (SHADOWED-SURROGATES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-REQUIRES)
    (CL:IF SETVALUE? (CL:SETF (%REQUIRES SELF) VALUE)
     (CL:SETQ VALUE (%REQUIRES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-MODULE-LISP-PACKAGE)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-MODULE-LISP-PACKAGE
      (WRAP-STRING (%WRAPPER-VALUE VALUE)) NULL-STRING-WRAPPER)
     (CL:SETQ VALUE (WRAP-STRING (MODULE-LISP-PACKAGE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-MODULE-CPP-PACKAGE)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-MODULE-CPP-PACKAGE
      (WRAP-STRING (%WRAPPER-VALUE VALUE)) NULL-STRING-WRAPPER)
     (CL:SETQ VALUE (WRAP-STRING (MODULE-CPP-PACKAGE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-JAVA-PACKAGE)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-JAVA-PACKAGE
      (WRAP-STRING (%WRAPPER-VALUE VALUE)) NULL-STRING-WRAPPER)
     (CL:SETQ VALUE (WRAP-STRING (JAVA-PACKAGE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CASE-SENSITIVE?)
    (CL:IF SETVALUE?
     (CL:SETF (%CASE-SENSITIVE? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%CASE-SENSITIVE? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CLEARABLE?)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-CLEARABLE?
      (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE) TRUE-WRAPPER
       FALSE-WRAPPER)
      FALSE-WRAPPER)
     (CL:SETQ VALUE
      (CL:IF (CLEARABLE? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PROTECT-SURROGATES?)
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-HIERARCHY-STELLA-PROTECT-SURROGATES?
      (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE) TRUE-WRAPPER
       FALSE-WRAPPER)
      FALSE-WRAPPER)
     (CL:SETQ VALUE
      (CL:IF (PROTECT-SURROGATES? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-MODULE-FULL-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%MODULE-FULL-NAME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%MODULE-FULL-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-MODULE-NAME)
    (CL:IF SETVALUE?
     (CL:SETF (%MODULE-NAME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%MODULE-NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-MODULE-STRINGIFIED-SOURCE)
    (CL:IF SETVALUE?
     (CL:SETF (%MODULE-STRINGIFIED-SOURCE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%MODULE-STRINGIFIED-SOURCE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-STRINGIFIED-OPTIONS)
    (CL:IF SETVALUE?
     (CL:SETF (%STRINGIFIED-OPTIONS SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%STRINGIFIED-OPTIONS SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CARDINAL-MODULE)
    (CL:IF SETVALUE? (CL:SETF (%CARDINAL-MODULE SELF) VALUE)
     (CL:SETQ VALUE (%CARDINAL-MODULE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SYMBOL-OFFSET-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%SYMBOL-OFFSET-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%SYMBOL-OFFSET-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SURROGATE-OFFSET-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%SURROGATE-OFFSET-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%SURROGATE-OFFSET-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-STRICT-INFERENCE-CACHE)
    (CL:IF SETVALUE? (CL:SETF (%STRICT-INFERENCE-CACHE SELF) VALUE)
     (CL:SETQ VALUE (%STRICT-INFERENCE-CACHE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEFAULT-INFERENCE-CACHE)
    (CL:IF SETVALUE? (CL:SETF (%DEFAULT-INFERENCE-CACHE SELF) VALUE)
     (CL:SETQ VALUE (%DEFAULT-INFERENCE-CACHE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PROTOTYPE-INFERENCE-CACHE)
    (CL:IF SETVALUE? (CL:SETF (%PROTOTYPE-INFERENCE-CACHE SELF) VALUE)
     (CL:SETQ VALUE (%PROTOTYPE-INFERENCE-CACHE SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-MODULE-SLOT-VALUE VALUE))

;;; (DEFCLASS WORLD ...)

(CL:DEFCLASS WORLD (CONTEXT)
  ((PARENT-CONTEXT :ALLOCATION :INSTANCE :ACCESSOR %PARENT-CONTEXT)))

(CL:DEFUN NEW-WORLD ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE WORLD)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%CONTEXT-NUMBER SELF) NULL-INTEGER)
   (CL:SETF (%ALL-SUPER-CONTEXTS SELF) NULL)
   (CL:SETF (%BASE-MODULE SELF) NULL)
   (CL:SETF (%CHILD-CONTEXTS SELF) (NEW-LIST))
   (CL:SETF (%PARENT-CONTEXT SELF) NULL)
   (CL:RETURN-FROM NEW-WORLD SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF WORLD))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-WORLD))

(CL:DEFUN ACCESS-WORLD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PARENT-CONTEXT)
    (CL:IF SETVALUE? (CL:SETF (%PARENT-CONTEXT SELF) VALUE)
     (CL:SETQ VALUE (%PARENT-CONTEXT SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CHILD-CONTEXTS)
    (CL:IF SETVALUE? (CL:SETF (%CHILD-CONTEXTS SELF) VALUE)
     (CL:SETQ VALUE (%CHILD-CONTEXTS SELF))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  (CL:RETURN-FROM ACCESS-WORLD-SLOT-VALUE VALUE))

;;; (DEFCLASS CS-VALUE ...)

(CL:DEFCLASS CS-VALUE (KEY-VALUE-LIST)
  ()
  (:DOCUMENTATION
   "Contextualized value.  Contains a sorted kv-cons list indexed
by context. The kv-cons list is never null.  Newer (higher numbered) contexts
appear first."))

(CL:DEFUN NEW-CS-VALUE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CS-VALUE)))
   (CL:SETF (%THE-KV-LIST SELF) NULL)
   (CL:RETURN-FROM NEW-CS-VALUE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CS-VALUE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-CS-VALUE))

;;; (DEFCLASS INTERVAL ...)

(CL:DEFCLASS INTERVAL (STANDARD-OBJECT)
  ((LOWER-BOUND :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %LOWER-BOUND)
   (UPPER-BOUND :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %UPPER-BOUND)))

(CL:DEFUN NEW-INTERVAL ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INTERVAL)))
   (CL:SETF (%UPPER-BOUND SELF) NULL-INTEGER)
   (CL:SETF (%LOWER-BOUND SELF) NULL-INTEGER)
   (CL:RETURN-FROM NEW-INTERVAL SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTERVAL))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-INTERVAL))

(CL:DEFUN ACCESS-INTERVAL-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-LOWER-BOUND)
    (CL:IF SETVALUE?
     (CL:SETF (%LOWER-BOUND SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%LOWER-BOUND SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-UPPER-BOUND)
    (CL:IF SETVALUE?
     (CL:SETF (%UPPER-BOUND SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%UPPER-BOUND SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-INTERVAL-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF INTERVAL) STREAM)
  (%%PRINT-STREAM STREAM "[" (%LOWER-BOUND SELF) ","
   (%UPPER-BOUND SELF) "]")
  :VOID)

;;; (DEFCLASS TAXONOMY-NODE ...)

(CL:DEFCLASS TAXONOMY-NODE (STANDARD-OBJECT)
  ((NATIVE-OBJECT :ALLOCATION :INSTANCE :ACCESSOR %NATIVE-OBJECT)
   (LABEL :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %LABEL)
   (INTERVALS :ALLOCATION :INSTANCE :ACCESSOR %INTERVALS)
   (INITIAL-INTERVAL :ALLOCATION :INSTANCE :ACCESSOR %INITIAL-INTERVAL)
   (FIRST-INTERVAL-LOWER-BOUND :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %FIRST-INTERVAL-LOWER-BOUND)
   (FIRST-INTERVAL-UPPER-BOUND :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %FIRST-INTERVAL-UPPER-BOUND)
   (PARENTS :ALLOCATION :INSTANCE :ACCESSOR %PARENTS)
   (CHILDREN :ALLOCATION :INSTANCE :ACCESSOR %CHILDREN)
   (TOTAL-ANCESTORS :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %TOTAL-ANCESTORS)
   (TREE-CHILDREN :ALLOCATION :INSTANCE :ACCESSOR %TREE-CHILDREN)
   (MARKER :ALLOCATION :INSTANCE :ACCESSOR %MARKER)))

(CL:DEFUN NEW-TAXONOMY-NODE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TAXONOMY-NODE)))
   (CL:SETF (%MARKER SELF) NULL) (CL:SETF (%TREE-CHILDREN SELF) NIL)
   (CL:SETF (%TOTAL-ANCESTORS SELF) 1) (CL:SETF (%CHILDREN SELF) NIL)
   (CL:SETF (%PARENTS SELF) NIL)
   (CL:SETF (%FIRST-INTERVAL-UPPER-BOUND SELF) -1)
   (CL:SETF (%FIRST-INTERVAL-LOWER-BOUND SELF) -1)
   (CL:SETF (%INITIAL-INTERVAL SELF) NULL)
   (CL:SETF (%INTERVALS SELF) NIL) (CL:SETF (%LABEL SELF) NULL-INTEGER)
   (CL:SETF (%NATIVE-OBJECT SELF) NULL)
   (CL:RETURN-FROM NEW-TAXONOMY-NODE SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TAXONOMY-NODE))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-TAXONOMY-NODE))

(CL:DEFUN ACCESS-TAXONOMY-NODE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-NATIVE-OBJECT)
    (CL:IF SETVALUE? (CL:SETF (%NATIVE-OBJECT SELF) VALUE)
     (CL:SETQ VALUE (%NATIVE-OBJECT SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-LABEL)
    (CL:IF SETVALUE? (CL:SETF (%LABEL SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%LABEL SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-INTERVALS)
    (CL:IF SETVALUE? (CL:SETF (%INTERVALS SELF) VALUE)
     (CL:SETQ VALUE (%INTERVALS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-INITIAL-INTERVAL)
    (CL:IF SETVALUE? (CL:SETF (%INITIAL-INTERVAL SELF) VALUE)
     (CL:SETQ VALUE (%INITIAL-INTERVAL SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-FIRST-INTERVAL-LOWER-BOUND)
    (CL:IF SETVALUE?
     (CL:SETF (%FIRST-INTERVAL-LOWER-BOUND SELF)
      (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%FIRST-INTERVAL-LOWER-BOUND SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-FIRST-INTERVAL-UPPER-BOUND)
    (CL:IF SETVALUE?
     (CL:SETF (%FIRST-INTERVAL-UPPER-BOUND SELF)
      (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%FIRST-INTERVAL-UPPER-BOUND SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PARENTS)
    (CL:IF SETVALUE? (CL:SETF (%PARENTS SELF) VALUE)
     (CL:SETQ VALUE (%PARENTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CHILDREN)
    (CL:IF SETVALUE? (CL:SETF (%CHILDREN SELF) VALUE)
     (CL:SETQ VALUE (%CHILDREN SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-TOTAL-ANCESTORS)
    (CL:IF SETVALUE?
     (CL:SETF (%TOTAL-ANCESTORS SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%TOTAL-ANCESTORS SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-TREE-CHILDREN)
    (CL:IF SETVALUE? (CL:SETF (%TREE-CHILDREN SELF) VALUE)
     (CL:SETQ VALUE (%TREE-CHILDREN SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-MARKER)
    (CL:IF SETVALUE? (CL:SETF (%MARKER SELF) VALUE)
     (CL:SETQ VALUE (%MARKER SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-TAXONOMY-NODE-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF TAXONOMY-NODE) STREAM)
  (%%PRINT-STREAM STREAM "|TN|" (%LABEL SELF) " " (%INTERVALS SELF) " "
   (%NATIVE-OBJECT SELF))
  :VOID)

;;; (DEFCLASS TAXONOMY-GRAPH ...)

(CL:DEFCLASS TAXONOMY-GRAPH (STANDARD-OBJECT)
  ((RENUMBER-IF-OUT-OF-NUMBERS? :DOCUMENTATION
    "If TRUE, relabel the entire graph when a new interval
for an incrementally inserted node can't be allocated due to lack of
splittable interval space.  Otherwise, create a `foreign' interval and
propagate it." :ALLOCATION :INSTANCE :ACCESSOR
    %RENUMBER-IF-OUT-OF-NUMBERS?)
   (RENUMBER-RATIO :TYPE CL:DOUBLE-FLOAT :INITFORM NULL-FLOAT
    :DOCUMENTATION "Whenever the ratio between foreign intervals and
non-foreign intervals becomes greater than `renumber-ratio', relabel
the whole graph non-incrementally." :ALLOCATION :INSTANCE :ACCESSOR
    %RENUMBER-RATIO)
   (INCREMENTAL-MODE? :ALLOCATION :INSTANCE :ACCESSOR
    %INCREMENTAL-MODE?)
   (LARGEST-POSTORDER-NUMBER :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %LARGEST-POSTORDER-NUMBER)
   (NUMBER-OF-NODES :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %NUMBER-OF-NODES)
   (NUMBER-OF-FOREIGN-INTERVAL-NODES :TYPE CL:FIXNUM :INITFORM
    NULL-INTEGER :ALLOCATION :INSTANCE :ACCESSOR
    %NUMBER-OF-FOREIGN-INTERVAL-NODES)
   (ROOTS :ALLOCATION :INSTANCE :ACCESSOR %ROOTS)
   (BROKEN-LINKS :ALLOCATION :INSTANCE :ACCESSOR %BROKEN-LINKS)
   (ADDED-LINKS :ALLOCATION :INSTANCE :ACCESSOR %ADDED-LINKS)
   (REMOVED-LINKS :ALLOCATION :INSTANCE :ACCESSOR %REMOVED-LINKS)))

(CL:DEFUN NEW-TAXONOMY-GRAPH ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TAXONOMY-GRAPH)))
   (CL:SETF (%REMOVED-LINKS SELF) NULL)
   (CL:SETF (%ADDED-LINKS SELF) NULL)
   (CL:SETF (%BROKEN-LINKS SELF) NULL) (CL:SETF (%ROOTS SELF) NULL)
   (CL:SETF (%NUMBER-OF-FOREIGN-INTERVAL-NODES SELF) NULL-INTEGER)
   (CL:SETF (%NUMBER-OF-NODES SELF) NULL-INTEGER)
   (CL:SETF (%LARGEST-POSTORDER-NUMBER SELF) NULL-INTEGER)
   (CL:SETF (%INCREMENTAL-MODE? SELF) CL:NIL)
   (CL:SETF (%RENUMBER-RATIO SELF) 0.1d0)
   (CL:SETF (%RENUMBER-IF-OUT-OF-NUMBERS? SELF) CL:NIL)
   (INITIALIZE-TAXONOMY-GRAPH SELF)
   (CL:RETURN-FROM NEW-TAXONOMY-GRAPH SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TAXONOMY-GRAPH))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-TAXONOMY-GRAPH))

(CL:DEFUN ACCESS-TAXONOMY-GRAPH-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-RENUMBER-IF-OUT-OF-NUMBERS?)
    (CL:IF SETVALUE?
     (CL:SETF (%RENUMBER-IF-OUT-OF-NUMBERS? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%RENUMBER-IF-OUT-OF-NUMBERS? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-RENUMBER-RATIO)
    (CL:IF SETVALUE?
     (CL:SETF (%RENUMBER-RATIO SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%RENUMBER-RATIO SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-INCREMENTAL-MODE?)
    (CL:IF SETVALUE?
     (CL:SETF (%INCREMENTAL-MODE? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%INCREMENTAL-MODE? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-LARGEST-POSTORDER-NUMBER)
    (CL:IF SETVALUE?
     (CL:SETF (%LARGEST-POSTORDER-NUMBER SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%LARGEST-POSTORDER-NUMBER SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-NUMBER-OF-NODES)
    (CL:IF SETVALUE?
     (CL:SETF (%NUMBER-OF-NODES SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%NUMBER-OF-NODES SELF)))))
   ((CL:EQ SLOTNAME
     SYM-HIERARCHY-STELLA-NUMBER-OF-FOREIGN-INTERVAL-NODES)
    (CL:IF SETVALUE?
     (CL:SETF (%NUMBER-OF-FOREIGN-INTERVAL-NODES SELF)
      (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%NUMBER-OF-FOREIGN-INTERVAL-NODES SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ROOTS)
    (CL:IF SETVALUE? (CL:SETF (%ROOTS SELF) VALUE)
     (CL:SETQ VALUE (%ROOTS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-BROKEN-LINKS)
    (CL:IF SETVALUE? (CL:SETF (%BROKEN-LINKS SELF) VALUE)
     (CL:SETQ VALUE (%BROKEN-LINKS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ADDED-LINKS)
    (CL:IF SETVALUE? (CL:SETF (%ADDED-LINKS SELF) VALUE)
     (CL:SETQ VALUE (%ADDED-LINKS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-REMOVED-LINKS)
    (CL:IF SETVALUE? (CL:SETF (%REMOVED-LINKS SELF) VALUE)
     (CL:SETQ VALUE (%REMOVED-LINKS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-TAXONOMY-GRAPH-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF TAXONOMY-GRAPH) STREAM)
  (%%PRINT-STREAM STREAM "|TG|" (%ROOTS SELF))
  :VOID)

;;; (DEFCLASS STELLA-EXCEPTION ...)

(CL:DEFINE-CONDITION STELLA-EXCEPTION (CL:SIMPLE-ERROR)
  ())

(CL:DEFUN NEW-STELLA-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE STELLA-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-STELLA-EXCEPTION SELF)))

;;; (DEFCLASS INPUT-OUTPUT-EXCEPTION ...)

(CL:DEFINE-CONDITION INPUT-OUTPUT-EXCEPTION (STELLA-EXCEPTION)
  ())

(CL:DEFUN NEW-INPUT-OUTPUT-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE INPUT-OUTPUT-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-INPUT-OUTPUT-EXCEPTION SELF)))

;;; (DEFCLASS READ-EXCEPTION ...)

(CL:DEFINE-CONDITION READ-EXCEPTION (INPUT-OUTPUT-EXCEPTION)
  ())

(CL:DEFUN NEW-READ-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE READ-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-READ-EXCEPTION SELF)))

;;; (DEFCLASS END-OF-FILE-EXCEPTION ...)

(CL:DEFINE-CONDITION END-OF-FILE-EXCEPTION (INPUT-OUTPUT-EXCEPTION)
  ())

(CL:DEFUN NEW-END-OF-FILE-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE END-OF-FILE-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-END-OF-FILE-EXCEPTION SELF)))

;;; (DEFCLASS NO-SUCH-FILE-EXCEPTION ...)

(CL:DEFINE-CONDITION NO-SUCH-FILE-EXCEPTION (INPUT-OUTPUT-EXCEPTION)
  ((FILENAME :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %FILENAME)))

(CL:DEFUN NEW-NO-SUCH-FILE-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE NO-SUCH-FILE-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:SETF (%FILENAME SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-NO-SUCH-FILE-EXCEPTION SELF)))

;;; (DEFCLASS FILE-ALREADY-EXISTS-EXCEPTION ...)

(CL:DEFINE-CONDITION FILE-ALREADY-EXISTS-EXCEPTION (INPUT-OUTPUT-EXCEPTION)
  ((FILENAME :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %FILENAME)))

(CL:DEFUN NEW-FILE-ALREADY-EXISTS-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE FILE-ALREADY-EXISTS-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:SETF (%FILENAME SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-FILE-ALREADY-EXISTS-EXCEPTION SELF)))

;;; (DEFCLASS UNHANDLED-EXCEPTION ...)

(CL:DEFINE-CONDITION UNHANDLED-EXCEPTION (STELLA-EXCEPTION)
  ())

(CL:DEFUN NEW-UNHANDLED-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE UNHANDLED-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-UNHANDLED-EXCEPTION SELF)))

;;; (DEFCLASS EVALUATION-EXCEPTION ...)

(CL:DEFINE-CONDITION EVALUATION-EXCEPTION (STELLA-EXCEPTION)
  ())

(CL:DEFUN NEW-EVALUATION-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE EVALUATION-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-EVALUATION-EXCEPTION SELF)))

;;; (DEFCLASS NO-SUCH-OBJECT-EXCEPTION ...)

(CL:DEFINE-CONDITION NO-SUCH-OBJECT-EXCEPTION (STELLA-EXCEPTION)
  ())

(CL:DEFUN NEW-NO-SUCH-OBJECT-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE NO-SUCH-OBJECT-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-NO-SUCH-OBJECT-EXCEPTION SELF)))

;;; (DEFCLASS NO-SUCH-CONTEXT-EXCEPTION ...)

(CL:DEFINE-CONDITION NO-SUCH-CONTEXT-EXCEPTION (NO-SUCH-OBJECT-EXCEPTION)
  ())

(CL:DEFUN NEW-NO-SUCH-CONTEXT-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE NO-SUCH-CONTEXT-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-NO-SUCH-CONTEXT-EXCEPTION SELF)))

;;; (DEFCLASS UNDEFINED-CLASS-EXCEPTION ...)

(CL:DEFINE-CONDITION UNDEFINED-CLASS-EXCEPTION (NO-SUCH-OBJECT-EXCEPTION)
  ())

(CL:DEFUN NEW-UNDEFINED-CLASS-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE UNDEFINED-CLASS-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-UNDEFINED-CLASS-EXCEPTION SELF)))

;;; (DEFCLASS BAD-ARGUMENT-EXCEPTION ...)

(CL:DEFINE-CONDITION BAD-ARGUMENT-EXCEPTION (STELLA-EXCEPTION)
  ())

(CL:DEFUN NEW-BAD-ARGUMENT-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE BAD-ARGUMENT-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-BAD-ARGUMENT-EXCEPTION SELF)))

;;; (DEFCLASS OBJECT-NOT-CLASS-EXCEPTION ...)

(CL:DEFINE-CONDITION OBJECT-NOT-CLASS-EXCEPTION (BAD-ARGUMENT-EXCEPTION)
  ())

(CL:DEFUN NEW-OBJECT-NOT-CLASS-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE OBJECT-NOT-CLASS-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-OBJECT-NOT-CLASS-EXCEPTION SELF)))

;;; (DEFCLASS INCOMPATIBLE-QUANTITY-EXCEPTION ...)

(CL:DEFINE-CONDITION INCOMPATIBLE-QUANTITY-EXCEPTION (STELLA-EXCEPTION)
  ())

(CL:DEFUN NEW-INCOMPATIBLE-QUANTITY-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE INCOMPATIBLE-QUANTITY-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-INCOMPATIBLE-QUANTITY-EXCEPTION SELF)))

;;; (DEFCLASS TIMEOUT-EXCEPTION ...)

(CL:DEFINE-CONDITION TIMEOUT-EXCEPTION (STELLA-EXCEPTION)
  ())

(CL:DEFUN NEW-TIMEOUT-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE TIMEOUT-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   (CL:RETURN-FROM NEW-TIMEOUT-EXCEPTION SELF)))

;;; (DEFCLASS QUANTITY ...)

(CL:DEFCLASS QUANTITY (OBJECT)
  ()
  (:DOCUMENTATION "General superclass for extensible quantity objects"))

(CL:DEFMETHOD COERCE-TO ((SELF QUANTITY) OTHER)
  (CL:IF (ISA? OTHER (PRIMARY-TYPE SELF))
   (CL:RETURN-FROM COERCE-TO OTHER) (CL:RETURN-FROM COERCE-TO NULL)))

(CL:DEFMETHOD LESS? ((SELF QUANTITY) OTHER)
  (CL:SETQ OTHER OTHER)
  (CL:RETURN-FROM LESS? CL:NIL))

(CL:DEFMETHOD LESS-EQUAL? ((SELF QUANTITY) OTHER)
  (CL:RETURN-FROM LESS-EQUAL?
   (CL:OR (OBJECT-EQL? SELF OTHER) (LESS? SELF OTHER))))

(CL:DEFMETHOD GREATER-EQUAL? ((SELF QUANTITY) OTHER)
  (CL:RETURN-FROM GREATER-EQUAL?
   (CL:OR (OBJECT-EQL? SELF OTHER) (GREATER? SELF OTHER))))

(CL:DEFMETHOD GREATER? ((SELF QUANTITY) OTHER)
  (CL:SETQ OTHER OTHER)
  (CL:RETURN-FROM GREATER? CL:NIL))

;;; (DEFCLASS WRAPPER ...)

(CL:DEFCLASS WRAPPER (OBJECT)
  ())

;;; (DEFCLASS LITERAL-WRAPPER ...)

(CL:DEFCLASS LITERAL-WRAPPER (WRAPPER)
  ())

;;; (DEFCLASS NUMBER-WRAPPER ...)

(CL:DEFCLASS NUMBER-WRAPPER (LITERAL-WRAPPER)
  ())

;;; (DEFCLASS INTEGER-WRAPPER ...)

(CL:DEFCLASS INTEGER-WRAPPER (NUMBER-WRAPPER)
  ((WRAPPER-VALUE :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %WRAPPER-VALUE)))

(CL:DEFUN NEW-INTEGER-WRAPPER (WRAPPER-VALUE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM WRAPPER-VALUE))
  #+MCL
  (CL:CHECK-TYPE WRAPPER-VALUE CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INTEGER-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-INTEGER-WRAPPER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INTEGER-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-INTEGER-WRAPPER))

(CL:DEFUN ACCESS-INTEGER-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-WRAPPER-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%WRAPPER-VALUE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%WRAPPER-VALUE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-INTEGER-WRAPPER-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF INTEGER-WRAPPER) STREAM)
  (CL:LET* ((VALUE (%WRAPPER-VALUE SELF)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VALUE))
   (CL:IF (CL:= VALUE NULL-INTEGER)
    (CL:IF *PRINTREADABLY?*
     (%%PRINT-STREAM STREAM SYM-HIERARCHY-STELLA-NULL-INTEGER)
     (%%PRINT-STREAM STREAM "|L|NULL-INTEGER"))
    (CL:IF *PRINTREADABLY?* (%%PRINT-STREAM STREAM VALUE)
     (%%PRINT-STREAM STREAM "|L|" VALUE))))
  :VOID)

;;; (DEFCLASS LONG-INTEGER-WRAPPER ...)

(CL:DEFCLASS LONG-INTEGER-WRAPPER (NUMBER-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR %WRAPPER-VALUE)))

(CL:DEFUN NEW-LONG-INTEGER-WRAPPER (WRAPPER-VALUE)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE LONG-INTEGER-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-LONG-INTEGER-WRAPPER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF LONG-INTEGER-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-LONG-INTEGER-WRAPPER))

(CL:DEFUN ACCESS-LONG-INTEGER-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-WRAPPER-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%WRAPPER-VALUE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-LONG-INTEGER (%WRAPPER-VALUE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-LONG-INTEGER-WRAPPER-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF LONG-INTEGER-WRAPPER) STREAM)
  (CL:LET* ((VALUE (%WRAPPER-VALUE SELF)))
   (CL:IF (CL:= VALUE NULL-LONG-INTEGER)
    (CL:IF *PRINTREADABLY?*
     (%%PRINT-STREAM STREAM SYM-HIERARCHY-STELLA-NULL-LONG-INTEGER)
     (%%PRINT-STREAM STREAM "|L|NULL-LONG-INTEGER"))
    (CL:IF *PRINTREADABLY?* (%%PRINT-STREAM STREAM VALUE)
     (%%PRINT-STREAM STREAM "|L|" VALUE))))
  :VOID)

;;; (DEFCLASS FLOAT-WRAPPER ...)

(CL:DEFCLASS FLOAT-WRAPPER (NUMBER-WRAPPER)
  ((WRAPPER-VALUE :TYPE CL:DOUBLE-FLOAT :INITFORM NULL-FLOAT
    :ALLOCATION :INSTANCE :ACCESSOR %WRAPPER-VALUE)))

(CL:DEFUN NEW-FLOAT-WRAPPER (WRAPPER-VALUE)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT WRAPPER-VALUE))
  #+MCL
  (CL:CHECK-TYPE WRAPPER-VALUE CL:DOUBLE-FLOAT)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FLOAT-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-FLOAT-WRAPPER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FLOAT-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-FLOAT-WRAPPER))

(CL:DEFUN ACCESS-FLOAT-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-WRAPPER-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%WRAPPER-VALUE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%WRAPPER-VALUE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-FLOAT-WRAPPER-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF FLOAT-WRAPPER) STREAM)
  (CL:LET* ((VALUE (%WRAPPER-VALUE SELF)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE))
   (CL:IF (CL:= VALUE NULL-FLOAT)
    (CL:IF *PRINTREADABLY?*
     (%%PRINT-STREAM STREAM SYM-HIERARCHY-STELLA-NULL-FLOAT)
     (%%PRINT-STREAM STREAM "|L|NULL-FLOAT"))
    (CL:IF *PRINTREADABLY?* (%%PRINT-STREAM STREAM VALUE)
     (%%PRINT-STREAM STREAM "|L|" VALUE))))
  :VOID)

;;; (DEFCLASS STRING-WRAPPER ...)

(CL:DEFCLASS STRING-WRAPPER (LITERAL-WRAPPER)
  ((WRAPPER-VALUE :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %WRAPPER-VALUE)))

(CL:DEFUN NEW-STRING-WRAPPER (WRAPPER-VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING WRAPPER-VALUE))
  #+MCL
  (CL:CHECK-TYPE WRAPPER-VALUE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE STRING-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-STRING-WRAPPER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF STRING-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-STRING-WRAPPER))

(CL:DEFUN ACCESS-STRING-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-WRAPPER-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%WRAPPER-VALUE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%WRAPPER-VALUE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-STRING-WRAPPER-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF STRING-WRAPPER) STREAM)
  (CL:LET* ((VALUE (%WRAPPER-VALUE SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
   (CL:IF (CL:EQ VALUE STELLA::NULL-STRING)
    (CL:IF *PRINTREADABLY?*
     (%%PRINT-STREAM STREAM SYM-HIERARCHY-STELLA-NULL-STRING)
     (%%PRINT-STREAM STREAM "|L|NULL-STRING"))
    (CL:IF *PRINTREADABLY?* (PRINT-STRING-READABLY VALUE STREAM)
     (%%PRINT-STREAM STREAM "|L|\"" VALUE "\""))))
  :VOID)

;;; (DEFCLASS MUTABLE-STRING-WRAPPER ...)

(CL:DEFCLASS MUTABLE-STRING-WRAPPER (LITERAL-WRAPPER)
  ((WRAPPER-VALUE :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %WRAPPER-VALUE)))

(CL:DEFUN NEW-MUTABLE-STRING-WRAPPER (WRAPPER-VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING WRAPPER-VALUE))
  #+MCL
  (CL:CHECK-TYPE WRAPPER-VALUE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE MUTABLE-STRING-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-MUTABLE-STRING-WRAPPER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF MUTABLE-STRING-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-MUTABLE-STRING-WRAPPER))

(CL:DEFMETHOD PRINT-OBJECT ((SELF MUTABLE-STRING-WRAPPER) STREAM)
  (CL:LET* ((VALUE (%WRAPPER-VALUE SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING VALUE))
   (CL:IF (NULL? VALUE)
    (CL:IF *PRINTREADABLY?*
     (%%PRINT-STREAM STREAM SYM-HIERARCHY-STELLA-NULL-MUTABLE-STRING)
     (%%PRINT-STREAM STREAM "|L|NULL-MUTABLE-STRING"))
    (CL:IF *PRINTREADABLY?*
     (PRINT-STRING-READABLY
      (CL:LET ((S VALUE)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
       (CL:THE CL:SIMPLE-STRING S))
      STREAM)
     (%%PRINT-STREAM STREAM "|L|\""
      (CL:LET ((S VALUE)) (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING S))
       (CL:THE CL:SIMPLE-STRING S))
      "\""))))
  :VOID)

;;; (DEFCLASS CHARACTER-WRAPPER ...)

(CL:DEFCLASS CHARACTER-WRAPPER (LITERAL-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR %WRAPPER-VALUE)))

(CL:DEFUN NEW-CHARACTER-WRAPPER (WRAPPER-VALUE)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CHARACTER-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-CHARACTER-WRAPPER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CHARACTER-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-CHARACTER-WRAPPER))

(CL:DEFUN ACCESS-CHARACTER-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-WRAPPER-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%WRAPPER-VALUE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-CHARACTER (%WRAPPER-VALUE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-CHARACTER-WRAPPER-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF CHARACTER-WRAPPER) STREAM)
  (CL:LET* ((VALUE (%WRAPPER-VALUE SELF)))
   (CL:IF (NULL? VALUE)
    (CL:IF *PRINTREADABLY?*
     (%%PRINT-STREAM STREAM SYM-HIERARCHY-STELLA-NULL-CHARACTER)
     (%%PRINT-STREAM STREAM "|L|NULL-CHARACTER"))
    (CL:PROGN
     (CL:WHEN (CL:NOT *PRINTREADABLY?*) (%%PRINT-STREAM STREAM "|L|"))
     (PRINT-CHARACTER VALUE STREAM))))
  :VOID)

;;; (DEFCLASS BOOLEAN-WRAPPER ...)

(CL:DEFCLASS BOOLEAN-WRAPPER (LITERAL-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR %WRAPPER-VALUE))
  (:DOCUMENTATION
   "Objectified version of the BOOLEAN data type.  The NULL
value can be used for a 3-valued semantics (see THREE-VALUED-BOOLEAN)."))

(CL:DEFUN NEW-BOOLEAN-WRAPPER (WRAPPER-VALUE)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE BOOLEAN-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-BOOLEAN-WRAPPER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF BOOLEAN-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-BOOLEAN-WRAPPER))

(CL:DEFUN ACCESS-BOOLEAN-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-WRAPPER-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%WRAPPER-VALUE SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%WRAPPER-VALUE SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-BOOLEAN-WRAPPER-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF BOOLEAN-WRAPPER) STREAM)
  (CL:PROGN
   (CL:WHEN (CL:NOT *PRINTREADABLY?*) (%%PRINT-STREAM STREAM "|L|"))
   (CL:IF (%WRAPPER-VALUE SELF)
    (%%PRINT-STREAM STREAM SYM-HIERARCHY-STELLA-TRUE)
    (%%PRINT-STREAM STREAM SYM-HIERARCHY-STELLA-FALSE)))
  :VOID)

;;; (DEFCLASS CODE-WRAPPER ...)

(CL:DEFCLASS CODE-WRAPPER (WRAPPER)
  ())

;;; (DEFCLASS FUNCTION-CODE-WRAPPER ...)

(CL:DEFCLASS FUNCTION-CODE-WRAPPER (CODE-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR %WRAPPER-VALUE)))

(CL:DEFUN NEW-FUNCTION-CODE-WRAPPER (WRAPPER-VALUE)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FUNCTION-CODE-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-FUNCTION-CODE-WRAPPER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FUNCTION-CODE-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-FUNCTION-CODE-WRAPPER))

(CL:DEFUN ACCESS-FUNCTION-CODE-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-WRAPPER-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%WRAPPER-VALUE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FUNCTION-CODE (%WRAPPER-VALUE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-FUNCTION-CODE-WRAPPER-SLOT-VALUE VALUE))

;;; (DEFCLASS METHOD-CODE-WRAPPER ...)

(CL:DEFCLASS METHOD-CODE-WRAPPER (CODE-WRAPPER)
  ((WRAPPER-VALUE :ALLOCATION :INSTANCE :ACCESSOR %WRAPPER-VALUE)))

(CL:DEFUN NEW-METHOD-CODE-WRAPPER (WRAPPER-VALUE)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE METHOD-CODE-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-METHOD-CODE-WRAPPER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF METHOD-CODE-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-METHOD-CODE-WRAPPER))

(CL:DEFUN ACCESS-METHOD-CODE-WRAPPER-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-WRAPPER-VALUE)
    (CL:IF SETVALUE?
     (CL:SETF (%WRAPPER-VALUE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-METHOD-CODE (%WRAPPER-VALUE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-METHOD-CODE-WRAPPER-SLOT-VALUE VALUE))

;;; (DEFCLASS VERBATIM-STRING-WRAPPER ...)

(CL:DEFCLASS VERBATIM-STRING-WRAPPER (STRING-WRAPPER)
  ()
  (:DOCUMENTATION
   "Wrapper class used to hold verbatim native code strings."))

(CL:DEFUN NEW-VERBATIM-STRING-WRAPPER (WRAPPER-VALUE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING WRAPPER-VALUE))
  #+MCL
  (CL:CHECK-TYPE WRAPPER-VALUE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE VERBATIM-STRING-WRAPPER)))
   (CL:SETF (%WRAPPER-VALUE SELF) WRAPPER-VALUE)
   (CL:RETURN-FROM NEW-VERBATIM-STRING-WRAPPER SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF VERBATIM-STRING-WRAPPER))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-VERBATIM-STRING-WRAPPER))

(CL:DEFMETHOD PRINT-OBJECT ((SELF VERBATIM-STRING-WRAPPER) STREAM)
  (%%PRINT-STREAM STREAM (CL:IF *PRINTREADABLY?* "" "|V|")
   (%WRAPPER-VALUE SELF))
  :VOID)

;;; (DEFCLASS LISP-CODE ...)

(CL:DEFCLASS LISP-CODE (CLSYS-ROOT-OBJECT)
  ()
  (:DOCUMENTATION
   "Used to indicate variables that input or output Common Lisp~
      structures."))

;;; (DEFCLASS SYSTEM-DEFINITION ...)

(CL:DEFCLASS SYSTEM-DEFINITION (STANDARD-OBJECT)
  ((NAME :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %NAME)
   (DIRECTORY :ALLOCATION :INSTANCE :ACCESSOR %DIRECTORY)
   (FILES :ALLOCATION :INSTANCE :ACCESSOR %FILES)
   (LISP-ONLY-FILES :ALLOCATION :INSTANCE :ACCESSOR %LISP-ONLY-FILES)
   (CPP-ONLY-FILES :ALLOCATION :INSTANCE :ACCESSOR %CPP-ONLY-FILES)
   (JAVA-ONLY-FILES :ALLOCATION :INSTANCE :ACCESSOR %JAVA-ONLY-FILES)
   (DATA-FILES :ALLOCATION :INSTANCE :ACCESSOR %DATA-FILES)
   (PREPROCESSED-FILES :ALLOCATION :INSTANCE :ACCESSOR
    %PREPROCESSED-FILES)
   (REQUIRED-SYSTEMS :ALLOCATION :INSTANCE :ACCESSOR %REQUIRED-SYSTEMS)
   (LOADED? :ALLOCATION :INSTANCE :ACCESSOR %LOADED?)
   (UP-TO-DATE? :ALLOCATION :INSTANCE :ACCESSOR %UP-TO-DATE?)
   (CARDINAL-MODULE :TYPE CL:SIMPLE-STRING :INITFORM
    STELLA::NULL-STRING :ALLOCATION :INSTANCE :ACCESSOR
    %CARDINAL-MODULE)
   (SOURCE-ROOT-DIRECTORY :ALLOCATION :INSTANCE :ACCESSOR
    %SOURCE-ROOT-DIRECTORY)
   (NATIVE-ROOT-DIRECTORY :ALLOCATION :INSTANCE :ACCESSOR
    %NATIVE-ROOT-DIRECTORY)
   (BINARY-ROOT-DIRECTORY :ALLOCATION :INSTANCE :ACCESSOR
    %BINARY-ROOT-DIRECTORY)
   (BANNER :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %BANNER)
   (PRODUCTION-SETTINGS :ALLOCATION :INSTANCE :ACCESSOR
    %PRODUCTION-SETTINGS)
   (DEVELOPMENT-SETTINGS :ALLOCATION :INSTANCE :ACCESSOR
    %DEVELOPMENT-SETTINGS)
   (FINALIZATION-FUNCTION :ALLOCATION :INSTANCE :ACCESSOR
    %FINALIZATION-FUNCTION))
  (:DOCUMENTATION
   "The System-Definition class is used to define systems of files
that constitute Stella applications."))

(CL:DEFUN NEW-SYSTEM-DEFINITION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SYSTEM-DEFINITION)))
   (CL:SETF (%FINALIZATION-FUNCTION SELF) NULL)
   (CL:SETF (%DEVELOPMENT-SETTINGS SELF) NULL)
   (CL:SETF (%PRODUCTION-SETTINGS SELF) NULL)
   (CL:SETF (%BANNER SELF) STELLA::NULL-STRING)
   (CL:SETF (%BINARY-ROOT-DIRECTORY SELF) STELLA::NULL-STRING)
   (CL:SETF (%NATIVE-ROOT-DIRECTORY SELF) STELLA::NULL-STRING)
   (CL:SETF (%SOURCE-ROOT-DIRECTORY SELF) STELLA::NULL-STRING)
   (CL:SETF (%CARDINAL-MODULE SELF) STELLA::NULL-STRING)
   (CL:SETF (%UP-TO-DATE? SELF) CL:NIL)
   (CL:SETF (%LOADED? SELF) CL:NIL)
   (CL:SETF (%REQUIRED-SYSTEMS SELF) NULL)
   (CL:SETF (%PREPROCESSED-FILES SELF) NULL)
   (CL:SETF (%DATA-FILES SELF) NULL)
   (CL:SETF (%JAVA-ONLY-FILES SELF) NULL)
   (CL:SETF (%CPP-ONLY-FILES SELF) NULL)
   (CL:SETF (%LISP-ONLY-FILES SELF) NULL) (CL:SETF (%FILES SELF) NULL)
   (CL:SETF (%DIRECTORY SELF) STELLA::NULL-STRING)
   (CL:SETF (%NAME SELF) STELLA::NULL-STRING)
   (CL:RETURN-FROM NEW-SYSTEM-DEFINITION SELF)))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SYSTEM-DEFINITION))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-SYSTEM-DEFINITION))

(CL:DEFUN ACCESS-SYSTEM-DEFINITION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-NAME)
    (CL:IF SETVALUE? (CL:SETF (%NAME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%NAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DIRECTORY)
    (CL:IF SETVALUE? (CL:SETF (%DIRECTORY SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%DIRECTORY SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-FILES)
    (CL:IF SETVALUE? (CL:SETF (%FILES SELF) VALUE)
     (CL:SETQ VALUE (%FILES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-LISP-ONLY-FILES)
    (CL:IF SETVALUE? (CL:SETF (%LISP-ONLY-FILES SELF) VALUE)
     (CL:SETQ VALUE (%LISP-ONLY-FILES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CPP-ONLY-FILES)
    (CL:IF SETVALUE? (CL:SETF (%CPP-ONLY-FILES SELF) VALUE)
     (CL:SETQ VALUE (%CPP-ONLY-FILES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-JAVA-ONLY-FILES)
    (CL:IF SETVALUE? (CL:SETF (%JAVA-ONLY-FILES SELF) VALUE)
     (CL:SETQ VALUE (%JAVA-ONLY-FILES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DATA-FILES)
    (CL:IF SETVALUE? (CL:SETF (%DATA-FILES SELF) VALUE)
     (CL:SETQ VALUE (%DATA-FILES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PREPROCESSED-FILES)
    (CL:IF SETVALUE? (CL:SETF (%PREPROCESSED-FILES SELF) VALUE)
     (CL:SETQ VALUE (%PREPROCESSED-FILES SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-REQUIRED-SYSTEMS)
    (CL:IF SETVALUE? (CL:SETF (%REQUIRED-SYSTEMS SELF) VALUE)
     (CL:SETQ VALUE (%REQUIRED-SYSTEMS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-LOADED?)
    (CL:IF SETVALUE?
     (CL:SETF (%LOADED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%LOADED? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-UP-TO-DATE?)
    (CL:IF SETVALUE?
     (CL:SETF (%UP-TO-DATE? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%UP-TO-DATE? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-CARDINAL-MODULE)
    (CL:IF SETVALUE?
     (CL:SETF (%CARDINAL-MODULE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%CARDINAL-MODULE SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-SOURCE-ROOT-DIRECTORY)
    (CL:IF SETVALUE?
     (CL:SETF (%SOURCE-ROOT-DIRECTORY SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%SOURCE-ROOT-DIRECTORY SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-NATIVE-ROOT-DIRECTORY)
    (CL:IF SETVALUE?
     (CL:SETF (%NATIVE-ROOT-DIRECTORY SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%NATIVE-ROOT-DIRECTORY SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-BINARY-ROOT-DIRECTORY)
    (CL:IF SETVALUE?
     (CL:SETF (%BINARY-ROOT-DIRECTORY SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%BINARY-ROOT-DIRECTORY SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-BANNER)
    (CL:IF SETVALUE? (CL:SETF (%BANNER SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%BANNER SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-COPYRIGHT-HEADER)
    (CL:IF SETVALUE? (CL:SETF (%BANNER SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%BANNER SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-PRODUCTION-SETTINGS)
    (CL:IF SETVALUE? (CL:SETF (%PRODUCTION-SETTINGS SELF) VALUE)
     (CL:SETQ VALUE (%PRODUCTION-SETTINGS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-DEVELOPMENT-SETTINGS)
    (CL:IF SETVALUE? (CL:SETF (%DEVELOPMENT-SETTINGS SELF) VALUE)
     (CL:SETQ VALUE (%DEVELOPMENT-SETTINGS SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-FINALIZATION-FUNCTION)
    (CL:IF SETVALUE? (CL:SETF (%FINALIZATION-FUNCTION SELF) VALUE)
     (CL:SETQ VALUE (%FINALIZATION-FUNCTION SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-SYSTEM-DEFINITION-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF SYSTEM-DEFINITION) STREAM)
  (%%PRINT-STREAM STREAM "|SYSTEM|" (%NAME SELF))
  :VOID)

;;; (DEFCLASS STREAM ...)

(CL:DEFCLASS STREAM (STANDARD-OBJECT)
  ((STATE :ALLOCATION :INSTANCE :ACCESSOR %STATE)))

(CL:DEFUN ACCESS-STREAM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-STATE)
    (CL:IF SETVALUE? (CL:SETF (%STATE SELF) VALUE)
     (CL:SETQ VALUE (%STATE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-STREAM-SLOT-VALUE VALUE))

;;; (DEFCLASS OUTPUT-STREAM ...)

(CL:DEFCLASS OUTPUT-STREAM (STREAM)
  ((NATIVE-STREAM :ALLOCATION :INSTANCE :ACCESSOR %NATIVE-STREAM)))

(CL:DEFUN NEW-OUTPUT-STREAM ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE OUTPUT-STREAM)))
   (CL:SETF (%STATE SELF) NULL) (CL:SETF (%NATIVE-STREAM SELF) NULL)
   (CL:RETURN-FROM NEW-OUTPUT-STREAM SELF)))

(CL:DEFMETHOD FREE ((SELF OUTPUT-STREAM))
  (CL:WHEN (TERMINATE-OUTPUT-STREAM? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF OUTPUT-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-OUTPUT-STREAM))

;;; (DEFCLASS INPUT-STREAM ...)

(CL:DEFCLASS INPUT-STREAM (STREAM)
  ((NATIVE-STREAM :ALLOCATION :INSTANCE :ACCESSOR %NATIVE-STREAM)
   (ECHO-STREAM :ALLOCATION :INSTANCE :ACCESSOR %ECHO-STREAM)
   (TOKENIZER-STATE :ALLOCATION :INSTANCE :ACCESSOR %TOKENIZER-STATE)
   (BUFFERING-SCHEME :DOCUMENTATION
    "One of :CHARACTER, :LINE or :BLOCK indicating what kind of
input buffer we are reading from.  This determines what read function to use
for tokenization." :ALLOCATION :INSTANCE :ACCESSOR %BUFFERING-SCHEME)))

(CL:DEFUN NEW-INPUT-STREAM ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INPUT-STREAM)))
   (CL:SETF (%STATE SELF) NULL)
   (CL:SETF (%BUFFERING-SCHEME SELF) KWD-HIERARCHY-LINE)
   (CL:SETF (%TOKENIZER-STATE SELF) NULL)
   (CL:SETF (%ECHO-STREAM SELF) NULL)
   (CL:SETF (%NATIVE-STREAM SELF) NULL)
   (CL:RETURN-FROM NEW-INPUT-STREAM SELF)))

(CL:DEFMETHOD FREE ((SELF INPUT-STREAM))
  (CL:WHEN (TERMINATE-INPUT-STREAM? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INPUT-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-INPUT-STREAM))

(CL:DEFUN ACCESS-INPUT-STREAM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-ECHO-STREAM)
    (CL:IF SETVALUE? (CL:SETF (%ECHO-STREAM SELF) VALUE)
     (CL:SETQ VALUE (%ECHO-STREAM SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-TOKENIZER-STATE)
    (CL:IF SETVALUE? (CL:SETF (%TOKENIZER-STATE SELF) VALUE)
     (CL:SETQ VALUE (%TOKENIZER-STATE SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-BUFFERING-SCHEME)
    (CL:IF SETVALUE? (CL:SETF (%BUFFERING-SCHEME SELF) VALUE)
     (CL:SETQ VALUE (%BUFFERING-SCHEME SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-INPUT-STREAM-SLOT-VALUE VALUE))

;;; (DEFCLASS OUTPUT-FILE-STREAM ...)

(CL:DEFCLASS OUTPUT-FILE-STREAM (OUTPUT-STREAM)
  ((FILENAME :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %FILENAME)
   (IF-EXISTS-ACTION :ALLOCATION :INSTANCE :ACCESSOR %IF-EXISTS-ACTION)
   (IF-NOT-EXISTS-ACTION :ALLOCATION :INSTANCE :ACCESSOR
    %IF-NOT-EXISTS-ACTION)))

(CL:DEFUN NEW-OUTPUT-FILE-STREAM (FILENAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE OUTPUT-FILE-STREAM)))
   (CL:SETF (%FILENAME SELF) FILENAME) (CL:SETF (%STATE SELF) NULL)
   (CL:SETF (%NATIVE-STREAM SELF) NULL)
   (CL:SETF (%IF-NOT-EXISTS-ACTION SELF) KWD-HIERARCHY-CREATE)
   (CL:SETF (%IF-EXISTS-ACTION SELF) KWD-HIERARCHY-SUPERSEDE)
   (INITIALIZE-FILE-OUTPUT-STREAM SELF)
   (CL:RETURN-FROM NEW-OUTPUT-FILE-STREAM SELF)))

(CL:DEFMETHOD FREE ((SELF OUTPUT-FILE-STREAM))
  (CL:WHEN (TERMINATE-FILE-OUTPUT-STREAM? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF OUTPUT-FILE-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-OUTPUT-FILE-STREAM))

(CL:DEFUN ACCESS-OUTPUT-FILE-STREAM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-FILENAME)
    (CL:IF SETVALUE? (CL:SETF (%FILENAME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%FILENAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-IF-EXISTS-ACTION)
    (CL:IF SETVALUE? (CL:SETF (%IF-EXISTS-ACTION SELF) VALUE)
     (CL:SETQ VALUE (%IF-EXISTS-ACTION SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-IF-NOT-EXISTS-ACTION)
    (CL:IF SETVALUE? (CL:SETF (%IF-NOT-EXISTS-ACTION SELF) VALUE)
     (CL:SETQ VALUE (%IF-NOT-EXISTS-ACTION SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-OUTPUT-FILE-STREAM-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF OUTPUT-FILE-STREAM) STREAM)
  (%%PRINT-STREAM STREAM "|FOS|'" (%FILENAME SELF) "'")
  :VOID)

;;; (DEFCLASS INPUT-FILE-STREAM ...)

(CL:DEFCLASS INPUT-FILE-STREAM (INPUT-STREAM)
  ((FILENAME :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %FILENAME)
   (IF-NOT-EXISTS-ACTION :ALLOCATION :INSTANCE :ACCESSOR
    %IF-NOT-EXISTS-ACTION)))

(CL:DEFUN NEW-INPUT-FILE-STREAM (FILENAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILENAME))
  #+MCL
  (CL:CHECK-TYPE FILENAME CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INPUT-FILE-STREAM)))
   (CL:SETF (%FILENAME SELF) FILENAME) (CL:SETF (%STATE SELF) NULL)
   (CL:SETF (%TOKENIZER-STATE SELF) NULL)
   (CL:SETF (%ECHO-STREAM SELF) NULL)
   (CL:SETF (%NATIVE-STREAM SELF) NULL)
   (CL:SETF (%BUFFERING-SCHEME SELF) KWD-HIERARCHY-BLOCK)
   (CL:SETF (%IF-NOT-EXISTS-ACTION SELF) KWD-HIERARCHY-ERROR)
   (INITIALIZE-FILE-INPUT-STREAM SELF)
   (CL:RETURN-FROM NEW-INPUT-FILE-STREAM SELF)))

(CL:DEFMETHOD FREE ((SELF INPUT-FILE-STREAM))
  (CL:WHEN (TERMINATE-FILE-INPUT-STREAM? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INPUT-FILE-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-INPUT-FILE-STREAM))

(CL:DEFUN ACCESS-INPUT-FILE-STREAM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-FILENAME)
    (CL:IF SETVALUE? (CL:SETF (%FILENAME SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%FILENAME SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-IF-NOT-EXISTS-ACTION)
    (CL:IF SETVALUE? (CL:SETF (%IF-NOT-EXISTS-ACTION SELF) VALUE)
     (CL:SETQ VALUE (%IF-NOT-EXISTS-ACTION SELF))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-BUFFERING-SCHEME)
    (CL:IF SETVALUE? (CL:SETF (%BUFFERING-SCHEME SELF) VALUE)
     (CL:SETQ VALUE (%BUFFERING-SCHEME SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-INPUT-FILE-STREAM-SLOT-VALUE VALUE))

(CL:DEFMETHOD PRINT-OBJECT ((SELF INPUT-FILE-STREAM) STREAM)
  (%%PRINT-STREAM STREAM "|FIS|'" (%FILENAME SELF) "'")
  :VOID)

;;; (DEFCLASS OUTPUT-STRING-STREAM ...)

(CL:DEFCLASS OUTPUT-STRING-STREAM (OUTPUT-STREAM)
  ((THE-STRING :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %THE-STRING)))

(CL:DEFUN NEW-OUTPUT-STRING-STREAM ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE OUTPUT-STRING-STREAM)))
   (CL:SETF (%STATE SELF) NULL) (CL:SETF (%NATIVE-STREAM SELF) NULL)
   (CL:SETF (%THE-STRING SELF) STELLA::NULL-STRING)
   (INITIALIZE-STRING-OUTPUT-STREAM SELF)
   (CL:RETURN-FROM NEW-OUTPUT-STRING-STREAM SELF)))

(CL:DEFMETHOD FREE ((SELF OUTPUT-STRING-STREAM))
  (CL:WHEN (TERMINATE-STRING-OUTPUT-STREAM? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF OUTPUT-STRING-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE
   SGT-HIERARCHY-STELLA-OUTPUT-STRING-STREAM))

(CL:DEFUN ACCESS-OUTPUT-STRING-STREAM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-THE-STRING)
    (CL:IF SETVALUE?
     (CL:SETF (%THE-STRING SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (THE-STRING-READER SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-OUTPUT-STRING-STREAM-SLOT-VALUE VALUE))

;;; (DEFCLASS INPUT-STRING-STREAM ...)

(CL:DEFCLASS INPUT-STRING-STREAM (INPUT-STREAM)
  ((THE-STRING :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %THE-STRING)))

(CL:DEFUN NEW-INPUT-STRING-STREAM (THE-STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING THE-STRING))
  #+MCL
  (CL:CHECK-TYPE THE-STRING CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE INPUT-STRING-STREAM)))
   (CL:SETF (%THE-STRING SELF) THE-STRING) (CL:SETF (%STATE SELF) NULL)
   (CL:SETF (%TOKENIZER-STATE SELF) NULL)
   (CL:SETF (%ECHO-STREAM SELF) NULL)
   (CL:SETF (%NATIVE-STREAM SELF) NULL)
   (CL:SETF (%BUFFERING-SCHEME SELF) KWD-HIERARCHY-BLOCK)
   (INITIALIZE-STRING-INPUT-STREAM SELF)
   (CL:RETURN-FROM NEW-INPUT-STRING-STREAM SELF)))

(CL:DEFMETHOD FREE ((SELF INPUT-STRING-STREAM))
  (CL:WHEN (TERMINATE-STRING-INPUT-STREAM? SELF) (UNMAKE SELF))
  :VOID)

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INPUT-STRING-STREAM))
  (CL:RETURN-FROM PRIMARY-TYPE SGT-HIERARCHY-STELLA-INPUT-STRING-STREAM))

(CL:DEFUN ACCESS-INPUT-STRING-STREAM-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-THE-STRING)
    (CL:IF SETVALUE?
     (CL:SETF (%THE-STRING SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%THE-STRING SELF)))))
   ((CL:EQ SLOTNAME SYM-HIERARCHY-STELLA-BUFFERING-SCHEME)
    (CL:IF SETVALUE? (CL:SETF (%BUFFERING-SCHEME SELF) VALUE)
     (CL:SETQ VALUE (%BUFFERING-SCHEME SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  (CL:RETURN-FROM ACCESS-INPUT-STRING-STREAM-SLOT-VALUE VALUE))

(CL:DEFUN HELP-STARTUP-HIERARCHY1 ()
  (CL:PROGN
   (CL:SETQ SYM-HIERARCHY-STELLA-TYPE-SPEC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE-SPEC" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-REFERENCE-COUNT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCE-COUNT" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-BAD?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BAD?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DELETED-OBJECT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DELETED-OBJECT?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-FIRST-ITERATION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST-ITERATION?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-OBJECT-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-ITERATOR" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-CONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS-ITERATOR" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-CONS-ITERATOR-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS-ITERATOR-CURSOR" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-LIST-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-ITERATOR" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-LIST-ITERATOR-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-ITERATOR-CURSOR" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-LIST-ITERATOR-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-ITERATOR-COLLECTION" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-DESTRUCTIVE-LIST-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESTRUCTIVE-LIST-ITERATOR" NULL
     1))
   (CL:SETQ SYM-HIERARCHY-STELLA-THE-CONS-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CONS-LIST" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-ALL-PURPOSE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-PURPOSE-ITERATOR" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ITERATOR-NEXT-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-NEXT-CODE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ITERATOR-FILTER-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-FILTER-CODE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ITERATOR-EMPTY-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-EMPTY-CODE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ITERATOR-NESTED-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-NESTED-ITERATOR" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ITERATOR-CONS-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-CONS-LIST" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ITERATOR-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-OBJECT" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ITERATOR-SECOND-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-SECOND-OBJECT" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ITERATOR-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-INTEGER" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ITERATOR-SECOND-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-SECOND-INTEGER" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-TYPES-TO-CLASSES-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPES-TO-CLASSES-ITERATOR" NULL
     1))
   (CL:SETQ SYM-HIERARCHY-STELLA-ITERATOR-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR-CURSOR" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-OBJECT-DICTIONARY-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-DICTIONARY-ITERATOR" NULL
     0))
   (CL:SETQ SGT-HIERARCHY-STELLA-PROPERTY-LIST-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY-LIST-ITERATOR" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-PLIST-ITERATOR-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PLIST-ITERATOR-CURSOR" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-PLIST-ITERATOR-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PLIST-ITERATOR-COLLECTION" NULL
     0))
   (CL:SETQ SGT-HIERARCHY-STELLA-KV-LIST-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KV-LIST-ITERATOR" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-THE-KV-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-KV-LIST" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-KV-LIST-ITERATOR-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KV-LIST-ITERATOR-CURSOR" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-INTEGER-INTERVAL-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-INTERVAL-ITERATOR" NULL
     1))
   (CL:SETQ SYM-HIERARCHY-STELLA-INTERVAL-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL-CURSOR" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-LOWER-BOUND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOWER-BOUND" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-UPPER-BOUND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPPER-BOUND" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-REVERSE-INTEGER-INTERVAL-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE-INTEGER-INTERVAL-ITERATOR"
     NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-STRING-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-ITERATOR" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-THE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-STRING" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURSOR" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-END
    (INTERN-RIGID-SYMBOL-WRT-MODULE "END" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-OBJECT-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-COLLECTION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-OBJECT-SEQUENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-SEQUENCE" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-CLASS-EXTENSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-EXTENSION" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-REST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REST" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-OBJECT-TO-OBJECT-DICTIONARY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-TO-OBJECT-DICTIONARY" NULL
     0))
   (CL:SETQ SGT-HIERARCHY-STELLA-PROPERTY-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTY-LIST" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-THE-PLIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-PLIST" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-KV-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KV-CONS" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-KEY-VALUE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-RECYCLE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RECYCLE-LIST" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-RECYCLE-LIST-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RECYCLE-LIST-OF" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-RECYCLED-ITEMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RECYCLED-ITEMS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-LIST-OF-RECYCLED-ITEMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-OF-RECYCLED-ITEMS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ALL-ITEMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-ITEMS" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-HIERARCHY2 ()
  (CL:PROGN
   (CL:SETQ SYM-HIERARCHY-STELLA-UNUSED-ITEMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNUSED-ITEMS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CURRENT-LENGTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT-LENGTH" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ITEM-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITEM-SIZE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-THE-STELLA-HASH-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-STELLA-HASH-TABLE" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-HASH-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HASH-TABLE" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-OBJECT-TO-OBJECT-HASH-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-TO-OBJECT-HASH-TABLE" NULL
     0))
   (CL:SETQ SGT-HIERARCHY-STELLA-INTEGER-HASH-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-HASH-TABLE" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-FLOAT-HASH-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-HASH-TABLE" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-STRING-HASH-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-HASH-TABLE" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-STRING-TO-INTEGER-HASH-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-TO-INTEGER-HASH-TABLE" NULL
     1))
   (CL:SETQ SGT-HIERARCHY-STELLA-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-ARRAY-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARRAY-SIZE" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-EXTENSIBLE-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIBLE-VECTOR" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-EXTENSIBLE-SYMBOL-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIBLE-SYMBOL-ARRAY" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-TOP-SYMBOL-OFFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOP-SYMBOL-OFFSET" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-POTENTIAL-FREE-SYMBOL-OFFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POTENTIAL-FREE-SYMBOL-OFFSET" NULL
     0))
   (CL:SETQ SGT-HIERARCHY-STELLA-VECTOR-SEQUENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR-SEQUENCE" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-SEQUENCE-LENGTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SEQUENCE-LENGTH" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-CUSTOM-VECTOR-SEQUENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CUSTOM-VECTOR-SEQUENCE" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-RESIZE-FACTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RESIZE-FACTOR" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-BOOLEAN-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-VECTOR" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-INTEGER-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-VECTOR" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-ACTIVE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-LIST" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-ACTIVE-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-SET" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-DEMON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEMON-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-NAME" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEMON-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-ACTION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEMON-CLASS-REFS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-CLASS-REFS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEMON-SLOT-REFS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-SLOT-REFS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEMON-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-CODE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEMON-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-METHOD" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEMON-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-DOCUMENTATION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEMON-GUARD?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-GUARD?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEMON-ALL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-ALL?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEMON-INHERIT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEMON-INHERIT?" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-KEYWORD-KEY-VALUE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD-KEY-VALUE-LIST" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-SYMBOL-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-NAME" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SYMBOL-ID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-ID" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-INTERNED-IN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERNED-IN" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-SYMBOL-SLOT-OFFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-SLOT-OFFSET" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SYMBOL-VALUE-AND-PLIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-VALUE-AND-PLIST" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-SURROGATE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SURROGATE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-NAME" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-TYPE-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE-CLASS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-TYPE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE-NAME" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOTREF-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF-SLOT" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOTREF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOTREF" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-KEYWORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-KEYWORD-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEYWORD-NAME" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-TRANSIENT-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSIENT-SYMBOL" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-PROJECTS-ONTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROJECTS-ONTO" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-PROJECTED-FROM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROJECTED-FROM" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-PROPERTIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ABSTRACT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT?" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-STORED-ACTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORED-ACTIVE?" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-ACTIVE-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACTIVE-OBJECT" NULL 1)))
  :VOID)

(CL:DEFUN HELP-STARTUP-HIERARCHY3 ()
  (CL:PROGN
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-CREATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CREATOR" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-INITIALIZER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-INITIALIZER" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-TERMINATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-TERMINATOR" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-DESTRUCTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DESTRUCTOR" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-PARAMETERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-PARAMETERS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-INITIAL-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-INITIAL-VALUE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-EXTENSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-EXTENSION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-CL-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-NATIVE-TYPE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-CPP-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CPP-NATIVE-TYPE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-JAVA-NATIVE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-JAVA-NATIVE-TYPE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-CL-STRUCT-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-STRUCT-SLOTS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-RECYCLE-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-RECYCLE-METHOD" NULL 0))
   (CL:SETQ KWD-HIERARCHY-NONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-REQUIRED-SLOT-NAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-REQUIRED-SLOT-NAMES" NULL
     0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-GUARD-CONSTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-GUARD-CONSTRUCTOR-DEMONS"
     NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-CONSTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CONSTRUCTOR-DEMONS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-GUARD-DESTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-GUARD-DESTRUCTOR-DEMONS"
     NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-DESTRUCTOR-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DESTRUCTOR-DEMONS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-KEY" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-SYNONYMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-SYNONYMS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CL-STRUCT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CL-STRUCT?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-MIXIN?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MIXIN?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-TYPE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-ARITY" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-DIRECT-SUPERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DIRECT-SUPERS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-DIRECT-SUBS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DIRECT-SUBS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-ALL-SUPER-CLASSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-ALL-SUPER-CLASSES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-ALL-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-ALL-SLOTS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-LOCAL-SLOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-LOCAL-SLOTS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-SLOT-AND-METHOD-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-SLOT-AND-METHOD-CACHE" NULL
     0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-ABSTRACT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-ABSTRACT?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-MIXIN?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-MIXIN?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-COLLECTION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-COLLECTION?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-CL-STRUCT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CL-STRUCT?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-PUBLIC?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-FINALIZED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-FINALIZED?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-SLOTS-FINALIZED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-SLOTS-FINALIZED?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-STRINGIFIED-SOURCE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-CONSTRUCTOR-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-CONSTRUCTOR-CODE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-SLOT-ACCESSOR-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-SLOT-ACCESSOR-CODE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-MARKED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-MARKED?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-TAXONOMY-NODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-TAXONOMY-NODE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-DOCUMENTATION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLASS-PRINT-FORM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-PRINT-FORM" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-PRINT-FORM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-FORM" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-DIRECT-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DIRECT-EQUIVALENT" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-TYPE-SPECIFIER" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-HOME-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-HOME-MODULE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-RENAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-RENAMES" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-CLOSURE-ASSUMPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-CLOSURE-ASSUMPTION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-DIRECT-SUPERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DIRECT-SUPERS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-DIRECT-SUBS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DIRECT-SUBS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-NAME" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-OWNER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-OWNER" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-BASE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-BASE-TYPE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-SLOTREF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-SLOTREF" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-PUBLIC?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-RENAMED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-RENAMED?" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-HIERARCHY4 ()
  (CL:PROGN
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-EXTERNAL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-EXTERNAL?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-MARKED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-MARKED?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DOCUMENTATION" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-ALLOCATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-ALLOCATION" NULL 0))
   (CL:SETQ KWD-HIERARCHY-INSTANCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INSTANCE" NULL 2))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-DEFAULT-EXPRESSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DEFAULT-EXPRESSION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-READER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-READER" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-WRITER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-WRITER" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-GUARD-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-GUARD-DEMONS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-DEMONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DEMONS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-REQUIRED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-REQUIRED?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-COMPONENT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-COMPONENT?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-READ-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-READ-ONLY?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-HARDWIRED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-HARDWIRED?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-CONTEXT-SENSITIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-CONTEXT-SENSITIVE?" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-METHOD-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-PARAMETER-DIRECTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-PARAMETER-DIRECTIONS" NULL
     0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-INLINED-FUNCTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-INLINED-FUNCTIONS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-EVALUATE-ARGUMENTS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-EVALUATE-ARGUMENTS?" NULL
     0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-SETTER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SETTER?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-PARAMETER-NAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-PARAMETER-NAMES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-PARAMETER-TYPE-SPECIFIERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-PARAMETER-TYPE-SPECIFIERS"
     NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-RETURN-TYPE-SPECIFIERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-RETURN-TYPE-SPECIFIERS"
     NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STRINGIFIED-SOURCE" NULL
     0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-FUNCTION-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-FUNCTION?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-FUNCTION?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-DOCUMENTATION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-AUXILIARY?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STORAGE-SLOT" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SLOT-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-AUXILIARY?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-PARAMETRIC-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETRIC-TYPE-SPECIFIER" NULL
     1))
   (CL:SETQ SYM-HIERARCHY-STELLA-SPECIFIER-BASE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIFIER-BASE-TYPE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SPECIFIER-PARAMETER-TYPES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIFIER-PARAMETER-TYPES" NULL
     0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SPECIFIER-DIMENSIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIFIER-DIMENSIONS" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-ANCHORED-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANCHORED-TYPE-SPECIFIER" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-SPECIFIER-PARAMETER-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIFIER-PARAMETER-NAME" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TABLE" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-TUPLE-DOMAINS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TUPLE-DOMAINS" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-GLOBAL-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBAL-VARIABLE" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-HOME-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-HOME-MODULE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-NAME" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-SPECIAL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-SPECIAL?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-CONSTANT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-CONSTANT?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-PUBLIC?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-AUXILIARY?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-GET-VALUE-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-GET-VALUE-CODE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-SET-VALUE-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-SET-VALUE-CODE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-VALUE-STACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-VALUE-STACK" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-DOCUMENTATION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-VARIABLE-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-STRINGIFIED-SOURCE" NULL
     0))
   (CL:SETQ SGT-HIERARCHY-STELLA-QUOTED-EXPRESSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTED-EXPRESSION" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-QUOTATION-TABLE-OFFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTATION-TABLE-OFFSET" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SURROGATE-VALUE-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-VALUE-INVERSE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-WORLD-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD-NAME" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE" NULL 1)))
  :VOID)

(CL:DEFUN HELP-STARTUP-HIERARCHY5 ()
  (CL:PROGN
   (CL:SETQ SGT-HIERARCHY-STELLA-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-CHILD-CONTEXTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILD-CONTEXTS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-BASE-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BASE-MODULE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ALL-SUPER-CONTEXTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-SUPER-CONTEXTS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CONTEXT-NUMBER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT-NUMBER" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-MODULE-LISP-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-LISP-PACKAGE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-MODULE-CPP-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-CPP-PACKAGE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SHADOWED-SURROGATES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHADOWED-SURROGATES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-JAVA-PACKAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-PACKAGE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CLEARABLE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEARABLE?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-PROTECT-SURROGATES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROTECT-SURROGATES?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-PARENT-MODULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT-MODULES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-NICKNAMES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NICKNAMES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-USES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-USED-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "USED-BY" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-REQUIRES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REQUIRES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CASE-SENSITIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CASE-SENSITIVE?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-MODULE-FULL-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-FULL-NAME" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-MODULE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-NAME" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-MODULE-STRINGIFIED-SOURCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE-STRINGIFIED-SOURCE" NULL
     0))
   (CL:SETQ SYM-HIERARCHY-STELLA-STRINGIFIED-OPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRINGIFIED-OPTIONS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CARDINAL-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CARDINAL-MODULE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SYMBOL-OFFSET-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL-OFFSET-TABLE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SURROGATE-OFFSET-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE-OFFSET-TABLE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-STRICT-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRICT-INFERENCE-CACHE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEFAULT-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULT-INFERENCE-CACHE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-PROTOTYPE-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROTOTYPE-INFERENCE-CACHE" NULL
     0))
   (CL:SETQ SYM-HIERARCHY-STELLA-PARENT-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT-CONTEXT" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-CS-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-INTERVAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-TAXONOMY-NODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TAXONOMY-NODE" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-NATIVE-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-OBJECT" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-LABEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LABEL" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-INTERVALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVALS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-INITIAL-INTERVAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INITIAL-INTERVAL" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-FIRST-INTERVAL-LOWER-BOUND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST-INTERVAL-LOWER-BOUND" NULL
     0))
   (CL:SETQ SYM-HIERARCHY-STELLA-FIRST-INTERVAL-UPPER-BOUND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST-INTERVAL-UPPER-BOUND" NULL
     0))
   (CL:SETQ SYM-HIERARCHY-STELLA-PARENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENTS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CHILDREN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILDREN" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-TOTAL-ANCESTORS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOTAL-ANCESTORS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-TREE-CHILDREN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TREE-CHILDREN" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-MARKER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MARKER" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-TAXONOMY-GRAPH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TAXONOMY-GRAPH" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-RENUMBER-IF-OUT-OF-NUMBERS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RENUMBER-IF-OUT-OF-NUMBERS?" NULL
     0))
   (CL:SETQ SYM-HIERARCHY-STELLA-RENUMBER-RATIO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RENUMBER-RATIO" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-INCREMENTAL-MODE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCREMENTAL-MODE?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-LARGEST-POSTORDER-NUMBER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LARGEST-POSTORDER-NUMBER" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-NUMBER-OF-NODES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-OF-NODES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-NUMBER-OF-FOREIGN-INTERVAL-NODES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-OF-FOREIGN-INTERVAL-NODES"
     NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ROOTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOTS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-BROKEN-LINKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BROKEN-LINKS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-ADDED-LINKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADDED-LINKS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-REMOVED-LINKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REMOVED-LINKS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-FILE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILE-NAME" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-WRAPPER-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WRAPPER-VALUE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-NULL-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-INTEGER" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-LONG-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LONG-INTEGER-WRAPPER" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-NULL-LONG-INTEGER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-LONG-INTEGER" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-FLOAT-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-WRAPPER" NULL 1)))
  :VOID)

(CL:DEFUN HELP-STARTUP-HIERARCHY6 ()
  (CL:PROGN
   (CL:SETQ SYM-HIERARCHY-STELLA-NULL-FLOAT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-FLOAT" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-NULL-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-STRING" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-MUTABLE-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTABLE-STRING-WRAPPER" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-NULL-MUTABLE-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-MUTABLE-STRING" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-CHARACTER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTER-WRAPPER" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-NULL-CHARACTER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL-CHARACTER" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-BOOLEAN-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN-WRAPPER" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-FUNCTION-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE-WRAPPER" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-METHOD-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE-WRAPPER" NULL 1))
   (CL:SETQ SGT-HIERARCHY-STELLA-VERBATIM-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBATIM-STRING-WRAPPER" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-THREE-VALUED-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THREE-VALUED-BOOLEAN" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-SYSTEM-DEFINITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYSTEM-DEFINITION" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAME" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTORY" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-LISP-ONLY-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-ONLY-FILES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-CPP-ONLY-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CPP-ONLY-FILES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-JAVA-ONLY-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-ONLY-FILES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DATA-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DATA-FILES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-PREPROCESSED-FILES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREPROCESSED-FILES" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-REQUIRED-SYSTEMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REQUIRED-SYSTEMS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-LOADED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOADED?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-UP-TO-DATE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TO-DATE?" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-SOURCE-ROOT-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SOURCE-ROOT-DIRECTORY" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-NATIVE-ROOT-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE-ROOT-DIRECTORY" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-BINARY-ROOT-DIRECTORY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BINARY-ROOT-DIRECTORY" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-BANNER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BANNER" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-COPYRIGHT-HEADER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COPYRIGHT-HEADER" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-PRODUCTION-SETTINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRODUCTION-SETTINGS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-DEVELOPMENT-SETTINGS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEVELOPMENT-SETTINGS" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-FINALIZATION-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZATION-FUNCTION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-STATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STATE" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-OUTPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-STREAM" NULL 1))
   (CL:SETQ KWD-HIERARCHY-LINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LINE" NULL 2))
   (CL:SETQ SGT-HIERARCHY-STELLA-INPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STREAM" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-ECHO-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ECHO-STREAM" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-TOKENIZER-STATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOKENIZER-STATE" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-BUFFERING-SCHEME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BUFFERING-SCHEME" NULL 0))
   (CL:SETQ KWD-HIERARCHY-CREATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATE" NULL 2))
   (CL:SETQ KWD-HIERARCHY-SUPERSEDE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPERSEDE" NULL 2))
   (CL:SETQ SGT-HIERARCHY-STELLA-OUTPUT-FILE-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-FILE-STREAM" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-FILENAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILENAME" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-IF-EXISTS-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-EXISTS-ACTION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-IF-NOT-EXISTS-ACTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF-NOT-EXISTS-ACTION" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-FILE-OUTPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILE-OUTPUT-STREAM" NULL 0))
   (CL:SETQ KWD-HIERARCHY-BLOCK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BLOCK" NULL 2))
   (CL:SETQ KWD-HIERARCHY-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SGT-HIERARCHY-STELLA-INPUT-FILE-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-FILE-STREAM" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-FILE-INPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILE-INPUT-STREAM" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-OUTPUT-STRING-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT-STRING-STREAM" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-STRING-OUTPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-OUTPUT-STREAM" NULL 0))
   (CL:SETQ SGT-HIERARCHY-STELLA-INPUT-STRING-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-STRING-STREAM" NULL 1))
   (CL:SETQ SYM-HIERARCHY-STELLA-STRING-INPUT-STREAM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-INPUT-STREAM" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-STARTUP-HIERARCHY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-HIERARCHY" NULL 0))
   (CL:SETQ SYM-HIERARCHY-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-HIERARCHY7 ()
  (CL:PROGN
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "OBJECT"
    "(DEFCLASS OBJECT () :DOCUMENTATION \"A reflective object that can participate in dynamically-typed
contexts.  Either a STANDARD-OBJECT or a WRAPPER or a GENERIC-OBJECT.
Also, either an OBJECT-WITH-INHERITED-TYPE or an OBJECT-WITH-OWN-TYPE.\" :PUBLIC-METHODS ((PRIMARY-TYPE ((SELF OBJECT)) :TYPE TYPE :DOCUMENTATION \"Returns the primary type of `self'.
Gets defined automatically for every non-abstract subclass of OBJECT.\" (RETURN NULL)) (HOME-MODULE ((SELF OBJECT)) :TYPE MODULE :DOCUMENTATION \"Return the home module of `self'.\" (RETURN NULL)) (DELETED? ((SELF OBJECT)) :TYPE BOOLEAN :DOCUMENTATION \"Default `deleted?' method which always returns FALSE.  Objects
that inherit DYNAMIC-SLOTS-MIXIN also inherit the dynamically-allocated slot
`deleted-object?' which is read/writable with specializations of this method.\" (RETURN FALSE))) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|i|\" (PRIMARY-TYPE SELF)) :METHODS ((INCREMENT-REFERENCE-COUNT ((SELF OBJECT)) NULL) (DECREMENT-REFERENCE-COUNT ((SELF OBJECT)) NULL)) :ABSTRACT? TRUE)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SECOND-CLASS-OBJECT"
    "(DEFCLASS SECOND-CLASS-OBJECT () :DOCUMENTATION \"A native reference-type object pretending to be second class,
i.e., it can't/won't participate in dynamically-typed contexts such as (real)
method dispatch.  Since it is a reference-type object, it is always passed via
a pointer reference similar to a real object.\" :ABSTRACT? TRUE)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NON-OBJECT"
    "(DEFCLASS NON-OBJECT () :DOCUMENTATION \"A data structure that cannot be a dispatch argument to
a (real) method, because its type is not accessible at run-time.\" :ABSTRACT? TRUE)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STANDARD-OBJECT"
    "(DEFCLASS STANDARD-OBJECT (OBJECT) :DOCUMENTATION \"Object that used to find its type stored in a :class slot.
By reimplementing `primary-type' as a method, the justification for this
class went away, but we'll keep it for now to keep things working.\" :ABSTRACT? TRUE :SYNONYMS (TYPE-SPEC))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TRANSIENT-MIXIN"
       "(DEFCLASS TRANSIENT-MIXIN () :DOCUMENTATION \"Transient objects are periodically swept back into a pool
of free objects.  A transient object should never be pointed at by a
permanent object.\" :MIXIN? TRUE :PUBLIC-SLOTS ((TRANSIENT? :TYPE BOOLEAN :INITIALLY TRUE :HARDWIRED? TRUE)))")))
    (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* CL:T))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "REFERENCE-COUNT-OBJECT"
       "(DEFCLASS REFERENCE-COUNT-OBJECT (OBJECT) :DOCUMENTATION \"A reference count objects contains a slot `reference-count' 
that is incremented whenever the object is assigned to a slot, and decremented
whenever it is deassigned from a slot.\" :ABSTRACT? TRUE :PUBLIC-SLOTS ((REFERENCE-COUNT :TYPE INTEGER :INITIALLY 0)) :METHODS ((INCREMENT-REFERENCE-COUNT ((SELF REFERENCE-COUNT-OBJECT)) (SETF (REFERENCE-COUNT SELF) (+ (REFERENCE-COUNT SELF) 1))) (DECREMENT-REFERENCE-COUNT ((SELF REFERENCE-COUNT-OBJECT)) (SETF (REFERENCE-COUNT SELF) (- (REFERENCE-COUNT SELF) 1)))))")))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-REFERENCE-COUNT-OBJECT-SLOT-VALUE)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DYNAMIC-SLOTS-MIXIN"
    "(DEFCLASS DYNAMIC-SLOTS-MIXIN () :DOCUMENTATION \"Enables objects to store slot values in non-preallocated storage.\" :MIXIN? TRUE :PUBLIC-SLOTS ((DYNAMIC-SLOTS :TYPE KEY-VALUE-LIST :ALLOCATION :EMBEDDED :PUBLIC? TRUE) (BAD? :TYPE BOOLEAN-WRAPPER :ALLOCATION :DYNAMIC :DEFAULT FALSE :DOCUMENTATION \"Indicates that an object is in need of repair.\") (DELETED-OBJECT? :TYPE BOOLEAN-WRAPPER :ALLOCATION :DYNAMIC :READER DELETED? :WRITER DELETED?-SETTER :DOCUMENTATION \"Indicates that an object has been 
destroyed/deleted.  A deleted object is visible only if something broke
before it was fully excised from the network).\")) :PUBLIC-METHODS ((DELETED? ((SELF DYNAMIC-SLOTS-MIXIN)) :TYPE BOOLEAN (LET ((DELETED? (SLOT-VALUE SELF DELETED-OBJECT?))) (IF (DEFINED? DELETED?) (RETURN DELETED?) (RETURN FALSE)))) (DELETED?-SETTER ((SELF DYNAMIC-SLOTS-MIXIN) (VALUE BOOLEAN)) :TYPE BOOLEAN (SETF (SLOT-VALUE SELF DELETED-OBJECT?) VALUE) (RETURN VALUE))))")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CONTEXT-SENSITIVE-OBJECT"
    "(DEFCLASS CONTEXT-SENSITIVE-OBJECT (STANDARD-OBJECT CONTEXT-SENSITIVE-MIXIN) :DOCUMENTATION \"Context sensitive objects inherit a slot `home-context'
that enables context-dependent access machinery to determine the
visibility of objects from modules.\" :ABSTRACT? TRUE)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CONTEXT-SENSITIVE-MIXIN"
    "(DEFCLASS CONTEXT-SENSITIVE-MIXIN () :DOCUMENTATION \"Mixin class that enables the class to support 
context sensitive slots.  The mixin allocates and initializes the
slot `home-context'.\" :MIXIN? TRUE :PUBLIC-SLOTS ((HOME-CONTEXT :TYPE CONTEXT :INITIALLY *CONTEXT*)) :PUBLIC-METHODS ((HOME-MODULE ((SELF CONTEXT-SENSITIVE-MIXIN)) :TYPE MODULE (LET ((CONTEXT (HOME-CONTEXT SELF))) (IF (DEFINED? CONTEXT) (RETURN (BASE-MODULE CONTEXT)) (RETURN NULL))))))")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ACTIVE-OBJECT"
    "(DEFCLASS ACTIVE-OBJECT (CONTEXT-SENSITIVE-OBJECT DYNAMIC-SLOTS-MIXIN) :DOCUMENTATION \"Active objects call class and slot triggers in response
to instance creation/destruction and slot updates.  They include internal
storage slots needed for class extensions, dynamic storage, and home context.\" :ABSTRACT? TRUE)")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ABSTRACT-ITERATOR"
       "(DEFCLASS ABSTRACT-ITERATOR (STANDARD-OBJECT) :ABSTRACT? TRUE :DOCUMENTATION \"Instances of ABSTRACT-ITERATOR support iteration over collections.\" :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-SLOTS ((VALUE :TYPE (LIKE (ANY-VALUE SELF)) :DOCUMENTATION \"The current value of this iterator\") (FIRST-ITERATION? :TYPE BOOLEAN :INITIALLY TRUE)) :PUBLIC-METHODS ((NEXT? ((SELF ABSTRACT-ITERATOR)) :TYPE BOOLEAN (RETURN NULL)) (LENGTH ((SELF ABSTRACT-ITERATOR)) :TYPE INTEGER)))")))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-ABSTRACT-ITERATOR-SLOT-VALUE)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ITERATOR"
    "(DEFCLASS ITERATOR (ABSTRACT-ITERATOR) :ABSTRACT? TRUE :DOCUMENTATION \"Instances of ITERATOR support iteration over 
collections of OBJECTs.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SYNONYMS (OBJECT-ITERATOR))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CONS-ITERATOR"
       "(DEFCLASS CONS-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator class for the class CONS.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :PUBLIC-SLOTS ((CONS-ITERATOR-CURSOR :TYPE CONS)) :TERMINATOR TERMINATE-CONS-ITERATOR?)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CONS-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CONS-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "LIST-ITERATOR"
       "(DEFCLASS LIST-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator class for the collection LIST.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :PUBLIC-SLOTS ((LIST-ITERATOR-CURSOR :TYPE CONS) (LIST-ITERATOR-COLLECTION :TYPE LIST)) :TERMINATOR TERMINATE-LIST-ITERATOR?)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-LIST-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-LIST-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DESTRUCTIVE-LIST-ITERATOR"
       "(DEFCLASS DESTRUCTIVE-LIST-ITERATOR (ITERATOR) :DOCUMENTATION \"An iterator that contains a cons list.  Iterates over
the stored list, and destroys it when the iterator is free'd.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :PUBLIC-SLOTS ((THE-CONS-LIST :TYPE CONS :INITIALLY NIL) (LIST-ITERATOR-CURSOR :TYPE CONS)) :TERMINATOR TERMINATE-DESTRUCTIVE-LIST-ITERATOR?)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-DESTRUCTIVE-LIST-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-DESTRUCTIVE-LIST-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ALL-PURPOSE-ITERATOR"
       "(DEFCLASS ALL-PURPOSE-ITERATOR (ITERATOR) :DOCUMENTATION \"The all-purpose iterator works by storing a `next?'
function within itself during iterator allocation.  The method
`ALL-PURPOSE-ITERAOR.next?' funcalls the stored `next?' function.
An assortment of storage slots are provided for constructing different
kinds of iterators.\" :PUBLIC-SLOTS ((KEY :TYPE OBJECT) (ITERATOR-NEXT-CODE :TYPE FUNCTION-CODE) (ITERATOR-FILTER-CODE :TYPE FUNCTION-CODE) (ITERATOR-EMPTY-CODE :TYPE FUNCTION-CODE) (ITERATOR-NESTED-ITERATOR :TYPE ITERATOR) (ITERATOR-CONS-LIST :TYPE CONS) (ITERATOR-OBJECT :TYPE OBJECT) (ITERATOR-SECOND-OBJECT :TYPE OBJECT) (ITERATOR-INTEGER :TYPE INTEGER) (ITERATOR-SECOND-INTEGER :TYPE INTEGER)) :TERMINATOR TERMINATE-ALL-PURPOSE-ITERATOR?)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-ALL-PURPOSE-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-ALL-PURPOSE-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TYPES-TO-CLASSES-ITERATOR"
       "(DEFCLASS TYPES-TO-CLASSES-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator that returns a class for each type
in a cons list of types.\" :PARAMETERS ((ANY-VALUE :TYPE CLASS)) :PUBLIC-SLOTS ((ITERATOR-CURSOR :TYPE (CONS OF TYPE) :REQUIRED? TRUE)) :METHODS ((NEXT? ((SELF TYPES-TO-CLASSES-ITERATOR)) :TYPE BOOLEAN (IF (FIRST-ITERATION? SELF) (SETF (FIRST-ITERATION? SELF) FALSE) (SETF (ITERATOR-CURSOR SELF) (REST (ITERATOR-CURSOR SELF)))) (COND ((NON-EMPTY? (ITERATOR-CURSOR SELF)) (SETF (SLOT-VALUE SELF VALUE) (TYPE-CLASS (FIRST (ITERATOR-CURSOR SELF)))) (RETURN TRUE)) (OTHERWISE (RETURN FALSE))))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TYPES-TO-CLASSES-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TYPES-TO-CLASSES-ITERATOR-SLOT-VALUE)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ABSTRACT-DICTIONARY-ITERATOR"
    "(DEFCLASS ABSTRACT-DICTIONARY-ITERATOR (ABSTRACT-ITERATOR) :ABSTRACT? TRUE :DOCUMENTATION \"Instances of ABSTRACT-DICTIONARY-ITERATOR support iteration
over dictionaries.\" :PARAMETERS ((ANY-KEY :TYPE UNKNOWN) (ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-SLOTS ((KEY :TYPE (LIKE (ANY-KEY SELF)))) :PUBLIC-METHODS ((VALUE-SETTER ((SELF ABSTRACT-DICTIONARY-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))) :TYPE (LIKE (ANY-VALUE SELF)) :DOCUMENTATION \"Abstract method needed to allow application of this
method on abstract iterator classes that do not implement it.  By having
this here all `next?' methods of dictionary iterators MUST use the `slot-value'
paradigm to set the iterator value.\") (KEY-SETTER ((SELF ABSTRACT-DICTIONARY-ITERATOR) (KEY (LIKE (ANY-KEY SELF)))) :TYPE (LIKE (ANY-KEY SELF)))))")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DICTIONARY-ITERATOR"
    "(DEFCLASS DICTIONARY-ITERATOR (ABSTRACT-DICTIONARY-ITERATOR) :ABSTRACT? TRUE :DOCUMENTATION \"Instances of DICTIONARY-ITERATOR support iteration
over dictionaries with keys and values of type OBJECT.\" :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :SYNONYMS (OBJECT-DICTIONARY-ITERATOR) :PUBLIC-METHODS ((VALUE-SETTER ((SELF DICTIONARY-ITERATOR) (VALUE (LIKE (ANY-VALUE SELF)))) :TYPE (LIKE (ANY-VALUE SELF)) (ERROR \"DICTIONARY-ITERATOR.value-setter not implemented on \" SELF)) (KEY-SETTER ((SELF DICTIONARY-ITERATOR) (KEY (LIKE (ANY-KEY SELF)))) :TYPE (LIKE (ANY-KEY SELF)) (ERROR \"DICTIONARY-ITERATOR.key-setter not implemented on \" SELF))))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PROPERTY-LIST-ITERATOR"
       "(DEFCLASS PROPERTY-LIST-ITERATOR (DICTIONARY-ITERATOR) :DOCUMENTATION \"Iterator class for the collection PROPERTY-LIST.\" :PUBLIC-SLOTS ((PLIST-ITERATOR-CURSOR :TYPE CONS) (PLIST-ITERATOR-COLLECTION :TYPE PROPERTY-LIST)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PROPERTY-LIST-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PROPERTY-LIST-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "KV-LIST-ITERATOR"
       "(DEFCLASS KV-LIST-ITERATOR (DICTIONARY-ITERATOR) :PUBLIC-SLOTS ((THE-KV-LIST :TYPE KEY-VALUE-LIST :PUBLIC? TRUE) (KV-LIST-ITERATOR-CURSOR :TYPE KV-CONS)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-KV-LIST-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-KV-LIST-ITERATOR-SLOT-VALUE)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INTERVAL-ITERATOR"
    "(DEFCLASS INTERVAL-ITERATOR (ABSTRACT-ITERATOR) :ABSTRACT? TRUE :DOCUMENTATION \"An iterator that specifies a (possibly infinite) range of
values.  Supports `member?' test as well as iteration methods.\" :PUBLIC-SLOTS ((LOWER-BOUND :TYPE UNKNOWN :REQUIRED? TRUE) (UPPER-BOUND :TYPE UNKNOWN :REQUIRED? TRUE)))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INTEGER-INTERVAL-ITERATOR"
       "(DEFCLASS INTEGER-INTERVAL-ITERATOR (INTERVAL-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE INTEGER)) :PUBLIC-SLOTS ((INTERVAL-CURSOR :TYPE INTEGER) (LOWER-BOUND :TYPE INTEGER :REQUIRED? TRUE) (UPPER-BOUND :TYPE INTEGER :REQUIRED? TRUE)) :INITIALIZER INITIALIZE-INTEGER-INTERVAL-ITERATOR)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-INTEGER-INTERVAL-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "REVERSE-INTEGER-INTERVAL-ITERATOR"
       "(DEFCLASS REVERSE-INTEGER-INTERVAL-ITERATOR (INTERVAL-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE INTEGER)) :PUBLIC-SLOTS ((INTERVAL-CURSOR :TYPE INTEGER) (LOWER-BOUND :TYPE INTEGER :REQUIRED? TRUE) (UPPER-BOUND :TYPE INTEGER :REQUIRED? TRUE)) :INITIALIZER INITIALIZE-REVERSE-INTEGER-INTERVAL-ITERATOR)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-REVERSE-INTEGER-INTERVAL-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION
      ACCESS-REVERSE-INTEGER-INTERVAL-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STRING-ITERATOR"
       "(DEFCLASS STRING-ITERATOR (ABSTRACT-ITERATOR) :DOCUMENTATION \"Iterator that yields characters from a string.\" :PARAMETERS ((ANY-VALUE :TYPE CHARACTER)) :PUBLIC-SLOTS ((THE-STRING :TYPE STRING) (CURSOR :TYPE INTEGER) (END :TYPE INTEGER)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-STRING-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-STRING-ITERATOR-SLOT-VALUE)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ABSTRACT-COLLECTION"
    "(DEFCLASS ABSTRACT-COLLECTION (STANDARD-OBJECT) :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-METHODS ((ALLOCATE-ITERATOR ((SELF ABSTRACT-COLLECTION)) :TYPE (ABSTRACT-ITERATOR OF (LIKE (ANY-VALUE SELF))) (RETURN NULL)) (LENGTH ((SELF ABSTRACT-COLLECTION)) :TYPE INTEGER (RETURN NULL)) (INSERT ((SELF ABSTRACT-COLLECTION) (VALUE (LIKE (ANY-VALUE SELF))))) (REMOVE ((SELF ABSTRACT-COLLECTION) (VALUE (LIKE (ANY-VALUE SELF)))) :TYPE ABSTRACT-COLLECTION)) :ABSTRACT? TRUE)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "COLLECTION"
    "(DEFCLASS COLLECTION (ABSTRACT-COLLECTION) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :PUBLIC-METHODS ((ALLOCATE-ITERATOR ((SELF COLLECTION)) :TYPE (ITERATOR OF (LIKE (ANY-VALUE SELF))) (RETURN NULL)) (LENGTH ((SELF COLLECTION)) :TYPE INTEGER (RETURN NULL)) (INSERT ((SELF COLLECTION) (VALUE (LIKE (ANY-VALUE SELF)))) (IGNORE VALUE) (RETURN)) (REMOVE ((SELF COLLECTION) (VALUE (LIKE (ANY-VALUE SELF)))) :TYPE COLLECTION (IGNORE VALUE) (RETURN NULL))) :ABSTRACT? TRUE :SYNONYMS (OBJECT-COLLECTION))")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SET-MIXIN"
    "(DEFCLASS SET-MIXIN () :DOCUMENTATION \"Users of this mixin check for duplicates inside of 
the method `insert'.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :MIXIN? TRUE)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SEQUENCE-MIXIN"
    "(DEFCLASS SEQUENCE-MIXIN () :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-METHODS ((FIRST ((SEQUENCE SEQUENCE-MIXIN)) :TYPE (LIKE (ANY-VALUE SELF))) (NTH ((SEQUENCE SEQUENCE-MIXIN) (POSITION INTEGER)) :TYPE (LIKE (ANY-VALUE SELF)))) :MIXIN? TRUE)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SEQUENCE"
    "(DEFCLASS SEQUENCE (COLLECTION SEQUENCE-MIXIN) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :PUBLIC-METHODS ((ALLOCATE-ITERATOR ((SELF SEQUENCE)) :TYPE (ITERATOR OF (LIKE (ANY-VALUE SELF))) (RETURN NULL)) (LENGTH ((SEQUENCE SEQUENCE)) :TYPE INTEGER (RETURN NULL))) :ABSTRACT? TRUE :SYNONYMS (OBJECT-SEQUENCE))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "LIST"
       "(DEFCLASS LIST (SEQUENCE) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :PUBLIC-SLOTS ((THE-CONS-LIST :TYPE (CONS OF (LIKE (ANY-VALUE SELF))) :INITIALLY NIL :PUBLIC? TRUE)) :INITIAL-VALUE NIL-LIST :PRINT-FORM (PROGN (PRINT-STREAM STREAM \"|l|\") (PRINT-CONS (THE-CONS-LIST SELF) STREAM \"(\" \")\")))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-LIST))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-LIST-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SET"
       "(DEFCLASS SET (LIST SET-MIXIN) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :INITIAL-VALUE NULL :PRINT-FORM (PROGN (PRINT-STREAM STREAM \"|s|\") (PRINT-CONS (THE-CONS-LIST SELF) STREAM \"(\" \")\")))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-SET)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CLASS-EXTENSION"
       "(DEFCLASS CLASS-EXTENSION (LIST) :PARAMETERS ((ANY-VALUE :TYPE ACTIVE-OBJECT)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CLASS-EXTENSION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CONS"
       "(DEFCLASS CONS (STANDARD-OBJECT) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :METHODS ((ALLOCATE-ITERATOR ((SELF CONS)) :TYPE (ITERATOR OF (LIKE (ANY-VALUE SELF))))) :PUBLIC-SLOTS ((VALUE :TYPE (LIKE (ANY-VALUE SELF)) :PUBLIC? TRUE) (REST :TYPE (CONS OF (LIKE (ANY-VALUE SELF))) :PUBLIC? TRUE :INITIALLY NIL)) :INITIAL-VALUE NIL :PRINT-FORM (PRINT-CONS SELF STREAM \"(\" \")\"))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-CONS))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CONS-SLOT-VALUE)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ABSTRACT-DICTIONARY"
    "(DEFCLASS ABSTRACT-DICTIONARY (ABSTRACT-COLLECTION) :PARAMETERS ((ANY-KEY :TYPE UNKNOWN) (ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-METHODS ((LOOKUP ((SELF ABSTRACT-DICTIONARY) (KEY (LIKE (ANY-KEY SELF)))) :TYPE (LIKE (ANY-VALUE SELF))) (INSERT-AT ((SELF ABSTRACT-DICTIONARY) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))))) :METHODS ((ALLOCATE-ITERATOR ((SELF ABSTRACT-DICTIONARY)) :TYPE (ABSTRACT-DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF))) (RETURN NULL))) :ABSTRACT? TRUE)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DICTIONARY"
    "(DEFCLASS DICTIONARY (ABSTRACT-DICTIONARY) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :METHODS ((ALLOCATE-ITERATOR ((SELF DICTIONARY)) :TYPE (DICTIONARY-ITERATOR OF (LIKE (ANY-KEY SELF)) (LIKE (ANY-VALUE SELF))) (RETURN NULL)) (LOOKUP ((SELF DICTIONARY) (KEY (LIKE (ANY-KEY SELF)))) :TYPE (LIKE (ANY-VALUE SELF)) (IGNORE KEY) (RETURN NULL)) (INSERT-AT ((SELF DICTIONARY) (KEY (LIKE (ANY-KEY SELF))) (VALUE (LIKE (ANY-VALUE SELF)))) (IGNORE KEY VALUE) (RETURN))) :ABSTRACT? TRUE :SYNONYMS (OBJECT-TO-OBJECT-DICTIONARY))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PROPERTY-LIST"
       "(DEFCLASS PROPERTY-LIST (DICTIONARY) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :PUBLIC-SLOTS ((THE-PLIST :TYPE CONS :INITIALLY NIL)) :PRINT-FORM (PROGN (PRINT-STREAM STREAM \"|pl|\") (PRINT-CONS (THE-PLIST SELF) STREAM \"(\" \")\")))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PROPERTY-LIST))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PROPERTY-LIST-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "KV-CONS"
       "(DEFCLASS KV-CONS (STANDARD-OBJECT) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :PUBLIC-SLOTS ((KEY :TYPE OBJECT) (VALUE :TYPE OBJECT) (REST :TYPE KV-CONS)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"<\" (KEY SELF) \",\" (VALUE SELF) \">\"))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-KV-CONS))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-KV-CONS-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "KEY-VALUE-LIST"
       "(DEFCLASS KEY-VALUE-LIST (DICTIONARY) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :PUBLIC-SLOTS ((THE-KV-LIST :TYPE KV-CONS)) :PRINT-FORM (PRINT-KEY-VALUE-LIST SELF STREAM))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-KEY-VALUE-LIST))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-KEY-VALUE-LIST-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "RECYCLE-LIST"
       "(DEFCLASS RECYCLE-LIST (SEQUENCE) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :PUBLIC-SLOTS ((RECYCLE-LIST-OF :TYPE TYPE) (RECYCLED-ITEMS :TYPE (LIKE (ANY-VALUE SELF))) (LIST-OF-RECYCLED-ITEMS :TYPE (LIST OF (LIKE (ANY-VALUE SELF))) :INITIALLY (MAKE-NON-RECYCLED-LIST)) (ALL-ITEMS :TYPE (LIKE (ANY-VALUE SELF))) (UNUSED-ITEMS :TYPE (LIKE (ANY-VALUE SELF))) (CURRENT-LENGTH :TYPE INTEGER :INITIALLY 0) (ITEM-SIZE :TYPE INTEGER)) :PRINT-FORM (IF (DEFINED? (RECYCLE-LIST-OF SELF)) (PRINT-NATIVE-STREAM STREAM \"|i|[RECYCLE-LIST OF \" (CURRENT-LENGTH SELF) \" \" (RECYCLE-LIST-OF SELF) \"'s]\") (PRINT-NATIVE-STREAM STREAM \"|i|@RECYCLE-LIST\")))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-RECYCLE-LIST))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-RECYCLE-LIST-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ABSTRACT-HASH-TABLE"
       "(DEFCLASS ABSTRACT-HASH-TABLE (ABSTRACT-DICTIONARY) :PARAMETERS ((ANY-KEY :TYPE UNKNOWN) (ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-SLOTS ((THE-HASH-TABLE :TYPE NATIVE-HASH-TABLE) (THE-STELLA-HASH-TABLE :TYPE STELLA-HASH-TABLE)) :INITIALIZER INITIALIZE-HASH-TABLE :ABSTRACT? TRUE)")))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-ABSTRACT-HASH-TABLE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "HASH-TABLE"
       "(DEFCLASS HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE OBJECT) (ANY-VALUE :TYPE OBJECT)) :INITIALIZER INITIALIZE-HASH-TABLE :SYNONYMS (OBJECT-TO-OBJECT-HASH-TABLE))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-HASH-TABLE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INTEGER-HASH-TABLE"
       "(DEFCLASS INTEGER-HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE INTEGER) (ANY-VALUE :TYPE OBJECT)) :INITIALIZER INITIALIZE-HASH-TABLE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-INTEGER-HASH-TABLE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FLOAT-HASH-TABLE"
       "(DEFCLASS FLOAT-HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE FLOAT) (ANY-VALUE :TYPE OBJECT)) :INITIALIZER INITIALIZE-HASH-TABLE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-FLOAT-HASH-TABLE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STRING-HASH-TABLE"
       "(DEFCLASS STRING-HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE STRING) (ANY-VALUE :TYPE OBJECT)) :INITIALIZER INITIALIZE-HASH-TABLE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-STRING-HASH-TABLE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "STRING-TO-INTEGER-HASH-TABLE"
       "(DEFCLASS STRING-TO-INTEGER-HASH-TABLE (ABSTRACT-HASH-TABLE) :PARAMETERS ((ANY-KEY :TYPE STRING) (ANY-VALUE :TYPE INTEGER)) :INITIALIZER INITIALIZE-HASH-TABLE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-STRING-TO-INTEGER-HASH-TABLE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "VECTOR"
       "(DEFCLASS VECTOR (SEQUENCE) :PUBLIC-SLOTS ((ARRAY-SIZE :TYPE INTEGER :REQUIRED? TRUE) (THE-ARRAY :TYPE (NATIVE-VECTOR OF (LIKE (ANY-VALUE SELF))))) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :PRINT-FORM (PRINT-VECTOR SELF STREAM) :INITIALIZER INITIALIZE-VECTOR)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-VECTOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-VECTOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "EXTENSIBLE-VECTOR"
       "(DEFCLASS EXTENSIBLE-VECTOR (VECTOR) :INITIALIZER INITIALIZE-VECTOR)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EXTENSIBLE-VECTOR)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "EXTENSIBLE-SYMBOL-ARRAY"
       "(DEFCLASS EXTENSIBLE-SYMBOL-ARRAY (EXTENSIBLE-VECTOR) :DOCUMENTATION \"Self-extending array with methods for storing and
accessing symbols within it.\" :PUBLIC-SLOTS ((TOP-SYMBOL-OFFSET :TYPE INTEGER :INITIALLY -1) (POTENTIAL-FREE-SYMBOL-OFFSET :TYPE INTEGER :INITIALLY 0)) :INITIALIZER INITIALIZE-VECTOR)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EXTENSIBLE-SYMBOL-ARRAY))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-EXTENSIBLE-SYMBOL-ARRAY-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "VECTOR-SEQUENCE"
       "(DEFCLASS VECTOR-SEQUENCE (VECTOR) :DOCUMENTATION \"Extensible sequence implemented by a vector.  Whenever we run
out of room, we grow the sequence by a factor of two.  Note that this keeps the
average insertion cost per element constant.  This is generally preferable over
linked lists unless we need within-list insertions or removals, since it uses
less space and has better cache locality.\" :PUBLIC-SLOTS ((SEQUENCE-LENGTH :TYPE INTEGER :INITIALLY 0)) :INITIALIZER INITIALIZE-VECTOR)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-VECTOR-SEQUENCE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-VECTOR-SEQUENCE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CUSTOM-VECTOR-SEQUENCE"
       "(DEFCLASS CUSTOM-VECTOR-SEQUENCE (VECTOR-SEQUENCE) :DOCUMENTATION \"VECTOR-SEQUENCE (which see) with a customizable resize factor.
The resize factor needs to be > 1.\" :PUBLIC-SLOTS ((RESIZE-FACTOR :TYPE FLOAT :INITIALLY 2.0)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CUSTOM-VECTOR-SEQUENCE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CUSTOM-VECTOR-SEQUENCE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BOOLEAN-VECTOR"
       "(DEFCLASS BOOLEAN-VECTOR (VECTOR) :PARAMETERS ((ANY-VALUE :TYPE BOOLEAN-WRAPPER)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-BOOLEAN-VECTOR)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INTEGER-VECTOR"
       "(DEFCLASS INTEGER-VECTOR (VECTOR) :PARAMETERS ((ANY-VALUE :TYPE INTEGER-WRAPPER)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-INTEGER-VECTOR)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ARRAY"
    "(DEFCLASS ARRAY (SECOND-CLASS-OBJECT) :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)) :SLOTS ((INITIAL-ELEMENT :TYPE (LIKE (ANY-VALUE SELF)) :REQUIRED? TRUE :ABSTRACT? TRUE :DOCUMENTATION \"Initializer pseudo-slot special-cased by the STELLA translator.\") (SIZE :TYPE (LIST OF INTEGER-WRAPPER) :REQUIRED? TRUE :ABSTRACT? TRUE :DOCUMENTATION \"Size pseudo-slot special-cased by the STELLA translator.\")) :METHODS ((AREF ((SELF ARRAY) (DIM0 INTEGER) |&REST| (DIMS INTEGER)) :TYPE (LIKE (ANY-VALUE SELF)) :PUBLIC? TRUE :NATIVE? TRUE) (AREF-SETTER ((SELF ARRAY) (VALUE (LIKE (ANY-VALUE SELF))) (DIM0 INTEGER) |&REST| (DIMS INTEGER)) :TYPE (LIKE (ANY-VALUE SELF)) :PUBLIC? TRUE :NATIVE? TRUE)) :CL-NATIVE-TYPE \"ARRAY\" :CPP-NATIVE-TYPE \"char*\" :JAVA-NATIVE-TYPE \"Object\")")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NATIVE-HASH-TABLE"
    "(DEFCLASS NATIVE-HASH-TABLE (SECOND-CLASS-OBJECT) :CPP-NATIVE-TYPE \"cpp_hash_table*\" :CL-NATIVE-TYPE \"HASH-TABLE\" :JAVA-NATIVE-TYPE \"java.util.HashMap\")")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NATIVE-VECTOR"
    "(DEFCLASS NATIVE-VECTOR (SECOND-CLASS-OBJECT) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :CPP-NATIVE-TYPE \"Object**\" :CL-NATIVE-TYPE \"VECTOR\" :JAVA-NATIVE-TYPE \"#$(STELLAROOT).Stella_Object[]\" :INITIAL-VALUE (VERBATIM :COMMON-LISP \"STELLA::NULL-NATIVE-VECTOR\" :JAVA \"null\" :CPP \"NULL\"))")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ACTIVE-COLLECTION-MIXIN"
    "(DEFCLASS ACTIVE-COLLECTION-MIXIN () :DOCUMENTATION \"Mixin class that provides collection instances with a
backpointer to the instance slot they belong to.\" :MIXIN? TRUE :PUBLIC-SLOTS ((ACTIVE-SLOT :TYPE STORAGE-SLOT) (OWNER-INSTANCE :TYPE STANDARD-OBJECT)))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ACTIVE-LIST"
       "(DEFCLASS ACTIVE-LIST (LIST ACTIVE-COLLECTION-MIXIN))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-ACTIVE-LIST)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ACTIVE-SET"
       "(DEFCLASS ACTIVE-SET (LIST SET-MIXIN ACTIVE-COLLECTION-MIXIN))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-ACTIVE-SET)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DEMON"
       "(DEFCLASS DEMON (STANDARD-OBJECT) :PUBLIC-SLOTS ((DEMON-NAME :TYPE STRING) (DEMON-ACTION :TYPE KEYWORD) (DEMON-CLASS-REFS :TYPE (LIST OF TYPE) :ALLOCATION :EMBEDDED) (DEMON-SLOT-REFS :TYPE (LIST OF SYMBOL) :ALLOCATION :EMBEDDED) (DEMON-CODE :TYPE FUNCTION-CODE) (DEMON-METHOD :TYPE METHOD-SLOT) (DEMON-DOCUMENTATION :TYPE STRING) (DEMON-GUARD? :TYPE BOOLEAN) (DEMON-ALL? :TYPE BOOLEAN) (DEMON-INHERIT? :TYPE BOOLEAN)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-DEMON))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-DEMON-SLOT-VALUE))))
  :VOID)

(CL:DEFUN HELP-STARTUP-HIERARCHY8 ()
  (CL:PROGN
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "KEYWORD-KEY-VALUE-LIST"
       "(DEFCLASS KEYWORD-KEY-VALUE-LIST (KEY-VALUE-LIST) :PARAMETERS ((ANY-KEY :TYPE KEYWORD) (ANY-VALUE :TYPE OBJECT)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-KEYWORD-KEY-VALUE-LIST)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "GENERALIZED-SYMBOL"
       "(DEFCLASS GENERALIZED-SYMBOL (CONTEXT-SENSITIVE-OBJECT) :PUBLIC-SLOTS ((SYMBOL-NAME :TYPE STRING :REQUIRED? TRUE) (SYMBOL-ID :TYPE INTEGER) (INTERNED-IN :RENAMES HOME-CONTEXT :TYPE MODULE)) :ABSTRACT? TRUE)")))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-GENERALIZED-SYMBOL-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SYMBOL"
       "(DEFCLASS SYMBOL (GENERALIZED-SYMBOL) :PUBLIC-SLOTS ((SYMBOL-SLOT-OFFSET :TYPE INTEGER) (SYMBOL-VALUE-AND-PLIST :TYPE CONS :INITIALLY NIL)) :PRINT-FORM (PRINT-SYMBOL SELF STREAM))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-SYMBOL))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-SYMBOL-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SURROGATE"
       "(DEFCLASS SURROGATE (GENERALIZED-SYMBOL) :DOCUMENTATION \"Rigid surrogate.\" :PUBLIC-SLOTS ((SURROGATE-VALUE :TYPE OBJECT) (SURROGATE-NAME :RENAMES SYMBOL-NAME) (TYPE-CLASS :RENAMES SURROGATE-VALUE :TYPE CLASS) (TYPE-NAME :RENAMES SYMBOL-NAME)) :PUBLIC-SLOTS ((SLOTREF-SLOT :RENAMES SURROGATE-VALUE :TYPE SLOT)) :SYNONYMS (TYPE SLOTREF) :PRINT-FORM (PRINT-SURROGATE SELF STREAM))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-SURROGATE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-SURROGATE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "KEYWORD"
       "(DEFCLASS KEYWORD (GENERALIZED-SYMBOL) :PUBLIC-SLOTS ((KEYWORD-NAME :RENAMES SYMBOL-NAME)) :PRINT-FORM (PRINT-KEYWORD SELF STREAM))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-KEYWORD))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-KEYWORD-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TRANSIENT-SYMBOL"
       "(DEFCLASS TRANSIENT-SYMBOL (SYMBOL TRANSIENT-MIXIN))")))
    (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* CL:T)
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TRANSIENT-SYMBOL)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "MAPPABLE-OBJECT"
       "(DEFCLASS MAPPABLE-OBJECT (STANDARD-OBJECT DYNAMIC-SLOTS-MIXIN) :DOCUMENTATION \"The class MAPPABLE-OBJECT enables the definition of projections
from a Stella class, slot, global variable, etc. onto a corresponding native
entity.\" :ABSTRACT? TRUE :PUBLIC-SLOTS ((PROJECTS-ONTO :TYPE (LIST OF SYMBOL) :ALLOCATION :DYNAMIC) (PROJECTED-FROM :TYPE (LIST OF SYMBOL) :ALLOCATION :DYNAMIC) (PROJECTION-TRANSFORM :TYPE SYMBOL :ALLOCATION :DYNAMIC :DOCUMENTATION \"Names a coersion function that translates
values retrieved from the `from' entity to the `projecting' entity.\")) :PUBLIC-SLOTS ((NATIVE-NAME :TYPE STRING :ALLOCATION :DYNAMIC :DOCUMENTATION \"Used in cases when the native name cannot be
cast as a symbol (e.g., because it contains illegal characters).\")))")))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-MAPPABLE-OBJECT-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "RELATION"
       "(DEFCLASS RELATION (MAPPABLE-OBJECT) :ABSTRACT? TRUE :PUBLIC-SLOTS ((DOCUMENTATION :TYPE STRING :ALLOCATION :DYNAMIC) (ABSTRACT? :TYPE BOOLEAN :OPTION-KEYWORD :ABSTRACT?) (META-ATTRIBUTES :TYPE (KEY-VALUE-LIST OF GENERALIZED-SYMBOL OBJECT) :ALLOCATION :DYNAMIC :OPTION-KEYWORD :META-ATTRIBUTES) (PROPERTIES :TYPE (LIST OF GENERALIZED-SYMBOL) :ALLOCATION :DYNAMIC :OPTION-KEYWORD :PROPERTIES)) :PUBLIC-METHODS ((NAME ((SELF RELATION)) :TYPE STRING (RETURN NULL)) (HOME-MODULE ((SELF RELATION)) :TYPE MODULE (RETURN NULL)) (ARITY ((SELF RELATION)) :TYPE INTEGER (RETURN NULL)) (PUBLIC? ((SELF RELATION)) :TYPE BOOLEAN (RETURN NULL)) (DIRECT-SUPERS ((SELF RELATION)) :TYPE (LIST OF RELATION) (RETURN NULL)) (ALL-SUPERS ((SELF RELATION)) :TYPE (LIST OF RELATION) (RETURN NULL)) (SLOTS ((SELF RELATION)) :TYPE (ITERATOR OF SLOT) (RETURN NULL))) :SLOTS ((STORED-ACTIVE? :TYPE BOOLEAN-WRAPPER :ALLOCATION :DYNAMIC :OPTION-KEYWORD :ACTIVE?)))")))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-RELATION-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CLASS"
       (CONCATENATE
        "(DEFCLASS CLASS (RELATION) :PUBLIC-SLOTS ((CL-STRUCT? :TYPE BOOLEAN :INITIALLY FALSE) (MIXIN? :TYPE BOOLEAN :INITIALLY FALSE) (PRINT-FORM :TYPE OBJECT :ALLOCATION :DYNAMIC :OPTION-KEYWORD :PRINT-FORM) (CLASS-TYPE :TYPE TYPE :PUBLIC? TRUE) (CLASS-ARITY :TYPE INTEGER :INITIALLY 1 :HARDWIRED? TRUE) (CLASS-DIRECT-SUPERS :TYPE (LIST OF TYPE) :ALLOCATION :EMBEDDED) (CLASS-DIRECT-SUBS :TYPE (LIST OF TYPE) :ALLOCATION :EMBEDDED) (CLASS-ALL-SUPER-CLASSES :TYPE (CONS OF CLASS) :INITIALLY NIL :PUBLIC? TRUE) (CLASS-ALL-SLOTS :TYPE (CONS OF SLOT)) (CLASS-LOCAL-SLOTS :TYPE (LIST OF SLOT)) (CLASS-SLOT-AND-METHOD-CACHE :TYPE (VECTOR OF SLOT)) (CLASS-ABSTRACT? :TYPE BOOLEAN :INITIALLY FALSE :RENAMES ABSTRACT?) (CLASS-MIXIN? :TYPE BOOLEAN :INITIALLY FALSE :RENAMES MIXIN?) (CLASS-COLLECTION? :TYPE BOOLEAN :INITIALLY FALSE) (CLASS-CL-STRUCT? :TYPE BOOLEAN :INITIALLY FALSE :RENAMES CL-STRUCT?) (CLASS-CL-STRUCT-SLOTS :TYPE (LIST OF STORAGE-SLOT) :ALLOCATION :DYNAMIC) (CLASS-PUBLIC? :TYPE BOOLEAN :INITIALLY TRUE :OPTION-KEYWORD :PUBLIC?) (CLASS-RECYCLE-METHOD :TYPE KEYWORD :ALLOCATION :DYNAMIC :DEFAULT :NONE :OPTION-KEYWORD :RECYCLE-METHOD) (CLASS-FINALIZED? :TYPE BOOLEAN :INITIALLY FALSE :PUBLIC? TRUE) (CLASS-SLOTS-FINALIZED? :TYPE BOOLEAN :INITIALLY FALSE) (CLASS-STRINGIFIED-SOURCE :TYPE STRING) (CLASS-PARAMETERS :TYPE (LIST OF SYMBOL) :ALLOCATION :DYNAMIC :DEFAULT NIL-LIST :OPTION-KEYWORD :PARAMETERS) (CLASS-CONSTRUCTOR-CODE :TYPE FUNCTION-CODE) (CLASS-SLOT-ACCESSOR-CODE :TYPE FUNCTION-CODE) (CLASS-CREATOR :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :CREATOR) (CLASS-INITIALIZER :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :INITIALIZER) (CLASS-TERMINATOR :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :TERMINATOR) (CLASS-DESTRUCTOR :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :DESTRUCTOR) (CLASS-DOCUMENTATION :ALLOCATION :DYNAMIC :RENAMES DOCUMENTATION :OPTION-KEYWORD :DOCUMENTATION) (CLASS-EXTENSION-NAME :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :EXTENSION) (CLASS-EXTENSION :TYPE CLASS-EXTENSION :ALLOCATION :DYNAMIC) (CLASS-REQUIRED-SLOT-NAMES :TYPE (LIST OF SYMBOL) :ALLOCATION :DYNAMIC :DEFAULT NIL-LIST) (CLASS-GUARD-CONSTRUCTOR-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (CLASS-CONSTRUCTOR-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (CLASS-GUARD-DESTRUCTOR-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (CLASS-DESTRUCTOR-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (CLASS-INITIAL-VALUE :TYPE OBJECT :ALLOCATION :DYNAMIC :OPTION-KEYWORD :INITIAL-VALUE) (CLASS-PRINT-FORM :TYPE OBJECT :RENAMES PRINT-FORM :OPTION-KEYWORD :PRINT-FORM) (CLASS-KEY :TYPE (LIST OF SLOT) :ALLOCATION :DYNAMIC :DEFAULT NIL-LIST) (CLASS-SYNONYMS :TYPE (LIST OF TYPE) :ALLOCATION :DYNAMIC :DEFAULT NIL-LIST :OPTION-KEYWORD :SYNONYMS) (CLASS-IS-LINK :TYPE TYPE :ALLOCATION :DYNAMIC) (CLASS-INVERSE-IS-LINK :TYPE CLASS :ALLOCATION :DYNAMIC) (CLASS-CL-NATIVE-TYPE :TYPE STRING :ALLOCATION :DYNAMIC :OPTION-KEYWORD :CL-NATIVE-TYPE) (CLASS-CPP-NATIVE-TYPE :TYPE STRING :ALLOCATION :DYNAMIC :OPTION-KEYWORD :CPP-NATIVE-TYPE) (CLASS-JAVA-NATIVE-TYPE :TYPE STRING :ALLOCATION :DYNAMIC :OPTION-KEYWORD :JAVA-NATIVE-TYPE) (CLASS-IDL-NATIVE-TYPE :TYPE STRING :ALLOCATION :DYNAMIC :OPTION-KEYWORD :IDL-NATIVE-TYPE) (CLASS-MARKED? :TYPE BOOLEAN) (CLASS-PROTOTYPE :TYPE OBJECT :ALLOCATION :DYNAMIC) (CLASS-TAXONOMY-NODE :TYPE TAXONOMY-NODE)) :PUBLIC-METHODS ((NAME ((SELF CLASS)) :TYPE STRING (RETURN (SYMBOL-NAME (CLASS-TYPE SELF)))) (HOME-MODULE ((SELF CLASS)) :TYPE MODULE (RETURN (INTERNED-IN (CLASS-TYPE SELF)))) (ARITY ((SELF CLASS)) :TYPE INTEGER (RETURN 1)) (PUBLIC? ((SELF CLASS)) :TYPE BOOLEAN :STORAGE-SLOT CLASS-PUBLIC? (RETURN (CLASS-PUBLIC? SELF))) (ACTIVE? ((SELF CLASS)) :TYPE BOOLEAN :STORAGE-SLOT STORED-ACTIVE? (RETURN (OR (AND (DEFINED? (STORED-ACTIVE? SELF)) (STORED-ACTIVE? SELF)) (SUBTYPE-OF? (CLASS-TYPE SELF) @ACTIVE-OBJECT)))) (CREATOR ((SELF CLASS)) :TYPE SYMBOL :STORAGE-SLOT CLASS-CREATOR (RETURN (CLASS-CREATOR SELF))) (INITIALIZER ((SEL"
        "F CLASS)) :TYPE SYMBOL :STORAGE-SLOT CLASS-INITIALIZER :INHERITS-THROUGH SUPER-CLASSES) (TERMINATOR ((SELF CLASS)) :TYPE SYMBOL :STORAGE-SLOT CLASS-TERMINATOR :INHERITS-THROUGH SUPER-CLASSES) (DESTRUCTOR ((SELF CLASS)) :TYPE SYMBOL :STORAGE-SLOT CLASS-DESTRUCTOR (RETURN (CLASS-DESTRUCTOR SELF))) (REQUIRED-SLOTS ((SELF CLASS)) :TYPE (LIST OF SYMBOL) :DOCUMENTATION \"Returns a list of names of required slots for `self'.\" (RETURN (CLASS-REQUIRED-SLOT-NAMES SELF))) (PARAMETERS ((SELF CLASS)) :TYPE (LIST OF SYMBOL) :DOCUMENTATION \"Returns the list of parameters names of `self'.\" :STORAGE-SLOT CLASS-PARAMETERS :INHERITS-THROUGH SUPER-CLASSES) (INITIAL-VALUE ((SELF CLASS)) :TYPE OBJECT :DOCUMENTATION \"Return an initial value for the class `self'.\" :STORAGE-SLOT CLASS-INITIAL-VALUE :INHERITS-THROUGH SUPER-CLASSES) (EXTENSION ((SELF CLASS)) :TYPE CLASS-EXTENSION :DOCUMENTATION \"Return the nearest class extension that records instances
of the class `self'.\" :STORAGE-SLOT CLASS-EXTENSION :INHERITS-THROUGH SUPER-CLASSES) (CL-NATIVE-TYPE ((SELF CLASS)) :TYPE STRING :STORAGE-SLOT CLASS-CL-NATIVE-TYPE (RETURN (CLASS-CL-NATIVE-TYPE SELF))) (CPP-NATIVE-TYPE ((SELF CLASS)) :TYPE STRING :STORAGE-SLOT CLASS-CPP-NATIVE-TYPE (RETURN (CLASS-CPP-NATIVE-TYPE SELF))) (IDL-NATIVE-TYPE ((SELF CLASS)) :TYPE STRING :STORAGE-SLOT CLASS-IDL-NATIVE-TYPE (RETURN (CLASS-CPP-NATIVE-TYPE SELF))) (JAVA-NATIVE-TYPE ((SELF CLASS)) :TYPE STRING :STORAGE-SLOT CLASS-JAVA-NATIVE-TYPE (LET ((NATIVETYPE (CLASS-JAVA-NATIVE-TYPE SELF))) (IF (DEFINED? NATIVETYPE) (RETURN (SUBSTITUTE-TEMPLATE-VARIABLES-IN-STRING NATIVETYPE *JAVA-STELLA-PACKAGE-MAPPING*)) (RETURN NULL))))) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|C|\" (CHOOSE (DEFINED? (CLASS-TYPE SELF)) (RELATIVE-NAME (CLASS-SYMBOL SELF) FALSE) \"??\")))"))))
    (CL:SETQ *HARDWIRED-CLASS-ARITY-ON-CLASS* 1)
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-CLASS))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CLASS-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "POLYMORPHIC-RELATION"
       "(DEFCLASS POLYMORPHIC-RELATION (RELATION) :ABSTRACT? TRUE :PUBLIC-SLOTS ((SLOT-DIRECT-EQUIVALENT :TYPE SLOT)) :PUBLIC-METHODS ((OWNER ((SELF POLYMORPHIC-RELATION)) :TYPE TYPE (RETURN NULL)) (RENAMES ((SELF POLYMORPHIC-RELATION)) :TYPE SYMBOL (RETURN NULL)) (ACTIVE? ((SELF POLYMORPHIC-RELATION)) :TYPE BOOLEAN :STORAGE-SLOT STORED-ACTIVE? :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"True if `self' or a superslot of `self' is marked active.\")))")))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-POLYMORPHIC-RELATION-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SLOT"
       "(DEFCLASS SLOT (POLYMORPHIC-RELATION) :ABSTRACT? TRUE :PUBLIC-METHODS ((NAME ((SELF SLOT)) :TYPE STRING (RETURN (SYMBOL-NAME (SLOT-NAME SELF)))) (TYPE ((SELF SLOT)) :TYPE TYPE :STORAGE-SLOT SLOT-BASE-TYPE :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"The type of a storage slot is its base type.\") (TYPE-SPECIFIER ((SELF SLOT)) :TYPE TYPE-SPEC :DOCUMENTATION \"If `self' has a complex type return its
type specifier, otherwise, return `type' of `self'.\" (LET ((TSPEC (SLOT-TYPE-SPECIFIER SELF))) (RETURN (CHOOSE (DEFINED? TSPEC) TSPEC (TYPE SELF))))) (OWNER ((SELF SLOT)) :TYPE TYPE :STORAGE-SLOT SLOT-OWNER (RETURN (SLOT-OWNER SELF))) (HOME-MODULE ((SELF SLOT)) :TYPE MODULE (LET ((MODULE (SLOT-HOME-MODULE SELF))) (IF (DEFINED? MODULE) (RETURN MODULE) (RETURN (INTERNED-IN (SLOT-NAME SELF)))))) (RENAMES ((SELF SLOT)) :TYPE SYMBOL :STORAGE-SLOT SLOT-RENAMES (RETURN (SLOT-RENAMES SELF))) (COLLECTION-VALUED? ((SELF SLOT)) :TYPE BOOLEAN :DOCUMENTATION \"True if slot values are collections.\" (RETURN (SUBTYPE-OF? (SLOT-BASE-TYPE SELF) @COLLECTION))) (CLOSURE-ASSUMPTION ((SELF SLOT)) :TYPE KEYWORD :STORAGE-SLOT SLOT-CLOSURE-ASSUMPTION :INHERITS-THROUGH EQUIVALENT-SLOT)) :PUBLIC-SLOTS ((INVERSE :TYPE SLOT :ALLOCATION :DYNAMIC) (SLOT-NAME :TYPE SYMBOL) (SLOT-OWNER :TYPE TYPE) (SLOT-BASE-TYPE :TYPE TYPE) (SLOT-SLOTREF :TYPE SLOTREF) (SLOT-DIRECT-SUPERS :TYPE (LIST OF SLOT) :ALLOCATION :DYNAMIC) (SLOT-DIRECT-SUBS :TYPE (LIST OF SLOT) :ALLOCATION :DYNAMIC) (SLOT-HOME-MODULE :TYPE MODULE :ALLOCATION :DYNAMIC) (SLOT-TYPE-SPECIFIER :TYPE COMPOUND-TYPE-SPECIFIER :ALLOCATION :DYNAMIC) (SLOT-PUBLIC? :TYPE BOOLEAN :INITIALLY TRUE :OPTION-KEYWORD :PUBLIC?) (SLOT-INVERSE :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :INVERSE) (SLOT-RENAMES :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :RENAMES) (SLOT-RENAMED? :TYPE BOOLEAN :INITIALLY FALSE) (SLOT-DOCUMENTATION :TYPE STRING :ALLOCATION :DYNAMIC :RENAMES DOCUMENTATION :OPTION-KEYWORD :DOCUMENTATION) (SLOT-EXTERNAL? :TYPE BOOLEAN :INITIALLY FALSE) (SLOT-MARKED? :TYPE BOOLEAN) (SLOT-AUXILIARY? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :OPTION-KEYWORD :AUXILIARY?) (SLOT-CLOSURE-ASSUMPTION :TYPE KEYWORD :ALLOCATION :DYNAMIC)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|S|\" (SYMBOL-NAME (SLOT-OWNER SELF)) \".\" (SYMBOL-NAME (SLOT-NAME SELF))))")))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-SLOT-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STORAGE-SLOT"
       "(DEFCLASS STORAGE-SLOT (SLOT) :PUBLIC-METHODS ((INITIALLY ((SELF STORAGE-SLOT)) :TYPE OBJECT) (ALLOCATION ((SELF STORAGE-SLOT)) :TYPE KEYWORD :STORAGE-SLOT SLOT-ALLOCATION :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"Return the most specific :allocation facet, or
:instance if all inherited values are NULL.\") (DEFAULT-FORM ((SELF STORAGE-SLOT)) :TYPE OBJECT :STORAGE-SLOT SLOT-DEFAULT-EXPRESSION :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"Returns the current value of default expression when the
slot has not been assigned a value.\") (REQUIRED? ((SELF STORAGE-SLOT)) :TYPE BOOLEAN :STORAGE-SLOT SLOT-REQUIRED? :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"True if a value must be assigned to this slot at
creation time.\") (COMPONENT? ((SELF STORAGE-SLOT)) :TYPE BOOLEAN :STORAGE-SLOT SLOT-COMPONENT? :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"True if fillers of this slot are components of the
owner slot, and therefore should be deleted if the owner is deleted.\") (READER ((SELF STORAGE-SLOT)) :TYPE SYMBOL :STORAGE-SLOT SLOT-READER :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"Name of a method called to read the value of the slot
`self'.\") (WRITER ((SELF STORAGE-SLOT)) :TYPE SYMBOL :STORAGE-SLOT SLOT-WRITER :INHERITS-THROUGH EQUIVALENT-SLOT :DOCUMENTATION \"Name of a method called to write the value of the slot
`self'.\")) :PUBLIC-SLOTS ((SLOT-INITIAL-VALUE :TYPE OBJECT :ALLOCATION :DYNAMIC :OPTION-KEYWORD :INITIALLY) (SLOT-ALLOCATION :TYPE KEYWORD :ALLOCATION :DYNAMIC :DEFAULT :INSTANCE :OPTION-KEYWORD :ALLOCATION) (SLOT-DEFAULT-EXPRESSION :TYPE OBJECT :ALLOCATION :DYNAMIC :OPTION-KEYWORD :DEFAULT) (SLOT-GUARD-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (SLOT-DEMONS :TYPE (LIST OF DEMON) :ALLOCATION :DYNAMIC) (SLOT-REQUIRED? :TYPE BOOLEAN :OPTION-KEYWORD :REQUIRED?) (SLOT-COMPONENT? :TYPE BOOLEAN :OPTION-KEYWORD :COMPONENT?) (SLOT-READ-ONLY? :TYPE BOOLEAN :OPTION-KEYWORD :READ-ONLY?) (SLOT-HARDWIRED? :TYPE BOOLEAN :OPTION-KEYWORD :HARDWIRED?) (SLOT-CONTEXT-SENSITIVE? :TYPE BOOLEAN :OPTION-KEYWORD :CONTEXT-SENSITIVE?) (SLOT-READER :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :READER) (SLOT-WRITER :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :WRITER) (SLOT-OPTION-KEYWORD :TYPE KEYWORD :ALLOCATION :DYNAMIC :OPTION-KEYWORD :OPTION-KEYWORD) (SLOT-OPTION-HANDLER :TYPE SYMBOL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :OPTION-HANDLER)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-STORAGE-SLOT))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-STORAGE-SLOT-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "METHOD-SLOT"
       "(DEFCLASS METHOD-SLOT (SLOT) :SYNONYMS (FUNCTION) :PUBLIC-SLOTS ((STORAGE-SLOT :TYPE SYMBOL :ALLOCATION :DYNAMIC) (SLOT-REQUIRED? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-SETTER? :TYPE BOOLEAN) (METHOD-DOCUMENTATION :TYPE STRING :ALLOCATION :DYNAMIC :RENAMES DOCUMENTATION) (METHOD-PARAMETER-NAMES :TYPE (LIST OF SYMBOL) :DEFAULT NIL-LIST :COMPONENT? TRUE) (METHOD-PARAMETER-TYPE-SPECIFIERS :TYPE (LIST OF TYPE-SPEC) :DEFAULT NIL-LIST :COMPONENT? TRUE) (METHOD-PARAMETER-DIRECTIONS :TYPE (LIST OF SYMBOL) :DEFAULT NIL-LIST :COMPONENT? TRUE :ALLOCATION :DYNAMIC) (METHOD-RETURN-TYPE-SPECIFIERS :TYPE (LIST OF TYPE-SPEC) :DEFAULT NIL-LIST :COMPONENT? TRUE) (METHOD-STRINGIFIED-SOURCE :TYPE STRING) (METHOD-CODE :TYPE METHOD-CODE) (FUNCTION-CODE :TYPE FUNCTION-CODE) (METHOD-FUNCTION? :TYPE BOOLEAN) (METHOD-VARIABLE-ARGUMENTS? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-BODY-ARGUMENT? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-AUXILIARY? :RENAMES SLOT-AUXILIARY?) (METHOD-NATIVE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-CONSTRUCTOR? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-GLOBALLY-INLINE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-INLINED-FUNCTIONS :TYPE (LIST OF SYMBOL) :ALLOCATION :DYNAMIC :DEFAULT NIL-LIST) (METHOD-STORAGE-SLOT :TYPE SYMBOL :ALLOCATION :DYNAMIC :RENAMES STORAGE-SLOT) (METHOD-INHERITS-THROUGH :TYPE SYMBOL :ALLOCATION :DYNAMIC) (METHOD-COMMAND? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT FALSE) (METHOD-EVALUATE-ARGUMENTS? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT TRUE) (METHOD-LISP-MACRO? :TYPE BOOLEAN-WRAPPER :ALLOCATION :DYNAMIC) (EVALUATOR-WRAPPER-CODE :TYPE FUNCTION-CODE :ALLOCATION :DYNAMIC)) :PUBLIC-METHODS ((SETTER? ((SELF METHOD-SLOT)) :TYPE BOOLEAN :STORAGE-SLOT METHOD-SETTER? (RETURN (METHOD-SETTER? SELF)))) :PRINT-FORM (IF (METHOD-FUNCTION? SELF) (PRINT-NATIVE-STREAM STREAM \"|F|\" (SYMBOL-NAME (SLOT-NAME SELF))) (PRINT-NATIVE-STREAM STREAM \"|M|\" (SYMBOL-NAME (SLOT-OWNER SELF)) \".\" (SYMBOL-NAME (SLOT-NAME SELF)))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-METHOD-SLOT))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-METHOD-SLOT-SLOT-VALUE)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "COMPOUND-TYPE-SPECIFIER"
    "(DEFCLASS COMPOUND-TYPE-SPECIFIER (STANDARD-OBJECT) :ABSTRACT? TRUE :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|TS|\" (YIELD-TYPE-SPEC-TREE SELF)))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PARAMETRIC-TYPE-SPECIFIER"
       "(DEFCLASS PARAMETRIC-TYPE-SPECIFIER (COMPOUND-TYPE-SPECIFIER) :PUBLIC-SLOTS ((SPECIFIER-BASE-TYPE :TYPE TYPE) (SPECIFIER-PARAMETER-TYPES :TYPE (LIST OF TYPE-SPEC) :ALLOCATION :EMBEDDED) (SPECIFIER-DIMENSIONS :TYPE (LIST OF OBJECT))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PARAMETRIC-TYPE-SPECIFIER))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PARAMETRIC-TYPE-SPECIFIER-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ANCHORED-TYPE-SPECIFIER"
       "(DEFCLASS ANCHORED-TYPE-SPECIFIER (COMPOUND-TYPE-SPECIFIER) :PUBLIC-SLOTS ((SPECIFIER-PARAMETER-NAME :TYPE SYMBOL)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-ANCHORED-TYPE-SPECIFIER))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-ANCHORED-TYPE-SPECIFIER-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TABLE"
       "(DEFCLASS TABLE (SLOT) :PARAMETERS ((ANY-VALUE :TYPE BOOLEAN)) :PUBLIC-SLOTS ((TUPLE-DOMAINS :TYPE (LIST OF TYPE-SPEC)) (VARIABLE-ARITY-TABLE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|T|\" (SYMBOL-NAME (SLOT-NAME SELF))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-TABLE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TABLE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "GLOBAL-VARIABLE"
       "(DEFCLASS GLOBAL-VARIABLE (MAPPABLE-OBJECT) :PUBLIC-SLOTS ((DOCUMENTATION :TYPE STRING)) :PUBLIC-METHODS ((NAME ((SELF GLOBAL-VARIABLE)) :TYPE STRING (RETURN (SYMBOL-NAME (VARIABLE-NAME SELF)))) (TYPE ((SELF GLOBAL-VARIABLE)) :TYPE TYPE :STORAGE-SLOT VARIABLE-TYPE (RETURN (VARIABLE-TYPE SELF))) (HOME-MODULE ((SELF GLOBAL-VARIABLE)) :TYPE MODULE (LET ((MODULE (VARIABLE-HOME-MODULE SELF))) (IF (DEFINED? MODULE) (RETURN MODULE) (RETURN (INTERNED-IN (VARIABLE-NAME SELF))))))) :PUBLIC-SLOTS ((VARIABLE-NAME :TYPE SYMBOL) (VARIABLE-TYPE :TYPE TYPE) (VARIABLE-TYPE-SPECIFIER :TYPE TYPE-SPEC :ALLOCATION :DYNAMIC) (VARIABLE-HOME-MODULE :TYPE MODULE :ALLOCATION :DYNAMIC) (VARIABLE-SPECIAL? :TYPE BOOLEAN) (VARIABLE-CONSTANT? :TYPE BOOLEAN) (VARIABLE-PUBLIC? :TYPE BOOLEAN :INITIALLY TRUE) (VARIABLE-AUXILIARY? :TYPE BOOLEAN) (VARIABLE-THREAD-LOCAL? :TYPE BOOLEAN :OPTION-KEYWORD :THREAD-LOCAL? :ALLOCATION :DYNAMIC :DOCUMENTATION \"If true, the variable will be allocated on a per-thread
basis similar to specials for which this is always true.  CAUTION: this is
only a documentation place holder so far and not yet used by the translators.\") (VARIABLE-GET-VALUE-CODE :TYPE FUNCTION-CODE) (VARIABLE-SET-VALUE-CODE :TYPE FUNCTION-CODE) (VARIABLE-VALUE-STACK :TYPE LIST) (VARIABLE-DOCUMENTATION :TYPE STRING :RENAMES DOCUMENTATION) (VARIABLE-STRINGIFIED-SOURCE :TYPE STRING)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-GLOBAL-VARIABLE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-GLOBAL-VARIABLE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "QUOTED-EXPRESSION"
       "(DEFCLASS QUOTED-EXPRESSION (STANDARD-OBJECT) :PUBLIC-SLOTS ((QUOTATION-TABLE-OFFSET :TYPE INTEGER)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-QUOTED-EXPRESSION))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-QUOTED-EXPRESSION-SLOT-VALUE)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "VOID"
    "(DEFCLASS VOID () :ABSTRACT? TRUE :JAVA-NATIVE-TYPE \"void\" :IDL-NATIVE-TYPE \"void\" :CPP-NATIVE-TYPE \"void\")")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "UNKNOWN"
    "(DEFCLASS UNKNOWN () :ABSTRACT? TRUE :CPP-NATIVE-TYPE \"unknown\" :IDL-NATIVE-TYPE \"unknown\" :JAVA-NATIVE-TYPE \"unknown\" :SLOTS ((UNKNOWN-SLOT :TYPE UNKNOWN)))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "THING"
       "(DEFCLASS THING (STANDARD-OBJECT DYNAMIC-SLOTS-MIXIN) :ABSTRACT? TRUE :DOCUMENTATION \"Defines a class that must be inherited by any
class that participates in the PowerLoom side of things.\" :PUBLIC-SLOTS ((SURROGATE-VALUE-INVERSE :TYPE SURROGATE)) :PRINT-FORM (IF (DEFINED? (SURROGATE-VALUE-INVERSE SELF)) (PRINT-NATIVE-STREAM STREAM \"|i|\" (SYMBOL-NAME (SURROGATE-VALUE-INVERSE SELF))) (PRINT-NATIVE-STREAM STREAM \"|i|\" (PRIMARY-TYPE SELF))))")))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-THING-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CONTEXT"
       "(DEFCLASS CONTEXT (THING) :ABSTRACT? TRUE :PUBLIC-SLOTS ((CHILD-CONTEXTS :TYPE (LIST OF CONTEXT) :ALLOCATION :EMBEDDED) (BASE-MODULE :TYPE MODULE) (ALL-SUPER-CONTEXTS :TYPE (CONS OF CONTEXT)) (CONTEXT-NUMBER :TYPE INTEGER)) :METHODS ((CONTEXT-NAME ((SELF CONTEXT)) :TYPE STRING (LET ((AUX SELF)) (TYPECASE AUX (MODULE (RETURN (MODULE-NAME AUX))) (WORLD (RETURN (WORLD-NAME AUX)))))) (PARENT-CONTEXTS ((SELF CONTEXT)) :TYPE (ITERATOR OF CONTEXT)) (HOME-MODULE ((SELF CONTEXT)) :TYPE MODULE :PUBLIC? TRUE (RETURN (BASE-MODULE SELF)))) :PRINT-FORM (PRINT-CONTEXT SELF STREAM))")))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CONTEXT-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "MODULE"
       "(DEFCLASS MODULE (CONTEXT) :PUBLIC-SLOTS ((PARENT-MODULES :TYPE (LIST OF MODULE) :ALLOCATION :EMBEDDED) (DOCUMENTATION :TYPE STRING :OPTION-KEYWORD :DOCUMENTATION) (NICKNAMES :TYPE (LIST OF STRING-WRAPPER) :OPTION-KEYWORD :NICKNAMES) (USES :TYPE (LIST OF MODULE) :ALLOCATION :EMBEDDED :OPTION-KEYWORD :USES) (USED-BY :TYPE (LIST OF MODULE) :ALLOCATION :EMBEDDED) (SHADOWED-SURROGATES :TYPE (LIST OF SURROGATE) :ALLOCATION :DYNAMIC) (REQUIRES :TYPE (LIST OF MODULE) :OPTION-KEYWORD :REQUIRES) (MODULE-LISP-PACKAGE :TYPE STRING :DEFAULT \"STELLA\" :ALLOCATION :DYNAMIC :OPTION-KEYWORD :MODULE-LISP-PACKAGE) (MODULE-CPP-PACKAGE :TYPE STRING :DEFAULT \"stella\" :ALLOCATION :DYNAMIC :OPTION-KEYWORD :MODULE-CPP-PACKAGE) (JAVA-PACKAGE :TYPE STRING :DEFAULT NULL :ALLOCATION :DYNAMIC :OPTION-KEYWORD :JAVA-PACKAGE) (CASE-SENSITIVE? :TYPE BOOLEAN :INITIALLY FALSE :OPTION-KEYWORD :CASE-SENSITIVE?) (CLEARABLE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :DEFAULT TRUE :OPTION-KEYWORD :CLEARABLE?) (CODE-ONLY? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :OPTION-KEYWORD :CODE-ONLY?) (NAMESPACE? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :OPTION-KEYWORD :NAMESPACE?) (API? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :OPTION-KEYWORD :API?) (PROTECT-SURROGATES? :TYPE BOOLEAN :ALLOCATION :DYNAMIC :OPTION-KEYWORD :PROTECT-SURROGATES? :DEFAULT TRUE) (JAVA-FLOTSAM-CLASS :TYPE STRING :ALLOCATION :DYNAMIC :OPTION-KEYWORD :JAVA-CATCHALL-CLASS) (MODULE-FULL-NAME :TYPE STRING) (MODULE-NAME :TYPE STRING :ALLOCATION :INSTANCE) (MODULE-STRINGIFIED-SOURCE :TYPE STRING) (STRINGIFIED-OPTIONS :TYPE STRING) (CARDINAL-MODULE :TYPE MODULE) (SYMBOL-OFFSET-TABLE :TYPE STRING-TO-INTEGER-HASH-TABLE) (SURROGATE-OFFSET-TABLE :TYPE STRING-TO-INTEGER-HASH-TABLE) (STRICT-INFERENCE-CACHE :TYPE WORLD) (DEFAULT-INFERENCE-CACHE :TYPE WORLD) (PROTOTYPE-INFERENCE-CACHE :TYPE WORLD)) :PUBLIC-METHODS ((NAME ((SELF MODULE)) :TYPE STRING (RETURN (MODULE-NAME SELF))) (PARENT-MODULE ((SELF MODULE)) :TYPE MODULE (RETURN (POP (PARENT-CONTEXTS SELF)))) (LISP-PACKAGE ((SELF MODULE)) :TYPE STRING :STORAGE-SLOT MODULE-LISP-PACKAGE :INHERITS-THROUGH PARENT-MODULES) (CPP-PACKAGE ((SELF MODULE)) :TYPE STRING :STORAGE-SLOT MODULE-CPP-PACKAGE :INHERITS-THROUGH PARENT-MODULES)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-MODULE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-MODULE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "WORLD"
       "(DEFCLASS WORLD (CONTEXT) :PUBLIC-SLOTS ((PARENT-CONTEXT :TYPE CONTEXT) (CHILD-CONTEXTS :TYPE (LIST OF WORLD) :ALLOCATION :EMBEDDED) (WORLD-NAME :TYPE STRING :ALLOCATION :DYNAMIC)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-WORLD))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-WORLD-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CS-VALUE"
       "(DEFCLASS CS-VALUE (KEY-VALUE-LIST) :DOCUMENTATION \"Contextualized value.  Contains a sorted kv-cons list indexed
by context. The kv-cons list is never null.  Newer (higher numbered) contexts
appear first.\" :PARAMETERS ((ANY-KEY :TYPE CONTEXT) (ANY-VALUE :TYPE OBJECT)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CS-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INTERVAL"
       "(DEFCLASS INTERVAL (STANDARD-OBJECT) :PUBLIC-SLOTS ((LOWER-BOUND :TYPE INTEGER) (UPPER-BOUND :TYPE INTEGER)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"[\" (LOWER-BOUND SELF) \",\" (UPPER-BOUND SELF) \"]\"))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-INTERVAL))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-INTERVAL-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TAXONOMY-NODE"
       "(DEFCLASS TAXONOMY-NODE (STANDARD-OBJECT) :PUBLIC-SLOTS ((NATIVE-OBJECT :TYPE OBJECT) (LABEL :TYPE INTEGER) (INTERVALS :TYPE (CONS OF INTERVAL) :INITIALLY NIL) (INITIAL-INTERVAL :TYPE INTERVAL) (FIRST-INTERVAL-LOWER-BOUND :TYPE INTEGER :INITIALLY -1) (FIRST-INTERVAL-UPPER-BOUND :TYPE INTEGER :INITIALLY -1) (PARENTS :TYPE (CONS OF TAXONOMY-NODE) :INITIALLY NIL) (CHILDREN :TYPE (CONS OF TAXONOMY-NODE) :INITIALLY NIL) (TOTAL-ANCESTORS :TYPE INTEGER :INITIALLY 1) (TREE-CHILDREN :TYPE (CONS OF TAXONOMY-NODE) :INITIALLY NIL) (MARKER :TYPE OBJECT)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|TN|\" (LABEL SELF) \" \" (INTERVALS SELF) \" \" (NATIVE-OBJECT SELF)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TAXONOMY-NODE))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TAXONOMY-NODE-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TAXONOMY-GRAPH"
       "(DEFCLASS TAXONOMY-GRAPH (STANDARD-OBJECT) :PUBLIC-SLOTS ((RENUMBER-IF-OUT-OF-NUMBERS? :DOCUMENTATION \"If TRUE, relabel the entire graph when a new interval
for an incrementally inserted node can't be allocated due to lack of
splittable interval space.  Otherwise, create a `foreign' interval and
propagate it.\" :TYPE BOOLEAN :INITIALLY FALSE) (RENUMBER-RATIO :DOCUMENTATION \"Whenever the ratio between foreign intervals and
non-foreign intervals becomes greater than `renumber-ratio', relabel
the whole graph non-incrementally.\" :TYPE FLOAT :INITIALLY 0.1)) :SLOTS ((INCREMENTAL-MODE? :TYPE BOOLEAN) (LARGEST-POSTORDER-NUMBER :TYPE INTEGER) (NUMBER-OF-NODES :TYPE INTEGER) (NUMBER-OF-FOREIGN-INTERVAL-NODES :TYPE INTEGER) (ROOTS :TYPE (LIST OF TAXONOMY-NODE)) (BROKEN-LINKS :TYPE (LIST OF (CONS OF TAXONOMY-NODE))) (ADDED-LINKS :TYPE (LIST OF (CONS OF TAXONOMY-NODE))) (REMOVED-LINKS :TYPE (LIST OF (CONS OF TAXONOMY-NODE)))) :INITIALIZER INITIALIZE-TAXONOMY-GRAPH :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|TG|\" (ROOTS SELF)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TAXONOMY-GRAPH))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TAXONOMY-GRAPH-SLOT-VALUE)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NATIVE-EXCEPTION"
    "(DEFCLASS NATIVE-EXCEPTION () :JAVA-NATIVE-TYPE \"java.lang.Exception\" :CL-NATIVE-TYPE \"CONDITION\" :CPP-NATIVE-TYPE \"std::exception\")")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STELLA-ROOT-EXCEPTION"
    "(DEFCLASS STELLA-ROOT-EXCEPTION (NATIVE-EXCEPTION) :PUBLIC-SLOTS ((MESSAGE :TYPE STRING :READER EXCEPTION-MESSAGE :REQUIRED? TRUE :ABSTRACT? TRUE)) :ABSTRACT? TRUE :JAVA-NATIVE-TYPE \"java.lang.RuntimeException\" :CL-NATIVE-TYPE \"SIMPLE-ERROR\" :CPP-NATIVE-TYPE \"std::runtime_error\")")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STELLA-EXCEPTION"
       "(DEFCLASS STELLA-EXCEPTION (STELLA-ROOT-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-STELLA-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INPUT-OUTPUT-EXCEPTION"
       "(DEFCLASS INPUT-OUTPUT-EXCEPTION (STELLA-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-INPUT-OUTPUT-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "READ-EXCEPTION"
       "(DEFCLASS READ-EXCEPTION (INPUT-OUTPUT-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-READ-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "END-OF-FILE-EXCEPTION"
       "(DEFCLASS END-OF-FILE-EXCEPTION (INPUT-OUTPUT-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-END-OF-FILE-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NO-SUCH-FILE-EXCEPTION"
       "(DEFCLASS NO-SUCH-FILE-EXCEPTION (INPUT-OUTPUT-EXCEPTION) :PUBLIC? TRUE :PUBLIC-SLOTS ((FILENAME :TYPE STRING)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-NO-SUCH-FILE-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "FILE-ALREADY-EXISTS-EXCEPTION"
       "(DEFCLASS FILE-ALREADY-EXISTS-EXCEPTION (INPUT-OUTPUT-EXCEPTION) :PUBLIC? TRUE :PUBLIC-SLOTS ((FILENAME :TYPE STRING)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-FILE-ALREADY-EXISTS-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "UNHANDLED-EXCEPTION"
       "(DEFCLASS UNHANDLED-EXCEPTION (STELLA-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-UNHANDLED-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "EVALUATION-EXCEPTION"
       "(DEFCLASS EVALUATION-EXCEPTION (STELLA-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EVALUATION-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NO-SUCH-OBJECT-EXCEPTION"
       "(DEFCLASS NO-SUCH-OBJECT-EXCEPTION (STELLA-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-NO-SUCH-OBJECT-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NO-SUCH-CONTEXT-EXCEPTION"
       "(DEFCLASS NO-SUCH-CONTEXT-EXCEPTION (NO-SUCH-OBJECT-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-NO-SUCH-CONTEXT-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "UNDEFINED-CLASS-EXCEPTION"
       "(DEFCLASS UNDEFINED-CLASS-EXCEPTION (NO-SUCH-OBJECT-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-UNDEFINED-CLASS-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BAD-ARGUMENT-EXCEPTION"
       "(DEFCLASS BAD-ARGUMENT-EXCEPTION (STELLA-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-BAD-ARGUMENT-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "OBJECT-NOT-CLASS-EXCEPTION"
       "(DEFCLASS OBJECT-NOT-CLASS-EXCEPTION (BAD-ARGUMENT-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-OBJECT-NOT-CLASS-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "INCOMPATIBLE-QUANTITY-EXCEPTION"
       "(DEFCLASS INCOMPATIBLE-QUANTITY-EXCEPTION (STELLA-EXCEPTION) :PUBLIC? TRUE :DOCUMENTATION \"Exception thrown when an operation is attempted on quantities
that are not compatible with the requested operation.  For example,
comparing dates and time durations.\")")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-INCOMPATIBLE-QUANTITY-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TIMEOUT-EXCEPTION"
       "(DEFCLASS TIMEOUT-EXCEPTION (STELLA-EXCEPTION) :PUBLIC? TRUE)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TIMEOUT-EXCEPTION)))
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "QUANTITY"
    "(DEFCLASS QUANTITY (OBJECT) :PUBLIC? TRUE :ABSTRACT? TRUE :DOCUMENTATION \"General superclass for extensible quantity objects\" :PUBLIC-METHODS ((COERCE-TO ((SELF QUANTITY) (OTHER OBJECT)) :TYPE QUANTITY (IF (ISA? OTHER (PRIMARY-TYPE SELF)) (RETURN OTHER) (RETURN NULL))) (LESS? ((SELF QUANTITY) (OTHER OBJECT)) :TYPE BOOLEAN (IGNORE OTHER) (RETURN FALSE)) (LESS-EQUAL? ((SELF QUANTITY) (OTHER OBJECT)) :TYPE BOOLEAN (RETURN (OR (OBJECT-EQL? SELF OTHER) (LESS? SELF OTHER)))) (GREATER-EQUAL? ((SELF QUANTITY) (OTHER OBJECT)) :TYPE BOOLEAN (RETURN (OR (OBJECT-EQL? SELF OTHER) (GREATER? SELF OTHER)))) (GREATER? ((SELF QUANTITY) (OTHER OBJECT)) :TYPE BOOLEAN (IGNORE OTHER) (RETURN FALSE))))")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "LITERAL"
    "(DEFCLASS LITERAL (NON-OBJECT) :ABSTRACT? TRUE)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NUMBER"
    "(DEFCLASS NUMBER (LITERAL) :ABSTRACT? TRUE)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INTEGER"
    "(DEFCLASS INTEGER (NUMBER) :CL-NATIVE-TYPE \"FIXNUM\" :CPP-NATIVE-TYPE \"int\" :IDL-NATIVE-TYPE \"long\" :JAVA-NATIVE-TYPE \"int\" :INITIAL-VALUE NULL-INTEGER :EQUALITY-TEST EQL?)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FLOAT"
    "(DEFCLASS FLOAT (NUMBER) :CL-NATIVE-TYPE \"FLOAT\" :CPP-NATIVE-TYPE \"double\" :IDL-NATIVE-TYPE \"double\" :JAVA-NATIVE-TYPE \"double\" :INITIAL-VALUE NULL-FLOAT :EQUALITY-TEST EQL?)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "MUTABLE-STRING"
    "(DEFCLASS MUTABLE-STRING (LITERAL) :CL-NATIVE-TYPE \"STRING\" :IDL-NATIVE-TYPE \"string\" :JAVA-NATIVE-TYPE \"StringBuffer\" :CPP-NATIVE-TYPE \"char*\" :EQUALITY-TEST STRING-EQL? :INITIAL-VALUE (VERBATIM :COMMON-LISP \"STELLA::NULL-STRING\" :JAVA \"null\" :CPP \"NULL\"))")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STRING"
    "(DEFCLASS STRING (LITERAL) :SYNONYMS (FILE-NAME) :CL-NATIVE-TYPE \"STRING\" :IDL-NATIVE-TYPE \"string\" :JAVA-NATIVE-TYPE \"String\" :CPP-NATIVE-TYPE \"char*\" :EQUALITY-TEST STRING-EQL? :INITIAL-VALUE (VERBATIM :COMMON-LISP \"STELLA::NULL-STRING\" :JAVA \"null\" :CPP \"NULL\"))")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CHARACTER"
    "(DEFCLASS CHARACTER (LITERAL) :CL-NATIVE-TYPE \"CHARACTER\" :CPP-NATIVE-TYPE \"char\" :IDL-NATIVE-TYPE \"char\" :JAVA-NATIVE-TYPE \"char\" :INITIAL-VALUE NULL-CHARACTER)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SHORT-INTEGER"
    "(DEFCLASS SHORT-INTEGER (NUMBER) :CL-NATIVE-TYPE \"FIXNUM\" :CPP-NATIVE-TYPE \"short int\" :IDL-NATIVE-TYPE \"short int\" :JAVA-NATIVE-TYPE \"short\" :INITIAL-VALUE NULL-SHORT-INTEGER :EQUALITY-TEST EQL?)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "LONG-INTEGER"
    "(DEFCLASS LONG-INTEGER (NUMBER) :CL-NATIVE-TYPE \"INTEGER\" :CPP-NATIVE-TYPE \"long long int\" :IDL-NATIVE-TYPE \"long int\" :JAVA-NATIVE-TYPE \"long\" :INITIAL-VALUE NULL-LONG-INTEGER :EQUALITY-TEST EQL?)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "UNSIGNED-SHORT-INTEGER"
    "(DEFCLASS UNSIGNED-SHORT-INTEGER (NUMBER) :CL-NATIVE-TYPE \"INTEGER\" :CPP-NATIVE-TYPE \"unsigned short int\" :IDL-NATIVE-TYPE \"unsigned short int\" :JAVA-NATIVE-TYPE \"short\" :INITIAL-VALUE NULL-UNSIGNED-SHORT-INTEGER :EQUALITY-TEST EQL?)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "UNSIGNED-LONG-INTEGER"
    "(DEFCLASS UNSIGNED-LONG-INTEGER (NUMBER) :CL-NATIVE-TYPE \"INTEGER\" :IDL-NATIVE-TYPE \"unsigned long int\" :CPP-NATIVE-TYPE \"unsigned long int\" :JAVA-NATIVE-TYPE \"long\" :INITIAL-VALUE NULL-UNSIGNED-LONG-INTEGER :EQUALITY-TEST EQL?)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SINGLE-FLOAT"
    "(DEFCLASS SINGLE-FLOAT (NUMBER) :CL-NATIVE-TYPE \"FLOAT\" :JAVA-NATIVE-TYPE \"float\" :IDL-NATIVE-TYPE \"float\" :CPP-NATIVE-TYPE \"float\" :INITIAL-VALUE NULL-SINGLE-FLOAT :EQUALITY-TEST EQL?)")
   (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DOUBLE-FLOAT"
    "(DEFCLASS DOUBLE-FLOAT (NUMBER) :CL-NATIVE-TYPE \"FLOAT\" :CPP-NATIVE-TYPE \"double\" :JAVA-NATIVE-TYPE \"double\" :IDL-NATIVE-TYPE \"double\" :INITIAL-VALUE NULL-DOUBLE-FLOAT :EQUALITY-TEST EQL?)"))
  :VOID)

(CL:DEFUN STARTUP-HIERARCHY ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-HIERARCHY1)
    (HELP-STARTUP-HIERARCHY2) (HELP-STARTUP-HIERARCHY3)
    (HELP-STARTUP-HIERARCHY4) (HELP-STARTUP-HIERARCHY5)
    (HELP-STARTUP-HIERARCHY6))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN* CL:NIL)
    (CL:SETQ *HARDWIRED-CLASS-ARITY-ON-CLASS* NULL-INTEGER))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5) (HELP-STARTUP-HIERARCHY7)
    (HELP-STARTUP-HIERARCHY8)
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BYTE"
     "(DEFCLASS BYTE (LITERAL) :CL-NATIVE-TYPE \"FIXNUM\" :CPP-NATIVE-TYPE \"char\" :IDL-NATIVE-TYPE \"char\" :JAVA-NATIVE-TYPE \"byte\" :INITIAL-VALUE NULL-BYTE :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "OCTET"
     "(DEFCLASS OCTET (BYTE) :CL-NATIVE-TYPE \"FIXNUM\" :CPP-NATIVE-TYPE \"char\" :IDL-NATIVE-TYPE \"octet\" :JAVA-NATIVE-TYPE \"byte\" :INITIAL-VALUE NULL-OCTET :EQUALITY-TEST EQL?)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "WRAPPER"
     "(DEFCLASS WRAPPER (OBJECT) :PUBLIC-SLOTS ((WRAPPER-VALUE :TYPE UNKNOWN :REQUIRED? TRUE)) :KEY (WRAPPER-VALUE) :PUBLIC? TRUE :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "LITERAL-WRAPPER"
     "(DEFCLASS LITERAL-WRAPPER (WRAPPER) :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NUMBER-WRAPPER"
     "(DEFCLASS NUMBER-WRAPPER (LITERAL-WRAPPER) :ABSTRACT? TRUE)")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INTEGER-WRAPPER"
        "(DEFCLASS INTEGER-WRAPPER (NUMBER-WRAPPER) :PUBLIC-SLOTS ((WRAPPER-VALUE :TYPE INTEGER)) :PRINT-FORM (LET ((VALUE (WRAPPER-VALUE SELF))) (IF (NULL? VALUE) (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (QUOTE NULL-INTEGER)) (PRINT-NATIVE-STREAM STREAM \"|L|NULL-INTEGER\")) (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM VALUE) (PRINT-NATIVE-STREAM STREAM \"|L|\" VALUE)))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INTEGER-WRAPPER))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INTEGER-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "LONG-INTEGER-WRAPPER"
        "(DEFCLASS LONG-INTEGER-WRAPPER (NUMBER-WRAPPER) :SLOTS ((WRAPPER-VALUE :TYPE LONG-INTEGER)) :PRINT-FORM (LET ((VALUE (WRAPPER-VALUE SELF))) (IF (NULL? VALUE) (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (QUOTE NULL-LONG-INTEGER)) (PRINT-NATIVE-STREAM STREAM \"|L|NULL-LONG-INTEGER\")) (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM VALUE) (PRINT-NATIVE-STREAM STREAM \"|L|\" VALUE)))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-LONG-INTEGER-WRAPPER))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-LONG-INTEGER-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FLOAT-WRAPPER"
        "(DEFCLASS FLOAT-WRAPPER (NUMBER-WRAPPER) :PUBLIC-SLOTS ((WRAPPER-VALUE :TYPE FLOAT)) :PRINT-FORM (LET ((VALUE (WRAPPER-VALUE SELF))) (IF (NULL? VALUE) (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (QUOTE NULL-FLOAT)) (PRINT-NATIVE-STREAM STREAM \"|L|NULL-FLOAT\")) (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM VALUE) (PRINT-NATIVE-STREAM STREAM \"|L|\" VALUE)))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-FLOAT-WRAPPER))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-FLOAT-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STRING-WRAPPER"
        "(DEFCLASS STRING-WRAPPER (LITERAL-WRAPPER) :PUBLIC-SLOTS ((WRAPPER-VALUE :TYPE STRING)) :PRINT-FORM (LET ((VALUE (WRAPPER-VALUE SELF))) (IF (NULL? VALUE) (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (QUOTE NULL-STRING)) (PRINT-NATIVE-STREAM STREAM \"|L|NULL-STRING\")) (IF *PRINTREADABLY?* (PRINT-STRING-READABLY VALUE STREAM) (PRINT-NATIVE-STREAM STREAM \"|L|\" #\\\" VALUE #\\\")))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-STRING-WRAPPER))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-STRING-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "MUTABLE-STRING-WRAPPER"
        "(DEFCLASS MUTABLE-STRING-WRAPPER (LITERAL-WRAPPER) :PUBLIC-SLOTS ((WRAPPER-VALUE :TYPE MUTABLE-STRING)) :PRINT-FORM (LET ((VALUE (WRAPPER-VALUE SELF))) (IF (NULL? VALUE) (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (QUOTE NULL-MUTABLE-STRING)) (PRINT-NATIVE-STREAM STREAM \"|L|NULL-MUTABLE-STRING\")) (IF *PRINTREADABLY?* (PRINT-STRING-READABLY VALUE STREAM) (PRINT-NATIVE-STREAM STREAM \"|L|\" #\\\" (MUTABLE-STRING-TO-STRING VALUE) #\\\")))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-MUTABLE-STRING-WRAPPER)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CHARACTER-WRAPPER"
        "(DEFCLASS CHARACTER-WRAPPER (LITERAL-WRAPPER) :PUBLIC-SLOTS ((WRAPPER-VALUE :TYPE CHARACTER)) :PRINT-FORM (LET ((VALUE (WRAPPER-VALUE SELF))) (IF (NULL? VALUE) (IF *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM (QUOTE NULL-CHARACTER)) (PRINT-NATIVE-STREAM STREAM \"|L|NULL-CHARACTER\")) (PROGN (UNLESS *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM \"|L|\")) (PRINT-CHARACTER VALUE STREAM)))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CHARACTER-WRAPPER))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CHARACTER-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BOOLEAN-WRAPPER"
        "(DEFCLASS BOOLEAN-WRAPPER (LITERAL-WRAPPER) :DOCUMENTATION \"Objectified version of the BOOLEAN data type.  The NULL
value can be used for a 3-valued semantics (see THREE-VALUED-BOOLEAN).\" :PUBLIC-SLOTS ((WRAPPER-VALUE :TYPE BOOLEAN :ALLOCATION :INSTANCE)) :PRINT-FORM (PROGN (UNLESS *PRINTREADABLY?* (PRINT-NATIVE-STREAM STREAM \"|L|\")) (IF (WRAPPER-VALUE SELF) (PRINT-NATIVE-STREAM STREAM (QUOTE TRUE)) (PRINT-NATIVE-STREAM STREAM (QUOTE FALSE)))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-BOOLEAN-WRAPPER))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-BOOLEAN-WRAPPER-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CODE-WRAPPER"
     "(DEFCLASS CODE-WRAPPER (WRAPPER) :ABSTRACT? TRUE)")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FUNCTION-CODE-WRAPPER"
        "(DEFCLASS FUNCTION-CODE-WRAPPER (CODE-WRAPPER) :PUBLIC-SLOTS ((WRAPPER-VALUE :TYPE FUNCTION-CODE)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-FUNCTION-CODE-WRAPPER))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-FUNCTION-CODE-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "METHOD-CODE-WRAPPER"
        "(DEFCLASS METHOD-CODE-WRAPPER (CODE-WRAPPER) :PUBLIC-SLOTS ((WRAPPER-VALUE :TYPE METHOD-CODE)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-METHOD-CODE-WRAPPER))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-METHOD-CODE-WRAPPER-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "VERBATIM-STRING-WRAPPER"
        "(DEFCLASS VERBATIM-STRING-WRAPPER (STRING-WRAPPER) :DOCUMENTATION \"Wrapper class used to hold verbatim native code strings.\" :PRINT-FORM (PRINT-NATIVE-STREAM STREAM (CHOOSE *PRINTREADABLY?* \"\" \"|V|\") (WRAPPER-VALUE SELF)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-VERBATIM-STRING-WRAPPER)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "BOOLEAN"
     "(DEFCLASS BOOLEAN (LITERAL) :DOCUMENTATION \"Boolean type with values TRUE and FALSE.\" :INITIAL-VALUE FALSE :CL-NATIVE-TYPE \"FIXNUM\" :CPP-NATIVE-TYPE \"boolean\" :IDL-NATIVE-TYPE \"boolean\" :JAVA-NATIVE-TYPE \"boolean\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ONE-BIT-BOOLEAN"
     "(DEFCLASS ONE-BIT-BOOLEAN (BOOLEAN) :DOCUMENTATION \"Space-saving representation of BOOLEAN which takes longer
to read and write than BOOLEAN.  Not yet implemented.\" :CPP-NATIVE-TYPE \"one_bit_boolean\")")
    (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
     "(DEFTYPE THREE-VALUED-BOOLEAN BOOLEAN-WRAPPER)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CODE"
     "(DEFCLASS CODE (LITERAL) :ABSTRACT? TRUE)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FUNCTION-CODE"
     "(DEFCLASS FUNCTION-CODE (CODE) :CL-NATIVE-TYPE \"FUNCTION\" :JAVA-NATIVE-TYPE \"java.lang.reflect.Method\" :CPP-NATIVE-TYPE \"cpp_function_code\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "METHOD-CODE"
     "(DEFCLASS METHOD-CODE (CODE) :CL-NATIVE-TYPE \"STANDARD-GENERIC-FUNCTION\" :JAVA-NATIVE-TYPE \"java.lang.reflect.Method\" :CPP-NATIVE-TYPE \"cpp_method_code\" :INITIAL-VALUE (SAFE-CAST NULL @METHOD-CODE))")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "LISP-CODE"
     "(DEFCLASS LISP-CODE () :ABSTRACT? TRUE :DOCUMENTATION \"Used to indicate variables that input or output Common Lisp~
      structures.\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "THIRTY-TWO-BIT-VECTOR"
     "(DEFCLASS THIRTY-TWO-BIT-VECTOR (INTEGER) :CL-NATIVE-TYPE \"FIXNUM\" :CPP-NATIVE-TYPE \"long\" :JAVA-NATIVE-TYPE \"int\" :DOCUMENTATION \"Bit vector used to implement BOOLEAN slots.\" :INITIAL-VALUE NULL-INTEGER)")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TICKTOCK"
     "(DEFCLASS TICKTOCK () :DOCUMENTATION \"A data type that is used to hold information for computing
timing of code.  It is intentionally opaque to the user.
It should only be used as an argument to the TICKTOCK-DIFFERENCE
function.  Values are obtained with the GET-TICKTOCK function.\" :CPP-NATIVE-TYPE \"clock_t\" :CL-NATIVE-TYPE \"FIXNUM\" :JAVA-NATIVE-TYPE \"long\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NATIVE-OBJECT-POINTER"
     "(DEFCLASS NATIVE-OBJECT-POINTER (SECOND-CLASS-OBJECT) :DOCUMENTATION \"A pointer type that can point at an arbitrary native
non-literal object.  Usable to store native objects that fall outside the
STELLA OBJECT hierarchy (e.g., native arrays) without having to use their
exact type.\" :CL-NATIVE-TYPE \"T\" :CPP-NATIVE-TYPE \"char*\" :JAVA-NATIVE-TYPE \"Object\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PROCESS-LOCK-OBJECT"
     "(DEFCLASS PROCESS-LOCK-OBJECT () :DOCUMENTATION \"A process lock object for synchronizing in a multi-threaded environment.
Fully supported in Java; supported in some Common Lisp systems; not supported
in C++.\" :CL-NATIVE-TYPE \"T\" :CPP-NATIVE-TYPE \"char*\" :JAVA-NATIVE-TYPE \"Object\")")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SYSTEM-DEFINITION"
        "(DEFCLASS SYSTEM-DEFINITION (STANDARD-OBJECT) :DOCUMENTATION \"The System-Definition class is used to define systems of files
that constitute Stella applications.\" :SLOTS ((NAME :TYPE STRING) (DIRECTORY :TYPE FILE-NAME) (FILES :TYPE (CONS OF STRING-WRAPPER)) (LISP-ONLY-FILES :TYPE (CONS OF STRING-WRAPPER)) (CPP-ONLY-FILES :TYPE (CONS OF STRING-WRAPPER)) (JAVA-ONLY-FILES :TYPE (CONS OF STRING-WRAPPER)) (DATA-FILES :TYPE (CONS OF STRING-WRAPPER)) (PREPROCESSED-FILES :TYPE (CONS OF STRING-WRAPPER)) (REQUIRED-SYSTEMS :TYPE (CONS OF STRING-WRAPPER)) (LOADED? :TYPE BOOLEAN) (UP-TO-DATE? :TYPE BOOLEAN) (CARDINAL-MODULE :TYPE STRING) (SOURCE-ROOT-DIRECTORY :TYPE FILE-NAME) (NATIVE-ROOT-DIRECTORY :TYPE FILE-NAME) (BINARY-ROOT-DIRECTORY :TYPE FILE-NAME) (BANNER :TYPE STRING) (COPYRIGHT-HEADER :RENAMES BANNER) (PRODUCTION-SETTINGS :TYPE (CONS OF INTEGER-WRAPPER)) (DEVELOPMENT-SETTINGS :TYPE (CONS OF INTEGER-WRAPPER)) (FINALIZATION-FUNCTION :TYPE SYMBOL)) :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|SYSTEM|\" (NAME SELF)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SYSTEM-DEFINITION))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SYSTEM-DEFINITION-SLOT-VALUE)))
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ARGUMENT-LIST"
     "(DEFCLASS ARGUMENT-LIST () :PARAMETERS ((ANY-VALUE :TYPE UNKNOWN)) :PUBLIC-METHODS ((LENGTH ((SELF ARGUMENT-LIST)) :TYPE INTEGER :NATIVE? TRUE)) :METHODS ((ALLOCATE-ITERATOR ((SELF ARGUMENT-LIST)) :TYPE (ARGUMENT-LIST-ITERATOR OF (LIKE (ANY-VALUE SELF))) :NATIVE? TRUE)) :CL-NATIVE-TYPE \"CONS\" :CPP-NATIVE-TYPE \"void\" :JAVA-NATIVE-TYPE \"void\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ARGUMENT-LIST-ITERATOR"
     "(DEFCLASS ARGUMENT-LIST-ITERATOR (ABSTRACT-ITERATOR) :PUBLIC-SLOTS ((VALUE :READER ARGUMENT)) :METHODS ((ARGUMENT ((SELF ARGUMENT-LIST-ITERATOR)) :TYPE (LIKE (ANY-VALUE SELF)) :NATIVE? TRUE) (NEXT? ((SELF ARGUMENT-LIST-ITERATOR)) :TYPE BOOLEAN :NATIVE? TRUE)) :CL-NATIVE-TYPE \"CONS\" :CPP-NATIVE-TYPE \"va_list\" :JAVA-NATIVE-TYPE \"void\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NATIVE-STREAM"
     "(DEFCLASS NATIVE-STREAM () :ABSTRACT? TRUE :CPP-NATIVE-TYPE \"std::ios*\" :JAVA-NATIVE-TYPE \"Object\" :CL-NATIVE-TYPE \"STREAM\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NATIVE-OUTPUT-STREAM"
     "(DEFCLASS NATIVE-OUTPUT-STREAM (NATIVE-STREAM) :ABSTRACT? TRUE :CPP-NATIVE-TYPE \"std::ostream*\" :JAVA-NATIVE-TYPE \"java.io.PrintStream\" :CL-NATIVE-TYPE \"STREAM\")")
    (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NATIVE-INPUT-STREAM"
     "(DEFCLASS NATIVE-INPUT-STREAM (NATIVE-STREAM) :ABSTRACT? TRUE :CPP-NATIVE-TYPE \"std::istream*\" :JAVA-NATIVE-TYPE \"java.io.PushbackInputStream\" :CL-NATIVE-TYPE \"STREAM\")")
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "STREAM"
        "(DEFCLASS STREAM (STANDARD-OBJECT) :ABSTRACT? TRUE :PUBLIC-SLOTS ((STATE :TYPE KEYWORD)))")))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-STREAM-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "OUTPUT-STREAM"
        "(DEFCLASS OUTPUT-STREAM (STREAM) :PUBLIC-SLOTS ((NATIVE-STREAM :TYPE NATIVE-OUTPUT-STREAM :PUBLIC? TRUE) (NATIVE-OUTPUT-STREAM :RENAMES NATIVE-STREAM)) :TERMINATOR TERMINATE-OUTPUT-STREAM?)")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-OUTPUT-STREAM)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INPUT-STREAM"
        "(DEFCLASS INPUT-STREAM (STREAM) :PUBLIC-SLOTS ((NATIVE-STREAM :TYPE NATIVE-INPUT-STREAM :PUBLIC? TRUE) (NATIVE-INPUT-STREAM :RENAMES NATIVE-STREAM) (ECHO-STREAM :TYPE OUTPUT-STREAM) (TOKENIZER-STATE :TYPE TOKENIZER-STREAM-STATE) (BUFFERING-SCHEME :TYPE KEYWORD :INITIALLY :LINE :DOCUMENTATION \"One of :CHARACTER, :LINE or :BLOCK indicating what kind of
input buffer we are reading from.  This determines what read function to use
for tokenization.\")) :TERMINATOR TERMINATE-INPUT-STREAM?)")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INPUT-STREAM))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INPUT-STREAM-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "OUTPUT-FILE-STREAM"
        "(DEFCLASS OUTPUT-FILE-STREAM (OUTPUT-STREAM) :SYNONYMS (FILE-OUTPUT-STREAM) :PUBLIC-SLOTS ((FILENAME :TYPE STRING :REQUIRED? TRUE :PUBLIC? TRUE) (IF-EXISTS-ACTION :TYPE KEYWORD :INITIALLY :SUPERSEDE :PUBLIC? TRUE) (IF-NOT-EXISTS-ACTION :TYPE KEYWORD :INITIALLY :CREATE :PUBLIC? TRUE)) :INITIALIZER INITIALIZE-FILE-OUTPUT-STREAM :TERMINATOR TERMINATE-FILE-OUTPUT-STREAM? :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|FOS|'\" (FILENAME SELF) \"'\"))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-OUTPUT-FILE-STREAM))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-OUTPUT-FILE-STREAM-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INPUT-FILE-STREAM"
        "(DEFCLASS INPUT-FILE-STREAM (INPUT-STREAM) :SYNONYMS (FILE-INPUT-STREAM) :PUBLIC-SLOTS ((FILENAME :TYPE STRING :REQUIRED? TRUE :PUBLIC? TRUE) (IF-NOT-EXISTS-ACTION :TYPE KEYWORD :INITIALLY :ERROR :PUBLIC? TRUE) (BUFFERING-SCHEME :INITIALLY :BLOCK)) :INITIALIZER INITIALIZE-FILE-INPUT-STREAM :TERMINATOR TERMINATE-FILE-INPUT-STREAM? :PRINT-FORM (PRINT-NATIVE-STREAM STREAM \"|FIS|'\" (FILENAME SELF) \"'\"))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INPUT-FILE-STREAM))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INPUT-FILE-STREAM-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "OUTPUT-STRING-STREAM"
        "(DEFCLASS OUTPUT-STRING-STREAM (OUTPUT-STREAM) :SYNONYMS (STRING-OUTPUT-STREAM) :PUBLIC-SLOTS ((THE-STRING :TYPE STRING :PUBLIC? TRUE :READER THE-STRING-READER)) :TERMINATOR TERMINATE-STRING-OUTPUT-STREAM? :INITIALIZER INITIALIZE-STRING-OUTPUT-STREAM)")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-OUTPUT-STRING-STREAM))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-OUTPUT-STRING-STREAM-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INPUT-STRING-STREAM"
        "(DEFCLASS INPUT-STRING-STREAM (INPUT-STREAM) :SYNONYMS (STRING-INPUT-STREAM) :PUBLIC-SLOTS ((THE-STRING :TYPE STRING :REQUIRED? TRUE :PUBLIC? TRUE) (BUFFERING-SCHEME :INITIALLY :BLOCK)) :TERMINATOR TERMINATE-STRING-INPUT-STREAM? :INITIALIZER INITIALIZE-STRING-INPUT-STREAM)")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INPUT-STRING-STREAM))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INPUT-STRING-STREAM-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (TRANSIENT? BOOLEAN) ((SELF TRANSIENT-MIXIN)) :AUXILIARY? TRUE (RETURN *HARDWIRED-TRANSIENT?-ON-TRANSIENT-MIXIN*))"
     NULL NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (BAD? BOOLEAN-WRAPPER) ((SELF DYNAMIC-SLOTS-MIXIN)) :AUXILIARY? TRUE (LET ((ANSWER (SLOT-VALUE SELF BAD?))) (IF (NULL? ANSWER) (RETURN FALSE) (RETURN ANSWER))))"
     NULL NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-HIERARCHY"
     "(DEFUN STARTUP-HIERARCHY () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-HIERARCHY) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-HIERARCHY-STELLA-STARTUP-HIERARCHY)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-HIERARCHY-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupHierarchy") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "/STELLA")))))
  :VOID)
