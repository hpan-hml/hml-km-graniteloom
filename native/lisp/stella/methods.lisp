;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; methods.lisp

#|
+---------------------------- BEGIN LICENSE BLOCK ---------------------------+
|                                                                            |
| Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
|                                                                            |
| The contents of this file are subject to the Mozilla Public License        |
| Version 1.1 (the "License"); you may not use this file except in           |
| compliance with the License. You may obtain a copy of the License at       |
| http://www.mozilla.org/MPL/                                                |
|                                                                            |
| Software distributed under the License is distributed on an "AS IS" basis, |
| WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
| for the specific language governing rights and limitations under the       |
| License.                                                                   |
|                                                                            |
| The Original Code is the STELLA Programming Language.                      |
|                                                                            |
| The Initial Developer of the Original Code is                              |
| UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
| 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
|                                                                            |
| Portions created by the Initial Developer are Copyright (C) 1996-2006      |
| the Initial Developer. All Rights Reserved.                                |
|                                                                            |
| Contributor(s):                                                            |
|                                                                            |
| Alternatively, the contents of this file may be used under the terms of    |
| either the GNU General Public License Version 2 or later (the "GPL"), or   |
| the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
| in which case the provisions of the GPL or the LGPL are applicable instead |
| of those above. If you wish to allow use of your version of this file only |
| under the terms of either the GPL or the LGPL, and not to allow others to  |
| use your version of this file under the terms of the MPL, indicate your    |
| decision by deleting the provisions above and replace them with the notice |
| and other provisions required by the GPL or the LGPL. If you do not delete |
| the provisions above, a recipient may use your version of this file under  |
| the terms of any one of the MPL, the GPL or the LGPL.                      |
|                                                                            |
+---------------------------- END LICENSE BLOCK -----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-METHODS-STELLA-SURROGATE NULL)
(CL:DEFVAR SGT-METHODS-STELLA-PARAMETRIC-TYPE-SPECIFIER NULL)
(CL:DEFVAR SGT-METHODS-STELLA-ANCHORED-TYPE-SPECIFIER NULL)
(CL:DEFVAR SGT-METHODS-STELLA-OBJECT NULL)
(CL:DEFVAR SGT-METHODS-STELLA-VOID NULL)
(CL:DEFVAR SYM-METHODS-STELLA-LIKE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SIZE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-UNKNOWN NULL)
(CL:DEFVAR SYM-METHODS-STELLA-OF NULL)
(CL:DEFVAR SYM-METHODS-STELLA-NULL NULL)
(CL:DEFVAR SGT-METHODS-STELLA-ARRAY NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SELF NULL)
(CL:DEFVAR SYM-METHODS-STELLA-IN NULL)
(CL:DEFVAR SYM-METHODS-STELLA-OUT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-INOUT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-PARAMETER-DIRECTIONS NULL)
(CL:DEFVAR SYM-METHODS-STELLA-ARGUMENT-LIST NULL)
(CL:DEFVAR |SYM-METHODS-STELLA-&REST| NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-VARIABLE-ARGUMENTS? NULL)
(CL:DEFVAR |SYM-METHODS-STELLA-&BODY| NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-BODY-ARGUMENT? NULL)
(CL:DEFVAR SGT-METHODS-STELLA-UNKNOWN NULL)
(CL:DEFVAR SGT-METHODS-STELLA-CONS NULL)
(CL:DEFVAR KWD-METHODS-TYPE NULL)
(CL:DEFVAR KWD-METHODS-RETURN-TYPES NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
(CL:DEFVAR KWD-METHODS-PUBLIC? NULL)
(CL:DEFVAR KWD-METHODS-ABSTRACT? NULL)
(CL:DEFVAR KWD-METHODS-NATIVE? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-NATIVE? NULL)
(CL:DEFVAR KWD-METHODS-CONSTRUCTOR? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-CONSTRUCTOR? NULL)
(CL:DEFVAR KWD-METHODS-GLOBALLY-INLINE? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-GLOBALLY-INLINE? NULL)
(CL:DEFVAR KWD-METHODS-INLINE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-INLINED-FUNCTIONS NULL)
(CL:DEFVAR KWD-METHODS-AUXILIARY? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SLOT-AUXILIARY? NULL)
(CL:DEFVAR KWD-METHODS-DOCUMENTATION NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DOCUMENTATION NULL)
(CL:DEFVAR KWD-METHODS-RETURNS NULL)
(CL:DEFVAR KWD-METHODS-STORAGE-SLOT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-STORAGE-SLOT NULL)
(CL:DEFVAR KWD-METHODS-INHERITS-THROUGH NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-INHERITS-THROUGH NULL)
(CL:DEFVAR KWD-METHODS-PROPERTIES NULL)
(CL:DEFVAR SYM-METHODS-STELLA-PROPERTIES NULL)
(CL:DEFVAR KWD-METHODS-META-ATTRIBUTES NULL)
(CL:DEFVAR SYM-METHODS-STELLA-META-ATTRIBUTES NULL)
(CL:DEFVAR KWD-METHODS-COMMAND? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-COMMAND? NULL)
(CL:DEFVAR KWD-METHODS-LISP-MACRO? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-LISP-MACRO? NULL)
(CL:DEFVAR KWD-METHODS-EVALUATE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-EVALUATE-ARGUMENTS? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-CONCATENATE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DEFINE-FUNCTION-OBJECT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-THE-CODE NULL)
(CL:DEFVAR KWD-METHODS-FUNCTION NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DEFINE-METHOD-OBJECT NULL)
(CL:DEFVAR KWD-METHODS-METHOD NULL)
(CL:DEFVAR SGT-METHODS-STELLA-BOOLEAN NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SUPER-CLASSES NULL)
(CL:DEFVAR SYM-METHODS-STELLA-EQUIVALENT-SLOT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-CLASS-ALL-SUPER-CLASSES NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SLOT-DIRECT-EQUIVALENT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-LET NULL)
(CL:DEFVAR SYM-METHODS-STELLA-CURSOR NULL)
(CL:DEFVAR SYM-METHODS-STELLA-VALUE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SLOT-VALUE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-LOOP NULL)
(CL:DEFVAR SYM-METHODS-STELLA-WHEN NULL)
(CL:DEFVAR SYM-METHODS-STELLA-RETURN NULL)
(CL:DEFVAR SYM-METHODS-STELLA-SETQ NULL)
(CL:DEFVAR SYM-METHODS-STELLA-IF NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DEFINED? NULL)
(CL:DEFVAR SGT-METHODS-STELLA-COLLECTION NULL)
(CL:DEFVAR SYM-METHODS-STELLA-FIRST NULL)
(CL:DEFVAR SYM-METHODS-STELLA-VARIABLE-ARITY-TABLE? NULL)
(CL:DEFVAR SGT-METHODS-STELLA-VECTOR NULL)
(CL:DEFVAR SYM-METHODS-STELLA-EVALUATOR-WRAPPER-CODE NULL)
(CL:DEFVAR SGT-METHODS-STELLA-METHOD-SLOT NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-MACRO? NULL)
(CL:DEFVAR SYM-METHODS-STELLA-VARIABLE-TYPE-SPECIFIER NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DEFSPECIAL NULL)
(CL:DEFVAR SYM-METHODS-STELLA-DEFCONSTANT NULL)
(CL:DEFVAR KWD-METHODS-UNBOUND-SPECIAL-VARIABLE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-VARIABLE-HOME-MODULE NULL)
(CL:DEFVAR SYM-METHODS-STELLA-STARTUP-METHODS NULL)
(CL:DEFVAR SYM-METHODS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STELLA-MODULE* SYMBOL-SYM STANDARD-OUTPUT *MODULE*
  NULL-FUNCTION-CODE-WRAPPER *REDEFINE-RELATION-HOOKS* NULL-STRING-WRAPPER
  STANDARD-WARNING TRUE-WRAPPER FALSE-WRAPPER NULL-INTEGER STANDARD-ERROR EOL
  NIL))

;;; (DEFUN (APPLY OBJECT) ...)

(CL:DEFUN APPLY (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
OBJECT."
  (CL:CASE (LENGTH ARGUMENTS) (0 (CL:RETURN-FROM APPLY (CL:FUNCALL CODE)))
   (1 (CL:RETURN-FROM APPLY (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (APPLY-METHOD OBJECT) ...)

(CL:DEFUN APPLY-METHOD (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
OBJECT."
  (CL:CASE (LENGTH ARGUMENTS)
   (0
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Can't call method code on 0 arguments.")))
   (1 (CL:RETURN-FROM APPLY-METHOD (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (APPLY-INTEGER-METHOD INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM) APPLY-INTEGER-METHOD))
(CL:DEFUN APPLY-INTEGER-METHOD (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
INTEGER."
  (CL:CASE (LENGTH ARGUMENTS)
   (0
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Can't call method code on 0 arguments.")))
   (1
    (CL:RETURN-FROM APPLY-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY-INTEGER-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (APPLY-STRING-METHOD STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:SIMPLE-STRING) APPLY-STRING-METHOD))
(CL:DEFUN APPLY-STRING-METHOD (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
STRING."
  (CL:CASE (LENGTH ARGUMENTS)
   (0
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Can't call method code on 0 arguments.")))
   (1
    (CL:RETURN-FROM APPLY-STRING-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY-STRING-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY-STRING-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY-STRING-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY-STRING-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (APPLY-BOOLEAN-METHOD BOOLEAN) ...)

(CL:DEFUN APPLY-BOOLEAN-METHOD (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
BOOLEAN."
  (CL:CASE (LENGTH ARGUMENTS)
   (0
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Can't call method code on 0 arguments.")))
   (1
    (CL:RETURN-FROM APPLY-BOOLEAN-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY-BOOLEAN-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY-BOOLEAN-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY-BOOLEAN-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY-BOOLEAN-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (APPLY-FLOAT-METHOD FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:DOUBLE-FLOAT) APPLY-FLOAT-METHOD))
(CL:DEFUN APPLY-FLOAT-METHOD (CODE ARGUMENTS)
  "Apply `code' to `arguments', returning a value of type
FLOAT."
  (CL:CASE (LENGTH ARGUMENTS)
   (0
    (CL:ERROR
     (NEW-STELLA-EXCEPTION "Can't call method code on 0 arguments.")))
   (1
    (CL:RETURN-FROM APPLY-FLOAT-METHOD (CL:FUNCALL CODE (%%VALUE ARGUMENTS))))
   (2
    (CL:RETURN-FROM APPLY-FLOAT-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS)))))
   (3
    (CL:RETURN-FROM APPLY-FLOAT-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2))))
   (4
    (CL:RETURN-FROM APPLY-FLOAT-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3))))
   (5
    (CL:RETURN-FROM APPLY-FLOAT-METHOD
     (CL:FUNCALL CODE (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
      (NTH ARGUMENTS 2) (NTH ARGUMENTS 3) (NTH ARGUMENTS 4))))
   (CL:OTHERWISE
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Too many function arguments in `apply'.  Max is 5.")))))

;;; (DEFUN (DEFINED-TYPE? BOOLEAN) ...)

(CL:DEFUN DEFINED-TYPE? (TYPE)
  (CL:LET* ((VALUE (%SURROGATE-VALUE TYPE)) (VALUETYPE NULL))
   (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
    (CL:SETQ VALUETYPE (PRIMARY-TYPE VALUE))
    (CL:RETURN-FROM DEFINED-TYPE?
     (CL:OR (CL:EQ SGT-METHODS-STELLA-SURROGATE VALUETYPE)
      (CL:EQ SGT-METHODS-STELLA-PARAMETRIC-TYPE-SPECIFIER VALUETYPE)
      (CL:EQ SGT-METHODS-STELLA-ANCHORED-TYPE-SPECIFIER VALUETYPE))))
   (CL:RETURN-FROM DEFINED-TYPE? CL:NIL)))

;;; (DEFUN (REAL-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFUN REAL-TYPE-SPECIFIER (TYPE)
  (CL:LET* ((VALUE (%SURROGATE-VALUE TYPE)))
   (CL:IF (DEFINED-TYPE? TYPE)
    (CL:IF (TYPE? VALUE)
     (CL:RETURN-FROM REAL-TYPE-SPECIFIER (REAL-TYPE-SPECIFIER VALUE))
     (CL:RETURN-FROM REAL-TYPE-SPECIFIER VALUE))
    (CL:RETURN-FROM REAL-TYPE-SPECIFIER TYPE))))

;;; (DEFUN (CANONICAL-TYPE TYPE) ...)

(CL:DEFUN CANONICAL-TYPE (TYPE)
  (CL:LET* ((CLASS (%SURROGATE-VALUE TYPE)))
   (CL:IF (CL:NOT (CL:EQ CLASS NULL))
    (CL:RETURN-FROM CANONICAL-TYPE (%CLASS-TYPE CLASS))
    (CL:RETURN-FROM CANONICAL-TYPE TYPE))))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE SURROGATE))
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER (REAL-TYPE-SPECIFIER TYPESPECTREE)))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE SYMBOL))
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER
   (REAL-TYPE-SPECIFIER (TYPIFY TYPESPECTREE))))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE PARAMETRIC-TYPE-SPECIFIER))
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER TYPESPECTREE))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE ANCHORED-TYPE-SPECIFIER))
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER TYPESPECTREE))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(CL:DEFMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE OBJECT))
  (CL:CERROR "Continue anyway? " "Illegal type specification `~A'"
   TYPESPECTREE)
  (CL:RETURN-FROM YIELD-TYPE-SPECIFIER SGT-METHODS-STELLA-OBJECT))

;;; (DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ...)

(%%DEFCONSMETHOD YIELD-TYPE-SPECIFIER ((TYPESPECTREE CL:CONS))
  (CL:COND
   ((CL:EQ TYPESPECTREE NIL)
    (CL:RETURN-FROM YIELD-TYPE-SPECIFIER SGT-METHODS-STELLA-VOID))
   ((CL:EQ (%%VALUE TYPESPECTREE) SYM-METHODS-STELLA-LIKE)
    (CL:RETURN-FROM YIELD-TYPE-SPECIFIER
     (YIELD-ANCHORED-TYPE-SPECIFIER TYPESPECTREE)))
   (CL:T
    (CL:RETURN-FROM YIELD-TYPE-SPECIFIER
     (YIELD-PARAMETRIC-TYPE-SPECIFIER TYPESPECTREE)))))

;;; (DEFUN (YIELD-PARAMETRIC-TYPE-SPECIFIER PARAMETRIC-TYPE-SPECIFIER) ...)

(CL:DEFUN YIELD-PARAMETRIC-TYPE-SPECIFIER (TYPESPECTREE)
  (CL:LET*
   ((TYPESPEC (NEW-PARAMETRIC-TYPE-SPECIFIER)) (PARAMETERTYPESPEC NULL)
    (CURSOR TYPESPECTREE))
   (CL:LET* ((HEAD-000 (%%VALUE CURSOR))) (CL:SETQ CURSOR (%%REST CURSOR))
    (CL:LET*
     ((BASETYPE (TYPIFY HEAD-000))
      (REALBASETYPESPEC (REAL-TYPE-SPECIFIER BASETYPE))
      (DEFINEDBASETYPE? (CL:NOT (CL:EQ BASETYPE REALBASETYPESPEC))))
     (CL:LET* ((HEAD-001 (%%VALUE CURSOR))) (CL:SETQ CURSOR (%%REST CURSOR))
      (CL:LET* ((OPERATOR HEAD-001) (ARRAYTYPE? CL:NIL))
       (CL:WHEN DEFINEDBASETYPE?
        (CL:SETQ BASETYPE (TYPE-SPEC-TO-BASE-TYPE REALBASETYPESPEC)))
       (CL:SETF (%SPECIFIER-BASE-TYPE TYPESPEC) (VERIFY-TYPE BASETYPE))
       (CL:WHEN (ARRAY-TYPE-SPECIFIER? TYPESPEC)
        (CL:WHEN (CL:EQ OPERATOR SYM-METHODS-STELLA-SIZE)
         (CL:LET* ((HEAD-002 (%%VALUE CURSOR)))
          (CL:SETQ CURSOR (%%REST CURSOR)) (CL:SETQ OPERATOR HEAD-002)))
        (CL:SETQ ARRAYTYPE? CL:T)
        (CL:SETF (%SPECIFIER-DIMENSIONS TYPESPEC)
         (PARSE-ARRAY-DIMENSIONS-SPEC OPERATOR))
        (CL:LET* ((HEAD-003 (%%VALUE CURSOR)))
         (CL:SETQ CURSOR (%%REST CURSOR)) (CL:SETQ OPERATOR HEAD-003)))
       (CL:WHEN
        (CL:AND ARRAYTYPE? (CL:EQ (%SPECIFIER-DIMENSIONS TYPESPEC) NULL))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
           " Illegal array type specifier dimensions: `"
           (DE-UGLIFY-PARSE-TREE TYPESPECTREE) "'." EOL)))
        (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER
         (YIELD-PARAMETRIC-TYPE-SPECIFIER
          (LIST* SYM-METHODS-STELLA-UNKNOWN SYM-METHODS-STELLA-OF NIL))))
       (CL:WHEN (CL:NOT (CL:EQ OPERATOR SYM-METHODS-STELLA-OF))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
           " Bad type specifier `" (DE-UGLIFY-PARSE-TREE TYPESPECTREE) "'."
           EOL)))
        (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER
         (YIELD-PARAMETRIC-TYPE-SPECIFIER
          (LIST* SYM-METHODS-STELLA-UNKNOWN SYM-METHODS-STELLA-OF NIL))))
       (CL:LET*
        ((P NULL) (ITER-000 CURSOR)
         (INTO-000 (%SPECIFIER-PARAMETER-TYPES TYPESPEC)) (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ P (%%VALUE ITER-000))
         (CL:SETQ PARAMETERTYPESPEC (YIELD-TYPE-SPECIFIER P))
         (CL:WHEN (ARRAY-TYPE-SPECIFIER? PARAMETERTYPESPEC)
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (SIGNAL-TRANSLATION-ERROR)
           (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
            (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
            (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
             " Illegal nested array type specifier: " EOL "   `"
             (DE-UGLIFY-PARSE-TREE TYPESPECTREE) "'" EOL
             "   Use multi-dimensional arrays instead." EOL)))
          (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER
           (YIELD-PARAMETRIC-TYPE-SPECIFIER
            (LIST* SYM-METHODS-STELLA-UNKNOWN SYM-METHODS-STELLA-OF NIL))))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN (CL:SETQ COLLECT-000 (CONS PARAMETERTYPESPEC NIL))
           (CL:IF (CL:EQ (%THE-CONS-LIST INTO-000) NIL)
            (CL:SETF (%THE-CONS-LIST INTO-000) COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST INTO-000)
             COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000) (CONS PARAMETERTYPESPEC NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:WHEN DEFINEDBASETYPE?
        (CL:COND
         ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER?
           (SAFE-PRIMARY-TYPE REALBASETYPESPEC))
          (CL:PROGN
           (CL:LET* ((TEST-VALUE-000 CL:NIL))
            (CL:SETQ TEST-VALUE-000
             (CL:= (LENGTH (%SPECIFIER-PARAMETER-TYPES REALBASETYPESPEC))
              (LENGTH (%SPECIFIER-PARAMETER-TYPES TYPESPEC))))
            (CL:WHEN TEST-VALUE-000
             (CL:LET* ((ALWAYS?-000 CL:T))
              (CL:LET*
               ((PARTYPE NULL)
                (ITER-001
                 (%THE-CONS-LIST (%SPECIFIER-PARAMETER-TYPES TYPESPEC)))
                (RPARTYPE NULL)
                (ITER-002
                 (%THE-CONS-LIST
                  (%SPECIFIER-PARAMETER-TYPES REALBASETYPESPEC))))
               (CL:LOOP WHILE
                (CL:AND (CL:NOT (CL:EQ ITER-001 NIL))
                 (CL:NOT (CL:EQ ITER-002 NIL)))
                DO (CL:SETQ PARTYPE (%%VALUE ITER-001))
                (CL:SETQ RPARTYPE (%%VALUE ITER-002))
                (CL:WHEN
                 (CL:NOT
                  (OPTIMISTIC-SUBTYPE-OF? (TYPE-SPEC-TO-BASE-TYPE PARTYPE)
                   (TYPE-SPEC-TO-BASE-TYPE RPARTYPE)))
                 (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
                (CL:SETQ ITER-001 (%%REST ITER-001))
                (CL:SETQ ITER-002 (%%REST ITER-002))))
              (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
            (CL:WHEN (CL:NOT TEST-VALUE-000)
             (CL:LET* ((*PRINTREADABLY?* CL:T))
              (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
              (SIGNAL-TRANSLATION-ERROR)
              (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
               (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
               (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
                " Parameter types of `" (DE-UGLIFY-PARSE-TREE TYPESPECTREE)
                "' are incompatible " EOL
                " with parameter types of defined type `"
                (%%VALUE TYPESPECTREE) "'." EOL)))
             (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER
              (YIELD-PARAMETRIC-TYPE-SPECIFIER
               (LIST* SYM-METHODS-STELLA-UNKNOWN SYM-METHODS-STELLA-OF
                NIL)))))))
         (CL:T)))
       (CL:RETURN-FROM YIELD-PARAMETRIC-TYPE-SPECIFIER TYPESPEC)))))))

;;; (DEFUN (PARSE-ARRAY-DIMENSIONS-SPEC (LIST OF INTEGER-WRAPPER)) ...)

(CL:DEFUN PARSE-ARRAY-DIMENSIONS-SPEC (DIMENSIONSSPEC)
  (CL:LET* ((DIMENSIONS (NEW-LIST)))
   (CL:WHEN (CL:EQ DIMENSIONSSPEC NULL)
    (CL:RETURN-FROM PARSE-ARRAY-DIMENSIONS-SPEC NULL))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CONS? DIMENSIONSSPEC) (CL:NOT (CL:EQ DIMENSIONSSPEC NIL))))
    (CL:SETQ DIMENSIONSSPEC (CONS DIMENSIONSSPEC NIL)))
   (CL:LET* ((DIMSPEC NULL) (ITER-000 DIMENSIONSSPEC) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DIMSPEC (%%VALUE ITER-000))
     (CL:WHEN (CONS? DIMSPEC) (CL:SETQ DIMSPEC (%%VALUE DIMSPEC)))
     (CL:COND
      ((CL:OR (CL:EQ DIMSPEC NULL) (CL:EQ DIMSPEC SYM-METHODS-STELLA-NULL))
       (CL:SETQ DIMSPEC NULL))
      ((INTEGER? DIMSPEC))
      (CL:T (CL:RETURN-FROM PARSE-ARRAY-DIMENSIONS-SPEC NULL)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS DIMSPEC NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST DIMENSIONS) NIL)
        (CL:SETF (%THE-CONS-LIST DIMENSIONS) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST DIMENSIONS)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS DIMSPEC NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM PARSE-ARRAY-DIMENSIONS-SPEC DIMENSIONS)))

;;; (DEFUN (YIELD-ARRAY-DIMENSIONS-TREE CONS) ...)

(CL:DEFUN YIELD-ARRAY-DIMENSIONS-TREE (ARRAYTYPE)
  (CL:LET* ((DIMENSIONS (%SPECIFIER-DIMENSIONS ARRAYTYPE)) (RESULT NIL))
   (CL:WHEN (CL:EQ DIMENSIONS NULL)
    (CL:RETURN-FROM YIELD-ARRAY-DIMENSIONS-TREE NULL))
   (CL:LET*
    ((DIM NULL) (ITER-000 (%THE-CONS-LIST DIMENSIONS)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ DIM (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (CL:IF (CL:EQ DIM NULL) NIL (CONS DIM NIL)) NIL))
       (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (CL:IF (CL:EQ DIM NULL) NIL (CONS DIM NIL)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:IF (CL:= (LENGTH RESULT) 1)
    (CL:RETURN-FROM YIELD-ARRAY-DIMENSIONS-TREE (%%VALUE RESULT))
    (CL:RETURN-FROM YIELD-ARRAY-DIMENSIONS-TREE RESULT))))

;;; (DEFUN (ARRAY-TYPE-SPECIFIER? BOOLEAN) ...)

(CL:DEFUN ARRAY-TYPE-SPECIFIER? (TYPESPEC)
  (CL:COND
   ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? (SAFE-PRIMARY-TYPE TYPESPEC))
    (CL:PROGN
     (CL:LET* ((BASETYPE (%SPECIFIER-BASE-TYPE TYPESPEC)))
      (CL:WHEN (CL:EQ BASETYPE SGT-METHODS-STELLA-ARRAY)
       (CL:RETURN-FROM ARRAY-TYPE-SPECIFIER? CL:T)))))
   (CL:T))
  (CL:RETURN-FROM ARRAY-TYPE-SPECIFIER? CL:NIL))

;;; (DEFUN (ARRAY-TYPE-RANK INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) ARRAY-TYPE-RANK))
(CL:DEFUN ARRAY-TYPE-RANK (ARRAYTYPE)
  (CL:LET* ((DIMENSIONS (%SPECIFIER-DIMENSIONS ARRAYTYPE)))
   (CL:IF (CL:EQ DIMENSIONS NULL)
    (CL:RETURN-FROM ARRAY-TYPE-RANK NULL-INTEGER)
    (CL:RETURN-FROM ARRAY-TYPE-RANK (LENGTH DIMENSIONS)))))

;;; (DEFUN (ARRAY-TYPE-DIMENSIONS (LIST OF INTEGER-WRAPPER)) ...)

(CL:DEFUN ARRAY-TYPE-DIMENSIONS (ARRAYTYPE)
  (CL:RETURN-FROM ARRAY-TYPE-DIMENSIONS (%SPECIFIER-DIMENSIONS ARRAYTYPE)))

;;; (DEFUN (INDEFINITE-ARRAY-TYPE? BOOLEAN) ...)

(CL:DEFUN INDEFINITE-ARRAY-TYPE? (ARRAYTYPE)
  (CL:LET* ((DIMENSIONS (%SPECIFIER-DIMENSIONS ARRAYTYPE)))
   (CL:IF (CL:EQ DIMENSIONS NULL) (CL:RETURN-FROM INDEFINITE-ARRAY-TYPE? CL:T)
    (CL:LET* ((DIM NULL) (ITER-000 (%THE-CONS-LIST DIMENSIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ DIM (%%VALUE ITER-000))
      (CL:WHEN (CL:EQ DIM NULL) (CL:RETURN-FROM INDEFINITE-ARRAY-TYPE? CL:T))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CL:RETURN-FROM INDEFINITE-ARRAY-TYPE? CL:NIL)))

;;; (DEFUN (YIELD-ANCHORED-TYPE-SPECIFIER ANCHORED-TYPE-SPECIFIER) ...)

(CL:DEFUN YIELD-ANCHORED-TYPE-SPECIFIER (TYPESPECTREE)
  (CL:LET*
   ((TYPESPEC (NEW-ANCHORED-TYPE-SPECIFIER))
    (LIKEARGUMENT (%%VALUE (%%REST TYPESPECTREE))))
   (CL:WHEN (CL:NOT (CL:EQ LIKEARGUMENT SYM-METHODS-STELLA-SELF))
    (CL:SETF (%SPECIFIER-PARAMETER-NAME TYPESPEC)
     (PERMANENTIFY (%%VALUE LIKEARGUMENT))))
   (CL:RETURN-FROM YIELD-ANCHORED-TYPE-SPECIFIER TYPESPEC)))

;;; (DEFUN INCORPORATE-INPUT-PARAMETERS ...)

(CL:DEFUN INCORPORATE-INPUT-PARAMETERS (METHOD PARAMETERS)
  (CL:WHEN (CL:EQ PARAMETERS NIL)
   (CL:RETURN-FROM INCORPORATE-INPUT-PARAMETERS))
  (CL:LET* ((NAME NULL) (TS NULL) (DIRECTION NULL) (VARIABLEARGS? CL:NIL))
   (CL:SETF (%METHOD-PARAMETER-NAMES METHOD) (NEW-LIST))
   (CL:SETF (%METHOD-PARAMETER-TYPE-SPECIFIERS METHOD) (NEW-LIST))
   (CL:LET* ((P NULL) (ITER-000 PARAMETERS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ P (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE P)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 SGT-METHODS-STELLA-CONS)
         (CL:PROGN
          (CL:CASE (LENGTH P) (2 (CL:SETQ DIRECTION SYM-METHODS-STELLA-IN))
           (3
            (CL:COND
             ((CL:OR (CL:EQ (%%VALUE P) SYM-METHODS-STELLA-IN)
               (CL:EQ (%%VALUE P) SYM-METHODS-STELLA-OUT)
               (CL:EQ (%%VALUE P) SYM-METHODS-STELLA-INOUT))
              (CL:SETQ DIRECTION (%%VALUE P))
              (CL:WHEN (NULL-LIST? (METHOD-PARAMETER-DIRECTIONS METHOD))
               (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS METHOD)
                SYM-METHODS-STELLA-METHOD-PARAMETER-DIRECTIONS (NEW-LIST)
                NULL)
               (CL:LET* ((PAR NULL) (ITER-001 PARAMETERS))
                (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
                 (CL:SETQ PAR (%%VALUE ITER-001))
                 (CL:IF (CL:EQ PAR P) (CL:RETURN)
                  (INSERT (METHOD-PARAMETER-DIRECTIONS METHOD)
                   SYM-METHODS-STELLA-IN))
                 (CL:SETQ ITER-001 (%%REST ITER-001))))))
             (CL:T
              (CL:LET* ((*PRINTREADABLY?* CL:T))
               (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
               (SIGNAL-TRANSLATION-ERROR)
               (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
                (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
                (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
                 " Illegal direction for method parameter: `"
                 (DE-UGLIFY-PARSE-TREE P) "'." EOL)))
              (CL:SETQ DIRECTION SYM-METHODS-STELLA-IN)))
            (CL:SETQ P (%%REST P)))
           (CL:OTHERWISE
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
              (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
               " Illegal method parameter: `" (DE-UGLIFY-PARSE-TREE P) "'."
               EOL)))
            (CL:GO :CONTINUE)))
          (CL:IF VARIABLEARGS?
           (CL:LET*
            ((VARARGTYPE
              (LIST* SYM-METHODS-STELLA-ARGUMENT-LIST SYM-METHODS-STELLA-OF
               (%%VALUE (%%REST P)) NIL)))
            (CL:SETQ NAME (%%VALUE P))
            (CL:SETQ TS (YIELD-TYPE-SPECIFIER VARARGTYPE)))
           (CL:PROGN
            (CL:WHEN
             (CL:NOT
              (CL:AND (SYMBOL? (%%VALUE P))
               (CL:OR (SYMBOL? (%%VALUE (%%REST P)))
                (SURROGATE? (%%VALUE (%%REST P)))
                (CONS? (%%VALUE (%%REST P))))))
             (CL:LET* ((*PRINTREADABLY?* CL:T))
              (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
              (SIGNAL-TRANSLATION-ERROR)
              (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
               (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
               (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
                " Illegal method parameter: `" (DE-UGLIFY-PARSE-TREE P) "'."
                EOL)))
             (CL:GO :CONTINUE))
            (CL:SETQ NAME (%%VALUE P))
            (CL:SETQ TS (YIELD-TYPE-SPECIFIER (%%VALUE (%%REST P))))))))
        ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
         (CL:PROGN
          (CL:COND
           ((CL:EQ P |SYM-METHODS-STELLA-&REST|)
            (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS METHOD)
             SYM-METHODS-STELLA-METHOD-VARIABLE-ARGUMENTS?
             (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
            (CL:SETQ VARIABLEARGS? CL:T) (CL:GO :CONTINUE))
           ((CL:EQ P |SYM-METHODS-STELLA-&BODY|)
            (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS METHOD)
             SYM-METHODS-STELLA-METHOD-BODY-ARGUMENT?
             (CL:IF CL:T TRUE-WRAPPER FALSE-WRAPPER) FALSE-WRAPPER)
            (CL:GO :CONTINUE))
           (CL:T
            (CL:LET* ((*PRINTREADABLY?* CL:T))
             (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
             (SIGNAL-TRANSLATION-ERROR)
             (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
              (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
              (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
               " Untyped parameter in parameter list: `"
               (DE-UGLIFY-PARSE-TREE PARAMETERS) "'." EOL)))
            (CL:SETQ NAME P) (CL:SETQ TS SGT-METHODS-STELLA-UNKNOWN)))))
        (CL:T
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-ERROR)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
            " Illegal parameter list: `" (DE-UGLIFY-PARSE-TREE PARAMETERS)
            "'." EOL)))
         (CL:GO :CONTINUE))))
      (INSERT (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD) TS)
      (INSERT (METHOD-PARAMETER-NAMES METHOD) (PERMANENTIFY NAME))
      (CL:WHEN (DEFINED-LIST? (METHOD-PARAMETER-DIRECTIONS METHOD))
       (INSERT (METHOD-PARAMETER-DIRECTIONS METHOD) DIRECTION))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (REVERSE (METHOD-PARAMETER-NAMES METHOD))
   (REVERSE (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
   (REVERSE (METHOD-PARAMETER-DIRECTIONS METHOD)))
  :VOID)

;;; (DEFUN INCORPORATE-FIRST-INPUT-PARAMETER ...)

(CL:DEFUN INCORPORATE-FIRST-INPUT-PARAMETER (METHOD)
  (CL:LET*
   ((PARAMETERTYPESPECS (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD))
    (FIRSTARGTYPE (FIRST PARAMETERTYPESPECS)))
   (CL:WHEN (CL:NOT (%METHOD-FUNCTION? METHOD))
    (CL:COND
     ((EMPTY? PARAMETERTYPESPECS)
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
         " Method has no input parameters, converting it into a function."
         EOL)))
      (CL:SETF (%METHOD-FUNCTION? METHOD) CL:T)
      (CL:RETURN-FROM INCORPORATE-FIRST-INPUT-PARAMETER))
     ((CL:AND (CL:NOT (CL:EQ FIRSTARGTYPE NULL))
       (CL:NOT (TYPE? FIRSTARGTYPE)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
       (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
        (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
         " Illegal complex argument type for the first method parameter: " EOL
         "   `" (DE-UGLIFY-PARSE-TREE FIRSTARGTYPE) "'." EOL)))
      (CL:WHEN (ANCHORED-TYPE-SPECIFIER? FIRSTARGTYPE)
       (FIRST-SETTER (METHOD-PARAMETER-TYPE-SPECIFIERS METHOD)
        SGT-METHODS-STELLA-UNKNOWN)
       (CL:SETQ FIRSTARGTYPE SGT-METHODS-STELLA-UNKNOWN)))))
   (CL:SETF (%SLOT-OWNER METHOD)
    (CL:IF (CL:NOT (CL:EQ FIRSTARGTYPE NULL))
     (TYPE-SPEC-TO-BASE-TYPE FIRSTARGTYPE) NULL)))
  :VOID)

;;; (DEFUN (DEFINE-STELLA-METHOD-SLOT METHOD-SLOT) ...)

(CL:DEFUN DEFINE-STELLA-METHOD-SLOT (INPUTNAME RETURNTYPES FUNCTION? INPUTPARAMETERS OPTIONS)
  "Define a new Stella method object (a slot), and attach it
to the class identified by the first parameter in 'inputParameters'."
  (CL:LET* ((NEWMETHOD (NEW-METHOD-SLOT)) (NAME (PERMANENTIFY INPUTNAME)))
   (CL:SETF (%SLOT-NAME NEWMETHOD) NAME)
   (CL:SETF (%METHOD-FUNCTION? NEWMETHOD) FUNCTION?)
   (INCORPORATE-INPUT-PARAMETERS NEWMETHOD INPUTPARAMETERS)
   (INCORPORATE-FIRST-INPUT-PARAMETER NEWMETHOD)
   (CL:WHEN (CL:EQ RETURNTYPES NIL)
    (CL:COND
     ((CL:NOT (CL:EQ (LOOKUP OPTIONS KWD-METHODS-TYPE) NULL))
      (CL:SETQ RETURNTYPES (CONS (LOOKUP OPTIONS KWD-METHODS-TYPE) NIL)))
     ((CL:NOT (CL:EQ (LOOKUP OPTIONS KWD-METHODS-RETURN-TYPES) NULL))
      (CL:SETQ RETURNTYPES
       (CONS (LOOKUP OPTIONS KWD-METHODS-RETURN-TYPES) NIL)))))
   (CL:LET*
    ((TYPESPEC
      (CL:IF (CL:EQ RETURNTYPES NIL) SGT-METHODS-STELLA-VOID
       (YIELD-TYPE-SPECIFIER (%%VALUE RETURNTYPES)))))
    (CL:IF (TYPE? TYPESPEC) (CL:SETF (%SLOT-BASE-TYPE NEWMETHOD) TYPESPEC)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
      SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER TYPESPEC NULL)))
   (CL:WHEN (CL:NOT (CL:EQ RETURNTYPES NIL))
    (CL:SETF (%METHOD-RETURN-TYPE-SPECIFIERS NEWMETHOD) (NEW-LIST)))
   (CL:LET*
    ((TS NULL) (ITER-000 RETURNTYPES)
     (INTO-000 (METHOD-RETURN-TYPE-SPECIFIERS NEWMETHOD)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TS (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (YIELD-TYPE-SPECIFIER TS) NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST INTO-000) NIL)
        (CL:SETF (%THE-CONS-LIST INTO-000) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST INTO-000) COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS (YIELD-TYPE-SPECIFIER TS) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((KEY NULL) (VALUE NULL) (ITER-001 (ALLOCATE-ITERATOR OPTIONS)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ KEY (%KEY ITER-001))
     (CL:SETQ VALUE (%VALUE ITER-001))
     (CL:LET* ((TEST-VALUE-000 KEY))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-PUBLIC?)
        (CL:SETF (%SLOT-PUBLIC? NEWMETHOD) (%WRAPPER-VALUE VALUE)))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-ABSTRACT?)
        (CL:SETF (%ABSTRACT? NEWMETHOD) (%WRAPPER-VALUE VALUE)))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-NATIVE?)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-NATIVE?
         (CL:IF (%WRAPPER-VALUE VALUE) TRUE-WRAPPER FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-CONSTRUCTOR?)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-CONSTRUCTOR?
         (CL:IF (%WRAPPER-VALUE VALUE) TRUE-WRAPPER FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-GLOBALLY-INLINE?)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-GLOBALLY-INLINE?
         (CL:IF (%WRAPPER-VALUE VALUE) TRUE-WRAPPER FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-INLINE)
        (CL:WHEN (EMPTY? (METHOD-INLINED-FUNCTIONS NEWMETHOD))
         (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
          SYM-METHODS-STELLA-METHOD-INLINED-FUNCTIONS (NEW-LIST) NULL))
        (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE VALUE)))
         (CL:COND
          ((CL:EQ TEST-VALUE-001 SGT-METHODS-STELLA-CONS)
           (CL:PROGN
            (CL:LET* ((FNNAME NULL) (ITER-002 VALUE))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
              (CL:SETQ FNNAME (%%VALUE ITER-002))
              (INSERT (METHOD-INLINED-FUNCTIONS NEWMETHOD) FNNAME)
              (CL:SETQ ITER-002 (%%REST ITER-002))))))
          ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
           (CL:PROGN (INSERT (METHOD-INLINED-FUNCTIONS NEWMETHOD) VALUE)))
          (CL:T (CL:WARN "Illegal :inline argument: `~A'" VALUE)))))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-AUXILIARY?)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-SLOT-AUXILIARY?
         (CL:IF (%WRAPPER-VALUE VALUE) TRUE-WRAPPER FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-DOCUMENTATION)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-DOCUMENTATION (WRAP-STRING (%WRAPPER-VALUE VALUE))
         NULL-STRING-WRAPPER))
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-METHODS-TYPE)
         (CL:EQ TEST-VALUE-000 KWD-METHODS-RETURNS)))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-STORAGE-SLOT)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-STORAGE-SLOT (PERMANENTIFY VALUE) NULL))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-INHERITS-THROUGH)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-INHERITS-THROUGH (PERMANENTIFY VALUE)
         NULL))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-PROPERTIES)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-PROPERTIES VALUE NULL))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-META-ATTRIBUTES)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-META-ATTRIBUTES VALUE NULL))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-COMMAND?)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-COMMAND?
         (CL:IF (%WRAPPER-VALUE VALUE) TRUE-WRAPPER FALSE-WRAPPER)
         FALSE-WRAPPER))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-LISP-MACRO?)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-LISP-MACRO?
         (CL:IF (%WRAPPER-VALUE VALUE) TRUE-WRAPPER FALSE-WRAPPER) NULL))
       ((CL:EQ TEST-VALUE-000 KWD-METHODS-EVALUATE-ARGUMENTS?)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWMETHOD)
         SYM-METHODS-STELLA-METHOD-EVALUATE-ARGUMENTS?
         (CL:IF (%WRAPPER-VALUE VALUE) TRUE-WRAPPER FALSE-WRAPPER)
         FALSE-WRAPPER))
       (CL:T
        (CL:WHEN (CL:NOT (RUN-OPTION-HANDLER? NEWMETHOD KEY VALUE))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (SIGNAL-TRANSLATION-WARNING)
          (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
           (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
           (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING) EOL
            " Skipping invalid method option `" (DE-UGLIFY-PARSE-TREE KEY) "'"
            EOL "in the definition of method `" (%SLOT-OWNER NEWMETHOD) "'.`"
            (DE-UGLIFY-PARSE-TREE NAME) "'." EOL)))))))))
   (CL:RETURN-FROM DEFINE-STELLA-METHOD-SLOT NEWMETHOD)))

;;; (DEFUN (ATTACH-METHOD-SLOT-TO-OWNER METHOD-SLOT) ...)

(CL:DEFUN ATTACH-METHOD-SLOT-TO-OWNER (NEWMETHOD)
  (CL:WHEN (%METHOD-FUNCTION? NEWMETHOD)
   (CL:RETURN-FROM ATTACH-METHOD-SLOT-TO-OWNER (ATTACH-FUNCTION NEWMETHOD)))
  (CL:WHEN (CL:EQ (%SURROGATE-VALUE (%SLOT-OWNER NEWMETHOD)) NULL)
   (CL:RETURN-FROM ATTACH-METHOD-SLOT-TO-OWNER NEWMETHOD))
  (CL:WHEN (CL:NOT (UNDEFINE-CONFLICTING-DEFINITIONS? NEWMETHOD))
   (CL:RETURN-FROM ATTACH-METHOD-SLOT-TO-OWNER NULL))
  (CL:RETURN-FROM ATTACH-METHOD-SLOT-TO-OWNER (ATTACH-SLOT-TO-OWNER NEWMETHOD)))

;;; (DEFGLOBAL *MAXIMUM-STRING-CONSTANT-SIZE* ...)

(CL:DEFVAR *MAXIMUM-STRING-CONSTANT-SIZE* 4000
  "Maximum size for a string constant in the target language.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *MAXIMUM-STRING-CONSTANT-SIZE*))

;;; (DEFUN (YIELD-STRING-CONSTANT-TREE OBJECT) ...)

(CL:DEFUN YIELD-STRING-CONSTANT-TREE (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:LET*
   ((LENGTH (CL:THE CL:FIXNUM (CL:LENGTH STRING))) (CHUNKS NIL) (START 0)
    (STRINGTREE NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LENGTH START))
   (CL:WHEN (CL:<= LENGTH *MAXIMUM-STRING-CONSTANT-SIZE*)
    (CL:RETURN-FROM YIELD-STRING-CONSTANT-TREE (WRAP-STRING STRING)))
   (CL:LOOP WHILE (CL:< (CL:+ START *MAXIMUM-STRING-CONSTANT-SIZE*) LENGTH) DO
    (CL:SETQ CHUNKS
     (CONS
      (WRAP-STRING
       (SUBSEQUENCE STRING START (CL:+ START *MAXIMUM-STRING-CONSTANT-SIZE*)))
      CHUNKS))
    (CL:SETQ START (CL:+ START *MAXIMUM-STRING-CONSTANT-SIZE*)))
   (CL:WHEN (CL:< START LENGTH)
    (CL:SETQ CHUNKS
     (CONS (WRAP-STRING (SUBSEQUENCE STRING START LENGTH)) CHUNKS)))
   (CL:SETQ STRINGTREE (%%VALUE CHUNKS))
   (CL:LET* ((CHUNK NULL) (ITER-000 (%%REST CHUNKS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CHUNK (%%VALUE ITER-000))
     (CL:SETQ STRINGTREE
      (LIST* SYM-METHODS-STELLA-CONCATENATE CHUNK (CONS STRINGTREE NIL)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM YIELD-STRING-CONSTANT-TREE STRINGTREE)))

;;; (DEFUN (YIELD-DEFINE-STELLA-METHOD-OBJECT CONS) ...)

(CL:DEFUN YIELD-DEFINE-STELLA-METHOD-OBJECT (METHOD CODEMETHOD WRAPPERMETHOD)
  (CL:LET* ((NAME (STRINGIFY (%SLOT-NAME METHOD))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
   (CL:COND
    ((%METHOD-FUNCTION? METHOD)
     (CL:RETURN-FROM YIELD-DEFINE-STELLA-METHOD-OBJECT
      (LIST* SYM-METHODS-STELLA-DEFINE-FUNCTION-OBJECT
       (CL:IF (STRING-EQL? NAME (%SYMBOL-NAME (%SLOT-NAME METHOD)))
        (WRAP-STRING NAME) (WRAP-STRING (CONCATENATE " " NAME)))
       (CONS (YIELD-STRING-CONSTANT-TREE (%METHOD-STRINGIFIED-SOURCE METHOD))
        (CONS
         (CL:IF (CL:NOT (CL:EQ CODEMETHOD NULL))
          (LIST* SYM-METHODS-STELLA-THE-CODE KWD-METHODS-FUNCTION
           (%SLOT-NAME CODEMETHOD) NIL)
          SYM-METHODS-STELLA-NULL)
         (CONS
          (CL:IF (CL:NOT (CL:EQ WRAPPERMETHOD NULL))
           (LIST* SYM-METHODS-STELLA-THE-CODE KWD-METHODS-FUNCTION
            (%SLOT-NAME WRAPPERMETHOD) (CONS WRAPPERMETHOD NIL))
           SYM-METHODS-STELLA-NULL)
          NIL))))))
    (CL:T
     (CL:RETURN-FROM YIELD-DEFINE-STELLA-METHOD-OBJECT
      (LIST* SYM-METHODS-STELLA-DEFINE-METHOD-OBJECT
       (YIELD-STRING-CONSTANT-TREE (%METHOD-STRINGIFIED-SOURCE METHOD))
       (CONS
        (CL:IF (CL:NOT (CL:EQ CODEMETHOD NULL))
         (LIST* SYM-METHODS-STELLA-THE-CODE KWD-METHODS-METHOD
          (%SLOT-OWNER CODEMETHOD) (CONS (%SLOT-NAME CODEMETHOD) NIL))
         SYM-METHODS-STELLA-NULL)
        (CONS SYM-METHODS-STELLA-NULL NIL))))))))

;;; (DEFUN (YIELD-CLASS-PARAMETER-TYPES (CONS OF TYPE)) ...)

(CL:DEFUN YIELD-CLASS-PARAMETER-TYPES (CLASS)
  (CL:LET* ((TYPES NIL))
   (CL:LET*
    ((PNAME NULL) (ITER-000 (%THE-CONS-LIST (PARAMETERS CLASS)))
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PNAME (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (%SLOT-BASE-TYPE (LOOKUP-SLOT CLASS PNAME)) NIL))
       (CL:IF (CL:EQ TYPES NIL) (CL:SETQ TYPES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST TYPES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (%SLOT-BASE-TYPE (LOOKUP-SLOT CLASS PNAME)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM YIELD-CLASS-PARAMETER-TYPES TYPES)))

;;; (DEFUN (OPTIMISTIC-SUBTYPE-OF? BOOLEAN) ...)

(CL:DEFUN OPTIMISTIC-SUBTYPE-OF? (SUBTYPE SUPERTYPE)
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ (%SURROGATE-VALUE SUBTYPE) NULL))
    (CL:NOT (CL:EQ (%SURROGATE-VALUE SUPERTYPE) NULL))
    (%CLASS-FINALIZED? (%SURROGATE-VALUE SUBTYPE)))
   (CL:RETURN-FROM OPTIMISTIC-SUBTYPE-OF? (SUBTYPE-OF? SUBTYPE SUPERTYPE))
   (CL:RETURN-FROM OPTIMISTIC-SUBTYPE-OF? CL:T)))

;;; (DEFUN WARN-OF-PARAMETER-MISMATCH ...)

(CL:DEFUN WARN-OF-PARAMETER-MISMATCH (SELF MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET*
   ((INHERITEDTYPES
     (YIELD-CLASS-PARAMETER-TYPES
      (%SURROGATE-VALUE (%SPECIFIER-BASE-TYPE SELF)))))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:WARN
     "`~A'~%Type `~A' takes parameters of type ~%`~A' but was modified by a list of types `~A'"
     MESSAGE (%SPECIFIER-BASE-TYPE SELF) INHERITEDTYPES
     (%THE-CONS-LIST (%SPECIFIER-PARAMETER-TYPES SELF)))))
  :VOID)

;;; (DEFUN (VALIDATE-TYPE-SPECIFIER TYPE) ...)

(CL:DEFUN VALIDATE-TYPE-SPECIFIER (SELF ANCHORCLASS SKIPANCHOREDTYPE?)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN (CL:EQ (%SURROGATE-VALUE (%SPECIFIER-BASE-TYPE SELF)) NULL)
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER SGT-METHODS-STELLA-UNKNOWN))
      (CL:LET*
       ((PARAMETERDIFFERENTIAL
         (CL:- (LENGTH (%SPECIFIER-PARAMETER-TYPES SELF))
          (LENGTH
           (PARAMETERS (%SURROGATE-VALUE (%SPECIFIER-BASE-TYPE SELF)))))))
       (CL:DECLARE (CL:TYPE CL:FIXNUM PARAMETERDIFFERENTIAL))
       (CL:COND
        ((CL:> PARAMETERDIFFERENTIAL 0)
         (WARN-OF-PARAMETER-MISMATCH SELF
          "Too many parameters in type specification."))
        ((CL:< PARAMETERDIFFERENTIAL 0)
         (WARN-OF-PARAMETER-MISMATCH SELF
          "Not enough parameters in type specification."))
        (CL:T
         (CL:LET*
          ((BASECLASS (%SURROGATE-VALUE (TYPE-SPEC-TO-BASE-TYPE SELF))))
          (CL:WHEN (%CLASS-SLOTS-FINALIZED? BASECLASS)
           (CL:LET* ((INHERITEDTYPES (YIELD-CLASS-PARAMETER-TYPES BASECLASS)))
            (CL:LET*
             ((SUPERTYPE NULL) (ITER-000 INHERITEDTYPES) (SUBTYPESPEC NULL)
              (ITER-001 (%THE-CONS-LIST (%SPECIFIER-PARAMETER-TYPES SELF))))
             (CL:LOOP WHILE
              (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
               (CL:NOT (CL:EQ ITER-001 NIL)))
              DO (CL:SETQ SUPERTYPE (%%VALUE ITER-000))
              (CL:SETQ SUBTYPESPEC (%%VALUE ITER-001))
              (CL:WHEN
               (CL:AND (CL:NOT (ANCHORED-TYPE-SPECIFIER? SUBTYPESPEC))
                (CL:NOT (CL:EQ SUPERTYPE SGT-METHODS-STELLA-UNKNOWN))
                (CL:NOT
                 (OPTIMISTIC-SUBTYPE-OF? (TYPE-SPEC-TO-BASE-TYPE SUBTYPESPEC)
                  SUPERTYPE)))
               (WARN-OF-PARAMETER-MISMATCH SELF
                "Parametric subtype(s) don't specialize supertype(s)"))
              (CL:SETQ ITER-000 (%%REST ITER-000))
              (CL:SETQ ITER-001 (%%REST ITER-001)))))))))
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER (%SPECIFIER-BASE-TYPE SELF)))))
    ((SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN SKIPANCHOREDTYPE?
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER NULL))
      (CL:WHEN (CL:EQ ANCHORCLASS NULL)
       (CL:WARN "Illegal use of anchored type for function that has no first
argument (and hence nothing to anchor onto).")
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER NULL))
      (CL:LET* ((SLOTNAME (%SPECIFIER-PARAMETER-NAME SELF)) (ANCHORSLOT NULL))
       (CL:WHEN (CL:EQ SLOTNAME NULL)
        (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER (%CLASS-TYPE ANCHORCLASS)))
       (CL:LET* () (CL:SETQ ANCHORSLOT (LOOKUP-SLOT ANCHORCLASS SLOTNAME))
        (CL:WHEN (CL:EQ ANCHORSLOT NULL)
         (CL:CERROR "Continue anyway? "
          "Can't find a slot named `~A' on the class `~A'" SLOTNAME
          (CLASS-NAME ANCHORCLASS))))
       (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER
        (%SLOT-BASE-TYPE ANCHORSLOT)))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM VALIDATE-TYPE-SPECIFIER SELF)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "validate-type-specifier: Not defined on `" SELF "'")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (SYNTHESIZE-METHOD-BODY CONS) ...)

(CL:DEFUN SYNTHESIZE-METHOD-BODY (METHOD)
  (CL:WHEN (CL:EQ (%SURROGATE-VALUE SGT-METHODS-STELLA-BOOLEAN) NULL)
   (CL:RETURN-FROM SYNTHESIZE-METHOD-BODY NIL))
  (CL:LET*
   ((STORAGESLOTNAME
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS METHOD)
      SYM-METHODS-STELLA-STORAGE-SLOT NULL))
    (INHERITANCESLOTNAME
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS METHOD)
      SYM-METHODS-STELLA-METHOD-INHERITS-THROUGH NULL))
    (STORAGESLOT NULL) (INHERITANCESLOT NULL) (DEFAULTVALUE NULL))
   (CL:COND
    ((CL:EQ INHERITANCESLOTNAME SYM-METHODS-STELLA-SUPER-CLASSES)
     (CL:SETQ INHERITANCESLOTNAME SYM-METHODS-STELLA-CLASS-ALL-SUPER-CLASSES))
    ((CL:EQ INHERITANCESLOTNAME SYM-METHODS-STELLA-EQUIVALENT-SLOT)
     (CL:SETQ INHERITANCESLOTNAME SYM-METHODS-STELLA-SLOT-DIRECT-EQUIVALENT))
    (CL:T))
   (CL:SETQ STORAGESLOT
    (LOOKUP-SLOT (%SURROGATE-VALUE (%SLOT-OWNER METHOD)) STORAGESLOTNAME))
   (CL:WHEN (CL:EQ STORAGESLOT NULL)
    (CL:WARN
     ":storage-slot references non-existent slot `~A' on the class `~A'"
     STORAGESLOTNAME (%SLOT-OWNER METHOD))
    (CL:RETURN-FROM SYNTHESIZE-METHOD-BODY NIL))
   (CL:SETQ INHERITANCESLOT
    (LOOKUP-SLOT (%SURROGATE-VALUE (%SLOT-OWNER METHOD)) INHERITANCESLOTNAME))
   (CL:WHEN (CL:EQ INHERITANCESLOT NULL)
    (CL:WARN
     ":inherits-through references non-existent slot `~A' on the class `~A'"
     INHERITANCESLOTNAME (%SLOT-OWNER METHOD))
    (CL:RETURN-FROM SYNTHESIZE-METHOD-BODY NIL))
   (CL:SETQ DEFAULTVALUE (SYSTEM-DEFAULT-VALUE STORAGESLOT))
   (CL:RETURN-FROM SYNTHESIZE-METHOD-BODY
    (CONS
     (LIST* SYM-METHODS-STELLA-LET
      (LIST* (LIST* SYM-METHODS-STELLA-CURSOR SYM-METHODS-STELLA-SELF NIL)
       (LIST* SYM-METHODS-STELLA-VALUE
        (LIST* SYM-METHODS-STELLA-SLOT-VALUE SYM-METHODS-STELLA-CURSOR
         STORAGESLOTNAME NIL)
        NIL)
       NIL)
      (LIST* SYM-METHODS-STELLA-LOOP
       (CONS SYM-METHODS-STELLA-WHEN
        (CONCATENATE
         (CL:IF (SUBTYPE-OF? (TYPE STORAGESLOT) SGT-METHODS-STELLA-BOOLEAN)
          (CONS SYM-METHODS-STELLA-VALUE NIL)
          (CONS
           (LIST* SYM-METHODS-STELLA-DEFINED? SYM-METHODS-STELLA-VALUE NIL)
           NIL))
         (CONS (LIST* SYM-METHODS-STELLA-RETURN SYM-METHODS-STELLA-VALUE NIL)
          NIL)))
       (LIST* SYM-METHODS-STELLA-SETQ SYM-METHODS-STELLA-CURSOR
        (CL:IF
         (CL:OR
          (SUBTYPE-OF? (TYPE INHERITANCESLOT) SGT-METHODS-STELLA-COLLECTION)
          (SUBTYPE-OF? (TYPE INHERITANCESLOT) SGT-METHODS-STELLA-CONS))
         (LIST* SYM-METHODS-STELLA-FIRST
          (CONS INHERITANCESLOTNAME (CONS SYM-METHODS-STELLA-CURSOR NIL)) NIL)
         (CONS INHERITANCESLOTNAME (CONS SYM-METHODS-STELLA-CURSOR NIL)))
        NIL)
       (LIST* SYM-METHODS-STELLA-IF
        (LIST* SYM-METHODS-STELLA-DEFINED? SYM-METHODS-STELLA-CURSOR NIL)
        (LIST* SYM-METHODS-STELLA-SETQ SYM-METHODS-STELLA-VALUE
         (LIST* SYM-METHODS-STELLA-SLOT-VALUE SYM-METHODS-STELLA-CURSOR
          STORAGESLOTNAME NIL)
         NIL)
        (LIST* SYM-METHODS-STELLA-RETURN
         (CL:IF (CL:NOT (CL:EQ DEFAULTVALUE NULL)) DEFAULTVALUE
          SYM-METHODS-STELLA-NULL)
         NIL)
        NIL)
       NIL)
      NIL)
     NIL))))

;;; (DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ...)

(CL:DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF METHOD-SLOT))
  (CL:LET*
   ((OWNERCLASS
     (CL:IF (CL:NOT (CL:EQ (%SLOT-OWNER SELF) NULL))
      (%SURROGATE-VALUE (%SLOT-OWNER SELF)) NULL)))
   (CL:LET*
    ((TS NULL)
     (ITER-000 (%THE-CONS-LIST (METHOD-PARAMETER-TYPE-SPECIFIERS SELF))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TS (%%VALUE ITER-000))
     (VALIDATE-TYPE-SPECIFIER TS OWNERCLASS CL:NIL)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN
    (CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
      NULL))
    (CL:SETF (%SLOT-BASE-TYPE SELF)
     (VALIDATE-TYPE-SPECIFIER
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
      OWNERCLASS CL:NIL)))
   (CL:LET* ((TS NULL) (ITER-001 (REST (METHOD-RETURN-TYPE-SPECIFIERS SELF))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ TS (%%VALUE ITER-001))
     (VALIDATE-TYPE-SPECIFIER TS OWNERCLASS CL:NIL)
     (CL:SETQ ITER-001 (%%REST ITER-001)))))
  :VOID)

;;; (DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT))
  :VOID)

;;; (DEFMETHOD UNFINALIZE-LOCAL-SLOT ...)

(CL:DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT))
  :VOID)

;;; (DEFUN UNDEFINE-EXTERNAL-SLOTS ...)

(CL:DEFUN UNDEFINE-EXTERNAL-SLOTS (NAME)
  (CL:LET* ((SLOTS NIL))
   (CL:LET* ((MODULE NULL) (ITER-000 (ALL-MODULES)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ MODULE (%VALUE ITER-000))
     (CL:LET*
      ((SLOT NULL) (ITER-001 (ALL-SLOTS MODULE CL:T)) (COLLECT-000 NULL))
      (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ SLOT (%VALUE ITER-001))
       (CL:WHEN (CL:AND (CL:EQ (%SLOT-NAME SLOT) NAME) (%SLOT-EXTERNAL? SLOT))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS SLOT NIL))
          (CL:IF (CL:EQ SLOTS NIL) (CL:SETQ SLOTS COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST SLOTS COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS SLOT NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))))
   (CL:LET* ((SLOT NULL) (ITER-002 SLOTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ SLOT (%%VALUE ITER-002)) (DESTROY-EXTERNAL-SLOT SLOT)
     (CL:SETQ ITER-002 (%%REST ITER-002)))))
  :VOID)

;;; (DEFUN DESTROY-EXTERNAL-SLOT ...)

(CL:DEFUN DESTROY-EXTERNAL-SLOT (SELF)
  (CL:WHEN
   (CL:NOT
    (CL:OR (DELETED? SELF) (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (BAD? SELF))
     (CL:NOT (%SLOT-EXTERNAL? SELF))))
   (CL:LET* ((OWNERCLASS (%SURROGATE-VALUE (%SLOT-OWNER SELF))))
    (CL:WHEN (CL:NOT (CL:EQ OWNERCLASS NULL))
     (REMOVE (%CLASS-LOCAL-SLOTS OWNERCLASS) SELF)
     (UNFINALIZE-CLASS-SLOTS OWNERCLASS) (DELETED?-SETTER SELF CL:T))))
  :VOID)

;;; (DEFUN DESTROY-METHOD ...)

(CL:DEFUN DESTROY-METHOD (SELF)
  (DESTROY-EXTERNAL-SLOT SELF)
  :VOID)

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF SLOT))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
    "method-argument-count: Not defined on `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM METHOD-ARGUMENT-COUNT 1))

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF METHOD-SLOT))
  (CL:RETURN-FROM METHOD-ARGUMENT-COUNT (LENGTH (METHOD-PARAMETER-NAMES SELF))))

;;; (DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ...)

(CL:DEFMETHOD METHOD-ARGUMENT-COUNT ((SELF TABLE))
  (CL:RETURN-FROM METHOD-ARGUMENT-COUNT (CL:1- (LENGTH (%TUPLE-DOMAINS SELF)))))

;;; (DEFMETHOD (METHOD-VARIABLE-ARGUMENTS? BOOLEAN) ...)

(CL:DEFMETHOD METHOD-VARIABLE-ARGUMENTS? ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM METHOD-VARIABLE-ARGUMENTS? CL:NIL))

;;; (DEFMETHOD (METHOD-BODY-ARGUMENT? BOOLEAN) ...)

(CL:DEFMETHOD METHOD-BODY-ARGUMENT? ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM METHOD-BODY-ARGUMENT? CL:NIL))

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF STORAGE-SLOT))
  (CL:RETURN-FROM ARITY 2))

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF METHOD-SLOT))
  (CL:WHEN
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-METHODS-STELLA-METHOD-VARIABLE-ARGUMENTS? FALSE-WRAPPER))
   (CL:RETURN-FROM ARITY NULL-INTEGER))
  (CL:LET*
   ((RETURNTYPECOUNT (LENGTH (METHOD-RETURN-TYPE-SPECIFIERS SELF)))
    (RESULT
     (CL:+ (LENGTH (METHOD-PARAMETER-TYPE-SPECIFIERS SELF)) RETURNTYPECOUNT)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM RETURNTYPECOUNT RESULT))
   (CL:CASE RETURNTYPECOUNT
    (1
     (CL:IF
      (CL:EQ (FIRST (METHOD-RETURN-TYPE-SPECIFIERS SELF))
       SGT-METHODS-STELLA-BOOLEAN)
      (CL:RETURN-FROM ARITY (CL:1- RESULT)) (CL:RETURN-FROM ARITY RESULT)))
    (0 (CL:RETURN-FROM ARITY RESULT))
    (CL:OTHERWISE
     (CL:IF
      (CL:EQ (LAST (METHOD-RETURN-TYPE-SPECIFIERS SELF))
       SGT-METHODS-STELLA-BOOLEAN)
      (CL:RETURN-FROM ARITY (CL:1- RESULT)) (CL:RETURN-FROM ARITY RESULT))))))

;;; (DEFMETHOD (ARITY INTEGER) ...)

(CL:DEFMETHOD ARITY ((SELF TABLE))
  (CL:IF
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-METHODS-STELLA-VARIABLE-ARITY-TABLE? FALSE-WRAPPER))
   (CL:RETURN-FROM ARITY NULL-INTEGER)
   (CL:RETURN-FROM ARITY (LENGTH (%TUPLE-DOMAINS SELF)))))

;;; (DEFUN (TYPE-SPEC-TO-BASE-TYPE TYPE) ...)

(CL:DEFUN TYPE-SPEC-TO-BASE-TYPE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM TYPE-SPEC-TO-BASE-TYPE SELF)))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM TYPE-SPEC-TO-BASE-TYPE (%SPECIFIER-BASE-TYPE SELF))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "type-spec-to-base-type: Not defined on `" SELF "'")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (BASE-TYPE-TO-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFUN BASE-TYPE-TO-TYPE-SPEC (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET*
       ((CLASS (%SURROGATE-VALUE SELF)) (PARAMETERS (PARAMETERS CLASS))
        (PARAMETERTYPE NULL) (PARAMETERTYPES NULL))
       (CL:WHEN (NON-EMPTY? PARAMETERS) (CL:SETQ PARAMETERTYPES (NEW-LIST))
        (CL:LET*
         ((PARAMETER NULL) (ITER-000 (%THE-CONS-LIST PARAMETERS))
          (COLLECT-000 NULL))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ PARAMETER (%%VALUE ITER-000))
          (CL:SETQ PARAMETERTYPE
           (COMPUTE-RETURN-TYPE-SPEC (LOOKUP-SLOT CLASS PARAMETER) SELF))
          (CL:WHEN (UNKNOWN-TYPE? PARAMETERTYPE)
           (CL:RETURN-FROM BASE-TYPE-TO-TYPE-SPEC SELF))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS PARAMETERTYPE NIL))
            (CL:IF (CL:EQ (%THE-CONS-LIST PARAMETERTYPES) NIL)
             (CL:SETF (%THE-CONS-LIST PARAMETERTYPES) COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST PARAMETERTYPES)
              COLLECT-000)))
           (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PARAMETERTYPE NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:LET* ((SELF-001 (NEW-PARAMETRIC-TYPE-SPECIFIER)))
         (CL:SETF (%SPECIFIER-BASE-TYPE SELF-001) SELF)
         (CL:SETF (%SPECIFIER-PARAMETER-TYPES SELF-001) PARAMETERTYPES)
         (CL:LET* ((VALUE-000 SELF-001))
          (CL:RETURN-FROM BASE-TYPE-TO-TYPE-SPEC VALUE-000))))
       (CL:RETURN-FROM BASE-TYPE-TO-TYPE-SPEC SELF))))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM BASE-TYPE-TO-TYPE-SPEC SELF)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "base-type-to-type-spec: Not defined on `" SELF "'")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (TYPE-SPEC-TO-CLASS CLASS) ...)

(CL:DEFUN TYPE-SPEC-TO-CLASS (SELF)
  (CL:RETURN-FROM TYPE-SPEC-TO-CLASS
   (%SURROGATE-VALUE (TYPE-SPEC-TO-BASE-TYPE SELF))))

;;; (DEFUN (COMPATIBLE-PARAMETER-TYPES? BOOLEAN) ...)

(CL:DEFUN COMPATIBLE-PARAMETER-TYPES? (SUBTYPE SUPERTYPE)
  (CL:WHEN (CL:OR (TYPE? SUBTYPE) (TYPE? SUPERTYPE))
   (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:T))
  (CL:LET* ((SUBCLASS NULL) (SUPERCLASS NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SUBTYPE)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
      (CL:PROGN (CL:SETQ SUBCLASS (%SURROGATE-VALUE SUBTYPE))))
     ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ SUBCLASS (%SURROGATE-VALUE (%SPECIFIER-BASE-TYPE SUBTYPE)))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SUPERTYPE)))
    (CL:COND
     ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
      (CL:PROGN (CL:SETQ SUPERCLASS (%SURROGATE-VALUE SUPERTYPE))))
     ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-001)
      (CL:PROGN
       (CL:SETQ SUPERCLASS
        (%SURROGATE-VALUE (%SPECIFIER-BASE-TYPE SUPERTYPE)))))
     (CL:T
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-001
        "' is not a valid case option")
       (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
   (CL:LET*
    ((SUPPAR NULL) (ITER-000 (%THE-CONS-LIST (PARAMETERS SUPERCLASS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUPPAR (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:LET* ((FOUND?-000 CL:NIL))
       (CL:LET*
        ((SUBPAR NULL) (ITER-001 (%THE-CONS-LIST (PARAMETERS SUBCLASS))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ SUBPAR (%%VALUE ITER-001))
         (CL:WHEN (CL:EQ SUPPAR SUBPAR) (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:WHEN (CL:NOT FOUND?-000)
        (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:NIL)))
      (CL:LET*
       ((SUBPARTYPE (EXTRACT-PARAMETER-TYPE SUBTYPE SUPPAR))
        (SUPPARTYPE (EXTRACT-PARAMETER-TYPE SUPERTYPE SUPPAR)))
       (CL:WHEN (CL:EQ SUBPARTYPE SUPPARTYPE) (CL:GO :CONTINUE))
       (CL:WHEN
        (CL:AND (CL:NOT (ANCHORED-TYPE-SPECIFIER? SUBPARTYPE))
         (CL:EQ (%SURROGATE-VALUE (TYPE-SPEC-TO-BASE-TYPE SUBPARTYPE)) NULL))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
           " Parameter type `" (TYPE-SPEC-TO-BASE-TYPE SUBPARTYPE) "' of `"
           (DE-UGLIFY-PARSE-TREE SUBTYPE) "' is not yet defined." EOL)))
        (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:NIL))
       (CL:WHEN
        (CL:AND (CL:NOT (ANCHORED-TYPE-SPECIFIER? SUPPARTYPE))
         (CL:EQ (%SURROGATE-VALUE (TYPE-SPEC-TO-BASE-TYPE SUPPARTYPE)) NULL))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
           " Parameter type `" (TYPE-SPEC-TO-BASE-TYPE SUPPARTYPE) "' of `"
           (DE-UGLIFY-PARSE-TREE SUPERTYPE) "' is not yet defined." EOL)))
        (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:NIL))
       (CL:WHEN (CL:NOT (SUB-TYPE-SPEC-OF? SUBPARTYPE SUPPARTYPE))
        (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:NIL)))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM COMPATIBLE-PARAMETER-TYPES? CL:T)))

;;; (DEFUN (SUB-TYPE-SPEC-OF? BOOLEAN) ...)

(CL:DEFUN SUB-TYPE-SPEC-OF? (SUBTYPE SUPERTYPE)
  (CL:WHEN (CL:EQ SUBTYPE SUPERTYPE) (CL:RETURN-FROM SUB-TYPE-SPEC-OF? CL:T))
  (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE SUBTYPE)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-002)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SUPERTYPE)))
       (CL:COND
        ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
         (CL:PROGN
          (CL:RETURN-FROM SUB-TYPE-SPEC-OF?
           (CL:AND (SUBTYPE-OF? SUBTYPE SUPERTYPE)
            (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE)))))
        ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
         (CL:PROGN
          (CL:RETURN-FROM SUB-TYPE-SPEC-OF?
           (CL:AND (SUBTYPE-OF? SUBTYPE (%SPECIFIER-BASE-TYPE SUPERTYPE))
            (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE)))))
        (CL:T (CL:RETURN-FROM SUB-TYPE-SPEC-OF? CL:NIL))))))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-002)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SUPERTYPE)))
       (CL:COND
        ((SUBTYPE-OF-SURROGATE? TEST-VALUE-001)
         (CL:PROGN
          (CL:RETURN-FROM SUB-TYPE-SPEC-OF?
           (CL:AND (SUBTYPE-OF? (%SPECIFIER-BASE-TYPE SUBTYPE) SUPERTYPE)
            (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE)))))
        ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-001)
         (CL:PROGN
          (CL:RETURN-FROM SUB-TYPE-SPEC-OF?
           (CL:AND
            (SUBTYPE-OF? (%SPECIFIER-BASE-TYPE SUBTYPE)
             (%SPECIFIER-BASE-TYPE SUPERTYPE))
            (COMPATIBLE-PARAMETER-TYPES? SUBTYPE SUPERTYPE)))))
        (CL:T (CL:RETURN-FROM SUB-TYPE-SPEC-OF? CL:NIL))))))
    ((SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER? TEST-VALUE-002)
     (CL:PROGN
      (CL:RETURN-FROM SUB-TYPE-SPEC-OF?
       (CL:AND (ANCHORED-TYPE-SPECIFIER? SUPERTYPE)
        (CL:EQ (%SPECIFIER-PARAMETER-NAME SUBTYPE)
         (%SPECIFIER-PARAMETER-NAME SUPERTYPE))))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "sub-type-spec-of?: Not defined on `" SUBTYPE "'")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (VOID? BOOLEAN) ...)

(CL:DEFUN VOID? (TYPE)
  (CL:RETURN-FROM VOID? (CL:EQ TYPE SGT-METHODS-STELLA-VOID)))

;;; (DEFUN (EXTRACT-PARAMETER-TYPE TYPE-SPEC BOOLEAN) ...)

(CL:DEFUN EXTRACT-PARAMETER-TYPE (SELF PARAMETER)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((SLOT (LOOKUP-SLOT (%SURROGATE-VALUE SELF) PARAMETER)))
       (CL:IF (CL:NOT (CL:EQ SLOT NULL))
        (CL:RETURN-FROM EXTRACT-PARAMETER-TYPE (CL:VALUES (TYPE SLOT) CL:T))
        (CL:RETURN-FROM EXTRACT-PARAMETER-TYPE
         (CL:VALUES SGT-METHODS-STELLA-OBJECT CL:NIL))))))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET*
       ((PNAME NULL)
        (ITER-000
         (%THE-CONS-LIST
          (PARAMETERS (%SURROGATE-VALUE (%SPECIFIER-BASE-TYPE SELF)))))
        (PTYPE NULL)
        (ITER-001 (%THE-CONS-LIST (%SPECIFIER-PARAMETER-TYPES SELF))))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-001 NIL)))
        DO (CL:SETQ PNAME (%%VALUE ITER-000))
        (CL:SETQ PTYPE (%%VALUE ITER-001))
        (CL:WHEN (CL:EQ PNAME PARAMETER)
         (CL:RETURN-FROM EXTRACT-PARAMETER-TYPE (CL:VALUES PTYPE CL:T)))
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CL:RETURN-FROM EXTRACT-PARAMETER-TYPE
       (CL:VALUES SGT-METHODS-STELLA-OBJECT CL:NIL))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "extract-parameter-type: Not defined on `" SELF "'")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (COMPUTE-ANCHORED-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFUN COMPUTE-ANCHORED-TYPE-SPEC (OWNERTYPE RELTYPE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OWNERTYPE)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN (CL:EQ (%SPECIFIER-PARAMETER-NAME RELTYPE) NULL)
       (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC OWNERTYPE))
      (CL:LET*
       ((SLOT
         (LOOKUP-SLOT (%SURROGATE-VALUE OWNERTYPE)
          (%SPECIFIER-PARAMETER-NAME RELTYPE))))
       (CL:WHEN (CL:EQ SLOT NULL)
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
         (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
          (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
           " Missing :parameter named `" (%SPECIFIER-PARAMETER-NAME RELTYPE)
           "'" EOL "   for the class `" (DE-UGLIFY-PARSE-TREE OWNERTYPE) "'"
           EOL "." EOL)))
        (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC SGT-METHODS-STELLA-OBJECT))
       (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC (%SLOT-BASE-TYPE SLOT)))))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN (CL:EQ (%SPECIFIER-PARAMETER-NAME RELTYPE) NULL)
       (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC OWNERTYPE))
      (CL:LET*
       ((PNAME NULL)
        (ITER-000
         (%THE-CONS-LIST
          (PARAMETERS (%SURROGATE-VALUE (%SPECIFIER-BASE-TYPE OWNERTYPE)))))
        (PTYPE NULL)
        (ITER-001 (%THE-CONS-LIST (%SPECIFIER-PARAMETER-TYPES OWNERTYPE))))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-001 NIL)))
        DO (CL:SETQ PNAME (%%VALUE ITER-000))
        (CL:SETQ PTYPE (%%VALUE ITER-001))
        (CL:WHEN (CL:EQ PNAME (%SPECIFIER-PARAMETER-NAME RELTYPE))
         (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC PTYPE))
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CL:RETURN-FROM COMPUTE-ANCHORED-TYPE-SPEC
       (COMPUTE-ANCHORED-TYPE-SPEC (%SPECIFIER-BASE-TYPE OWNERTYPE)
        RELTYPE))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "compute-anchored-type-spec: Not defined on `" OWNERTYPE "'")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (COMPUTE-RELATIVE-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFUN COMPUTE-RELATIVE-TYPE-SPEC (RELATIVETYPE OWNERTYPE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE RELATIVETYPE)))
   (CL:COND
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET*
        ((TS NULL)
         (ITER-000
          (%THE-CONS-LIST (%SPECIFIER-PARAMETER-TYPES RELATIVETYPE))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ TS (%%VALUE ITER-000))
         (CL:WHEN (CL:NOT (TYPE? TS)) (CL:SETQ ALWAYS?-000 CL:NIL)
          (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:WHEN ALWAYS?-000
        (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC RELATIVETYPE)))
      (CL:LET*
       ((TYPESLIST (NEW-LIST)) (RELATIVETS NULL)
        (FOUNDRELATIVISTICTYPE? CL:NIL))
       (CL:LET*
        ((TS NULL)
         (ITER-001 (%THE-CONS-LIST (%SPECIFIER-PARAMETER-TYPES RELATIVETYPE)))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ TS (%%VALUE ITER-001))
         (CL:SETQ RELATIVETS (COMPUTE-RELATIVE-TYPE-SPEC TS OWNERTYPE))
         (CL:WHEN (CL:NOT (CL:EQ RELATIVETS TS))
          (CL:SETQ FOUNDRELATIVISTICTYPE? CL:T))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN (CL:SETQ COLLECT-000 (CONS RELATIVETS NIL))
           (CL:IF (CL:EQ (%THE-CONS-LIST TYPESLIST) NIL)
            (CL:SETF (%THE-CONS-LIST TYPESLIST) COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST TYPESLIST)
             COLLECT-000)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS RELATIVETS NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:IF FOUNDRELATIVISTICTYPE?
        (CL:LET* ((NEWTS (NEW-PARAMETRIC-TYPE-SPECIFIER)))
         (CL:SETF (%SPECIFIER-BASE-TYPE NEWTS)
          (%SPECIFIER-BASE-TYPE RELATIVETYPE))
         (CL:SETF (%SPECIFIER-PARAMETER-TYPES NEWTS) TYPESLIST)
         (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC NEWTS))
        (CL:PROGN (FREE TYPESLIST)
         (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC RELATIVETYPE))))))
    ((SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC
       (COMPUTE-ANCHORED-TYPE-SPEC OWNERTYPE RELATIVETYPE))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM COMPUTE-RELATIVE-TYPE-SPEC RELATIVETYPE)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "compute-relative-type-spec: Not defined on `" RELATIVETYPE "'")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFMETHOD COMPUTE-RETURN-TYPE-SPEC ((SELF SLOT) FIRSTARGTYPE)
  (CL:SETQ FIRSTARGTYPE FIRSTARGTYPE)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
    "compute-return-type-spec: Not defined on `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFMETHOD COMPUTE-RETURN-TYPE-SPEC ((SELF METHOD-SLOT) FIRSTARGTYPE)
  (CL:IF
   (CL:EQ
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
    NULL)
   (CL:RETURN-FROM COMPUTE-RETURN-TYPE-SPEC (%SLOT-BASE-TYPE SELF))
   (CL:RETURN-FROM COMPUTE-RETURN-TYPE-SPEC
    (COMPUTE-RELATIVE-TYPE-SPEC
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
     FIRSTARGTYPE))))

;;; (DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFMETHOD COMPUTE-RETURN-TYPE-SPEC ((SELF STORAGE-SLOT) FIRSTARGTYPE)
  (CL:IF
   (CL:EQ
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
    NULL)
   (CL:RETURN-FROM COMPUTE-RETURN-TYPE-SPEC (TYPE SELF))
   (CL:RETURN-FROM COMPUTE-RETURN-TYPE-SPEC
    (COMPUTE-RELATIVE-TYPE-SPEC
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER NULL)
     FIRSTARGTYPE))))

;;; (DEFUN (YIELD-TYPE-SPEC-TREE OBJECT) ...)

(CL:DEFUN YIELD-TYPE-SPEC-TREE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM YIELD-TYPE-SPEC-TREE
       (INTERN-SYMBOL-IN-MODULE (%SYMBOL-NAME SELF) (%HOME-CONTEXT SELF)
        CL:T))))
    ((SUBTYPE-OF-PARAMETRIC-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:LET* ((LISTOFTYPES NIL))
       (CL:LET*
        ((TS NULL)
         (ITER-000 (%THE-CONS-LIST (%SPECIFIER-PARAMETER-TYPES SELF)))
         (COLLECT-000 NULL))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ TS (%%VALUE ITER-000))
         (CL:IF (CL:EQ COLLECT-000 NULL)
          (CL:PROGN (CL:SETQ COLLECT-000 (CONS (YIELD-TYPE-SPEC-TREE TS) NIL))
           (CL:IF (CL:EQ LISTOFTYPES NIL) (CL:SETQ LISTOFTYPES COLLECT-000)
            (ADD-CONS-TO-END-OF-CONS-LIST LISTOFTYPES COLLECT-000)))
          (CL:PROGN
           (CL:SETF (%%REST COLLECT-000) (CONS (YIELD-TYPE-SPEC-TREE TS) NIL))
           (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CL:RETURN-FROM YIELD-TYPE-SPEC-TREE
        (CONS
         (INTERN-SYMBOL-IN-MODULE (%SYMBOL-NAME (%SPECIFIER-BASE-TYPE SELF))
          (%HOME-CONTEXT (%SPECIFIER-BASE-TYPE SELF)) CL:T)
         (CONCATENATE
          (CL:IF (ARRAY-TYPE-SPECIFIER? SELF)
           (LIST* SYM-METHODS-STELLA-SIZE (YIELD-ARRAY-DIMENSIONS-TREE SELF)
            NIL)
           NIL)
          (CONS SYM-METHODS-STELLA-OF (CONCATENATE LISTOFTYPES NIL))))))))
    ((SUBTYPE-OF-ANCHORED-TYPE-SPECIFIER? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (CL:NOT (CL:EQ (%SPECIFIER-PARAMETER-NAME SELF) NULL))
       (CL:RETURN-FROM YIELD-TYPE-SPEC-TREE
        (LIST* SYM-METHODS-STELLA-LIKE
         (CONS (%SPECIFIER-PARAMETER-NAME SELF)
          (CONS SYM-METHODS-STELLA-SELF NIL))
         NIL))
       (CL:RETURN-FROM YIELD-TYPE-SPEC-TREE
        (LIST* SYM-METHODS-STELLA-LIKE SYM-METHODS-STELLA-SELF NIL)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "validate-type-specifier: Not defined on `" SELF "'")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFGLOBAL *FUNCTION-LOOKUP-TABLE* ...)

(CL:DEFVAR *FUNCTION-LOOKUP-TABLE* NULL
  "Lookup table for functions.")

;;; (DEFUN (ATTACH-FUNCTION METHOD-SLOT) ...)

(CL:DEFUN ATTACH-FUNCTION (NEWFUNCTION)
  (CL:LET*
   ((NAME (%SLOT-NAME NEWFUNCTION)) (OLDFUNCTION (LOOKUP-FUNCTION NAME)))
   (CL:WHEN (CL:NOT (UNDEFINE-CONFLICTING-DEFINITIONS? NEWFUNCTION))
    (CL:RETURN-FROM ATTACH-FUNCTION NULL))
   (INSERT-AT *FUNCTION-LOOKUP-TABLE* NAME NEWFUNCTION)
   (UNREGISTER-SLOT-NAME NEWFUNCTION)
   (CL:SETF (%SLOT-EXTERNAL? NEWFUNCTION) CL:T)
   (FINALIZE-SLOT-TYPE-COMPUTATIONS NEWFUNCTION)
   (CL:WHEN (CL:NOT (CL:EQ OLDFUNCTION NULL))
    (RUN-HOOKS *REDEFINE-RELATION-HOOKS* (LIST OLDFUNCTION NEWFUNCTION))
    (FREE OLDFUNCTION))
   (CL:RETURN-FROM ATTACH-FUNCTION NEWFUNCTION)))

;;; (DEFUN (LOOKUP-FUNCTION FUNCTION) ...)

(CL:DEFUN LOOKUP-FUNCTION (FUNCTIONSYMBOL)
  "Return the function defined for 'functionSymbol', if it exists."
  (CL:SETQ FUNCTIONSYMBOL (SOFT-PERMANENTIFY FUNCTIONSYMBOL))
  (CL:LET* ((FUNCTION (LOOKUP *FUNCTION-LOOKUP-TABLE* FUNCTIONSYMBOL)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ FUNCTION NULL))
     (CL:EQ (PRIMARY-TYPE FUNCTION) SGT-METHODS-STELLA-VECTOR))
    (CL:LET*
     ((RECORD FUNCTION)
      (DEFINITION
       (%WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY RECORD)) 0)))
      (OLDFUNCTION (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY RECORD)) 1))
      (MODULENAME
       (%WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY RECORD)) 2)))
      (CODE
       (CL:IF
        (CL:NOT
         (CL:EQ (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY RECORD)) 3)
          NULL))
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY RECORD)) 3))
        NULL))
      (WRAPPERCODE
       (CL:IF (CL:>= (LENGTH RECORD) 5)
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY RECORD)) 4))
        NULL)))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DEFINITION MODULENAME))
     (INSERT-AT *FUNCTION-LOOKUP-TABLE* FUNCTIONSYMBOL OLDFUNCTION)
     (CL:LET*
      ((*MODULE* (GET-STELLA-MODULE MODULENAME CL:T)) (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:SETQ FUNCTION
       (DEFINE-METHOD-FROM-STRINGIFIED-SOURCE (%SYMBOL-NAME FUNCTIONSYMBOL)
        STELLA::NULL-STRING DEFINITION)))
     (CL:WHEN (CL:NOT (CL:EQ FUNCTION NULL))
      (CL:WHEN (CL:NOT (CL:EQ CODE NULL))
       (CL:SETF (%FUNCTION-CODE FUNCTION) CODE))
      (CL:WHEN (CL:NOT (CL:EQ WRAPPERCODE NULL))
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
        SYM-METHODS-STELLA-EVALUATOR-WRAPPER-CODE
        (WRAP-FUNCTION-CODE WRAPPERCODE) NULL-FUNCTION-CODE-WRAPPER)))))
   (CL:RETURN-FROM LOOKUP-FUNCTION FUNCTION)))

;;; (DEFUN (LOOKUP-FUNCTION-BY-NAME FUNCTION) ...)

(CL:DEFUN LOOKUP-FUNCTION-BY-NAME (NAME)
  "Return a function with name 'name' visible from the current module.
Scan all visible symbols looking for one that has a function defined for it."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (CL:LET* ((FUNCTION NULL) (SYMBOL NULL))
   (CL:LET* ((MODULE NULL) (ITER-000 (VISIBLE-MODULES *MODULE*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ MODULE (%%VALUE ITER-000))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:LET* () (CL:SETQ SYMBOL (LOOKUP-SYMBOL-IN-MODULE NAME MODULE CL:T))
       (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ SYMBOL NULL))))
      (CL:WHEN TEST-VALUE-000
       (CL:LET* () (CL:SETQ FUNCTION (LOOKUP-FUNCTION SYMBOL))
        (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ FUNCTION NULL)))))
      (CL:WHEN TEST-VALUE-000
       (CL:RETURN-FROM LOOKUP-FUNCTION-BY-NAME FUNCTION)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:RETURN-FROM LOOKUP-FUNCTION-BY-NAME NULL)))

;;; (DEFUN (LOOKUP-FUNCTION-OR-STELLA-FUNCTION FUNCTION) ...)

(CL:DEFUN LOOKUP-FUNCTION-OR-STELLA-FUNCTION (FUNCTIONSYMBOL)
  (CL:RETURN-FROM LOOKUP-FUNCTION-OR-STELLA-FUNCTION
   (LOOKUP-FUNCTION FUNCTIONSYMBOL)))

;;; (DEFUN (LOOKUP-FUNCTION-HOME-MODULE MODULE) ...)

(CL:DEFUN LOOKUP-FUNCTION-HOME-MODULE (FUNCTIONSYMBOL)
  (CL:SETQ FUNCTIONSYMBOL (SOFT-PERMANENTIFY FUNCTIONSYMBOL))
  (CL:LET* ((FUNCTION (LOOKUP *FUNCTION-LOOKUP-TABLE* FUNCTIONSYMBOL)))
   (CL:WHEN (CL:EQ FUNCTION NULL)
    (CL:RETURN-FROM LOOKUP-FUNCTION-HOME-MODULE NULL))
   (CL:LET* ((TEST-VALUE-000 (PRIMARY-TYPE FUNCTION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SGT-METHODS-STELLA-VECTOR)
      (CL:RETURN-FROM LOOKUP-FUNCTION-HOME-MODULE
       (GET-STELLA-MODULE
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY FUNCTION)) 2))
        CL:T)))
     ((CL:EQ TEST-VALUE-000 SGT-METHODS-STELLA-METHOD-SLOT)
      (CL:RETURN-FROM LOOKUP-FUNCTION-HOME-MODULE (HOME-MODULE FUNCTION)))
     (CL:T (CL:RETURN-FROM LOOKUP-FUNCTION-HOME-MODULE NULL))))))

;;; (DEFUN UNDEFINE-FUNCTION ...)

(CL:DEFUN UNDEFINE-FUNCTION (NAME)
  (CL:LET* ((FUNCTION (LOOKUP-FUNCTION NAME)))
   (CL:WHEN (CL:NOT (CL:EQ FUNCTION NULL)) (DESTROY-FUNCTION FUNCTION)))
  :VOID)

;;; (DEFUN DESTROY-FUNCTION ...)

(CL:DEFUN DESTROY-FUNCTION (FUNCTION)
  (CL:LET*
   ((FUNCTIONNAME (%SLOT-NAME FUNCTION)) (SLOTREF (%SLOT-SLOTREF FUNCTION))
    (REALFUNCTION (LOOKUP-FUNCTION FUNCTIONNAME)))
   (CL:WHEN (CL:EQ FUNCTION REALFUNCTION)
    (REMOVE-AT *FUNCTION-LOOKUP-TABLE* FUNCTIONNAME))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ SLOTREF NULL))
     (CL:EQ FUNCTION (%SURROGATE-VALUE SLOTREF)))
    (CL:SETF (%SURROGATE-VALUE SLOTREF) NULL))
   (DELETED?-SETTER FUNCTION CL:T) (FREE FUNCTION))
  :VOID)

;;; (DEFUN (UNDEFINE-CONFLICTING-DEFINITIONS? BOOLEAN) ...)

(CL:DEFUN UNDEFINE-CONFLICTING-DEFINITIONS? (NEWSLOT)
  (CL:COND
   ((%METHOD-FUNCTION? NEWSLOT)
    (CL:WHEN (WARN-ABOUT-FUNCTION-SHADOWING-SLOTS? NEWSLOT)
     (CL:WHEN
      (CL:NOT
       (Y-OR-N? "Do you want to remove the conflicting method definitions? "))
      (CL:RETURN-FROM UNDEFINE-CONFLICTING-DEFINITIONS? CL:NIL))
     (UNDEFINE-EXTERNAL-SLOTS (%SLOT-NAME NEWSLOT))
     (UNREGISTER-SLOT-NAME NEWSLOT))
    (CL:COND
     ((CL:NOT (CL:EQ (LOOKUP-MACRO (%SLOT-NAME NEWSLOT)) NULL))
      (CL:IF
       (CL:NOT
        (%WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWSLOT)
          SYM-METHODS-STELLA-METHOD-MACRO? FALSE-WRAPPER)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-WARNING)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING) EOL " Function `"
          (DE-UGLIFY-PARSE-TREE NEWSLOT)
          "' redefines an exisiting macro of the same name." EOL)))
       (CL:WHEN (CL:EQ (%FUNCTION-CODE NEWSLOT) NULL)
        (CL:SETF (%FUNCTION-CODE NEWSLOT)
         (%FUNCTION-CODE (LOOKUP-MACRO (%SLOT-NAME NEWSLOT)))))))
     ((CL:NOT (CL:EQ (LOOKUP-FUNCTION (%SLOT-NAME NEWSLOT)) NULL))
      (CL:WHEN
       (%WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWSLOT)
         SYM-METHODS-STELLA-METHOD-MACRO? FALSE-WRAPPER))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (SIGNAL-TRANSLATION-WARNING)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> WARNING: " STANDARD-WARNING)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-WARNING) EOL " Macro `"
          (DE-UGLIFY-PARSE-TREE NEWSLOT)
          "' redefines an exisiting function of the same name." EOL)))))))
   (CL:T
    (CL:WHEN (WARN-ABOUT-SLOT-SHADOWED-BY-A-FUNCTION? NEWSLOT)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      " Removing the preexisting function definition." EOL)
     (UNDEFINE-FUNCTION (%SLOT-NAME NEWSLOT)))))
  (CL:RETURN-FROM UNDEFINE-CONFLICTING-DEFINITIONS? CL:T))

;;; (DEFUN DEFINE-FUNCTION-OBJECT ...)

(CL:DEFUN DEFINE-FUNCTION-OBJECT (NAME DEFINITION CODE WRAPPERCODE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME DEFINITION))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DEFINITION CL:SIMPLE-STRING)
  (CL:LET*
   ((NAMESYMBOL
     (CL:IF
      (CL:EQL
       (CL:LET ((SELF NAME) (POSITION 0))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)))
       #\ )
      (READ-S-EXPRESSION-FROM-STRING NAME)
      (INTERN-SYMBOL-IN-MODULE NAME NULL CL:NIL)))
    (OLDFUNCTION (LOOKUP *FUNCTION-LOOKUP-TABLE* NAMESYMBOL))
    (RECORD (NEW-VECTOR (CL:IF (CL:NOT (CL:EQ WRAPPERCODE NULL)) 5 4))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ OLDFUNCTION NULL))
     (CL:EQ (PRIMARY-TYPE OLDFUNCTION) SGT-METHODS-STELLA-VECTOR))
    (CL:SETQ OLDFUNCTION NULL))
   (CL:LET
    ((SELF (%THE-ARRAY RECORD)) (VALUE (WRAP-STRING DEFINITION)) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET ((SELF (%THE-ARRAY RECORD)) (VALUE OLDFUNCTION) (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY RECORD))
     (VALUE (WRAP-STRING (%MODULE-FULL-NAME *MODULE*))) (POSITION 2))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:WHEN (CL:NOT (CL:EQ CODE NULL))
    (CL:LET
     ((SELF (%THE-ARRAY RECORD)) (VALUE (WRAP-FUNCTION-CODE CODE))
      (POSITION 3))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE)))
   (CL:WHEN (CL:NOT (CL:EQ WRAPPERCODE NULL))
    (CL:LET
     ((SELF (%THE-ARRAY RECORD)) (VALUE (WRAP-FUNCTION-CODE WRAPPERCODE))
      (POSITION 4))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE)))
   (INSERT-AT *FUNCTION-LOOKUP-TABLE* NAMESYMBOL RECORD))
  :VOID)

;;; (DEFGLOBAL *GLOBAL-VARIABLE-LOOKUP-TABLE* ...)

(CL:DEFVAR *GLOBAL-VARIABLE-LOOKUP-TABLE* NULL
  "Lookup table for global variables.")

;;; (DEFUN (INTERN-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFUN INTERN-GLOBAL-VARIABLE (GLOBAL)
  (CL:LET*
   ((NAME (%VARIABLE-NAME GLOBAL)) (OLDGLOBAL (LOOKUP-GLOBAL-VARIABLE NAME)))
   (CL:WHEN (CL:NOT (CL:EQ OLDGLOBAL NULL))
    (CL:COND
     ((STRING-EQL? (%VARIABLE-STRINGIFIED-SOURCE GLOBAL)
       (%VARIABLE-STRINGIFIED-SOURCE OLDGLOBAL))
      (FREE GLOBAL) (CL:RETURN-FROM INTERN-GLOBAL-VARIABLE OLDGLOBAL))
     (CL:T
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "Redefining the global variable `" (%VARIABLE-NAME GLOBAL) "'" EOL)
      (FREE OLDGLOBAL))))
   (INSERT-AT *GLOBAL-VARIABLE-LOOKUP-TABLE* NAME GLOBAL)
   (CL:RETURN-FROM INTERN-GLOBAL-VARIABLE GLOBAL)))

;;; (DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFMETHOD LOOKUP-GLOBAL-VARIABLE ((SELF GENERALIZED-SYMBOL))
  "Return a global variable with name 'self'."
  (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE
   (LOOKUP *GLOBAL-VARIABLE-LOOKUP-TABLE* SELF)))

;;; (DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFMETHOD LOOKUP-GLOBAL-VARIABLE ((SELF SURROGATE))
  "Return a global variable with name 'self'."
  (CL:LET*
   ((SYMBOL
     (LOOKUP-RIGID-SYMBOL-WRT-MODULE (%SYMBOL-NAME SELF) (%HOME-CONTEXT SELF)
      SYMBOL-SYM)))
   (CL:IF (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE (LOOKUP-GLOBAL-VARIABLE SYMBOL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE NULL))))

;;; (DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ...)

(CL:DEFMETHOD LOOKUP-GLOBAL-VARIABLE ((SELF CL:STRING))
  "Return a global variable with name 'self'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF))
  #+MCL
  (CL:CHECK-TYPE SELF CL:SIMPLE-STRING)
  (CL:LET* ((SYMBOL (LOOKUP-SYMBOL SELF)))
   (CL:IF (CL:NOT (CL:EQ SYMBOL NULL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE (LOOKUP-GLOBAL-VARIABLE SYMBOL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE NULL))))

;;; (DEFUN (GLOBAL-VARIABLE-TYPE-SPEC TYPE-SPEC) ...)

(CL:DEFUN GLOBAL-VARIABLE-TYPE-SPEC (GLOBAL)
  "Return the type spec for the global variable `global'."
  (CL:LET*
   ((TYPE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS GLOBAL)
      SYM-METHODS-STELLA-VARIABLE-TYPE-SPECIFIER NULL)))
   (CL:IF (CL:NOT (CL:EQ TYPE NULL))
    (CL:RETURN-FROM GLOBAL-VARIABLE-TYPE-SPEC TYPE)
    (CL:RETURN-FROM GLOBAL-VARIABLE-TYPE-SPEC (%VARIABLE-TYPE GLOBAL)))))

;;; (DEFUN (LOOKUP-GLOBAL-VARIABLE-TYPE TYPE-SPEC) ...)

(CL:DEFUN LOOKUP-GLOBAL-VARIABLE-TYPE (NAME)
  (CL:LET* ((GLOBAL (LOOKUP-GLOBAL-VARIABLE NAME)))
   (CL:IF (CL:NOT (CL:EQ GLOBAL NULL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-TYPE
     (GLOBAL-VARIABLE-TYPE-SPEC GLOBAL))
    (CL:RETURN-FROM LOOKUP-GLOBAL-VARIABLE-TYPE NULL))))

;;; (DEFUN (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE GLOBAL-VARIABLE OBJECT) ...)

(CL:DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE (TREE STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (CL:LET*
   ((TYPETREE (%%VALUE (%%REST (%%REST TREE))))
    (INITIALVALUETREE (FOURTH TREE)) (OPTIONSTREE (NTH-REST TREE 4))
    (SPECIAL? (CL:EQ (%%VALUE TREE) SYM-METHODS-STELLA-DEFSPECIAL))
    (CONSTANT? (CL:EQ (%%VALUE TREE) SYM-METHODS-STELLA-DEFCONSTANT))
    (NOINITIALVALUE? CL:NIL) (GLOBAL (NEW-GLOBAL-VARIABLE))
    (INTERNEDGLOBAL NULL))
   (CL:WHEN
    (CL:OR (CL:<= (LENGTH TREE) 3)
     (CL:AND
      (MEMBER?
       (GET-QUOTED-TREE "((:DOCUMENTATION :PUBLIC? :AUXILIARY?) \"/STELLA\")"
        "/STELLA")
       INITIALVALUETREE)
      (CL:LOGBITP 0 (CL:THE CL:FIXNUM (LENGTH OPTIONSTREE)))))
    (CL:SETQ NOINITIALVALUE? CL:T)
    (CL:SETQ INITIALVALUETREE
     (CL:IF SPECIAL? KWD-METHODS-UNBOUND-SPECIAL-VARIABLE NULL))
    (CL:SETQ OPTIONSTREE (NTH-REST TREE 3)))
   (CL:SETF (%VARIABLE-NAME GLOBAL) (PERMANENTIFY (%%VALUE (%%REST TREE))))
   (CL:SETF (%VARIABLE-STRINGIFIED-SOURCE GLOBAL) STRINGIFIEDSOURCE)
   (CL:SETQ INTERNEDGLOBAL (INTERN-GLOBAL-VARIABLE GLOBAL))
   (RECORD-VARIABLE-HOME-MODULE INTERNEDGLOBAL)
   (CL:WHEN (CL:AND NOINITIALVALUE? (CL:NOT SPECIAL?))
    (CL:IF CONSTANT?
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
        " Missing value in constant declaration." EOL)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
        " Missing initial value in variable declaration." EOL))))
    (CL:RETURN-FROM DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
     (CL:VALUES INTERNEDGLOBAL INITIALVALUETREE)))
   (CL:WHEN (CL:NOT (CL:EQ GLOBAL INTERNEDGLOBAL))
    (CL:RETURN-FROM DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
     (CL:VALUES INTERNEDGLOBAL INITIALVALUETREE)))
   (CL:SETQ TYPETREE (YIELD-TYPE-SPECIFIER TYPETREE))
   (VALIDATE-TYPE-SPECIFIER TYPETREE NULL CL:T)
   (CL:IF (TYPE? TYPETREE) (CL:SETF (%VARIABLE-TYPE GLOBAL) TYPETREE)
    (CL:PROGN
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS GLOBAL)
      SYM-METHODS-STELLA-VARIABLE-TYPE-SPECIFIER TYPETREE NULL)
     (CL:SETF (%VARIABLE-TYPE GLOBAL) (TYPE-SPEC-TO-BASE-TYPE TYPETREE))))
   (CL:SETF (%VARIABLE-SPECIAL? GLOBAL) SPECIAL?)
   (CL:SETF (%VARIABLE-CONSTANT? GLOBAL) CONSTANT?)
   (CL:WHEN (CL:NOT (CL:EQ OPTIONSTREE NIL))
    (CL:LET* ((OPTIONS (NEW-PROPERTY-LIST)))
     (CL:SETF (%THE-PLIST OPTIONS) OPTIONSTREE)
     (CL:LET* ((KEY NULL) (VALUE NULL) (ITER-000 (%THE-PLIST OPTIONS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ KEY (%%VALUE ITER-000))
       (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
       (CL:LET* ((TEST-VALUE-000 KEY))
        (CL:COND
         ((CL:EQ TEST-VALUE-000 KWD-METHODS-DOCUMENTATION)
          (CL:SETF (%DOCUMENTATION GLOBAL) (%WRAPPER-VALUE VALUE)))
         ((CL:EQ TEST-VALUE-000 KWD-METHODS-PUBLIC?)
          (CL:SETF (%VARIABLE-PUBLIC? GLOBAL)
           (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (COERCE-TO-BOOLEAN VALUE))))
         ((CL:EQ TEST-VALUE-000 KWD-METHODS-AUXILIARY?)
          (CL:SETF (%VARIABLE-AUXILIARY? GLOBAL)
           (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (COERCE-TO-BOOLEAN VALUE))))
         (CL:T
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
            "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
       (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
     (CL:SETF (%THE-PLIST OPTIONS) NULL)))
   (CL:RETURN-FROM DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
    (CL:VALUES GLOBAL INITIALVALUETREE))))

;;; (DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE ...)

(CL:DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE (STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE
   (UNSTRINGIFY-STELLA-SOURCE STRINGIFIEDSOURCE NULL) STRINGIFIEDSOURCE)
  :VOID)

;;; (DEFUN (RECORD-VARIABLE-HOME-MODULE MODULE) ...)

(CL:DEFUN RECORD-VARIABLE-HOME-MODULE (SELF)
  (CL:LET*
   ((NAME (%VARIABLE-NAME SELF)) (NAMEMODULE (%HOME-CONTEXT NAME))
    (DEFINITIONMODULE *MODULE*) (HOMEMODULE NAMEMODULE))
   (CL:IF (EXPLICITLY-QUALIFIED-NAME? NAME DEFINITIONMODULE)
    (CL:SETQ HOMEMODULE NAMEMODULE) (CL:SETQ HOMEMODULE DEFINITIONMODULE))
   (CL:WHEN (CL:NOT (CL:EQ HOMEMODULE NAMEMODULE))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-METHODS-STELLA-VARIABLE-HOME-MODULE HOMEMODULE NULL))
   (CL:RETURN-FROM RECORD-VARIABLE-HOME-MODULE HOMEMODULE)))

;;; (DEFUN (GET-GLOBAL-VALUE OBJECT) ...)

(CL:DEFUN GET-GLOBAL-VALUE (SELF)
  "Return the (possibly-wrapped) value of the global
variable for the surrogate 'self'."
  (CL:RETURN-FROM GET-GLOBAL-VALUE
   (CL:FUNCALL (%VARIABLE-GET-VALUE-CODE (LOOKUP-GLOBAL-VARIABLE SELF)))))

;;; (DEFUN (SET-GLOBAL-VALUE OBJECT) ...)

(CL:DEFUN SET-GLOBAL-VALUE (SELF VALUE)
  "Set the value of the global variable for the surrogate
'self' to 'value'."
  (CL:RETURN-FROM SET-GLOBAL-VALUE
   (CL:FUNCALL (%VARIABLE-SET-VALUE-CODE (LOOKUP-GLOBAL-VARIABLE SELF)) VALUE)))

;;; (DEFUN DESTROY-VARIABLE ...)

(CL:DEFUN DESTROY-VARIABLE (VARIABLE)
  (CL:LET*
   ((VARIABLENAME (%VARIABLE-NAME VARIABLE))
    (REALVARIABLE (LOOKUP-GLOBAL-VARIABLE VARIABLENAME)))
   (CL:WHEN (CL:EQ VARIABLE REALVARIABLE)
    (REMOVE-AT *GLOBAL-VARIABLE-LOOKUP-TABLE* VARIABLENAME))
   (DELETED?-SETTER VARIABLE CL:T) (FREE VARIABLE))
  :VOID)

;;; (DEFUN (DEFINE-STELLA-TYPE-FROM-PARSE-TREE TYPE) ...)

(CL:DEFUN DEFINE-STELLA-TYPE-FROM-PARSE-TREE (TREE)
  (CL:LET*
   ((TYPENAME (%%VALUE (%%REST TREE)))
    (TYPEDEFINITION (YIELD-TYPE-SPECIFIER (%%VALUE (%%REST (%%REST TREE)))))
    (TYPE NULL))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE TYPENAME))
     (CL:PROGN (CL:SETQ TYPE (TYPIFY TYPENAME))
      (CL:WHEN
       (CL:AND (CL:NOT (DEFINED-TYPE? TYPE))
        (CL:NOT (CL:EQ (%SURROGATE-VALUE TYPE) NULL)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
        (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
         (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
          " Cannot define type `" (DE-UGLIFY-PARSE-TREE TYPENAME) "', since `"
          (DE-UGLIFY-PARSE-TREE TYPE) "'" EOL "   already points to `"
          (%SURROGATE-VALUE TYPE) "'." EOL)))
       (CL:RETURN-FROM DEFINE-STELLA-TYPE-FROM-PARSE-TREE NULL))
      (CL:SETF (%SURROGATE-VALUE TYPE) TYPEDEFINITION)
      (CL:RETURN-FROM DEFINE-STELLA-TYPE-FROM-PARSE-TREE TYPE)))
    (CL:T
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*)) (SIGNAL-TRANSLATION-ERROR)
      (CL:WHEN (CL:NOT (SUPPRESS-WARNINGS?))
       (PRINT-ERROR-CONTEXT ">> ERROR: " STANDARD-ERROR)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) EOL
        " Illegal type name: `" (DE-UGLIFY-PARSE-TREE TYPENAME) "'." EOL)))
     (CL:RETURN-FROM DEFINE-STELLA-TYPE-FROM-PARSE-TREE NULL)))))

;;; (DEFUN DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE ...)

(CL:DEFUN DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE (STRINGIFIEDSOURCE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGIFIEDSOURCE))
  #+MCL
  (CL:CHECK-TYPE STRINGIFIEDSOURCE CL:SIMPLE-STRING)
  (DEFINE-STELLA-TYPE-FROM-PARSE-TREE
   (UNSTRINGIFY-STELLA-SOURCE STRINGIFIEDSOURCE NULL))
  :VOID)

(CL:DEFUN HELP-STARTUP-METHODS1 ()
  (CL:PROGN
   (CL:SETQ SGT-METHODS-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-PARAMETRIC-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARAMETRIC-TYPE-SPECIFIER" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-ANCHORED-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANCHORED-TYPE-SPECIFIER" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-VOID
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VOID" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-LIKE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIKE" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SIZE" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-UNKNOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OF" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARRAY" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-SELF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SELF" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-IN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-OUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUT" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-INOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INOUT" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-PARAMETER-DIRECTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-PARAMETER-DIRECTIONS" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-ARGUMENT-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-LIST" NULL 0))
   (CL:SETQ |SYM-METHODS-STELLA-&REST|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "&REST" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-VARIABLE-ARGUMENTS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-VARIABLE-ARGUMENTS?" NULL 0))
   (CL:SETQ |SYM-METHODS-STELLA-&BODY|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "&BODY" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-BODY-ARGUMENT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-BODY-ARGUMENT?" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-UNKNOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN" NULL 1))
   (CL:SETQ SGT-METHODS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" NULL 1))
   (CL:SETQ KWD-METHODS-TYPE (INTERN-RIGID-SYMBOL-WRT-MODULE "TYPE" NULL 2))
   (CL:SETQ KWD-METHODS-RETURN-TYPES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN-TYPES" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-SLOT-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-TYPE-SPECIFIER" NULL 0))
   (CL:SETQ KWD-METHODS-PUBLIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PUBLIC?" NULL 2))
   (CL:SETQ KWD-METHODS-ABSTRACT?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT?" NULL 2))
   (CL:SETQ KWD-METHODS-NATIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NATIVE?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-NATIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-NATIVE?" NULL 0))
   (CL:SETQ KWD-METHODS-CONSTRUCTOR?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTRUCTOR?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-CONSTRUCTOR?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CONSTRUCTOR?" NULL 0))
   (CL:SETQ KWD-METHODS-GLOBALLY-INLINE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GLOBALLY-INLINE?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-GLOBALLY-INLINE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-GLOBALLY-INLINE?" NULL 0))
   (CL:SETQ KWD-METHODS-INLINE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INLINE" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-INLINED-FUNCTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-INLINED-FUNCTIONS" NULL 0))
   (CL:SETQ KWD-METHODS-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AUXILIARY?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-SLOT-AUXILIARY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-AUXILIARY?" NULL 0))
   (CL:SETQ KWD-METHODS-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 0))
   (CL:SETQ KWD-METHODS-RETURNS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURNS" NULL 2))
   (CL:SETQ KWD-METHODS-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-STORAGE-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STORAGE-SLOT" NULL 0))
   (CL:SETQ KWD-METHODS-INHERITS-THROUGH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INHERITS-THROUGH" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-INHERITS-THROUGH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-INHERITS-THROUGH" NULL 0))
   (CL:SETQ KWD-METHODS-PROPERTIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-PROPERTIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPERTIES" NULL 0))
   (CL:SETQ KWD-METHODS-META-ATTRIBUTES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-META-ATTRIBUTES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-ATTRIBUTES" NULL 0))
   (CL:SETQ KWD-METHODS-COMMAND?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMAND?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-COMMAND?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-COMMAND?" NULL 0))
   (CL:SETQ KWD-METHODS-LISP-MACRO?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISP-MACRO?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-LISP-MACRO?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-LISP-MACRO?" NULL 0))
   (CL:SETQ KWD-METHODS-EVALUATE-ARGUMENTS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATE-ARGUMENTS?" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-EVALUATE-ARGUMENTS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-EVALUATE-ARGUMENTS?" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-CONCATENATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCATENATE" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-DEFINE-FUNCTION-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE-FUNCTION-OBJECT" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-THE-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-CODE" NULL 0))
   (CL:SETQ KWD-METHODS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-DEFINE-METHOD-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINE-METHOD-OBJECT" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-METHODS2 ()
  (CL:PROGN
   (CL:SETQ KWD-METHODS-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD" NULL 2))
   (CL:SETQ SGT-METHODS-STELLA-BOOLEAN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOOLEAN" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-SUPER-CLASSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPER-CLASSES" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-EQUIVALENT-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT-SLOT" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-CLASS-ALL-SUPER-CLASSES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS-ALL-SUPER-CLASSES" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-SLOT-DIRECT-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-DIRECT-EQUIVALENT" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-LET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LET" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURSOR" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-SLOT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT-VALUE" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-LOOP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOP" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-WHEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHEN" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-RETURN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETURN" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-SETQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETQ" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-IF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IF" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-DEFINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINED?" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-FIRST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FIRST" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-VARIABLE-ARITY-TABLE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-ARITY-TABLE?" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VECTOR" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-EVALUATOR-WRAPPER-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATOR-WRAPPER-CODE" NULL 0))
   (CL:SETQ SGT-METHODS-STELLA-METHOD-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-SLOT" NULL 1))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-MACRO?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-MACRO?" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-VARIABLE-TYPE-SPECIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE-SPECIFIER" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-DEFSPECIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSPECIAL" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-DEFCONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCONSTANT" NULL 0))
   (CL:SETQ KWD-METHODS-UNBOUND-SPECIAL-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBOUND-SPECIAL-VARIABLE" NULL 2))
   (CL:SETQ SYM-METHODS-STELLA-VARIABLE-HOME-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-HOME-MODULE" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-STARTUP-METHODS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-METHODS" NULL 0))
   (CL:SETQ SYM-METHODS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME" NULL 0)))
  :VOID)

(CL:DEFUN HELP-STARTUP-METHODS3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "APPLY"
    "(DEFUN (APPLY OBJECT) ((CODE FUNCTION-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
OBJECT.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-METHOD"
    "(DEFUN (APPLY-METHOD OBJECT) ((CODE METHOD-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
OBJECT.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-INTEGER-METHOD"
    "(DEFUN (APPLY-INTEGER-METHOD INTEGER) ((CODE METHOD-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
INTEGER.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY-INTEGER-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-STRING-METHOD"
    "(DEFUN (APPLY-STRING-METHOD STRING) ((CODE METHOD-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
STRING.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY-STRING-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-BOOLEAN-METHOD"
    "(DEFUN (APPLY-BOOLEAN-METHOD BOOLEAN) ((CODE METHOD-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
BOOLEAN.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY-BOOLEAN-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-FLOAT-METHOD"
    "(DEFUN (APPLY-FLOAT-METHOD FLOAT) ((CODE METHOD-CODE) (ARGUMENTS (CONS OF OBJECT))) :DOCUMENTATION \"Apply `code' to `arguments', returning a value of type
FLOAT.\" :PUBLIC? TRUE)" (CL:FUNCTION APPLY-FLOAT-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINED-TYPE?"
    "(DEFUN (DEFINED-TYPE? BOOLEAN) ((TYPE TYPE)) :PUBLIC? TRUE)"
    (CL:FUNCTION DEFINED-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "REAL-TYPE-SPECIFIER"
    "(DEFUN (REAL-TYPE-SPECIFIER TYPE-SPEC) ((TYPE TYPE)))"
    (CL:FUNCTION REAL-TYPE-SPECIFIER) NULL)
   (DEFINE-FUNCTION-OBJECT "CANONICAL-TYPE"
    "(DEFUN (CANONICAL-TYPE TYPE) ((TYPE TYPE)))" (CL:FUNCTION CANONICAL-TYPE)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE TYPE)))"
    (CL:FUNCTION YIELD-TYPE-SPECIFIER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE SYMBOL)))"
    (CL:FUNCTION YIELD-TYPE-SPECIFIER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE PARAMETRIC-TYPE-SPECIFIER)))"
    (CL:FUNCTION YIELD-TYPE-SPECIFIER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE ANCHORED-TYPE-SPECIFIER)))"
    (CL:FUNCTION YIELD-TYPE-SPECIFIER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE OBJECT)))"
    (CL:FUNCTION YIELD-TYPE-SPECIFIER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (YIELD-TYPE-SPECIFIER TYPE-SPEC) ((TYPESPECTREE CONS)))"
    (CL:FUNCTION YIELD-TYPE-SPECIFIER) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-PARAMETRIC-TYPE-SPECIFIER"
    "(DEFUN (YIELD-PARAMETRIC-TYPE-SPECIFIER PARAMETRIC-TYPE-SPECIFIER) ((TYPESPECTREE CONS)))"
    (CL:FUNCTION YIELD-PARAMETRIC-TYPE-SPECIFIER) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-ARRAY-DIMENSIONS-SPEC"
    "(DEFUN (PARSE-ARRAY-DIMENSIONS-SPEC (LIST OF INTEGER-WRAPPER)) ((DIMENSIONSSPEC OBJECT)))"
    (CL:FUNCTION PARSE-ARRAY-DIMENSIONS-SPEC) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-ARRAY-DIMENSIONS-TREE"
    "(DEFUN (YIELD-ARRAY-DIMENSIONS-TREE CONS) ((ARRAYTYPE PARAMETRIC-TYPE-SPECIFIER)))"
    (CL:FUNCTION YIELD-ARRAY-DIMENSIONS-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ARRAY-TYPE-SPECIFIER?"
    "(DEFUN (ARRAY-TYPE-SPECIFIER? BOOLEAN) ((TYPESPEC TYPE-SPEC)))"
    (CL:FUNCTION ARRAY-TYPE-SPECIFIER?) NULL)
   (DEFINE-FUNCTION-OBJECT "ARRAY-TYPE-RANK"
    "(DEFUN (ARRAY-TYPE-RANK INTEGER) ((ARRAYTYPE PARAMETRIC-TYPE-SPECIFIER)))"
    (CL:FUNCTION ARRAY-TYPE-RANK) NULL)
   (DEFINE-FUNCTION-OBJECT "ARRAY-TYPE-DIMENSIONS"
    "(DEFUN (ARRAY-TYPE-DIMENSIONS (LIST OF INTEGER-WRAPPER)) ((ARRAYTYPE PARAMETRIC-TYPE-SPECIFIER)))"
    (CL:FUNCTION ARRAY-TYPE-DIMENSIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "INDEFINITE-ARRAY-TYPE?"
    "(DEFUN (INDEFINITE-ARRAY-TYPE? BOOLEAN) ((ARRAYTYPE PARAMETRIC-TYPE-SPECIFIER)))"
    (CL:FUNCTION INDEFINITE-ARRAY-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-ANCHORED-TYPE-SPECIFIER"
    "(DEFUN (YIELD-ANCHORED-TYPE-SPECIFIER ANCHORED-TYPE-SPECIFIER) ((TYPESPECTREE CONS)))"
    (CL:FUNCTION YIELD-ANCHORED-TYPE-SPECIFIER) NULL)
   (DEFINE-FUNCTION-OBJECT "INCORPORATE-INPUT-PARAMETERS"
    "(DEFUN INCORPORATE-INPUT-PARAMETERS ((METHOD METHOD-SLOT) (PARAMETERS CONS)))"
    (CL:FUNCTION INCORPORATE-INPUT-PARAMETERS) NULL)
   (DEFINE-FUNCTION-OBJECT "INCORPORATE-FIRST-INPUT-PARAMETER"
    "(DEFUN INCORPORATE-FIRST-INPUT-PARAMETER ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION INCORPORATE-FIRST-INPUT-PARAMETER) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-STELLA-METHOD-SLOT"
    "(DEFUN (DEFINE-STELLA-METHOD-SLOT METHOD-SLOT) ((INPUTNAME SYMBOL) (RETURNTYPES CONS) (FUNCTION? BOOLEAN) (INPUTPARAMETERS CONS) (OPTIONS KEYWORD-KEY-VALUE-LIST)) :DOCUMENTATION \"Define a new Stella method object (a slot), and attach it
to the class identified by the first parameter in 'inputParameters'.\")"
    (CL:FUNCTION DEFINE-STELLA-METHOD-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "ATTACH-METHOD-SLOT-TO-OWNER"
    "(DEFUN (ATTACH-METHOD-SLOT-TO-OWNER METHOD-SLOT) ((NEWMETHOD METHOD-SLOT)))"
    (CL:FUNCTION ATTACH-METHOD-SLOT-TO-OWNER) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-STRING-CONSTANT-TREE"
    "(DEFUN (YIELD-STRING-CONSTANT-TREE OBJECT) ((STRING STRING)))"
    (CL:FUNCTION YIELD-STRING-CONSTANT-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-DEFINE-STELLA-METHOD-OBJECT"
    "(DEFUN (YIELD-DEFINE-STELLA-METHOD-OBJECT CONS) ((METHOD METHOD-SLOT) (CODEMETHOD METHOD-SLOT) (WRAPPERMETHOD METHOD-SLOT)))"
    (CL:FUNCTION YIELD-DEFINE-STELLA-METHOD-OBJECT) NULL)
   (DEFINE-FUNCTION-OBJECT "YIELD-CLASS-PARAMETER-TYPES"
    "(DEFUN (YIELD-CLASS-PARAMETER-TYPES (CONS OF TYPE)) ((CLASS CLASS)))"
    (CL:FUNCTION YIELD-CLASS-PARAMETER-TYPES) NULL)
   (DEFINE-FUNCTION-OBJECT "OPTIMISTIC-SUBTYPE-OF?"
    "(DEFUN (OPTIMISTIC-SUBTYPE-OF? BOOLEAN) ((SUBTYPE TYPE) (SUPERTYPE TYPE)))"
    (CL:FUNCTION OPTIMISTIC-SUBTYPE-OF?) NULL)
   (DEFINE-FUNCTION-OBJECT "WARN-OF-PARAMETER-MISMATCH"
    "(DEFUN WARN-OF-PARAMETER-MISMATCH ((SELF PARAMETRIC-TYPE-SPECIFIER) (MESSAGE STRING)))"
    (CL:FUNCTION WARN-OF-PARAMETER-MISMATCH) NULL)
   (DEFINE-FUNCTION-OBJECT "VALIDATE-TYPE-SPECIFIER"
    "(DEFUN (VALIDATE-TYPE-SPECIFIER TYPE) ((SELF TYPE-SPEC) (ANCHORCLASS CLASS) (SKIPANCHOREDTYPE? BOOLEAN)))"
    (CL:FUNCTION VALIDATE-TYPE-SPECIFIER) NULL)
   (DEFINE-FUNCTION-OBJECT "SYNTHESIZE-METHOD-BODY"
    "(DEFUN (SYNTHESIZE-METHOD-BODY CONS) ((METHOD METHOD-SLOT)))"
    (CL:FUNCTION SYNTHESIZE-METHOD-BODY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD FINALIZE-SLOT-TYPE-COMPUTATIONS ((SELF METHOD-SLOT)))"
    (CL:FUNCTION FINALIZE-SLOT-TYPE-COMPUTATIONS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD HELP-FINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT)))"
    (CL:FUNCTION HELP-FINALIZE-LOCAL-SLOT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD UNFINALIZE-LOCAL-SLOT ((SELF METHOD-SLOT)))"
    (CL:FUNCTION UNFINALIZE-LOCAL-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "UNDEFINE-EXTERNAL-SLOTS"
    "(DEFUN UNDEFINE-EXTERNAL-SLOTS ((NAME SYMBOL)))"
    (CL:FUNCTION UNDEFINE-EXTERNAL-SLOTS) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-EXTERNAL-SLOT"
    "(DEFUN DESTROY-EXTERNAL-SLOT ((SELF SLOT)))"
    (CL:FUNCTION DESTROY-EXTERNAL-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "DESTROY-METHOD"
    "(DEFUN DESTROY-METHOD ((SELF METHOD-SLOT)))" (CL:FUNCTION DESTROY-METHOD)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF SLOT)))"
    (CL:FUNCTION METHOD-ARGUMENT-COUNT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF STORAGE-SLOT)))"
    (CL:FUNCTION METHOD-ARGUMENT-COUNT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF METHOD-SLOT)))"
    (CL:FUNCTION METHOD-ARGUMENT-COUNT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-ARGUMENT-COUNT INTEGER) ((SELF TABLE)))"
    (CL:FUNCTION METHOD-ARGUMENT-COUNT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-VARIABLE-ARGUMENTS? BOOLEAN) ((SELF STORAGE-SLOT)))"
    (CL:FUNCTION METHOD-VARIABLE-ARGUMENTS?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (METHOD-BODY-ARGUMENT? BOOLEAN) ((SELF STORAGE-SLOT)))"
    (CL:FUNCTION METHOD-BODY-ARGUMENT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ARITY INTEGER) ((SELF STORAGE-SLOT)) :PUBLIC? TRUE)"
    (CL:FUNCTION ARITY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ARITY INTEGER) ((SELF METHOD-SLOT)) :PUBLIC? TRUE)"
    (CL:FUNCTION ARITY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ARITY INTEGER) ((SELF TABLE)) :PUBLIC? TRUE)"
    (CL:FUNCTION ARITY) NULL)
   (DEFINE-FUNCTION-OBJECT "TYPE-SPEC-TO-BASE-TYPE"
    "(DEFUN (TYPE-SPEC-TO-BASE-TYPE TYPE) ((SELF TYPE-SPEC)) :PUBLIC? TRUE)"
    (CL:FUNCTION TYPE-SPEC-TO-BASE-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "BASE-TYPE-TO-TYPE-SPEC"
    "(DEFUN (BASE-TYPE-TO-TYPE-SPEC TYPE-SPEC) ((SELF TYPE-SPEC)))"
    (CL:FUNCTION BASE-TYPE-TO-TYPE-SPEC) NULL)
   (DEFINE-FUNCTION-OBJECT "TYPE-SPEC-TO-CLASS"
    "(DEFUN (TYPE-SPEC-TO-CLASS CLASS) ((SELF TYPE-SPEC)) :PUBLIC? TRUE)"
    (CL:FUNCTION TYPE-SPEC-TO-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPATIBLE-PARAMETER-TYPES?"
    "(DEFUN (COMPATIBLE-PARAMETER-TYPES? BOOLEAN) ((SUBTYPE TYPE-SPEC) (SUPERTYPE TYPE-SPEC)) :PUBLIC? TRUE)"
    (CL:FUNCTION COMPATIBLE-PARAMETER-TYPES?) NULL)
   (DEFINE-FUNCTION-OBJECT "SUB-TYPE-SPEC-OF?"
    "(DEFUN (SUB-TYPE-SPEC-OF? BOOLEAN) ((SUBTYPE TYPE-SPEC) (SUPERTYPE TYPE-SPEC)))"
    (CL:FUNCTION SUB-TYPE-SPEC-OF?) NULL)
   (DEFINE-FUNCTION-OBJECT "VOID?"
    "(DEFUN (VOID? BOOLEAN) ((TYPE TYPE-SPEC)) :PUBLIC? TRUE)"
    (CL:FUNCTION VOID?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXTRACT-PARAMETER-TYPE"
    "(DEFUN (EXTRACT-PARAMETER-TYPE TYPE-SPEC BOOLEAN) ((SELF TYPE-SPEC) (PARAMETER SYMBOL)) :PUBLIC? TRUE)"
    (CL:FUNCTION EXTRACT-PARAMETER-TYPE) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-ANCHORED-TYPE-SPEC"
    "(DEFUN (COMPUTE-ANCHORED-TYPE-SPEC TYPE-SPEC) ((OWNERTYPE TYPE-SPEC) (RELTYPE ANCHORED-TYPE-SPECIFIER)))"
    (CL:FUNCTION COMPUTE-ANCHORED-TYPE-SPEC) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-RELATIVE-TYPE-SPEC"
    "(DEFUN (COMPUTE-RELATIVE-TYPE-SPEC TYPE-SPEC) ((RELATIVETYPE TYPE-SPEC) (OWNERTYPE TYPE-SPEC)))"
    (CL:FUNCTION COMPUTE-RELATIVE-TYPE-SPEC) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ((SELF SLOT) (FIRSTARGTYPE TYPE-SPEC)))"
    (CL:FUNCTION COMPUTE-RETURN-TYPE-SPEC) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ((SELF METHOD-SLOT) (FIRSTARGTYPE TYPE-SPEC)))"
    (CL:FUNCTION COMPUTE-RETURN-TYPE-SPEC) NULL))
  :VOID)

(CL:DEFUN STARTUP-METHODS ()
  (CL:LET* ((*MODULE* *STELLA-MODULE*) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-METHODS1)
    (HELP-STARTUP-METHODS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *FUNCTION-LOOKUP-TABLE* (NEW-HASH-TABLE))
    (CL:SETQ *GLOBAL-VARIABLE-LOOKUP-TABLE* (NEW-HASH-TABLE)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-METHODS3)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COMPUTE-RETURN-TYPE-SPEC TYPE-SPEC) ((SELF STORAGE-SLOT) (FIRSTARGTYPE TYPE-SPEC)))"
     (CL:FUNCTION COMPUTE-RETURN-TYPE-SPEC) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-TYPE-SPEC-TREE"
     "(DEFUN (YIELD-TYPE-SPEC-TREE OBJECT) ((SELF TYPE-SPEC)))"
     (CL:FUNCTION YIELD-TYPE-SPEC-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "ATTACH-FUNCTION"
     "(DEFUN (ATTACH-FUNCTION METHOD-SLOT) ((NEWFUNCTION METHOD-SLOT)))"
     (CL:FUNCTION ATTACH-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION"
     "(DEFUN (LOOKUP-FUNCTION FUNCTION) ((FUNCTIONSYMBOL SYMBOL)) :DOCUMENTATION \"Return the function defined for 'functionSymbol', if it exists.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION-BY-NAME"
     "(DEFUN (LOOKUP-FUNCTION-BY-NAME FUNCTION) ((NAME STRING)) :DOCUMENTATION \"Return a function with name 'name' visible from the current module.
Scan all visible symbols looking for one that has a function defined for it.\" :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-FUNCTION-BY-NAME) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION-OR-STELLA-FUNCTION"
     "(DEFUN (LOOKUP-FUNCTION-OR-STELLA-FUNCTION FUNCTION) ((FUNCTIONSYMBOL SYMBOL)) :GLOBALLY-INLINE? TRUE (RETURN (LOOKUP-FUNCTION FUNCTIONSYMBOL)))"
     (CL:FUNCTION LOOKUP-FUNCTION-OR-STELLA-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-FUNCTION-HOME-MODULE"
     "(DEFUN (LOOKUP-FUNCTION-HOME-MODULE MODULE) ((FUNCTIONSYMBOL SYMBOL)))"
     (CL:FUNCTION LOOKUP-FUNCTION-HOME-MODULE) NULL)
    (DEFINE-FUNCTION-OBJECT "UNDEFINE-FUNCTION"
     "(DEFUN UNDEFINE-FUNCTION ((NAME SYMBOL)))"
     (CL:FUNCTION UNDEFINE-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTROY-FUNCTION"
     "(DEFUN DESTROY-FUNCTION ((FUNCTION METHOD-SLOT)))"
     (CL:FUNCTION DESTROY-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "UNDEFINE-CONFLICTING-DEFINITIONS?"
     "(DEFUN (UNDEFINE-CONFLICTING-DEFINITIONS? BOOLEAN) ((NEWSLOT METHOD-SLOT)))"
     (CL:FUNCTION UNDEFINE-CONFLICTING-DEFINITIONS?) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-FUNCTION-OBJECT"
     "(DEFUN DEFINE-FUNCTION-OBJECT ((NAME STRING) (DEFINITION STRING) (CODE FUNCTION-CODE) (WRAPPERCODE FUNCTION-CODE)))"
     (CL:FUNCTION DEFINE-FUNCTION-OBJECT) NULL)
    (DEFINE-FUNCTION-OBJECT "INTERN-GLOBAL-VARIABLE"
     "(DEFUN (INTERN-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((GLOBAL GLOBAL-VARIABLE)))"
     (CL:FUNCTION INTERN-GLOBAL-VARIABLE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((SELF GENERALIZED-SYMBOL)) :PUBLIC? TRUE :DOCUMENTATION \"Return a global variable with name 'self'.\")"
     (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((SELF SURROGATE)) :PUBLIC? TRUE :DOCUMENTATION \"Return a global variable with name 'self'.\")"
     (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (LOOKUP-GLOBAL-VARIABLE GLOBAL-VARIABLE) ((SELF STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Return a global variable with name 'self'.\")"
     (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE) NULL)
    (DEFINE-FUNCTION-OBJECT "GLOBAL-VARIABLE-TYPE-SPEC"
     "(DEFUN (GLOBAL-VARIABLE-TYPE-SPEC TYPE-SPEC) ((GLOBAL GLOBAL-VARIABLE)) :DOCUMENTATION \"Return the type spec for the global variable `global'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION GLOBAL-VARIABLE-TYPE-SPEC) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-GLOBAL-VARIABLE-TYPE"
     "(DEFUN (LOOKUP-GLOBAL-VARIABLE-TYPE TYPE-SPEC) ((NAME SYMBOL)) :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-GLOBAL-VARIABLE-TYPE) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE"
     "(DEFUN (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE GLOBAL-VARIABLE OBJECT) ((TREE CONS) (STRINGIFIEDSOURCE STRING)))"
     (CL:FUNCTION DEFINE-STELLA-GLOBAL-VARIABLE-FROM-PARSE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT
     "DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE"
     "(DEFUN DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE ((STRINGIFIEDSOURCE STRING)) :PUBLIC? TRUE)"
     (CL:FUNCTION DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-VARIABLE-HOME-MODULE"
     "(DEFUN (RECORD-VARIABLE-HOME-MODULE MODULE) ((SELF GLOBAL-VARIABLE)))"
     (CL:FUNCTION RECORD-VARIABLE-HOME-MODULE) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-GLOBAL-VALUE"
     "(DEFUN (GET-GLOBAL-VALUE OBJECT) ((SELF SURROGATE)) :DOCUMENTATION \"Return the (possibly-wrapped) value of the global
variable for the surrogate 'self'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION GET-GLOBAL-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "SET-GLOBAL-VALUE"
     "(DEFUN (SET-GLOBAL-VALUE OBJECT) ((SELF SURROGATE) (VALUE OBJECT)) :DOCUMENTATION \"Set the value of the global variable for the surrogate
'self' to 'value'.\" :PUBLIC? TRUE)" (CL:FUNCTION SET-GLOBAL-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTROY-VARIABLE"
     "(DEFUN DESTROY-VARIABLE ((VARIABLE GLOBAL-VARIABLE)))"
     (CL:FUNCTION DESTROY-VARIABLE) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-STELLA-TYPE-FROM-PARSE-TREE"
     "(DEFUN (DEFINE-STELLA-TYPE-FROM-PARSE-TREE TYPE) ((TREE CONS)) :PUBLIC? TRUE)"
     (CL:FUNCTION DEFINE-STELLA-TYPE-FROM-PARSE-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE"
     "(DEFUN DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE ((STRINGIFIEDSOURCE STRING)) :PUBLIC? TRUE)"
     (CL:FUNCTION DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-METHODS"
     "(DEFUN STARTUP-METHODS () :PUBLIC? TRUE)" (CL:FUNCTION STARTUP-METHODS)
     NULL)
    (CL:LET* ((FUNCTION (LOOKUP-FUNCTION SYM-METHODS-STELLA-STARTUP-METHODS)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-METHODS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupMethods") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAXIMUM-STRING-CONSTANT-SIZE* INTEGER 4000 :DOCUMENTATION \"Maximum size for a string constant in the target language.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FUNCTION-LOOKUP-TABLE* (HASH-TABLE OF SYMBOL STANDARD-OBJECT) (NEW (HASH-TABLE OF SYMBOL FUNCTION)) :DOCUMENTATION \"Lookup table for functions.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GLOBAL-VARIABLE-LOOKUP-TABLE* (HASH-TABLE OF SYMBOL GLOBAL-VARIABLE) (NEW (HASH-TABLE OF SYMBOL GLOBAL-VARIABLE)) :DOCUMENTATION \"Lookup table for global variables.\" :PUBLIC? TRUE)")))
  :VOID)
