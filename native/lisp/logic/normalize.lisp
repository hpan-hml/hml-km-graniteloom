;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; normalize.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2010      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-CUT NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-BOUND-VARIABLES NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-FORK NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-QUERY NULL)
(CL:DEFVAR KWD-NORMALIZE-AND NULL)
(CL:DEFVAR KWD-NORMALIZE-CONSTANT NULL)
(CL:DEFVAR SGT-NORMALIZE-STELLA-TRUE NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-CONSTANT NULL)
(CL:DEFVAR SGT-NORMALIZE-STELLA-CS-VALUE NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-AND NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-DESCRIPTIVE? NULL)
(CL:DEFVAR KWD-NORMALIZE-OR NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-OR NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-WEIGHT NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-NEURAL-NETWORK NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-VARIABLE-TYPE? NULL)
(CL:DEFVAR KWD-NORMALIZE-DESCRIPTION NULL)
(CL:DEFVAR KWD-NORMALIZE-EXISTS NULL)
(CL:DEFVAR KWD-NORMALIZE-NOT NULL)
(CL:DEFVAR KWD-NORMALIZE-ERROR NULL)
(CL:DEFVAR SGT-NORMALIZE-STELLA-FALSE NULL)
(CL:DEFVAR KWD-NORMALIZE-FORALL NULL)
(CL:DEFVAR KWD-NORMALIZE-EQUIVALENT NULL)
(CL:DEFVAR KWD-NORMALIZE-ISA NULL)
(CL:DEFVAR KWD-NORMALIZE-PREDICATE NULL)
(CL:DEFVAR KWD-NORMALIZE-FUNCTION NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-EXISTS NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SGT-NORMALIZE-STELLA-THING NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-VARIABLE-ARITY NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-ARITY NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-CLASS NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-FUNCTION NULL)
(CL:DEFVAR SGT-NORMALIZE-PL-KERNEL-KB-VALUE NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-FUNCTION NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-DONT-OPTIMIZE? NULL)
(CL:DEFVAR KWD-NORMALIZE-IMPLIES NULL)
(CL:DEFVAR KWD-NORMALIZE-FAIL NULL)
(CL:DEFVAR KWD-NORMALIZE-COLLECT-INTO NULL)
(CL:DEFVAR KWD-NORMALIZE-TAIL NULL)
(CL:DEFVAR KWD-NORMALIZE-HEAD NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-NOT NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-NOT NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-FORALL NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-EXISTS NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-OR NULL)
(CL:DEFVAR SGT-NORMALIZE-LOGIC-AND NULL)
(CL:DEFVAR SYM-NORMALIZE-LOGIC-STARTUP-NORMALIZE NULL)
(CL:DEFVAR SYM-NORMALIZE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* STANDARD-ERROR NULL-INTEGER EOL NULL-FLOAT
  NULL-FLOAT-WRAPPER *MODULE* FALSE-PROPOSITION TRUE-PROPOSITION FALSE-WRAPPER
  TRUE-WRAPPER NIL))

;;; (DEFUN (SEARCH-CONTROL-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN SEARCH-CONTROL-PROPOSITION? (SELF)
  (CL:LET* ((TEST-VALUE-000 (%OPERATOR SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 SGT-NORMALIZE-PL-KERNEL-KB-CUT)
      (CL:EQ TEST-VALUE-000 SGT-NORMALIZE-PL-KERNEL-KB-BOUND-VARIABLES)
      (CL:EQ TEST-VALUE-000 SGT-NORMALIZE-PL-KERNEL-KB-FORK)
      (CL:EQ TEST-VALUE-000 SGT-NORMALIZE-PL-KERNEL-KB-QUERY))
     CL:T)
    (CL:T CL:NIL))))

;;; (DEFUN (DUPLICATE-AND-OR-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN DUPLICATE-AND-OR-ARGUMENTS? (PROP1 PROP2)
  (CL:AND (EQUIVALENT-PROPOSITIONS? PROP1 PROP2 NULL)
   (CL:NOT
    (CL:OR (SEARCH-CONTROL-PROPOSITION? PROP1)
     (SEARCH-CONTROL-PROPOSITION? PROP2)))))

;;; (DEFUN COLLECT-FLAT-CONJUNCTS ...)

(CL:DEFUN COLLECT-FLAT-CONJUNCTS (SELF FLATCONJUNCTS)
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-AND)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
       (COLLECT-FLAT-CONJUNCTS ARG FLATCONJUNCTS)
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:RETURN-FROM COLLECT-FLAT-CONJUNCTS))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)
     (CL:WHEN (CL:EQ (%OPERATOR SELF) SGT-NORMALIZE-STELLA-TRUE)
      (CL:RETURN-FROM COLLECT-FLAT-CONJUNCTS)))
    (CL:T (CLEAR (%DEPENDENT-PROPOSITIONS SELF)))))
  (CL:LET* ((FOUND?-000 CL:NIL))
   (CL:LET* ((PROP NULL) (ITER-000 (%THE-CONS-LIST FLATCONJUNCTS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PROP (%%VALUE ITER-000))
     (CL:WHEN (DUPLICATE-AND-OR-ARGUMENTS? PROP SELF)
      (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN (CL:NOT FOUND?-000) (PUSH FLATCONJUNCTS SELF))))

;;; (DEFUN OVERLAY-WITH-CONSTANT-PROPOSITION ...)

(CL:DEFUN OVERLAY-WITH-CONSTANT-PROPOSITION (SELF CONSTANTPROPOSITION)
  (CL:LET* ((OVERLAY (CREATE-PROPOSITION SYM-NORMALIZE-LOGIC-CONSTANT 0)))
   (CL:SETF (%OPERATOR OVERLAY) (%OPERATOR CONSTANTPROPOSITION))
   (CL:LET*
    ((OBJECT-000 OVERLAY)
     (VALUE-000
      (ACCESS-IN-CONTEXT (%TRUTH-VALUE CONSTANTPROPOSITION)
       (%HOME-CONTEXT CONSTANTPROPOSITION) CL:NIL))
     (OLD-VALUE-001 (%TRUTH-VALUE OBJECT-000))
     (NEW-VALUE-000
      (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-000 (%HOME-CONTEXT OBJECT-000)
       CL:NIL)))
    (CL:WHEN
     (CL:NOT
      (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
       (CL:EQ (PRIMARY-TYPE OLD-VALUE-001) SGT-NORMALIZE-STELLA-CS-VALUE)))
     (CL:SETF (%TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))
   (OVERLAY-PROPOSITION SELF OVERLAY)))

;;; (DEFUN (CONJOIN-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN CONJOIN-PROPOSITIONS (CONJUNCTS)
  (CL:LET* ((FLATCONJUNCTS (NEW-LIST)) (RESULT NULL))
   (CL:LET* ((C NULL) (ITER-000 CONJUNCTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ C (%%VALUE ITER-000)) (COLLECT-FLAT-CONJUNCTS C FLATCONJUNCTS)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (REVERSE FLATCONJUNCTS)
   (CL:CASE (LENGTH FLATCONJUNCTS)
    (0
     (CL:LET*
      ((PROPOSITION (CREATE-PROPOSITION SYM-NORMALIZE-LOGIC-CONSTANT 0)))
      (OVERLAY-WITH-CONSTANT-PROPOSITION PROPOSITION TRUE-PROPOSITION)
      (CL:RETURN-FROM CONJOIN-PROPOSITIONS PROPOSITION)))
    (1 (CL:RETURN-FROM CONJOIN-PROPOSITIONS (FIRST FLATCONJUNCTS)))
    (CL:OTHERWISE))
   (CL:SETQ RESULT
    (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-AND (LENGTH FLATCONJUNCTS)))
   (CL:SETF (%ARGUMENTS RESULT) (COPY-LIST-TO-ARGUMENTS-VECTOR FLATCONJUNCTS))
   (CL:WHEN
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (FIRST FLATCONJUNCTS))
      SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS RESULT)
     SYM-NORMALIZE-LOGIC-DESCRIPTIVE? TRUE-WRAPPER FALSE-WRAPPER))
   RESULT))

;;; (DEFUN (CONJOIN-TWO-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN CONJOIN-TWO-PROPOSITIONS (PROP1 PROP2)
  (CL:COND ((CL:EQ PROP1 NULL) PROP2) ((CL:EQ PROP2 NULL) PROP1)
   ((DUPLICATE-AND-OR-ARGUMENTS? PROP1 PROP2) PROP1)
   (CL:T
    (CL:LET*
     ((ANDPROPOSITION (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-AND 2)))
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS ANDPROPOSITION))) (VALUE PROP1)
       (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS ANDPROPOSITION))) (VALUE PROP2)
       (POSITION 1))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:WHEN
      (%WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP1)
        SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ANDPROPOSITION)
       SYM-NORMALIZE-LOGIC-DESCRIPTIVE? TRUE-WRAPPER FALSE-WRAPPER))
     ANDPROPOSITION))))

;;; (DEFUN COLLECT-FLAT-DISJUNCTS ...)

(CL:DEFUN COLLECT-FLAT-DISJUNCTS (SELF FLATDISJUNCTS)
  (CL:COND
   ((CL:EQ (%KIND SELF) KWD-NORMALIZE-OR)
    (CL:LET*
     ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
      (COLLECT-FLAT-DISJUNCTS ARG FLATDISJUNCTS)
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
    (FREE SELF))
   (CL:T
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET* ((PROP NULL) (ITER-000 (%THE-CONS-LIST FLATDISJUNCTS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ PROP (%%VALUE ITER-000))
       (CL:WHEN (DUPLICATE-AND-OR-ARGUMENTS? PROP SELF)
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:WHEN (CL:NOT FOUND?-000) (PUSH FLATDISJUNCTS SELF)
      (CLEAR (%DEPENDENT-PROPOSITIONS SELF)))))))

;;; (DEFUN (DISJOIN-PROPOSITIONS PROPOSITION) ...)

(CL:DEFUN DISJOIN-PROPOSITIONS (DISJUNCTS)
  (CL:WHEN (CL:EQ DISJUNCTS NIL)
   (CL:RETURN-FROM DISJOIN-PROPOSITIONS FALSE-PROPOSITION))
  (CL:LET* ((FLATDISJUNCTS (NEW-LIST)) (RESULT NULL))
   (CL:LET* ((C NULL) (ITER-000 DISJUNCTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ C (%%VALUE ITER-000)) (COLLECT-FLAT-DISJUNCTS C FLATDISJUNCTS)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (REVERSE FLATDISJUNCTS)
   (CL:CASE (LENGTH FLATDISJUNCTS)
    (0
     (CL:LET*
      ((PROPOSITION (CREATE-PROPOSITION SYM-NORMALIZE-LOGIC-CONSTANT 0)))
      (OVERLAY-WITH-CONSTANT-PROPOSITION PROPOSITION FALSE-PROPOSITION)
      (CL:RETURN-FROM DISJOIN-PROPOSITIONS PROPOSITION)))
    (1 (CL:RETURN-FROM DISJOIN-PROPOSITIONS (FIRST FLATDISJUNCTS)))
    (CL:OTHERWISE))
   (CL:SETQ RESULT
    (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-OR (LENGTH FLATDISJUNCTS)))
   (CL:SETF (%ARGUMENTS RESULT) (COPY-LIST-TO-ARGUMENTS-VECTOR FLATDISJUNCTS))
   (CL:WHEN
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (FIRST FLATDISJUNCTS))
      SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS RESULT)
     SYM-NORMALIZE-LOGIC-DESCRIPTIVE? TRUE-WRAPPER FALSE-WRAPPER))
   RESULT))

;;; (DEFUN (RENAME-LOGIC-VARIABLE-APART PATTERN-VARIABLE) ...)

(CL:DEFUN RENAME-LOGIC-VARIABLE-APART (VARIABLE DESTRUCTIVE?)
  (CL:LET* ((*MODULE* (HOME-MODULE VARIABLE)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET* ((NEWNAME (LOCAL-GENSYM (%SYMBOL-NAME (%SKOLEM-NAME VARIABLE)))))
    (CL:WHEN (CL:NOT DESTRUCTIVE?)
     (CL:SETQ VARIABLE (COPY-VARIABLE VARIABLE (NEW-KEY-VALUE-MAP))))
    (CL:SETF (%SKOLEM-NAME VARIABLE) NEWNAME) VARIABLE)))

;;; (DEFUN OVERLAY-PROPOSITION ...)

(CL:DEFUN OVERLAY-PROPOSITION (SELF OVERLAYINGPROP)
  (CL:SETF (%KIND SELF) (%KIND OVERLAYINGPROP))
  (CL:SETF (%OPERATOR SELF) (%OPERATOR OVERLAYINGPROP))
  (CL:LET*
   ((OBJECT-000 SELF)
    (VALUE-000
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE OVERLAYINGPROP)
      (%HOME-CONTEXT OVERLAYINGPROP) CL:NIL))
    (OLD-VALUE-001 (%TRUTH-VALUE OBJECT-000))
    (NEW-VALUE-000
     (UPDATE-IN-CONTEXT OLD-VALUE-001 VALUE-000 (%HOME-CONTEXT OBJECT-000)
      CL:NIL)))
   (CL:WHEN
    (CL:NOT
     (CL:AND (CL:NOT (CL:EQ OLD-VALUE-001 NULL))
      (CL:EQ (PRIMARY-TYPE OLD-VALUE-001) SGT-NORMALIZE-STELLA-CS-VALUE)))
    (CL:SETF (%TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SYM-NORMALIZE-LOGIC-WEIGHT
   (WRAP-FLOAT
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OVERLAYINGPROP)
      SYM-NORMALIZE-LOGIC-WEIGHT NULL-FLOAT-WRAPPER)))
   NULL-FLOAT-WRAPPER)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-NORMALIZE-LOGIC-NEURAL-NETWORK
   (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OVERLAYINGPROP)
    SYM-NORMALIZE-LOGIC-NEURAL-NETWORK NULL)
   NULL)
  (CL:SETF (%ARGUMENTS SELF) (COPY (%ARGUMENTS OVERLAYINGPROP)))
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OVERLAYINGPROP)
      SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL)
     NULL))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
    SYM-NORMALIZE-LOGIC-IO-VARIABLES
    (COPY
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OVERLAYINGPROP)
      SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
    NULL))
  (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? OVERLAYINGPROP))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
    SYM-NORMALIZE-LOGIC-VARIABLE-TYPE? TRUE-WRAPPER NULL))
  (CL:WHEN
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS OVERLAYINGPROP)
     SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
    SYM-NORMALIZE-LOGIC-DESCRIPTIVE? TRUE-WRAPPER FALSE-WRAPPER)))

;;; (DEFUN NORMALIZE-EXISTS-PROPOSITION ...)

(CL:DEFUN NORMALIZE-EXISTS-PROPOSITION (SELF)
  (CL:LET*
   ((WHEREPROPOSITION
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0)))
   (CL:LET* ((*EVALUATIONMODE* KWD-NORMALIZE-DESCRIPTION))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
    (NORMALIZE-PROPOSITION WHEREPROPOSITION))
   (CL:WHEN (CL:EQ (%KIND WHEREPROPOSITION) KWD-NORMALIZE-EXISTS)
    (CL:LET* ((COMBINEDARGS NIL))
     (CL:LET*
      ((VBL NULL)
       (VECTOR-000
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ VBL
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS VBL NIL))
         (CL:IF (CL:EQ COMBINEDARGS NIL) (CL:SETQ COMBINEDARGS COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST COMBINEDARGS COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VBL NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:LET*
      ((VBL NULL)
       (VECTOR-001
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WHEREPROPOSITION)
         SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
       (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)) (COLLECT-001 NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ VBL
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001)) INDEX-001))
       (CL:IF (CL:EQ COLLECT-001 NULL)
        (CL:PROGN (CL:SETQ COLLECT-001 (CONS VBL NIL))
         (CL:IF (CL:EQ COMBINEDARGS NIL) (CL:SETQ COMBINEDARGS COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST COMBINEDARGS COLLECT-001)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS VBL NIL))
         (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-NORMALIZE-LOGIC-IO-VARIABLES
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR COMBINEDARGS) NULL)
     (CL:SETF (%ARGUMENTS SELF) (%ARGUMENTS WHEREPROPOSITION))
     (DELETED?-SETTER WHEREPROPOSITION CL:T)))
   (CL:WHEN
    (CL:OR
     (EMPTY?
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
     (CL:EQ (%KIND WHEREPROPOSITION) KWD-NORMALIZE-CONSTANT))
    (OVERLAY-PROPOSITION SELF WHEREPROPOSITION))))

;;; (DEFUN (MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? BOOLEAN) ...)

(CL:DEFUN MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? (SELF)
  (CL:LET*
   ((ANTECEDENT NULL)
    (CONSEQUENT
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 1))
    (POSITIVEGOALS NIL) (NEGATEDGOALS NIL))
   (CL:WHEN (CL:NOT (CL:EQ (%KIND CONSEQUENT) KWD-NORMALIZE-OR))
    (CL:RETURN-FROM MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? CL:NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS CONSEQUENT)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:LET* ((DISJUNCT ARG))
      (CL:IF (CL:EQ (%KIND DISJUNCT) KWD-NORMALIZE-NOT)
       (CL:SETQ NEGATEDGOALS
        (CONS
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS DISJUNCT)))
          0)
         NEGATEDGOALS))
       (CL:SETQ POSITIVEGOALS (CONS DISJUNCT POSITIVEGOALS))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ POSITIVEGOALS NIL))
     (CL:NOT (CL:EQ NEGATEDGOALS NIL)))
    (CL:SETQ ANTECEDENT (CONJOIN-PROPOSITIONS (REVERSE NEGATEDGOALS)))
    (CL:SETQ CONSEQUENT (DISJOIN-PROPOSITIONS (REVERSE POSITIVEGOALS)))
    (NORMALIZE-PROPOSITION ANTECEDENT) (NORMALIZE-PROPOSITION CONSEQUENT)
    (CL:LET
     ((SELF (%THE-ARRAY (%ARGUMENTS SELF))) (VALUE ANTECEDENT) (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET
     ((SELF (%THE-ARRAY (%ARGUMENTS SELF))) (VALUE CONSEQUENT) (POSITION 1))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:RETURN-FROM MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? CL:T))
   CL:NIL))

;;; (DEFUN FLATTEN-NESTED-FORALL-PROPOSITION ...)

(CL:DEFUN FLATTEN-NESTED-FORALL-PROPOSITION (SELF)
  (CL:LET*
   ((IOVARIABLES NIL)
    (OUTERANTECEDENT
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0))
    (NESTEDFORALL
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 1))
    (INNERANTECEDENT
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS NESTEDFORALL)))
      0))
    (INNERCONSEQUENT
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS NESTEDFORALL)))
      1)))
   (CL:LET*
    ((V NULL)
     (VECTOR-000
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:SETQ IOVARIABLES (CONS V IOVARIABLES))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET*
    ((V NULL)
     (VECTOR-001
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NESTEDFORALL)
       SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
     (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
    (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
     (CL:SETQ V
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001)) INDEX-001))
     (CL:SETQ IOVARIABLES (CONS V IOVARIABLES))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
    SYM-NORMALIZE-LOGIC-IO-VARIABLES
    (COPY-CONS-LIST-TO-VARIABLES-VECTOR (REVERSE IOVARIABLES)) NULL)
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS SELF)))
     (VALUE (CONJOIN-TWO-PROPOSITIONS OUTERANTECEDENT INNERANTECEDENT))
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY (%ARGUMENTS SELF))) (VALUE INNERCONSEQUENT)
     (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (NORMALIZE-PROPOSITION
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0))))

;;; (DEFUN NORMALIZE-FORALL-PROPOSITION ...)

(CL:DEFUN NORMALIZE-FORALL-PROPOSITION (SELF)
  (CL:LET*
   ((ANTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0))
    (CQARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 1))
    (ANTECEDENT NULL) (CONSEQUENT NULL))
   (CL:WHEN (CL:OR (VARIABLE? ANTARG) (VARIABLE? CQARG))
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "ERROR: Can't yet handle propositional variables within FORALL." EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-NORMALIZE-ERROR))
     (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:SETQ ANTECEDENT ANTARG) (CL:SETQ CONSEQUENT CQARG)
   (CL:LET* ((*EVALUATIONMODE* KWD-NORMALIZE-DESCRIPTION))
    (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
    (NORMALIZE-PROPOSITION ANTECEDENT) (NORMALIZE-PROPOSITION CONSEQUENT))
   (CL:WHEN (CL:EQ (%KIND ANTECEDENT) KWD-NORMALIZE-CONSTANT)
    (CL:LET* ((TEST-VALUE-000 (%OPERATOR ANTECEDENT)))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 SGT-NORMALIZE-STELLA-TRUE)
       (CL:WHEN (MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? SELF)
        (CL:RETURN-FROM NORMALIZE-FORALL-PROPOSITION)))
      ((CL:EQ TEST-VALUE-000 SGT-NORMALIZE-STELLA-FALSE)
       (OVERLAY-WITH-CONSTANT-PROPOSITION SELF TRUE-PROPOSITION)
       (CL:RETURN-FROM NORMALIZE-FORALL-PROPOSITION))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-000
         "' is not a valid case option")
        (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
   (CL:LET* ((TEST-VALUE-001 (%KIND CONSEQUENT)))
    (CL:COND
     ((CL:EQ TEST-VALUE-001 KWD-NORMALIZE-FORALL)
      (CL:WHEN (CL:NOT (NATURAL-DEDUCTION-MODE?))
       (FLATTEN-NESTED-FORALL-PROPOSITION SELF)))
     ((CL:EQ TEST-VALUE-001 KWD-NORMALIZE-CONSTANT)
      (CL:LET* ((TEST-VALUE-002 (%OPERATOR CONSEQUENT)))
       (CL:COND
        ((CL:EQ TEST-VALUE-002 SGT-NORMALIZE-STELLA-FALSE)
         (OVERLAY-PROPOSITION SELF ANTECEDENT) (INVERT-PROPOSITION SELF)
         (CL:RETURN-FROM NORMALIZE-FORALL-PROPOSITION))
        ((CL:EQ TEST-VALUE-002 SGT-NORMALIZE-STELLA-TRUE)
         (OVERLAY-WITH-CONSTANT-PROPOSITION SELF TRUE-PROPOSITION)
         (CL:RETURN-FROM NORMALIZE-FORALL-PROPOSITION))
        (CL:T
         (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" TEST-VALUE-002
           "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002))))))))
     (CL:T)))
   (CL:WHEN
    (EMPTY?
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
    (CL:SETQ ANTECEDENT (INVERT-PROPOSITION ANTECEDENT))
    (OVERLAY-PROPOSITION SELF
     (DISJOIN-PROPOSITIONS (CONS-LIST ANTECEDENT CONSEQUENT)))
    (NORMALIZE-PROPOSITION SELF)
    (CL:RETURN-FROM NORMALIZE-FORALL-PROPOSITION))
   (CL:LET* ((IMPLIESPROPOSITION (DERIVE-IMPLIES-FROM-FORALL SELF)))
    (CL:WHEN (CL:NOT (CL:EQ IMPLIESPROPOSITION NULL))
     (OVERLAY-PROPOSITION SELF IMPLIESPROPOSITION)))))

;;; (DEFUN NORMALIZE-NOT-PROPOSITION ...)

(CL:DEFUN NORMALIZE-NOT-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENT
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0))
    (PROPOSITION NULL))
   (CL:WHEN (VARIABLE? ARGUMENT)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (CL:LET* ((*PRINTREADABLY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
       "ERROR: Can't yet handle propositional variables within negations."
       EOL)
      (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-NORMALIZE-ERROR))
     (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
   (CL:SETQ PROPOSITION ARGUMENT)
   (CL:WHEN (CL:EQ (%KIND PROPOSITION) KWD-NORMALIZE-EQUIVALENT)
    (NORMALIZE-PROPOSITION PROPOSITION))
   (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-ISA)
       (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FUNCTION))
      (CL:IF (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? PROPOSITION))
       (OVERLAY-WITH-CONSTANT-PROPOSITION SELF FALSE-PROPOSITION)
       (NORMALIZE-PROPOSITION PROPOSITION)))
     ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)
      (CL:LET* ((TEST-VALUE-001 (%OPERATOR PROPOSITION)))
       (CL:COND
        ((CL:EQ TEST-VALUE-001 SGT-NORMALIZE-STELLA-TRUE)
         (OVERLAY-WITH-CONSTANT-PROPOSITION SELF FALSE-PROPOSITION))
        ((CL:EQ TEST-VALUE-001 SGT-NORMALIZE-STELLA-FALSE)
         (OVERLAY-WITH-CONSTANT-PROPOSITION SELF TRUE-PROPOSITION))
        (CL:T))))
     (CL:T (INVERT-PROPOSITION PROPOSITION)
      (OVERLAY-PROPOSITION SELF PROPOSITION))))))

;;; (DEFUN NORMALIZE-AND-PROPOSITION ...)

(CL:DEFUN NORMALIZE-AND-PROPOSITION (SELF)
  (CL:LET* ((OTHERPROPS NIL) (CONJOIN? CL:NIL) (EXISTSVARIABLES NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:WHEN (VARIABLE? ARG)
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
         "ERROR: Can't yet handle propositional variables within conjunctions."
         EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-NORMALIZE-ERROR))
       (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
     (CL:LET* ((CONJUNCT ARG)) (NORMALIZE-PROPOSITION CONJUNCT)
      (CL:LET* ((TEST-VALUE-000 (%KIND CONJUNCT)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-EXISTS)
         (CL:LET*
          ((V NULL)
           (VECTOR-001
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONJUNCT)
             SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
           (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)) (COLLECT-000 NULL))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
          (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
           (CL:SETQ V
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
             INDEX-001))
           (CL:LET* ((FOUND?-000 CL:NIL))
            (CL:LET* ((VAR NULL) (ITER-000 EXISTSVARIABLES))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
              (CL:SETQ VAR (%%VALUE ITER-000))
              (CL:WHEN (VARIABLE-EQL? (%SKOLEM-NAME VAR) (%SKOLEM-NAME V))
               (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
              (CL:SETQ ITER-000 (%%REST ITER-000))))
            (CL:WHEN FOUND?-000 (RENAME-LOGIC-VARIABLE-APART V CL:T)))
           (CL:IF (CL:EQ COLLECT-000 NULL)
            (CL:PROGN (CL:SETQ COLLECT-000 (CONS V NIL))
             (CL:IF (CL:EQ EXISTSVARIABLES NIL)
              (CL:SETQ EXISTSVARIABLES COLLECT-000)
              (ADD-CONS-TO-END-OF-CONS-LIST EXISTSVARIABLES COLLECT-000)))
            (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS V NIL))
             (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
           (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
         (CL:SETQ OTHERPROPS
          (CONS
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS CONJUNCT))) 0)
           OTHERPROPS))
         (CL:SETQ CONJOIN? CL:T))
        ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-AND)
         (CL:SETQ OTHERPROPS (CONS CONJUNCT OTHERPROPS))
         (CL:SETQ CONJOIN? CL:T))
        ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)
         (CL:COND
          ((CL:EQ (%OPERATOR CONJUNCT) SGT-NORMALIZE-STELLA-TRUE)
           (CL:SETQ CONJOIN? CL:T)
           (CL:SETQ OTHERPROPS (CONS CONJUNCT OTHERPROPS)))
          ((CL:EQ (%OPERATOR CONJUNCT) SGT-NORMALIZE-STELLA-FALSE)
           (OVERLAY-WITH-CONSTANT-PROPOSITION SELF FALSE-PROPOSITION)
           (CL:RETURN-FROM NORMALIZE-AND-PROPOSITION))))
        (CL:T
         (CL:LET* ((TEST-VALUE-001 CL:NIL))
          (CL:SETQ TEST-VALUE-001 (CL:NOT CONJOIN?))
          (CL:WHEN TEST-VALUE-001
           (CL:LET* ((FOUND?-001 CL:NIL))
            (CL:LET* ((PROP NULL) (ITER-001 OTHERPROPS))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
              (CL:SETQ PROP (%%VALUE ITER-001))
              (CL:WHEN (DUPLICATE-AND-OR-ARGUMENTS? PROP CONJUNCT)
               (CL:SETQ FOUND?-001 CL:T) (CL:RETURN))
              (CL:SETQ ITER-001 (%%REST ITER-001))))
            (CL:SETQ TEST-VALUE-001 FOUND?-001)))
          (CL:IF TEST-VALUE-001 (CL:SETQ CONJOIN? CL:T)
           (CL:SETQ OTHERPROPS (CONS CONJUNCT OTHERPROPS))))))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:SETQ OTHERPROPS (REVERSE OTHERPROPS))
   (CL:WHEN (CL:NOT (CL:EQ EXISTSVARIABLES NIL))
    (CL:LET*
     ((EXISTSPROPOSITION (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-EXISTS 1)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS EXISTSPROPOSITION)
      SYM-NORMALIZE-LOGIC-IO-VARIABLES
      (COPY-CONS-LIST-TO-VARIABLES-VECTOR EXISTSVARIABLES) NULL)
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS EXISTSPROPOSITION)))
       (VALUE (CONJOIN-PROPOSITIONS OTHERPROPS)) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (OVERLAY-PROPOSITION SELF EXISTSPROPOSITION))
    (CL:RETURN-FROM NORMALIZE-AND-PROPOSITION))
   (CL:WHEN (CL:OR CONJOIN? (CL:<= (LENGTH OTHERPROPS) 1))
    (OVERLAY-PROPOSITION SELF (CONJOIN-PROPOSITIONS OTHERPROPS)))))

;;; (DEFUN NORMALIZE-OR-PROPOSITION ...)

(CL:DEFUN NORMALIZE-OR-PROPOSITION (SELF)
  (CL:LET* ((PROPOSITIONS NIL) (DISJOIN? CL:NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:WHEN (VARIABLE? ARG)
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
         "ERROR: Can't yet handle propositional variables within disjunctions."
         EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-NORMALIZE-ERROR))
       (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
     (CL:LET* ((DISJUNCT ARG)) (NORMALIZE-PROPOSITION DISJUNCT)
      (CL:LET* ((TEST-VALUE-000 (%KIND DISJUNCT)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-OR)
         (CL:SETQ PROPOSITIONS (CONS DISJUNCT PROPOSITIONS))
         (CL:SETQ DISJOIN? CL:T))
        ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)
         (CL:COND
          ((CL:EQ (%OPERATOR DISJUNCT) SGT-NORMALIZE-STELLA-FALSE)
           (CL:SETQ DISJOIN? CL:T))
          ((CL:EQ (%OPERATOR DISJUNCT) SGT-NORMALIZE-STELLA-TRUE)
           (OVERLAY-WITH-CONSTANT-PROPOSITION SELF TRUE-PROPOSITION)
           (CL:RETURN-FROM NORMALIZE-OR-PROPOSITION))
          (CL:T
           (CL:IF (MEMBER? PROPOSITIONS DISJUNCT) (CL:SETQ DISJOIN? CL:T)
            (CL:SETQ PROPOSITIONS (CONS DISJUNCT PROPOSITIONS))))))
        (CL:T
         (CL:LET* ((TEST-VALUE-001 CL:NIL))
          (CL:SETQ TEST-VALUE-001 (CL:NOT DISJOIN?))
          (CL:WHEN TEST-VALUE-001
           (CL:LET* ((FOUND?-000 CL:NIL))
            (CL:LET* ((PROP NULL) (ITER-000 PROPOSITIONS))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
              (CL:SETQ PROP (%%VALUE ITER-000))
              (CL:WHEN (DUPLICATE-AND-OR-ARGUMENTS? PROP DISJUNCT)
               (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
              (CL:SETQ ITER-000 (%%REST ITER-000))))
            (CL:SETQ TEST-VALUE-001 FOUND?-000)))
          (CL:IF TEST-VALUE-001 (CL:SETQ DISJOIN? CL:T)
           (CL:SETQ PROPOSITIONS (CONS DISJUNCT PROPOSITIONS))))))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:WHEN (CL:OR DISJOIN? (CL:<= (LENGTH PROPOSITIONS) 1))
    (OVERLAY-PROPOSITION SELF (DISJOIN-PROPOSITIONS PROPOSITIONS)))))

;;; (DEFUN HELP-NORMALIZE-PREDICATE-PROPOSITION ...)

(CL:DEFUN HELP-NORMALIZE-PREDICATE-PROPOSITION (SELF RELATIONREF PREDICATEARGUMENTS)
  (CL:LET*
   ((OUTPUTARGUMENT (LAST PREDICATEARGUMENTS)) (INPUTARGUMENTS NIL)
    (FUNCTIONPROP NULL) (EQUIVALENCEPROP NULL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:- (LENGTH PREDICATEARGUMENTS) 2))
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY PREDICATEARGUMENTS)) I)
         NIL))
       (CL:IF (CL:EQ INPUTARGUMENTS NIL) (CL:SETQ INPUTARGUMENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST INPUTARGUMENTS COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY PREDICATEARGUMENTS)) I)
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETQ FUNCTIONPROP
    (FIND-OR-CREATE-FUNCTION-PROPOSITION RELATIONREF INPUTARGUMENTS))
   (CL:SETQ EQUIVALENCEPROP
    (CREATE-EQUIVALENCE-PROPOSITION (LAST (%ARGUMENTS FUNCTIONPROP))
     OUTPUTARGUMENT))
   (OVERLAY-PROPOSITION SELF EQUIVALENCEPROP) (NORMALIZE-PROPOSITION SELF)))

;;; (DEFUN NORMALIZE-HOLDS-PROPOSITION ...)

(CL:DEFUN NORMALIZE-HOLDS-PROPOSITION (SELF)
  (CL:LET*
   ((HOLDSARGUMENTS (%ARGUMENTS SELF))
    (RELATIONTERM
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HOLDSARGUMENTS)) 0))
    (NOFARGUMENTS (CL:1- (LENGTH HOLDSARGUMENTS)))
    (SURROGATE (EVALUATE-RELATION-TERM RELATIONTERM SELF))
    (PREDICATEARGUMENTS (NEW-VECTOR NOFARGUMENTS)) (DESCRIPTION NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFARGUMENTS))
   (CL:WHEN
    (CL:AND (CL:EQ SURROGATE NULL)
     (CL:OR (CL:NOT (ISA? RELATIONTERM SGT-NORMALIZE-LOGIC-DESCRIPTION))
      (CL:NOT (ARGUMENT-BOUND? RELATIONTERM))))
    (CL:RETURN-FROM NORMALIZE-HOLDS-PROPOSITION))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 NOFARGUMENTS)
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%THE-ARRAY PREDICATEARGUMENTS))
       (VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HOLDSARGUMENTS)) I))
       (POSITION (CL:1- I)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:COND
    ((CL:NOT (CL:EQ SURROGATE NULL))
     (CL:SETQ DESCRIPTION
      (EVALUATE-PREDICATE SURROGATE
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HOLDSARGUMENTS)) 1)))
     (CL:WHEN (CL:EQ DESCRIPTION NULL)
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
         "ERROR: Relation argument `" (%SYMBOL-NAME SURROGATE)
         "' in HOLDS proposition is not defined as a relation: `" SELF "'."
         EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-NORMALIZE-ERROR))
       (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
     (CL:COND ((CLASS? DESCRIPTION) (CL:SETF (%KIND SELF) KWD-NORMALIZE-ISA))
      ((FUNCTION? DESCRIPTION)
       (HELP-NORMALIZE-PREDICATE-PROPOSITION SELF
        (%SURROGATE-VALUE-INVERSE DESCRIPTION) PREDICATEARGUMENTS)
       (CL:RETURN-FROM NORMALIZE-HOLDS-PROPOSITION)))
     (CL:SETF (%OPERATOR SELF) (%SURROGATE-VALUE-INVERSE DESCRIPTION))
     (CL:SETF (%ARGUMENTS SELF) PREDICATEARGUMENTS)
     (NORMALIZE-PROPOSITION SELF) NULL)
    (CL:T (CL:SETQ DESCRIPTION RELATIONTERM)
     (CL:WHEN (CL:NOT (CL:= (ARITY DESCRIPTION) NOFARGUMENTS))
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
         "ERROR: Arity violation in HOLDS proposition: `" SELF "'." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001 KWD-NORMALIZE-ERROR))
       (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-001)))))
     (OVERLAY-PROPOSITION SELF
      (CONJOIN-PROPOSITIONS
       (INHERIT-DESCRIPTION-PROPOSITIONS PREDICATEARGUMENTS DESCRIPTION)))
     (NORMALIZE-PROPOSITION SELF)))))

;;; (DEFUN NORMALIZE-PREDICATE-PROPOSITION ...)

(CL:DEFUN NORMALIZE-PREDICATE-PROPOSITION (SELF)
  (CL:WHEN (CL:EQ (%OPERATOR SELF) SGT-NORMALIZE-PL-KERNEL-KB-HOLDS)
   (NORMALIZE-HOLDS-PROPOSITION SELF)
   (CL:WHEN (CL:NOT (CL:EQ (%OPERATOR SELF) SGT-NORMALIZE-PL-KERNEL-KB-HOLDS))
    (CL:RETURN-FROM NORMALIZE-PREDICATE-PROPOSITION)))
  (CL:WHEN (CL:EQ (%OPERATOR SELF) SGT-NORMALIZE-STELLA-THING)
   (OVERLAY-PROPOSITION SELF TRUE-PROPOSITION)
   (CL:RETURN-FROM NORMALIZE-PREDICATE-PROPOSITION))
  (CL:LET*
   ((CLAUSE NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ CLAUSE
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
    (CL:WHEN (ISA? CLAUSE SGT-NORMALIZE-LOGIC-PROPOSITION)
     (NORMALIZE-PROPOSITION CLAUSE))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))

;;; (DEFUN NORMALIZE-FUNCTION-PROPOSITION ...)

(CL:DEFUN NORMALIZE-FUNCTION-PROPOSITION (SELF)
  (CL:LET*
   ((CLAUSE NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ CLAUSE
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
    (CL:WHEN (ISA? CLAUSE SGT-NORMALIZE-LOGIC-PROPOSITION)
     (NORMALIZE-PROPOSITION CLAUSE))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))

;;; (DEFUN (COMPUTE-RELATION-TERM-SURROGATE SURROGATE) ...)

(CL:DEFUN COMPUTE-RELATION-TERM-SURROGATE (SKOLEM PROPOSITION)
  (CL:LET*
   ((FUNCTIONPROP (%DEFINING-PROPOSITION SKOLEM))
    (STRING (STRINGIFY (GENERATE-FUNCTION-AS-TERM FUNCTIONPROP)))
    (SURROGATE NULL) (ARITY 0) (ARGUMENTNAMES NULL) (ARGUMENTTYPES NULL)
    (DESCRIPTION NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING) (CL:TYPE CL:FIXNUM ARITY))
   (CL:SETQ SURROGATE
    (INTERN-DERIVED-SURROGATE (%OPERATOR FUNCTIONPROP) STRING))
   (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE-VALUE SURROGATE) NULL))
    (CL:RETURN-FROM COMPUTE-RELATION-TERM-SURROGATE SURROGATE))
   (CL:COND
    ((TEST-PROPERTY? SKOLEM SGT-NORMALIZE-PL-KERNEL-KB-VARIABLE-ARITY)
     (CL:SETQ ARITY -1))
    ((CL:NOT
      (CL:EQ (ACCESS-BINARY-VALUE SKOLEM SGT-NORMALIZE-PL-KERNEL-KB-ARITY)
       NULL))
     (CL:SETQ ARITY
      (%WRAPPER-VALUE
       (ACCESS-BINARY-VALUE SKOLEM SGT-NORMALIZE-PL-KERNEL-KB-ARITY))))
    (CL:T (CL:SETQ ARITY (CL:1- (LENGTH (%ARGUMENTS PROPOSITION))))))
   (CL:COND
    ((CL:= ARITY -1)
     (CL:SETQ ARGUMENTNAMES
      (LIST (YIELD-SYSTEM-DEFINED-PARAMETER-NAME 1 SKOLEM)))
     (CL:SETQ ARGUMENTTYPES (LIST SGT-NORMALIZE-STELLA-THING)))
    (CL:T (CL:SETQ ARGUMENTNAMES (NEW-LIST))
     (CL:SETQ ARGUMENTTYPES (NEW-LIST))
     (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- ARITY)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
      (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
       (INSERT ARGUMENTNAMES (YIELD-SYSTEM-DEFINED-PARAMETER-NAME I SKOLEM))
       (INSERT ARGUMENTTYPES SGT-NORMALIZE-STELLA-THING)
       (CL:SETQ ITER-000 (CL:1+ ITER-000))))
     (REVERSE ARGUMENTNAMES) (REVERSE ARGUMENTTYPES)))
   (CL:SETQ DESCRIPTION
    (CREATE-PRIMITIVE-DESCRIPTION ARGUMENTNAMES ARGUMENTTYPES (< ARITY 0)
     (CL:OR (CL:EQ (LOGICAL-TYPE SKOLEM) SGT-NORMALIZE-PL-KERNEL-KB-CLASS)
      (CLASS? SKOLEM))
     (CL:OR (CL:EQ (LOGICAL-TYPE SKOLEM) SGT-NORMALIZE-PL-KERNEL-KB-FUNCTION)
      (CL:EQ (%OPERATOR PROPOSITION) SGT-NORMALIZE-PL-KERNEL-KB-VALUE)
      (FUNCTION? SKOLEM))
     (%HOME-CONTEXT SURROGATE)))
   (CL:SETF (%SURROGATE-VALUE SURROGATE) DESCRIPTION)
   (CL:SETF (%SURROGATE-VALUE-INVERSE DESCRIPTION) SURROGATE)
   (ENSURE-DESCRIPTION-BODY DESCRIPTION) SURROGATE))

;;; (DEFUN (EVALUATE-RELATION-TERM SURROGATE) ...)

(CL:DEFUN EVALUATE-RELATION-TERM (RELATIONTERM PROPOSITION)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE RELATIONTERM)))
   (CL:COND ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000) (CL:PROGN RELATIONTERM))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-NORMALIZE-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN NULL))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-NORMALIZE-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:WHEN (CL:NOT (FUNCTION-OUTPUT-SKOLEM? RELATIONTERM))
       (CL:RETURN-FROM EVALUATE-RELATION-TERM NULL))
      (CL:LET*
       ((ARGUMENTS (%ARGUMENTS (%DEFINING-PROPOSITION RELATIONTERM)))
        (RELATIONTERMSURROGATE NULL)
        (RELATIONTERMVALUE (VALUE-OF RELATIONTERM)))
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET*
         ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ ARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:WHEN (ISA? ARG SGT-NORMALIZE-LOGIC-PATTERN-VARIABLE)
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
        (CL:WHEN FOUND?-000 (CL:RETURN-FROM EVALUATE-RELATION-TERM NULL)))
       (CL:WHEN (CL:NOT (CL:EQ RELATIONTERMVALUE RELATIONTERM))
        (CL:RETURN-FROM EVALUATE-RELATION-TERM
         (EVALUATE-RELATION-TERM RELATIONTERMVALUE PROPOSITION)))
       (CL:SETQ RELATIONTERMSURROGATE
        (COMPUTE-RELATION-TERM-SURROGATE RELATIONTERM PROPOSITION))
       (TRANSFER-PROPOSITIONS-AND-BACKLINKS RELATIONTERM
        (VALUE-OF RELATIONTERMSURROGATE))
       (CL:LET
        ((SELF (%THE-ARRAY ARGUMENTS)) (VALUE RELATIONTERMSURROGATE)
         (POSITION (CL:1- (LENGTH ARGUMENTS))))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       RELATIONTERMSURROGATE)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-NORMALIZE-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN (%SURROGATE-VALUE-INVERSE RELATIONTERM)))
    (CL:T NULL))))

;;; (DEFUN (NORMALIZE-VALUE-FUNCTION PROPOSITION) ...)

(CL:DEFUN NORMALIZE-VALUE-FUNCTION (SELF)
  (CL:LET*
   ((FUNCTIONSURROGATE
     (EVALUATE-RELATION-TERM
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0)
      SELF))
    (NEWARGUMENTCOUNT (CL:1- (LENGTH (%ARGUMENTS SELF))))
    (NEWPROPOSITION NULL) (DUPLICATE NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NEWARGUMENTCOUNT))
   (CL:WHEN (CL:EQ FUNCTIONSURROGATE NULL)
    (CL:RETURN-FROM NORMALIZE-VALUE-FUNCTION SELF))
   (CL:SETQ NEWPROPOSITION
    (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-FUNCTION NEWARGUMENTCOUNT))
   (CL:SETF (%OPERATOR NEWPROPOSITION) FUNCTIONSURROGATE)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 NEWARGUMENTCOUNT)
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS NEWPROPOSITION)))
       (VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) I))
       (POSITION (CL:1- I)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN
    (SKOLEM?
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
      (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS SELF))))))
    (CL:SETF
     (%DEFINING-PROPOSITION
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
       (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS SELF))))))
     NEWPROPOSITION))
   (CL:WHEN (CL:NOT (DESCRIPTION-MODE?))
    (CL:SETQ DUPLICATE (FIND-DUPLICATE-FUNCTION-PROPOSITION NEWPROPOSITION))
    (CL:WHEN (CL:NOT (CL:EQ DUPLICATE NULL))
     (CL:SETQ NEWPROPOSITION DUPLICATE)))
   NEWPROPOSITION))

;;; (DEFUN NORMALIZE-EQUIVALENT-PROPOSITION ...)

(CL:DEFUN NORMALIZE-EQUIVALENT-PROPOSITION (SELF)
  (CL:LET*
   ((FIRSTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0))
    (SECONDARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 1)))
   (CL:COND
    ((EQL? FIRSTARG SECONDARG)
     (OVERLAY-WITH-CONSTANT-PROPOSITION SELF TRUE-PROPOSITION))
    ((CL:OR (SKOLEM? FIRSTARG) (SKOLEM? SECONDARG) (COLLECTION? FIRSTARG)
      (COLLECTION? SECONDARG)))
    (CL:T (OVERLAY-WITH-CONSTANT-PROPOSITION SELF FALSE-PROPOSITION)))))

;;; (DEFUN (SHALLOW-COPY-PROPOSITION PROPOSITION) ...)

(CL:DEFUN SHALLOW-COPY-PROPOSITION (SELF)
  (CL:LET* ((COPY (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-AND 0)))
   (CL:WHEN
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS COPY)
     SYM-NORMALIZE-LOGIC-DESCRIPTIVE? TRUE-WRAPPER FALSE-WRAPPER))
   (CL:WHEN
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-NORMALIZE-LOGIC-DONT-OPTIMIZE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS COPY)
     SYM-NORMALIZE-LOGIC-DONT-OPTIMIZE? TRUE-WRAPPER FALSE-WRAPPER))
   (OVERLAY-PROPOSITION COPY SELF) COPY))

;;; (DEFUN NORMALIZE-PROPOSITION ...)

(CL:DEFUN NORMALIZE-PROPOSITION (SELF)
  (CL:WHEN (CL:NOT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (UNFASTENED? SELF)))
   (CL:RETURN-FROM NORMALIZE-PROPOSITION))
  (CL:WHEN (CONTAINS-NESTED-ARGUMENT? SELF)
   (CL:LET* ((PROPOSITION (SHALLOW-COPY-PROPOSITION SELF)))
    (CL:SETQ PROPOSITION (FLATTEN-NESTED-FUNCTION-ARGUMENTS PROPOSITION))
    (OVERLAY-PROPOSITION SELF PROPOSITION)))
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-AND)
     (NORMALIZE-AND-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-OR) (NORMALIZE-OR-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-NOT)
     (NORMALIZE-NOT-PROPOSITION SELF))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-ISA)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-PREDICATE))
     (NORMALIZE-PREDICATE-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FUNCTION)
     (NORMALIZE-FUNCTION-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-EXISTS)
     (NORMALIZE-EXISTS-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FORALL)
     (NORMALIZE-FORALL-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-EQUIVALENT)
     (NORMALIZE-EQUIVALENT-PROPOSITION SELF))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-IMPLIES)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FAIL)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-COLLECT-INTO)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN NORMALIZE-TOP-LEVEL-PROPOSITION ...)

(CL:DEFUN NORMALIZE-TOP-LEVEL-PROPOSITION (SELF)
  (NORMALIZE-PROPOSITION SELF)
  (CL:WHEN (CL:EQ (%KIND SELF) KWD-NORMALIZE-FORALL)
   (CL:LET*
    ((IOVARS
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
     (ARGS (%ARGUMENTS SELF)))
    (NORMALIZE-DESCRIPTIVE-PROPOSITION
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGS)) 0) IOVARS
     KWD-NORMALIZE-TAIL)
    (NORMALIZE-DESCRIPTIVE-PROPOSITION
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGS)) 1) IOVARS
     KWD-NORMALIZE-HEAD))))

;;; (DEFUN NORMALIZE-DESCRIPTIVE-PROPOSITION ...)

(CL:DEFUN NORMALIZE-DESCRIPTIVE-PROPOSITION (SELF IOVARIABLES KIND)
  (CL:LET* ((*EVALUATIONMODE* KWD-NORMALIZE-DESCRIPTION))
   (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
   (CL:HANDLER-CASE (EQUATE-TOP-LEVEL-EQUIVALENCES SELF IOVARIABLES KIND)
    (CLASH (E)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) (EXCEPTION-MESSAGE E)
      EOL)))
   (TIGHTEN-ARGUMENT-BINDINGS SELF IOVARIABLES) (SIMPLIFY-PROPOSITION SELF)
   (COLLAPSE-VALUE-OF-CHAINS-FOR-IO-VARIABLES IOVARIABLES)))

;;; (DEFUN INVERT-ATOMIC-PROPOSITION ...)

(CL:DEFUN INVERT-ATOMIC-PROPOSITION (SELF)
  (CL:LET*
   ((NEWATOMICPROPOSITION (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-NOT 1))
    (NEWNOTARGUMENTS (%ARGUMENTS NEWATOMICPROPOSITION))
    (NEWNOTPROPOSITION SELF))
   (CL:LET
    ((SELF (%THE-ARRAY NEWNOTARGUMENTS)) (VALUE NEWATOMICPROPOSITION)
     (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%KIND NEWATOMICPROPOSITION) (%KIND SELF))
   (CL:SETF (%OPERATOR NEWATOMICPROPOSITION) (%OPERATOR SELF))
   (CL:SETF (%ARGUMENTS NEWATOMICPROPOSITION) (%ARGUMENTS SELF))
   (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? SELF))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-NORMALIZE-LOGIC-VARIABLE-TYPE? NULL NULL)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWATOMICPROPOSITION)
     SYM-NORMALIZE-LOGIC-VARIABLE-TYPE? TRUE-WRAPPER NULL))
   (CL:WHEN
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-NORMALIZE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS NEWATOMICPROPOSITION)
     SYM-NORMALIZE-LOGIC-DESCRIPTIVE? TRUE-WRAPPER FALSE-WRAPPER))
   (CL:SETF (%KIND NEWNOTPROPOSITION) KWD-NORMALIZE-NOT)
   (CL:SETF (%OPERATOR NEWNOTPROPOSITION) SGT-NORMALIZE-LOGIC-NOT)
   (CL:SETF (%ARGUMENTS NEWNOTPROPOSITION) NEWNOTARGUMENTS)))

;;; (DEFUN INVERT-EXISTS-PROPOSITION ...)

(CL:DEFUN INVERT-EXISTS-PROPOSITION (SELF)
  (CL:LET*
   ((WHEREPROPOSITION
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0))
    (NEWARGUMENTS (NEW-VECTOR 2)))
   (FREE (%ARGUMENTS SELF)) (NORMALIZE-PROPOSITION WHEREPROPOSITION)
   (CL:SETQ WHEREPROPOSITION (SAFELY-INVERT-PROPOSITION WHEREPROPOSITION))
   (CL:SETF (%KIND SELF) KWD-NORMALIZE-FORALL)
   (CL:SETF (%OPERATOR SELF) SGT-NORMALIZE-LOGIC-FORALL)
   (CL:LET
    ((SELF (%THE-ARRAY NEWARGUMENTS)) (VALUE TRUE-PROPOSITION) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET
    ((SELF (%THE-ARRAY NEWARGUMENTS)) (VALUE WHEREPROPOSITION) (POSITION 1))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%ARGUMENTS SELF) NEWARGUMENTS) (NORMALIZE-PROPOSITION SELF)))

;;; (DEFUN INVERT-FORALL-PROPOSITION ...)

(CL:DEFUN INVERT-FORALL-PROPOSITION (SELF)
  (CL:LET*
   ((ANTECEDENT
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0))
    (CONSEQUENT
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 1))
    (NEWARGUMENTS (NEW-VECTOR 1)))
   (FREE (%ARGUMENTS SELF)) (NORMALIZE-PROPOSITION ANTECEDENT)
   (NORMALIZE-PROPOSITION CONSEQUENT)
   (CL:SETQ CONSEQUENT (SAFELY-INVERT-PROPOSITION CONSEQUENT))
   (CL:SETF (%KIND SELF) KWD-NORMALIZE-EXISTS)
   (CL:SETF (%OPERATOR SELF) SGT-NORMALIZE-LOGIC-EXISTS)
   (CL:LET
    ((SELF (%THE-ARRAY NEWARGUMENTS))
     (VALUE (CONJOIN-TWO-PROPOSITIONS ANTECEDENT CONSEQUENT)) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:SETF (%ARGUMENTS SELF) NEWARGUMENTS) (NORMALIZE-PROPOSITION SELF)))

;;; (DEFUN (EXTRACT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN EXTRACT-PROPOSITION (SELF MAPPING)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION SELF))
    (EXISTENTIALS
     (CL:IF (NON-EMPTY? (%INTERNAL-VARIABLES SELF))
      (TOP-LEVEL-EXISTENTIAL-VARIABLES SELF) NIL))
    (EXISTSPROPOSITION
     (CL:IF (CL:NOT (CL:EQ EXISTENTIALS NIL))
      (CREATE-PROPOSITION SYM-NORMALIZE-STELLA-EXISTS 1) NULL)))
   (CL:WHEN (CL:NOT (CL:EQ EXISTSPROPOSITION NULL))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS EXISTSPROPOSITION)
     SYM-NORMALIZE-LOGIC-IO-VARIABLES
     (COPY-VARIABLES-VECTOR (COPY-CONS-LIST-TO-VARIABLES-VECTOR EXISTENTIALS)
      MAPPING)
     NULL))
   (CL:SETQ PROPOSITION (COPY-PROPOSITION PROPOSITION MAPPING))
   (REMOVE-AT MAPPING (%PROPOSITION SELF))
   (CL:WHEN (CL:NOT (CL:EQ EXISTSPROPOSITION NULL))
    (CL:LET
     ((SELF (%THE-ARRAY (%ARGUMENTS EXISTSPROPOSITION))) (VALUE PROPOSITION)
      (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:SETQ PROPOSITION EXISTSPROPOSITION))
   PROPOSITION))

;;; (DEFUN INVERT-IMPLIES-PROPOSITION ...)

(CL:DEFUN INVERT-IMPLIES-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS SELF))
    (ARG1VALUE
     (CL:IF
      (SURROGATE?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
      (GET-DESCRIPTION
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0)))
    (ARG2VALUE
     (CL:IF
      (SURROGATE?
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1))
      (GET-DESCRIPTION
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1))
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1))))
   (CL:WHEN
    (CL:NOT
     (CL:AND (ISA? ARG1VALUE SGT-NORMALIZE-LOGIC-DESCRIPTION)
      (ISA? ARG2VALUE SGT-NORMALIZE-LOGIC-DESCRIPTION)))
    (INVERT-ATOMIC-PROPOSITION SELF)
    (CL:RETURN-FROM INVERT-IMPLIES-PROPOSITION))
   (CL:LET*
    ((SUBSET ARG1VALUE) (SUPERSET ARG2VALUE) (SUBSETPROP NULL)
     (SUPERSETPROP NULL) (MAPPING (NEW-KEY-VALUE-MAP))
     (NEWARGUMENTS (NEW-VECTOR 1)))
    (CL:SETF (%KIND SELF) KWD-NORMALIZE-EXISTS)
    (CL:SETF (%OPERATOR SELF) SGT-NORMALIZE-LOGIC-EXISTS)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-NORMALIZE-LOGIC-IO-VARIABLES
     (COPY-VARIABLES-VECTOR (%IO-VARIABLES SUBSET) MAPPING) NULL)
    (CL:LET*
     ((IOVAR NULL)
      (VECTOR-000
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-NORMALIZE-LOGIC-IO-VARIABLES NULL))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (SUPVAR NULL)
      (VECTOR-001 (%IO-VARIABLES SUPERSET)) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
      (CL:SETQ IOVAR
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
      (CL:SETQ SUPVAR
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001)) INDEX-001))
      (INSERT-AT MAPPING SUPVAR IOVAR) (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
    (CL:SETQ SUBSETPROP (EXTRACT-PROPOSITION SUBSET MAPPING))
    (CL:SETQ SUPERSETPROP (EXTRACT-PROPOSITION SUPERSET MAPPING))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SUPERSETPROP)
     SYM-NORMALIZE-LOGIC-VARIABLE-TYPE? NULL NULL)
    (INVERT-PROPOSITION SUPERSETPROP)
    (CL:LET
     ((SELF (%THE-ARRAY NEWARGUMENTS))
      (VALUE (CONJOIN-TWO-PROPOSITIONS SUBSETPROP SUPERSETPROP)) (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:SETF (%ARGUMENTS SELF) NEWARGUMENTS) (NORMALIZE-PROPOSITION SELF))))

;;; (DEFUN (INVERT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN INVERT-PROPOSITION (SELF)
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-ISA)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-NORMALIZE-EQUIVALENT))
     (INVERT-ATOMIC-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-AND)
     (CL:LET* ((ARGUMENTCOUNT (LENGTH (%ARGUMENTS SELF))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM ARGUMENTCOUNT))
      (SIMPLIFY-PROPOSITION SELF)
      (CL:WHEN (CL:< (LENGTH (%ARGUMENTS SELF)) ARGUMENTCOUNT)
       (CL:RETURN-FROM INVERT-PROPOSITION (INVERT-PROPOSITION SELF))))
     (CL:SETF (%KIND SELF) KWD-NORMALIZE-OR)
     (CL:SETF (%OPERATOR SELF) SGT-NORMALIZE-LOGIC-OR)
     (CL:LET*
      ((I NULL-INTEGER) (ITER-000 0)
       (UPPER-BOUND-000 (CL:1- (LENGTH (%ARGUMENTS SELF)))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
      (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
       (CL:LET
        ((SELF (%THE-ARRAY (%ARGUMENTS SELF)))
         (VALUE
          (SAFELY-INVERT-PROPOSITION
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
            I)))
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-OR)
     (CL:SETF (%KIND SELF) KWD-NORMALIZE-AND)
     (CL:SETF (%OPERATOR SELF) SGT-NORMALIZE-LOGIC-AND)
     (CL:LET*
      ((I NULL-INTEGER) (ITER-001 0)
       (UPPER-BOUND-001 (CL:1- (LENGTH (%ARGUMENTS SELF)))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
      (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ I ITER-001)
       (CL:LET
        ((SELF (%THE-ARRAY (%ARGUMENTS SELF)))
         (VALUE
          (SAFELY-INVERT-PROPOSITION
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
            I)))
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-NOT)
     (OVERLAY-PROPOSITION SELF
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0))
     (NORMALIZE-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-EXISTS)
     (CL:IF (FUNCTION-INDUCED-EXISTS? SELF)
      (EMBED-NEGATION-WITHIN-FUNCTION-INDUCED-EXISTS SELF)
      (INVERT-EXISTS-PROPOSITION SELF)))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FORALL)
     (INVERT-FORALL-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-IMPLIES)
     (INVERT-IMPLIES-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-CONSTANT)
     (CL:LET* ((TEST-VALUE-001 (%OPERATOR SELF)))
      (CL:COND
       ((CL:EQ TEST-VALUE-001 SGT-NORMALIZE-STELLA-TRUE)
        (CL:RETURN-FROM INVERT-PROPOSITION FALSE-PROPOSITION))
       ((CL:EQ TEST-VALUE-001 SGT-NORMALIZE-STELLA-FALSE)
        (CL:RETURN-FROM INVERT-PROPOSITION TRUE-PROPOSITION))
       (CL:T
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-001
          "' is not a valid case option")
         (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
    ((CL:EQ TEST-VALUE-000 KWD-NORMALIZE-FAIL)
     (INVERT-ATOMIC-PROPOSITION SELF))
    (CL:T
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
  SELF)

;;; (DEFUN (SAFELY-INVERT-PROPOSITION PROPOSITION) ...)

(CL:DEFUN SAFELY-INVERT-PROPOSITION (SELF)
  (CL:LET* ((COPY (SHALLOW-COPY-PROPOSITION SELF))) (INVERT-PROPOSITION COPY)
   COPY))

(CL:DEFUN HELP-STARTUP-NORMALIZE1 ()
  (CL:PROGN
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-CUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CUT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-BOUND-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BOUND-VARIABLES"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-FORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORK"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-NORMALIZE-AND (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-NORMALIZE-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 2))
   (CL:SETQ SGT-NORMALIZE-STELLA-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ SYM-NORMALIZE-LOGIC-CONSTANT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTANT" NULL 0))
   (CL:SETQ SGT-NORMALIZE-STELLA-CS-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-NORMALIZE-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-DESCRIPTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTIVE?" NULL 0))
   (CL:SETQ KWD-NORMALIZE-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ SYM-NORMALIZE-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT" NULL 0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-NEURAL-NETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEURAL-NETWORK" NULL 0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-VARIABLE-TYPE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-TYPE?" NULL 0))
   (CL:SETQ KWD-NORMALIZE-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ KWD-NORMALIZE-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-NORMALIZE-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-NORMALIZE-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SGT-NORMALIZE-STELLA-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FALSE" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ KWD-NORMALIZE-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-NORMALIZE-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ KWD-NORMALIZE-ISA (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-NORMALIZE-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-NORMALIZE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-NORMALIZE-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-NORMALIZE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-VARIABLE-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VARIABLE-ARITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-PL-KERNEL-KB-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VALUE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SYM-NORMALIZE-STELLA-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-NORMALIZE-LOGIC-DONT-OPTIMIZE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DONT-OPTIMIZE?" NULL 0))
   (CL:SETQ KWD-NORMALIZE-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ KWD-NORMALIZE-FAIL (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ KWD-NORMALIZE-COLLECT-INTO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO" NULL 2))
   (CL:SETQ KWD-NORMALIZE-TAIL (INTERN-RIGID-SYMBOL-WRT-MODULE "TAIL" NULL 2))
   (CL:SETQ KWD-NORMALIZE-HEAD (INTERN-RIGID-SYMBOL-WRT-MODULE "HEAD" NULL 2))
   (CL:SETQ SYM-NORMALIZE-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SGT-NORMALIZE-LOGIC-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 1))
   (CL:SETQ SGT-NORMALIZE-LOGIC-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 1))
   (CL:SETQ SYM-NORMALIZE-LOGIC-STARTUP-NORMALIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-NORMALIZE" NULL 0))
   (CL:SETQ SYM-NORMALIZE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN STARTUP-NORMALIZE ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-NORMALIZE1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "SEARCH-CONTROL-PROPOSITION?"
     "(DEFUN (SEARCH-CONTROL-PROPOSITION? BOOLEAN) ((SELF PROPOSITION)))"
     (CL:FUNCTION SEARCH-CONTROL-PROPOSITION?) NULL)
    (DEFINE-FUNCTION-OBJECT "DUPLICATE-AND-OR-ARGUMENTS?"
     "(DEFUN (DUPLICATE-AND-OR-ARGUMENTS? BOOLEAN) ((PROP1 PROPOSITION) (PROP2 PROPOSITION)))"
     (CL:FUNCTION DUPLICATE-AND-OR-ARGUMENTS?) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-FLAT-CONJUNCTS"
     "(DEFUN COLLECT-FLAT-CONJUNCTS ((SELF PROPOSITION) (FLATCONJUNCTS (LIST OF PROPOSITION))))"
     (CL:FUNCTION COLLECT-FLAT-CONJUNCTS) NULL)
    (DEFINE-FUNCTION-OBJECT "OVERLAY-WITH-CONSTANT-PROPOSITION"
     "(DEFUN OVERLAY-WITH-CONSTANT-PROPOSITION ((SELF PROPOSITION) (CONSTANTPROPOSITION PROPOSITION)))"
     (CL:FUNCTION OVERLAY-WITH-CONSTANT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "CONJOIN-PROPOSITIONS"
     "(DEFUN (CONJOIN-PROPOSITIONS PROPOSITION) ((CONJUNCTS (CONS OF PROPOSITION))))"
     (CL:FUNCTION CONJOIN-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "CONJOIN-TWO-PROPOSITIONS"
     "(DEFUN (CONJOIN-TWO-PROPOSITIONS PROPOSITION) ((PROP1 PROPOSITION) (PROP2 PROPOSITION)))"
     (CL:FUNCTION CONJOIN-TWO-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "COLLECT-FLAT-DISJUNCTS"
     "(DEFUN COLLECT-FLAT-DISJUNCTS ((SELF PROPOSITION) (FLATDISJUNCTS (LIST OF PROPOSITION))))"
     (CL:FUNCTION COLLECT-FLAT-DISJUNCTS) NULL)
    (DEFINE-FUNCTION-OBJECT "DISJOIN-PROPOSITIONS"
     "(DEFUN (DISJOIN-PROPOSITIONS PROPOSITION) ((DISJUNCTS (CONS OF PROPOSITION))))"
     (CL:FUNCTION DISJOIN-PROPOSITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "RENAME-LOGIC-VARIABLE-APART"
     "(DEFUN (RENAME-LOGIC-VARIABLE-APART PATTERN-VARIABLE) ((VARIABLE PATTERN-VARIABLE) (DESTRUCTIVE? BOOLEAN)))"
     (CL:FUNCTION RENAME-LOGIC-VARIABLE-APART) NULL)
    (DEFINE-FUNCTION-OBJECT "OVERLAY-PROPOSITION"
     "(DEFUN OVERLAY-PROPOSITION ((SELF PROPOSITION) (OVERLAYINGPROP PROPOSITION)))"
     (CL:FUNCTION OVERLAY-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-EXISTS-PROPOSITION"
     "(DEFUN NORMALIZE-EXISTS-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-EXISTS-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT?"
     "(DEFUN (MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT? BOOLEAN) ((SELF PROPOSITION)))"
     (CL:FUNCTION MIGRATE-CONSEQUENT-GOALS-TO-ANTECEDENT?) NULL)
    (DEFINE-FUNCTION-OBJECT "FLATTEN-NESTED-FORALL-PROPOSITION"
     "(DEFUN FLATTEN-NESTED-FORALL-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION FLATTEN-NESTED-FORALL-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-FORALL-PROPOSITION"
     "(DEFUN NORMALIZE-FORALL-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-FORALL-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-NOT-PROPOSITION"
     "(DEFUN NORMALIZE-NOT-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-NOT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-AND-PROPOSITION"
     "(DEFUN NORMALIZE-AND-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-AND-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-OR-PROPOSITION"
     "(DEFUN NORMALIZE-OR-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-OR-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-NORMALIZE-PREDICATE-PROPOSITION"
     "(DEFUN HELP-NORMALIZE-PREDICATE-PROPOSITION ((SELF PROPOSITION) (RELATIONREF SURROGATE) (PREDICATEARGUMENTS VECTOR)))"
     (CL:FUNCTION HELP-NORMALIZE-PREDICATE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-HOLDS-PROPOSITION"
     "(DEFUN NORMALIZE-HOLDS-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-HOLDS-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-PREDICATE-PROPOSITION"
     "(DEFUN NORMALIZE-PREDICATE-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-PREDICATE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-FUNCTION-PROPOSITION"
     "(DEFUN NORMALIZE-FUNCTION-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-FUNCTION-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPUTE-RELATION-TERM-SURROGATE"
     "(DEFUN (COMPUTE-RELATION-TERM-SURROGATE SURROGATE) ((SKOLEM SKOLEM) (PROPOSITION PROPOSITION)))"
     (CL:FUNCTION COMPUTE-RELATION-TERM-SURROGATE) NULL)
    (DEFINE-FUNCTION-OBJECT "EVALUATE-RELATION-TERM"
     "(DEFUN (EVALUATE-RELATION-TERM SURROGATE) ((RELATIONTERM OBJECT) (PROPOSITION PROPOSITION)))"
     (CL:FUNCTION EVALUATE-RELATION-TERM) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-VALUE-FUNCTION"
     "(DEFUN (NORMALIZE-VALUE-FUNCTION PROPOSITION) ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-VALUE-FUNCTION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-EQUIVALENT-PROPOSITION"
     "(DEFUN NORMALIZE-EQUIVALENT-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-EQUIVALENT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "SHALLOW-COPY-PROPOSITION"
     "(DEFUN (SHALLOW-COPY-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))"
     (CL:FUNCTION SHALLOW-COPY-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-PROPOSITION"
     "(DEFUN NORMALIZE-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-TOP-LEVEL-PROPOSITION"
     "(DEFUN NORMALIZE-TOP-LEVEL-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION NORMALIZE-TOP-LEVEL-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-DESCRIPTIVE-PROPOSITION"
     "(DEFUN NORMALIZE-DESCRIPTIVE-PROPOSITION ((SELF PROPOSITION) (IOVARIABLES VARIABLES-VECTOR) (KIND KEYWORD)))"
     (CL:FUNCTION NORMALIZE-DESCRIPTIVE-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INVERT-ATOMIC-PROPOSITION"
     "(DEFUN INVERT-ATOMIC-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION INVERT-ATOMIC-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INVERT-EXISTS-PROPOSITION"
     "(DEFUN INVERT-EXISTS-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION INVERT-EXISTS-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INVERT-FORALL-PROPOSITION"
     "(DEFUN INVERT-FORALL-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION INVERT-FORALL-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "EXTRACT-PROPOSITION"
     "(DEFUN (EXTRACT-PROPOSITION PROPOSITION) ((SELF DESCRIPTION) (MAPPING ENTITY-MAPPING)))"
     (CL:FUNCTION EXTRACT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INVERT-IMPLIES-PROPOSITION"
     "(DEFUN INVERT-IMPLIES-PROPOSITION ((SELF PROPOSITION)))"
     (CL:FUNCTION INVERT-IMPLIES-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "INVERT-PROPOSITION"
     "(DEFUN (INVERT-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))"
     (CL:FUNCTION INVERT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "SAFELY-INVERT-PROPOSITION"
     "(DEFUN (SAFELY-INVERT-PROPOSITION PROPOSITION) ((SELF PROPOSITION)))"
     (CL:FUNCTION SAFELY-INVERT-PROPOSITION) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-NORMALIZE"
     "(DEFUN STARTUP-NORMALIZE () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-NORMALIZE) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-NORMALIZE-LOGIC-STARTUP-NORMALIZE)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-NORMALIZE-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupNormalize") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC"))))))
