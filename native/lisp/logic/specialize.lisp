;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; specialize.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2010      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-SPECIALIZE-LOGIC-ABSTRACT-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-SELECTION-PATTERN NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-PROPOSITION-CURSOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-EQUIVALENTS-STACK NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-TRUE-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-SPECIALIZING-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-SPECIALIZING-RELATIONS NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-DESCRIPTION-EXTENSION-ITERATOR NULL)
(CL:DEFVAR KWD-SPECIALIZE-RELATION NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR KWD-SPECIALIZE-DEPENDENTS NULL)
(CL:DEFVAR KWD-SPECIALIZE-ISA NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-PROPOSITION NULL)
(CL:DEFVAR KWD-SPECIALIZE-FUNCTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-TEST-PROPERTY?-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-STELLA-THING NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-CLASS NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-RELATION NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-FUNCTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-SET NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-001 NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-ACCESS-BINARY-VALUE-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTIONOF NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-TRANSITIVE-CLOSURE-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-FILTER? NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-ADJACENCY-ITERATOR-STACK NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-BEEN-THERE-LIST NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-SUPPORTED-CLOSURE-ITERATOR NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-DIRECTLY-LINKED-OBJECTS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-INVERSE? NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-ROOT-TRUTH-VALUE NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-SUBSET-OF NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-SPECIALIZE-STELLA-CONS NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-SPECIALIZE-STELLA-NUMBER NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-SPECIALIZE-LOGIC-CLASHING-PROPOSITIONS-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-REFERENCE-PROPOSITION NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NULL)
(CL:DEFVAR SYM-SPECIALIZE-LOGIC-STARTUP-SPECIALIZE NULL)
(CL:DEFVAR SYM-SPECIALIZE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* *DONTUSEDEFAULTKNOWLEDGE?*
  *CONTEXT* *MEMOIZATION-ENABLED?* MEMOIZED-NULL-VALUE TRUE-WRAPPER
  FALSE-WRAPPER NULL-INTEGER *CYC-KLUDGES-ENABLED?* *QUERYITERATOR*
  NIL-PAGING-INDEX NIL-NON-PAGING-INDEX *REVERSEPOLARITY?* TRUE-TRUTH-VALUE
  NIL))

;;; (DEFCLASS ABSTRACT-PROPOSITIONS-ITERATOR ...)

(CL:DEFCLASS ABSTRACT-PROPOSITIONS-ITERATOR (ITERATOR)
  ((SELECTION-PATTERN :ALLOCATION :INSTANCE :ACCESSOR %SELECTION-PATTERN)
   (PROPOSITION-CURSOR :ALLOCATION :INSTANCE :ACCESSOR %PROPOSITION-CURSOR)
   (EQUIVALENTS-STACK :ALLOCATION :INSTANCE :ACCESSOR %EQUIVALENTS-STACK))
  (:DOCUMENTATION
   "Iterator class that can generate sets of propositions matching
its `selection-pattern'."))

(CL:DEFUN NEW-ABSTRACT-PROPOSITIONS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE ABSTRACT-PROPOSITIONS-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%EQUIVALENTS-STACK SELF) NULL)
   (CL:SETF (%PROPOSITION-CURSOR SELF) NULL)
   (CL:SETF (%SELECTION-PATTERN SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF ABSTRACT-PROPOSITIONS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-ABSTRACT-PROPOSITIONS-ITERATOR)

(CL:DEFUN ACCESS-ABSTRACT-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-SELECTION-PATTERN)
    (CL:IF SETVALUE? (CL:SETF (%SELECTION-PATTERN SELF) VALUE)
     (CL:SETQ VALUE (%SELECTION-PATTERN SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-PROPOSITION-CURSOR)
    (CL:IF SETVALUE? (CL:SETF (%PROPOSITION-CURSOR SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION-CURSOR SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-EQUIVALENTS-STACK)
    (CL:IF SETVALUE? (CL:SETF (%EQUIVALENTS-STACK SELF) VALUE)
     (CL:SETQ VALUE (%EQUIVALENTS-STACK SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS TRUE-PROPOSITIONS-ITERATOR ...)

(CL:DEFCLASS TRUE-PROPOSITIONS-ITERATOR (ABSTRACT-PROPOSITIONS-ITERATOR)
  ((TRUTH-VALUE :DOCUMENTATION
    "Truth-value of the most recently generated proposition (or
projected argument thereof).  This truth value is not necessarily the strictest
and might have involved defaults." :ALLOCATION :INSTANCE :ACCESSOR
    %TRUTH-VALUE))
  (:DOCUMENTATION "Iterator class that can generate sets of true propositions
matching its `selection-pattern'."))

(CL:DEFUN NEW-TRUE-PROPOSITIONS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRUE-PROPOSITIONS-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%EQUIVALENTS-STACK SELF) NULL)
   (CL:SETF (%PROPOSITION-CURSOR SELF) NULL)
   (CL:SETF (%SELECTION-PATTERN SELF) NULL) (CL:SETF (%TRUTH-VALUE SELF) NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRUE-PROPOSITIONS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-TRUE-PROPOSITIONS-ITERATOR)

(CL:DEFUN ACCESS-TRUE-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%TRUTH-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%TRUTH-VALUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS SPECIALIZING-PROPOSITIONS-ITERATOR ...)

(CL:DEFCLASS SPECIALIZING-PROPOSITIONS-ITERATOR (TRUE-PROPOSITIONS-ITERATOR)
  ((SPECIALIZING-RELATIONS :ALLOCATION :INSTANCE :ACCESSOR
    %SPECIALIZING-RELATIONS))
  (:DOCUMENTATION "Iterator class that can generate sets of true propositions
matching its `selection-pattern' or a more specific pattern that substitutes
one of the relations in `specializing-relations'."))

(CL:DEFUN NEW-SPECIALIZING-PROPOSITIONS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE SPECIALIZING-PROPOSITIONS-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%EQUIVALENTS-STACK SELF) NULL)
   (CL:SETF (%PROPOSITION-CURSOR SELF) NULL)
   (CL:SETF (%SELECTION-PATTERN SELF) NULL) (CL:SETF (%TRUTH-VALUE SELF) NULL)
   (CL:SETF (%SPECIALIZING-RELATIONS SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SPECIALIZING-PROPOSITIONS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-SPECIALIZING-PROPOSITIONS-ITERATOR)

(CL:DEFUN ACCESS-SPECIALIZING-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-SPECIALIZING-RELATIONS)
    (CL:IF SETVALUE? (CL:SETF (%SPECIALIZING-RELATIONS SELF) VALUE)
     (CL:SETQ VALUE (%SPECIALIZING-RELATIONS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (PROPOSITIONS-ITERATOR-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN PROPOSITIONS-ITERATOR-TRUTH-VALUE (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALIZE-LOGIC-TRUE-PROPOSITIONS-ITERATOR)
     (CL:PROGN (%TRUTH-VALUE SELF)))
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-SPECIALIZE-LOGIC-DESCRIPTION-EXTENSION-ITERATOR)
     (CL:PROGN (%TRUTH-VALUE SELF)))
    (CL:T NULL))))

;;; (DEFUN (NEXT-EQUIVALENT-SELECTION-PATTERN CONS) ...)

(CL:DEFUN NEXT-EQUIVALENT-SELECTION-PATTERN (SELF)
  (CL:LET*
   ((PATTERN (%SELECTION-PATTERN SELF)) (KEYWITHEQUIVALENTS NULL)
    (EQUIVALENTSSTACK (%EQUIVALENTS-STACK SELF)) (NEWSKOLEM NULL)
    (EQUIVALENTSKOLEMS NULL))
   (CL:WHEN (CL:EQ EQUIVALENTSSTACK NULL)
    (CL:SETQ KEYWITHEQUIVALENTS (FIND-SELECTION-KEY-WITH-EQUIVALENTS PATTERN))
    (CL:WHEN (CL:NOT (CL:EQ KEYWITHEQUIVALENTS NULL))
     (CL:SETQ EQUIVALENTSKOLEMS (VARIABLE-VALUE-INVERSE KEYWITHEQUIVALENTS))
     (CL:SETQ EQUIVALENTSSTACK (CONS EQUIVALENTSKOLEMS NIL))))
   (CL:WHEN (CL:EQ EQUIVALENTSSTACK NULL)
    (CL:SETF (%EQUIVALENTS-STACK SELF) NIL)
    (CL:RETURN-FROM NEXT-EQUIVALENT-SELECTION-PATTERN NULL))
   (CL:WHEN (CL:EQ EQUIVALENTSSTACK NIL)
    (CL:RETURN-FROM NEXT-EQUIVALENT-SELECTION-PATTERN NULL))
   (CL:SETQ EQUIVALENTSKOLEMS (%%VALUE EQUIVALENTSSTACK))
   (CL:SETQ NEWSKOLEM (%%VALUE EQUIVALENTSKOLEMS))
   (FIRST-SETTER EQUIVALENTSSTACK (%%REST EQUIVALENTSKOLEMS))
   (CL:WHEN (CL:EQ (%%VALUE EQUIVALENTSSTACK) NIL)
    (CL:SETQ EQUIVALENTSSTACK (%%REST EQUIVALENTSSTACK)))
   (CL:WHEN (CL:NOT (CL:EQ (VARIABLE-VALUE-INVERSE NEWSKOLEM) NIL))
    (CL:SETQ EQUIVALENTSSTACK
     (CONS (VARIABLE-VALUE-INVERSE NEWSKOLEM) EQUIVALENTSSTACK)))
   (CL:SETF (%EQUIVALENTS-STACK SELF) EQUIVALENTSSTACK)
   (CL:WHEN (CL:EQ KEYWITHEQUIVALENTS NULL)
    (CL:SETQ KEYWITHEQUIVALENTS
     (FIND-SELECTION-KEY-WITH-EQUIVALENTS PATTERN)))
   (SUBSTITUTE-CONS-TREE (COPY-CONS-TREE PATTERN) NEWSKOLEM
    KEYWITHEQUIVALENTS)))

;;; (DEFUN (PROPOSITION-TRUTH-VALUE TRUTH-VALUE) ...)

(CL:DEFUN PROPOSITION-TRUTH-VALUE (PROPOSITION)
  (CL:LET*
   ((TRUTHVALUE
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE PROPOSITION) (%HOME-CONTEXT PROPOSITION)
      CL:NIL)))
   (CL:IF (CL:NOT (CL:EQ TRUTHVALUE NULL)) TRUTHVALUE
    (CL:IF
     (CL:AND (CL:NOT *REVERSEPOLARITY?*)
      (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION))
     TRUE-TRUTH-VALUE NULL))))

;;; (DEFUN (TRUE-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN TRUE-PROPOSITION? (PROPOSITION)
  (CL:AND (CL:NOT (DELETED? PROPOSITION))
   (CL:IF *REVERSEPOLARITY?* (FALSE? PROPOSITION)
    (CL:OR (TRUE? PROPOSITION) (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION)))))

;;; (DEFUN (TRUE-PROPOSITIONS-ITERATOR.NEXT? BOOLEAN) ...)

(CL:DEFUN TRUE-PROPOSITIONS-ITERATOR.NEXT? (SELF)
  (CL:LET* ((CURSOR (%PROPOSITION-CURSOR SELF)) (PROPOSITION NULL))
   (CL:WHEN (CL:EQ CURSOR NULL)
    (CL:RETURN-FROM TRUE-PROPOSITIONS-ITERATOR.NEXT? CL:NIL))
   (CL:LOOP
    (CL:TAGBODY
     (CL:COND ((NEXT? CURSOR) (CL:SETQ PROPOSITION (%VALUE CURSOR)))
      (CL:T
       (CL:LET* ((PATTERN (NEXT-EQUIVALENT-SELECTION-PATTERN SELF)))
        (CL:COND
         ((CL:NOT (CL:EQ PATTERN NULL))
          (CL:SETQ CURSOR (ALLOCATE-ITERATOR (SELECT-PROPOSITIONS PATTERN)))
          (CL:SETF (%PROPOSITION-CURSOR SELF) CURSOR) (CL:GO :CONTINUE))
         (CL:T (CL:SETF (%PROPOSITION-CURSOR SELF) NULL)
          (CL:RETURN-FROM TRUE-PROPOSITIONS-ITERATOR.NEXT? CL:NIL))))))
     (CL:WHEN
      (CL:AND (CL:NOT (DELETED? PROPOSITION))
       (CL:IF *REVERSEPOLARITY?* (FALSE? PROPOSITION)
        (CL:OR (TRUE? PROPOSITION)
         (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION))))
      (CL:SETF (%VALUE SELF) PROPOSITION)
      (CL:SETF (%TRUTH-VALUE SELF) (PROPOSITION-TRUTH-VALUE PROPOSITION))
      (CL:RETURN-FROM TRUE-PROPOSITIONS-ITERATOR.NEXT? CL:T))
     :CONTINUE))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF TRUE-PROPOSITIONS-ITERATOR))
  (TRUE-PROPOSITIONS-ITERATOR.NEXT? SELF))

;;; (DEFUN (SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? BOOLEAN) ...)

(CL:DEFUN SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? (SELF)
  (CL:LET* ((SPECIALIZINGRELATIONS (%SPECIALIZING-RELATIONS SELF)))
   (CL:LOOP
    (CL:WHEN (TRUE-PROPOSITIONS-ITERATOR.NEXT? SELF)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ SPECIALIZINGRELATIONS NULL))
       (CL:NOT (CL:EQ SPECIALIZINGRELATIONS NIL)))
      (CL:SETF (%TRUTH-VALUE SELF)
       (CONJOIN-TRUTH-VALUES (%TRUTH-VALUE SELF)
        (%%VALUE (%%REST (%%VALUE SPECIALIZINGRELATIONS))))))
     (CL:SETF (%SPECIALIZING-RELATIONS SELF) SPECIALIZINGRELATIONS)
     (CL:RETURN-FROM SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? CL:T))
    (CL:IF (CL:EQ SPECIALIZINGRELATIONS NULL)
     (CL:COND
      ((CL:EQ (%%VALUE (%SELECTION-PATTERN SELF)) KWD-SPECIALIZE-RELATION)
       (CL:LET*
        ((RELATIONDESCRIPTION
          (SURROGATE-TO-DESCRIPTION
           (%%VALUE (%%REST (%%REST (%SELECTION-PATTERN SELF)))))))
        (CL:IF (CL:NOT (CL:EQ RELATIONDESCRIPTION NULL))
         (CL:SETQ SPECIALIZINGRELATIONS
          (ALL-SUPPORTED-NAMED-SUBCOLLECTIONS RELATIONDESCRIPTION))
         (CL:SETQ SPECIALIZINGRELATIONS NIL))))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
         "Illegal selection pattern in `" SELF "'")
        (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
     (CL:SETQ SPECIALIZINGRELATIONS (%%REST SPECIALIZINGRELATIONS)))
    (CL:WHEN (CL:EQ SPECIALIZINGRELATIONS NIL) (CL:SETF (%VALUE SELF) NULL)
     (CL:RETURN-FROM SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? CL:NIL))
    (FIRST-SETTER (%%REST (%%REST (%SELECTION-PATTERN SELF)))
     (%SURROGATE-VALUE-INVERSE (%%VALUE (%%VALUE SPECIALIZINGRELATIONS))))
    (CL:SETF (%PROPOSITION-CURSOR SELF)
     (ALLOCATE-ITERATOR (SELECT-PROPOSITIONS (%SELECTION-PATTERN SELF))))
    (CL:SETF (%EQUIVALENTS-STACK SELF) NULL))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF SPECIALIZING-PROPOSITIONS-ITERATOR))
  (SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? SELF))

;;; (DEFCONSTANT EMPTY-PROPOSITIONS-ITERATOR ...)

(CL:DEFVAR EMPTY-PROPOSITIONS-ITERATOR NULL
  "This iterator returns no values whenever its called.")

;;; (DEFUN (EMPTY-PROPOSITIONS-INDEX? BOOLEAN) ...)

(CL:DEFUN EMPTY-PROPOSITIONS-INDEX? (INDEX PRIMARYKEY SPECIALIZE?)
  (CL:WHEN
   (CL:AND (CL:NOT SPECIALIZE?)
    (CL:OR (CL:EQ INDEX NIL-PAGING-INDEX) (CL:EQ INDEX NIL-NON-PAGING-INDEX)))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE PRIMARYKEY)
      SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:WHEN (CL:EQ (VARIABLE-VALUE-INVERSE PRIMARYKEY) NIL)
       (CL:RETURN-FROM EMPTY-PROPOSITIONS-INDEX? CL:T))))
    (CL:T (CL:RETURN-FROM EMPTY-PROPOSITIONS-INDEX? CL:T))))
  CL:NIL)

;;; (DEFUN (ALL-TRUE-DEPENDENT-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-TRUE-DEPENDENT-PROPOSITIONS (SELF RELATION SPECIALIZE?)
  (CL:WHEN
   (CL:NOT (CL:OR (CL:NOT (CL:EQ RELATION NULL)) (CL:NOT SPECIALIZE?)))
   (CL:ERROR
    "Safety violation: INTERNAL-ERROR: Expected defined relation argument"))
  (CL:LET*
   ((PATTERN
     (CL:IF (CL:NOT (CL:EQ RELATION NULL))
      (CONS KWD-SPECIALIZE-RELATION
       (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL)
        (CONS RELATION (CONS (VALUE-OF SELF) NIL))))
      (CONS KWD-SPECIALIZE-DEPENDENTS
       (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL) (CONS (VALUE-OF SELF) NIL)))))
    (INDEX (SELECT-PROPOSITIONS PATTERN)) (ITERATOR NULL))
   (CL:WHEN (EMPTY-PROPOSITIONS-INDEX? INDEX SELF SPECIALIZE?)
    (CL:RETURN-FROM ALL-TRUE-DEPENDENT-PROPOSITIONS
     EMPTY-PROPOSITIONS-ITERATOR))
   (CL:SETQ ITERATOR
    (CL:IF SPECIALIZE? (NEW-SPECIALIZING-PROPOSITIONS-ITERATOR)
     (NEW-TRUE-PROPOSITIONS-ITERATOR)))
   (CL:SETF (%SELECTION-PATTERN ITERATOR) PATTERN)
   (CL:SETF (%PROPOSITION-CURSOR ITERATOR) (ALLOCATE-ITERATOR INDEX)) ITERATOR))

;;; (DEFUN (ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS (SELF)
  (CL:LET*
   ((PATTERN
     (CONS KWD-SPECIALIZE-ISA
      (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL) (CONS (VALUE-OF SELF) NIL))))
    (INDEX (SELECT-PROPOSITIONS PATTERN)))
   (CL:IF (EMPTY-PROPOSITIONS-INDEX? INDEX SELF CL:NIL)
    EMPTY-PROPOSITIONS-ITERATOR
    (CL:LET* ((SELF-000 (NEW-TRUE-PROPOSITIONS-ITERATOR)))
     (CL:SETF (%SELECTION-PATTERN SELF-000) PATTERN)
     (CL:SETF (%PROPOSITION-CURSOR SELF-000) (ALLOCATE-ITERATOR INDEX))
     (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))))

;;; (DEFUN (ARGUMENTS-UNIFY-WITH-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN ARGUMENTS-UNIFY-WITH-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:LET*
   ((PATTERNRECORD (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (UBSTACKOFFSET (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
    (SUCCESS? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET*
      ((SUPERARG NULL) (VECTOR-000 (%ARGUMENTS REFERENCEPROPOSITION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (SUBARG NULL)
       (VECTOR-001 (%ARGUMENTS SUBPROPOSITION)) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE
       (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
      (CL:LOOP WHILE
       (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
       (CL:SETQ SUPERARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
       (CL:SETQ SUBARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001)) INDEX-001))
       (CL:WHEN
        (CL:NOT
         (CL:AND (CL:NOT (NULL-INSTANCE? SUBARG))
          (BIND-ARGUMENT-TO-VALUE? SUPERARG (VALUE-OF SUBARG) CL:NIL)))
        (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
    (CL:WHEN TEST-VALUE-000
     (CL:SETQ TEST-VALUE-000
      (CL:= (LENGTH (%ARGUMENTS REFERENCEPROPOSITION))
       (LENGTH (%ARGUMENTS SUBPROPOSITION)))))
    (CL:SETQ SUCCESS? TEST-VALUE-000))
   (CL:WHEN (CL:NOT SUCCESS?)
    (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD (CL:1+ UBSTACKOFFSET)))
   SUCCESS?))

;;; (DEFUN (ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN ARGUMENTS-EQUAL-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET*
     ((SUPERARG NULL) (VECTOR-000 (%ARGUMENTS REFERENCEPROPOSITION))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (SUBARG NULL)
      (VECTOR-001 (%ARGUMENTS SUBPROPOSITION)) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
      (CL:SETQ SUPERARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
      (CL:SETQ SUBARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001)) INDEX-001))
      (CL:WHEN (CL:NOT (EQL? (VALUE-OF SUPERARG) (VALUE-OF SUBARG)))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
    (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000
     (CL:= (LENGTH (%ARGUMENTS REFERENCEPROPOSITION))
      (LENGTH (%ARGUMENTS SUBPROPOSITION)))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (ARGUMENTS-MATCH-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN ARGUMENTS-MATCH-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:IF (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
   (ARGUMENTS-UNIFY-WITH-ARGUMENTS? SUBPROPOSITION REFERENCEPROPOSITION)
   (ARGUMENTS-EQUAL-ARGUMENTS? SUBPROPOSITION REFERENCEPROPOSITION)))

;;; (DEFUN (PREFIX-ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN PREFIX-ARGUMENTS-EQUAL-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET*
     ((SUPERARG NULL) (VECTOR-000 (%ARGUMENTS REFERENCEPROPOSITION))
      (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (SUBARG NULL)
      (VECTOR-001 (%ARGUMENTS SUBPROPOSITION)) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)))
     (CL:DECLARE
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
     (CL:LOOP WHILE
      (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
      (CL:SETQ SUPERARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
      (CL:SETQ SUBARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001)) INDEX-001))
      (CL:WHEN (CL:NOT (EQL? (VALUE-OF SUPERARG) (VALUE-OF SUBARG)))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
    (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (ALL-MATCHING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-MATCHING-PROPOSITIONS (SELF)
  (CL:LET* ((BACKLINKEDARGUMENT NULL) (NOMATCHINGPROPOSITIONS? CL:NIL))
   (CL:MULTIPLE-VALUE-SETQ (BACKLINKEDARGUMENT NOMATCHINGPROPOSITIONS?)
    (SELECT-ARGUMENT-WITH-BACKLINKS SELF))
   (CL:WHEN NOMATCHINGPROPOSITIONS?
    (CL:RETURN-FROM ALL-MATCHING-PROPOSITIONS EMPTY-PROPOSITIONS-ITERATOR))
   (CL:WHEN (CL:EQ BACKLINKEDARGUMENT NULL)
    (CL:WHEN *CYC-KLUDGES-ENABLED?*
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:LET* ((FOUND?-000 CL:NIL))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:WHEN (CL:NOT (CL:EQ (ARGUMENT-BOUND-TO ARG) NULL))
          (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
       (CL:SETQ TEST-VALUE-000 FOUND?-000))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ TEST-VALUE-000
        (>
         (DYNAMICALLY-ESTIMATE-EXTENSION-SIZE
          (GET-DESCRIPTION (%OPERATOR SELF)))
         500)))
      (CL:WHEN TEST-VALUE-000
       (CL:RETURN-FROM ALL-MATCHING-PROPOSITIONS
        EMPTY-PROPOSITIONS-ITERATOR))))
    (CL:RETURN-FROM ALL-MATCHING-PROPOSITIONS
     (ALL-MATCHING-EXTENSION-MEMBERS SELF CL:T)))
   (CL:LET* ((PATTERNARGS NIL) (BINDING NULL))
    (CL:LET*
     ((ARG NULL) (VECTOR-001 (%ARGUMENTS SELF)) (INDEX-001 0)
      (LENGTH-001 (LENGTH VECTOR-001)) (COLLECT-000 NULL))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
     (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001)) INDEX-001))
      (CL:SETQ BINDING (ARGUMENT-BOUND-TO ARG))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ BINDING NULL))
        (ISA? BINDING SGT-SPECIALIZE-LOGIC-PROPOSITION)
        (CL:NOT (ALL-ARGUMENTS-BOUND? BINDING)))
       (CL:SETQ BINDING NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS (VALUE-OF BINDING) NIL))
        (CL:IF (CL:EQ PATTERNARGS NIL) (CL:SETQ PATTERNARGS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST PATTERNARGS COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS (VALUE-OF BINDING) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
    (CL:IF (CL:EQ (%%REST PATTERNARGS) NIL)
     (ALL-TRUE-DEPENDENT-PROPOSITIONS BACKLINKEDARGUMENT (%OPERATOR SELF)
      CL:T)
     (CL:LET*
      ((PATTERN
        (CONS KWD-SPECIALIZE-RELATION
         (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL)
          (CONS (%OPERATOR SELF) PATTERNARGS)))))
      (CL:LET* ((SELF-000 (NEW-SPECIALIZING-PROPOSITIONS-ITERATOR)))
       (CL:SETF (%SELECTION-PATTERN SELF-000) PATTERN)
       (CL:SETF (%PROPOSITION-CURSOR SELF-000)
        (ALLOCATE-ITERATOR (SELECT-PROPOSITIONS PATTERN)))
       (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))))))

;;; (DEFUN (ALL-PROPOSITIONS-MATCHING-ARGUMENTS (CONS OF PROPOSITION)) ...)

(CL:DEFUN ALL-PROPOSITIONS-MATCHING-ARGUMENTS (ARGUMENTS RELATION SPECIALIZE?)
  (CL:LET*
   ((BACKLINKEDINSTANCE (SELECT-INSTANCE-WITH-BACKLINKS ARGUMENTS RELATION)))
   (CL:WHEN (CL:EQ BACKLINKEDINSTANCE NULL)
    (CL:RETURN-FROM ALL-PROPOSITIONS-MATCHING-ARGUMENTS NIL))
   (CL:LET* ((VALUE-000 NIL))
    (CL:LET*
     ((PROP NULL)
      (ITER-000
       (ALL-TRUE-DEPENDENT-PROPOSITIONS BACKLINKEDINSTANCE RELATION
        SPECIALIZE?))
      (COLLECT-000 NULL))
     (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET* ((A1 NULL) (ITER-001 ARGUMENTS) (I NULL-INTEGER) (ITER-002 0))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ A1 (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
         (CL:WHEN
          (CL:NOT
           (EQL? (VALUE-OF A1)
            (VALUE-OF
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP)))
              I))))
          (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
         (CL:SETQ ITER-001 (%%REST ITER-001))
         (CL:SETQ ITER-002 (CL:1+ ITER-002))))
       (CL:WHEN ALWAYS?-000
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
          (CL:IF (CL:EQ VALUE-000 NIL) (CL:SETQ VALUE-000 COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST VALUE-000 COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))))
    (CL:LET* ((VALUE-001 VALUE-000)) VALUE-001))))

;;; (DEFUN (ALL-DEFINING-PROPOSITIONS (CONS OF PROPOSITION)) ...)

(CL:DEFUN ALL-DEFINING-PROPOSITIONS (OUTPUTARGUMENT RELATION SPECIALIZE?)
  (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:LET* ((RESULT NIL) (OUTPUTARGUMENTVALUE (VALUE-OF OUTPUTARGUMENT)))
    (CL:LET*
     ((PROP NULL)
      (ITER-000
       (ALL-TRUE-DEPENDENT-PROPOSITIONS OUTPUTARGUMENTVALUE RELATION
        SPECIALIZE?))
      (COLLECT-000 NULL))
     (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
      (CL:WHEN
       (CL:AND (CL:EQ (%KIND PROP) KWD-SPECIALIZE-FUNCTION)
        (EQL?
         (VALUE-OF
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP)))
           (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS PROP))))))
         OUTPUTARGUMENTVALUE))
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
         (CL:IF (CL:EQ RESULT NIL) (CL:SETQ RESULT COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST RESULT COLLECT-000)))
        (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
    RESULT)))

;;; (DEFUN (HELP-MEMOIZE-TEST-PROPERTY? BOOLEAN) ...)

(CL:DEFUN HELP-MEMOIZE-TEST-PROPERTY? (SELF RELATION)
  (CL:LET*
   ((*REVERSEPOLARITY?* CL:NIL) (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:IF
    (CL:AND (ISA? SELF SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT)
     (CL:EQ (VARIABLE-VALUE-INVERSE SELF) NIL))
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((P NULL)
       (ITER-000
        (ALLOCATE-ITERATOR
         (UNFILTERED-DEPENDENT-PROPOSITIONS SELF RELATION))))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
       (CL:WHEN
        (CL:AND (CL:EQ (%OPERATOR P) RELATION)
         (CL:AND (CL:NOT (DELETED? P))
          (CL:IF *REVERSEPOLARITY?* (FALSE? P)
           (CL:OR (TRUE? P) (FUNCTION-WITH-DEFINED-VALUE? P)))))
        (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))))
     (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000))
    (NEXT? (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF RELATION CL:NIL)))))

;;; (DEFUN (TEST-PROPERTY? BOOLEAN) ...)

(CL:DEFUN TEST-PROPERTY? (SELF RELATION)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE SGT-SPECIALIZE-LOGIC-F-TEST-PROPERTY?-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALIZE-LOGIC-F-TEST-PROPERTY?-MEMO-TABLE-000
      "(:MAX-VALUES 500 :TIMESTAMPS (:KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE-VALUE
       SGT-SPECIALIZE-LOGIC-F-TEST-PROPERTY?-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF RELATION *CONTEXT*
      MEMOIZED-NULL-VALUE 6))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (CL:IF (HELP-MEMOIZE-TEST-PROPERTY? SELF RELATION) TRUE-WRAPPER
       FALSE-WRAPPER))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000))))

;;; (DEFUN (HELP-MEMOIZE-TEST-ISA? BOOLEAN) ...)

(CL:DEFUN HELP-MEMOIZE-TEST-ISA? (MEMBER TYPE)
  (CL:LET*
   ((*REVERSEPOLARITY?* CL:NIL) (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:LET* ((FOUND?-000 CL:NIL))
    (CL:LET*
     ((PROP NULL) (ITER-000 (ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS MEMBER)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
      (CL:WHEN (RELATIONREF-SPECIALIZES-RELATIONREF? (%OPERATOR PROP) TYPE)
       (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))))
    (CL:LET* ((VALUE-000 FOUND?-000)) VALUE-000))))

;;; (DEFUN (TEST-ISA? BOOLEAN) ...)

(CL:DEFUN TEST-ISA? (MEMBER TYPE)
  (CL:COND ((CL:EQ TYPE SGT-SPECIALIZE-STELLA-THING) CL:T)
   ((CL:OR (CL:EQ TYPE SGT-SPECIALIZE-PL-KERNEL-KB-CLASS)
     (CL:EQ TYPE SGT-SPECIALIZE-PL-KERNEL-KB-RELATION)
     (CL:EQ TYPE SGT-SPECIALIZE-PL-KERNEL-KB-FUNCTION)
     (CL:EQ TYPE SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTION)
     (CL:EQ TYPE SGT-SPECIALIZE-PL-KERNEL-KB-SET))
    (CL:LET*
     ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
      (MEMOIZED-VALUE-000 NULL))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETQ MEMO-TABLE-000
       (%SURROGATE-VALUE SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-000))
      (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
       (INITIALIZE-MEMOIZATION-TABLE
        SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-000
        "(:MAX-VALUES 1000 :TIMESTAMPS (:META-KB-UPDATE))")
       (CL:SETQ MEMO-TABLE-000
        (%SURROGATE-VALUE SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-000)))
      (CL:SETQ MEMOIZED-ENTRY-000
       (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 MEMBER TYPE *CONTEXT*
        MEMOIZED-NULL-VALUE 6))
      (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
     (CL:COND
      ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
       (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
        (CL:SETQ MEMOIZED-VALUE-000 NULL)))
      (CL:T
       (CL:SETQ MEMOIZED-VALUE-000
        (CL:IF (HELP-MEMOIZE-TEST-ISA? MEMBER TYPE) TRUE-WRAPPER
         FALSE-WRAPPER))
       (CL:WHEN *MEMOIZATION-ENABLED?*
        (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
         (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
          MEMOIZED-VALUE-000)))))
     (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000))))
   (CL:T
    (CL:LET*
     ((MEMO-TABLE-001 NULL) (MEMOIZED-ENTRY-001 NULL)
      (MEMOIZED-VALUE-001 NULL))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETQ MEMO-TABLE-001
       (%SURROGATE-VALUE SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-001))
      (CL:WHEN (CL:EQ MEMO-TABLE-001 NULL)
       (INITIALIZE-MEMOIZATION-TABLE
        SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-001
        "(:MAX-VALUES 1000 :TIMESTAMPS (:KB-UPDATE))")
       (CL:SETQ MEMO-TABLE-001
        (%SURROGATE-VALUE SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-001)))
      (CL:SETQ MEMOIZED-ENTRY-001
       (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-001 MEMBER TYPE *CONTEXT*
        MEMOIZED-NULL-VALUE 6))
      (CL:SETQ MEMOIZED-VALUE-001 (%%VALUE MEMOIZED-ENTRY-001)))
     (CL:COND
      ((CL:NOT (CL:EQ MEMOIZED-VALUE-001 NULL))
       (CL:WHEN (CL:EQ MEMOIZED-VALUE-001 MEMOIZED-NULL-VALUE)
        (CL:SETQ MEMOIZED-VALUE-001 NULL)))
      (CL:T
       (CL:SETQ MEMOIZED-VALUE-001
        (CL:IF (HELP-MEMOIZE-TEST-ISA? MEMBER TYPE) TRUE-WRAPPER
         FALSE-WRAPPER))
       (CL:WHEN *MEMOIZATION-ENABLED?*
        (CL:SETF (%%VALUE MEMOIZED-ENTRY-001)
         (CL:IF (CL:EQ MEMOIZED-VALUE-001 NULL) MEMOIZED-NULL-VALUE
          MEMOIZED-VALUE-001)))))
     (CL:LET* ((VALUE-001 MEMOIZED-VALUE-001))
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-001))))))

;;; (DEFUN (HELP-MEMOIZE-ACCESS-BINARY-VALUE OBJECT) ...)

(CL:DEFUN HELP-MEMOIZE-ACCESS-BINARY-VALUE (SELF RELATION)
  (CL:LET*
   ((*REVERSEPOLARITY?* CL:NIL) (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:LET*
    ((RESULT NULL)
     (ITERATOR (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF RELATION CL:NIL))
     (PROPOSITION NULL))
    (CL:LOOP WHILE (NEXT? ITERATOR) DO (CL:SETQ PROPOSITION (%VALUE ITERATOR))
     (CL:WHEN
      (EQL?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 0)
       SELF)
      (CL:SETQ RESULT
       (VALUE-OF
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 1)))
      (CL:RETURN-FROM HELP-MEMOIZE-ACCESS-BINARY-VALUE RESULT)))
    NULL)))

;;; (DEFUN (ACCESS-BINARY-VALUE OBJECT) ...)

(CL:DEFUN ACCESS-BINARY-VALUE (SELF RELATION)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-SPECIALIZE-LOGIC-F-ACCESS-BINARY-VALUE-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALIZE-LOGIC-F-ACCESS-BINARY-VALUE-MEMO-TABLE-000
      "(:MAX-VALUES 1000 :TIMESTAMPS (:KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE-VALUE
       SGT-SPECIALIZE-LOGIC-F-ACCESS-BINARY-VALUE-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF RELATION *CONTEXT*
      MEMOIZED-NULL-VALUE 6))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (HELP-MEMOIZE-ACCESS-BINARY-VALUE SELF RELATION))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000)) VALUE-000)))

;;; (DEFUN (TEST-COLLECTIONOF-MEMBER-OF? BOOLEAN) ...)

(CL:DEFUN TEST-COLLECTIONOF-MEMBER-OF? (MEMBER TYPE)
  (CL:LET*
   ((*REVERSEPOLARITY?* CL:NIL) (*CONTEXT* (GET-PROPERTY-TEST-CONTEXT)))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?* *CONTEXT*))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALL-TRUE-DEPENDENT-PROPOSITIONS MEMBER
       SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTIONOF CL:T)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (DELETED? P))
       (CL:IF *REVERSEPOLARITY?* (FALSE? P)
        (CL:OR (TRUE? P) (FUNCTION-WITH-DEFINED-VALUE? P))))
      (CL:LET* ((COLLECTION (LAST (%ARGUMENTS P))))
       (CL:WHEN
        (CL:AND (CL:NOT (EQL? MEMBER COLLECTION))
         (COLLECTION-IMPLIES-COLLECTION? COLLECTION
          (SURROGATE-TO-DESCRIPTION TYPE)))
        (CL:RETURN-FROM TEST-COLLECTIONOF-MEMBER-OF? CL:T))))))
   CL:NIL))

;;; (DEFCLASS TRANSITIVE-CLOSURE-ITERATOR ...)

(CL:DEFCLASS TRANSITIVE-CLOSURE-ITERATOR (ITERATOR)
  ((ALLOCATE-ADJACENCY-ITERATOR-FUNCTION :ALLOCATION :INSTANCE :ACCESSOR
    %ALLOCATE-ADJACENCY-ITERATOR-FUNCTION)
   (FILTER? :ALLOCATION :INSTANCE :ACCESSOR %FILTER?)
   (ADJACENCY-ITERATOR-STACK :ALLOCATION :INSTANCE :ACCESSOR
    %ADJACENCY-ITERATOR-STACK)
   (BEEN-THERE-LIST :ALLOCATION :INSTANCE :ACCESSOR %BEEN-THERE-LIST))
  (:DOCUMENTATION "Iterator that visits all nodes reachable using an
embedded adjacency function."))

(CL:DEFUN NEW-TRANSITIVE-CLOSURE-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE TRANSITIVE-CLOSURE-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%BEEN-THERE-LIST SELF) NULL)
   (CL:SETF (%ADJACENCY-ITERATOR-STACK SELF) NIL)
   (CL:SETF (%FILTER? SELF) NULL)
   (CL:SETF (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF TRANSITIVE-CLOSURE-ITERATOR))
  SGT-SPECIALIZE-LOGIC-TRANSITIVE-CLOSURE-ITERATOR)

(CL:DEFUN ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION)
    (CL:IF SETVALUE?
     (CL:SETF (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION SELF)
      (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FUNCTION-CODE (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-FILTER?)
    (CL:IF SETVALUE? (CL:SETF (%FILTER? SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FUNCTION-CODE (%FILTER? SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-ADJACENCY-ITERATOR-STACK)
    (CL:IF SETVALUE? (CL:SETF (%ADJACENCY-ITERATOR-STACK SELF) VALUE)
     (CL:SETQ VALUE (%ADJACENCY-ITERATOR-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-BEEN-THERE-LIST)
    (CL:IF SETVALUE? (CL:SETF (%BEEN-THERE-LIST SELF) VALUE)
     (CL:SETQ VALUE (%BEEN-THERE-LIST SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (TRANSITIVE-CLOSURE-ITERATOR.NEXT? BOOLEAN) ...)

(CL:DEFUN TRANSITIVE-CLOSURE-ITERATOR.NEXT? (SELF)
  (CL:LET*
   ((NODE (%VALUE SELF))
    (ADJACENCYITERATOR
     (CL:FUNCALL (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION SELF) NODE)))
   (CL:IF (CL:NOT (CL:EQ ADJACENCYITERATOR NULL))
    (CL:SETF (%ADJACENCY-ITERATOR-STACK SELF)
     (CONS ADJACENCYITERATOR (%ADJACENCY-ITERATOR-STACK SELF)))
    (CL:PROGN
     (CL:SETQ ADJACENCYITERATOR (%%VALUE (%ADJACENCY-ITERATOR-STACK SELF)))
     (CL:WHEN (CL:EQ ADJACENCYITERATOR NULL)
      (CL:RETURN-FROM TRANSITIVE-CLOSURE-ITERATOR.NEXT? CL:NIL))))
   (CL:LOOP
    (CL:LOOP WHILE (CL:NOT (NEXT? ADJACENCYITERATOR)) DO
     (CL:SETF (%ADJACENCY-ITERATOR-STACK SELF)
      (%%REST (%ADJACENCY-ITERATOR-STACK SELF)))
     (CL:SETQ ADJACENCYITERATOR (%%VALUE (%ADJACENCY-ITERATOR-STACK SELF)))
     (CL:WHEN (CL:EQ ADJACENCYITERATOR NULL)
      (CL:RETURN-FROM TRANSITIVE-CLOSURE-ITERATOR.NEXT? CL:NIL)))
    (CL:SETQ NODE (%VALUE ADJACENCYITERATOR))
    (CL:WHEN
     (CL:AND (CL:NOT (MEMBER? (%BEEN-THERE-LIST SELF) NODE))
      (CL:OR (CL:EQ (%FILTER? SELF) NULL) (CL:FUNCALL (%FILTER? SELF) NODE)))
     (CL:SETF (%BEEN-THERE-LIST SELF) (CONS NODE (%BEEN-THERE-LIST SELF)))
     (CL:SETF (%VALUE SELF) NODE)
     (CL:RETURN-FROM TRANSITIVE-CLOSURE-ITERATOR.NEXT? CL:T)))))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF TRANSITIVE-CLOSURE-ITERATOR))
  (TRANSITIVE-CLOSURE-ITERATOR.NEXT? SELF))

;;; (DEFUN (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR ITERATOR) ...)

(CL:DEFUN ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR (STARTNODE ALLOCATEADJACENCYITERATOR FILTERFUNCTION)
  "Return an iterator that generates the transitive
closure of applying iterators generated by 'allocateAdjacencyIterator'
to 'startNode'.  If 'filterFunction' is non-null, that function is applied
as a filter to each node generated (nodes filtered out still generate
descendants, but they don't get returned)."
  (CL:LET* ((ITERATOR (NEW-TRANSITIVE-CLOSURE-ITERATOR)))
   (CL:SETF (%VALUE ITERATOR) STARTNODE)
   (CL:SETF (%BEEN-THERE-LIST ITERATOR) NIL)
   (CL:SETF (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION ITERATOR)
    ALLOCATEADJACENCYITERATOR)
   (CL:SETF (%FILTER? ITERATOR) FILTERFUNCTION) ITERATOR))

;;; (DEFCLASS SUPPORTED-CLOSURE-ITERATOR ...)

(CL:DEFCLASS SUPPORTED-CLOSURE-ITERATOR (TRANSITIVE-CLOSURE-ITERATOR)
  ()
  (:DOCUMENTATION
   "Iterator that visits all objects reachable via true link propositions
generated by an embedded link proposition iterator.  Each new object reached
is represented as an `(<object> <truth-value>)' pair, where <truth-value> is
the cumulative truth value of the links followed from the start to reach it.
The embedded `allocate-adjacency-iterator-function' needs to be able to take
an `(<object> <truth-value>)' pair as an argument which is different than the
requirement for TRANSITIVE-CLOSURE-ITERATOR's."))

(CL:DEFUN NEW-SUPPORTED-CLOSURE-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SUPPORTED-CLOSURE-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%BEEN-THERE-LIST SELF) NULL) (CL:SETF (%FILTER? SELF) NULL)
   (CL:SETF (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION SELF) NULL)
   (CL:SETF (%ADJACENCY-ITERATOR-STACK SELF) NIL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SUPPORTED-CLOSURE-ITERATOR))
  SGT-SPECIALIZE-LOGIC-SUPPORTED-CLOSURE-ITERATOR)

(CL:DEFUN ACCESS-SUPPORTED-CLOSURE-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-ADJACENCY-ITERATOR-STACK)
    (CL:IF SETVALUE? (CL:SETF (%ADJACENCY-ITERATOR-STACK SELF) VALUE)
     (CL:SETQ VALUE (%ADJACENCY-ITERATOR-STACK SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (ALLOCATE-SUPPORTED-CLOSURE-ITERATOR SUPPORTED-CLOSURE-ITERATOR) ...)

(CL:DEFUN ALLOCATE-SUPPORTED-CLOSURE-ITERATOR (STARTNODE ALLOCATEADJACENCYITERATOR FILTERFUNCTION)
  "Similar to `allocate-transitive-closure-iterator' (which see),
but return a SUPPORTED-CLOSURE-ITERATOR instead."
  (CL:LET* ((ITERATOR (NEW-SUPPORTED-CLOSURE-ITERATOR)))
   (CL:SETF (%VALUE ITERATOR) STARTNODE)
   (CL:SETF (%BEEN-THERE-LIST ITERATOR) NIL)
   (CL:SETF (%ALLOCATE-ADJACENCY-ITERATOR-FUNCTION ITERATOR)
    ALLOCATEADJACENCYITERATOR)
   (CL:SETF (%FILTER? ITERATOR) FILTERFUNCTION) ITERATOR))

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF SUPPORTED-CLOSURE-ITERATOR))
  (CL:COND
   ((TRANSITIVE-CLOSURE-ITERATOR.NEXT? SELF)
    (CL:SETF (%VALUE SELF)
     (CONS (%VALUE SELF)
      (CONS (%TRUTH-VALUE (%%VALUE (%ADJACENCY-ITERATOR-STACK SELF))) NIL)))
    CL:T)
   (CL:T CL:NIL)))

;;; (DEFCLASS DIRECTLY-LINKED-OBJECTS-ITERATOR ...)

(CL:DEFCLASS DIRECTLY-LINKED-OBJECTS-ITERATOR (TRUE-PROPOSITIONS-ITERATOR)
  ((INVERSE? :ALLOCATION :INSTANCE :ACCESSOR %INVERSE?)
   (ROOT-TRUTH-VALUE :ALLOCATION :INSTANCE :ACCESSOR %ROOT-TRUTH-VALUE)))

(CL:DEFUN NEW-DIRECTLY-LINKED-OBJECTS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE DIRECTLY-LINKED-OBJECTS-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%EQUIVALENTS-STACK SELF) NULL)
   (CL:SETF (%PROPOSITION-CURSOR SELF) NULL)
   (CL:SETF (%SELECTION-PATTERN SELF) NULL) (CL:SETF (%TRUTH-VALUE SELF) NULL)
   (CL:SETF (%ROOT-TRUTH-VALUE SELF) TRUE-TRUTH-VALUE)
   (CL:SETF (%INVERSE? SELF) CL:NIL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF DIRECTLY-LINKED-OBJECTS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-DIRECTLY-LINKED-OBJECTS-ITERATOR)

(CL:DEFUN ACCESS-DIRECTLY-LINKED-OBJECTS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-INVERSE?)
    (CL:IF SETVALUE?
     (CL:SETF (%INVERSE? SELF) (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE (CL:IF (%INVERSE? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-ROOT-TRUTH-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%ROOT-TRUTH-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%ROOT-TRUTH-VALUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF DIRECTLY-LINKED-OBJECTS-ITERATOR))
  (CL:LET* ((PROPOSITION NULL))
   (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
    (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
    (CL:WHEN (TRUE-PROPOSITIONS-ITERATOR.NEXT? SELF)
     (CL:SETQ PROPOSITION (%VALUE SELF))
     (CL:SETF (%VALUE SELF)
      (VALUE-OF
       (CL:IF (%INVERSE? SELF)
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 0)
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 1))))
     (CL:SETF (%TRUTH-VALUE SELF)
      (CONJOIN-TRUTH-VALUES (%TRUTH-VALUE SELF) (%ROOT-TRUTH-VALUE SELF)))
     (CL:RETURN-FROM NEXT? CL:T))
    (CL:SETF (%VALUE SELF) NULL) CL:NIL)))

;;; (DEFUN (ALL-DIRECTLY-LINKED-OBJECTS ITERATOR) ...)

(CL:DEFUN ALL-DIRECTLY-LINKED-OBJECTS (SELF RELATION INVERSE?)
  (CL:LET*
   ((PATTERN
     (CL:IF INVERSE? (MAKE-RELATION-PATTERN-2 RELATION NULL (VALUE-OF SELF))
      (MAKE-RELATION-PATTERN-2 RELATION (VALUE-OF SELF) NULL)))
    (INDEX (SELECT-PROPOSITIONS PATTERN)))
   (CL:WHEN (EMPTY-PROPOSITIONS-INDEX? INDEX SELF CL:NIL)
    (CL:RETURN-FROM ALL-DIRECTLY-LINKED-OBJECTS EMPTY-PROPOSITIONS-ITERATOR))
   (CL:LET* ((SELF-000 (NEW-DIRECTLY-LINKED-OBJECTS-ITERATOR)))
    (CL:SETF (%SELECTION-PATTERN SELF-000) PATTERN)
    (CL:SETF (%PROPOSITION-CURSOR SELF-000) (ALLOCATE-ITERATOR INDEX))
    (CL:SETF (%INVERSE? SELF-000) INVERSE?)
    (CL:LET* ((VALUE-000 SELF-000)) VALUE-000))))

;;; (DEFUN (ALL-DIRECT-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUPERCOLLECTIONS (SELF PERFORMFILTERING?)
  (CL:WHEN (ISA? SELF SGT-SPECIALIZE-LOGIC-DESCRIPTION)
   (DERIVE-DEFERRED-SATELLITE-RULES SELF))
  (CL:LET*
   ((DIRECTLYLINKEDOBJECTS
     (ALL-DIRECTLY-LINKED-OBJECTS SELF SGT-SPECIALIZE-PL-KERNEL-KB-SUBSET-OF
      *REVERSEPOLARITY?*)))
   (CL:WHEN (CL:NOT PERFORMFILTERING?)
    (CL:RETURN-FROM ALL-DIRECT-SUPERCOLLECTIONS DIRECTLYLINKEDOBJECTS))
   (CL:LET*
    ((DIRECTSUPERS NIL) (EQUIVALENTS (ALL-EQUIVALENT-COLLECTIONS SELF CL:T)))
    (CL:IF (CL:NOT (CL:EQ (%%REST EQUIVALENTS) NIL))
     (CL:LET* ((E NULL) (ITER-000 EQUIVALENTS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ E (%%VALUE ITER-000))
       (CL:LET*
        ((PARENT NULL) (ITER-001 (ALL-DIRECT-SUPERCOLLECTIONS E CL:NIL)))
        (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ PARENT (%VALUE ITER-001))
         (CL:WHEN
          (CL:AND (CL:NOT (MEMBER? EQUIVALENTS PARENT))
           (CL:NOT (MEMBER? DIRECTSUPERS PARENT)))
          (CL:SETQ DIRECTSUPERS (CONS PARENT DIRECTSUPERS)))))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ DIRECTSUPERS (CONSIFY DIRECTLYLINKEDOBJECTS)))
    (ALLOCATE-ITERATOR (MOST-SPECIFIC-COLLECTIONS DIRECTSUPERS)))))

;;; (DEFUN (ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS (SELF)
  (ALL-DIRECT-SUPERCOLLECTIONS SELF CL:NIL))

;;; (DEFUN (ALL-DIRECT-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUBCOLLECTIONS (SELF PERFORMFILTERING?)
  (CL:WHEN (ISA? SELF SGT-SPECIALIZE-LOGIC-DESCRIPTION)
   (DERIVE-DEFERRED-SATELLITE-RULES SELF))
  (CL:LET*
   ((DIRECTLYLINKEDOBJECTS
     (ALL-DIRECTLY-LINKED-OBJECTS SELF SGT-SPECIALIZE-PL-KERNEL-KB-SUBSET-OF
      (CL:NOT *REVERSEPOLARITY?*))))
   (CL:WHEN (CL:NOT PERFORMFILTERING?)
    (CL:RETURN-FROM ALL-DIRECT-SUBCOLLECTIONS DIRECTLYLINKEDOBJECTS))
   (CL:LET*
    ((DIRECTSUBS NIL) (EQUIVALENTS (ALL-EQUIVALENT-COLLECTIONS SELF CL:T)))
    (CL:IF (CL:NOT (CL:EQ (%%REST EQUIVALENTS) NIL))
     (CL:LET* ((E NULL) (ITER-000 EQUIVALENTS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ E (%%VALUE ITER-000))
       (CL:LET* ((CHILD NULL) (ITER-001 (ALL-DIRECT-SUBCOLLECTIONS E CL:NIL)))
        (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ CHILD (%VALUE ITER-001))
         (CL:WHEN
          (CL:AND (CL:NOT (MEMBER? EQUIVALENTS CHILD))
           (CL:NOT (MEMBER? DIRECTSUBS CHILD)))
          (CL:SETQ DIRECTSUBS (CONS CHILD DIRECTSUBS)))))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ DIRECTSUBS (CONSIFY DIRECTLYLINKEDOBJECTS)))
    (ALLOCATE-ITERATOR (MOST-GENERAL-COLLECTIONS DIRECTSUBS)))))

;;; (DEFUN (ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS (SELF)
  (ALL-DIRECT-SUBCOLLECTIONS SELF CL:NIL))

;;; (DEFUN (ALL-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-SUPERCOLLECTIONS (SELF)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-SPECIALIZE-LOGIC-F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALIZE-LOGIC-F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000
      "(:MAX-VALUES 1000 :TIMESTAMPS (:META-KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE-VALUE
       SGT-SPECIALIZE-LOGIC-F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF *CONTEXT*
      (CL:IF *REVERSEPOLARITY?* TRUE-WRAPPER FALSE-WRAPPER)
      MEMOIZED-NULL-VALUE -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (NEW-MEMOIZABLE-ITERATOR
       (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR SELF
        (CL:FUNCTION ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS) NULL)))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 (CLONE-MEMOIZED-ITERATOR MEMOIZED-VALUE-000)))
    VALUE-000)))

;;; (DEFUN (ALL-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-SUBCOLLECTIONS (SELF)
  (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR SELF
   (CL:FUNCTION ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS) NULL))

;;; (DEFUN (ALL-ISA-COLLECTIONS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-ISA-COLLECTIONS (SELF)
  (CL:LET* ((COLLECTIONS NIL))
   (CL:LET*
    ((P NULL) (ITER-000 (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF NULL CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%KIND P) KWD-SPECIALIZE-ISA)
      (CL:SETQ COLLECTIONS
       (CONS (GET-DESCRIPTION (%OPERATOR P)) COLLECTIONS)))))
   (CL:LET*
    ((P NULL)
     (ITER-001
      (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF
       SGT-SPECIALIZE-PL-KERNEL-KB-MEMBER-OF CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ P (%VALUE ITER-001))
     (CL:SETQ COLLECTIONS
      (CONS (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 1)
       COLLECTIONS))))
   COLLECTIONS))

;;; (DEFUN (ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (CONS OF CONS)) ...)

(CL:DEFUN ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (SELF)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-SPECIALIZE-LOGIC-F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALIZE-LOGIC-F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000
      "(:MAX-VALUES 1000 :TIMESTAMPS (:META-KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE-VALUE
       SGT-SPECIALIZE-LOGIC-F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF
      (CL:IF (CL:NOT *DONTUSEDEFAULTKNOWLEDGE?*) TRUE-WRAPPER FALSE-WRAPPER)
      *CONTEXT* (CL:IF *REVERSEPOLARITY?* TRUE-WRAPPER FALSE-WRAPPER) -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS SELF))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000)) VALUE-000)))

;;; (DEFUN (ALL-DIRECTLY-LINKED-SUBCOLLECTIONS TRUE-PROPOSITIONS-ITERATOR) ...)

(CL:DEFUN ALL-DIRECTLY-LINKED-SUBCOLLECTIONS (SELF)
  (CL:LET* ((OBJECT NULL) (TRUTHVALUE NULL) (ITERATOR NULL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SGT-SPECIALIZE-STELLA-CONS)
      (CL:PROGN (CL:SETQ OBJECT (%%VALUE SELF))
       (CL:SETQ TRUTHVALUE (%%VALUE (%%REST SELF)))))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT)
      (CL:PROGN (CL:SETQ OBJECT SELF)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:WHEN (ISA? OBJECT SGT-SPECIALIZE-LOGIC-DESCRIPTION)
    (DERIVE-DEFERRED-SATELLITE-RULES OBJECT))
   (CL:SETQ ITERATOR
    (ALL-DIRECTLY-LINKED-OBJECTS OBJECT SGT-SPECIALIZE-PL-KERNEL-KB-SUBSET-OF
     (CL:NOT *REVERSEPOLARITY?*)))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ITERATOR)
      SGT-SPECIALIZE-LOGIC-DIRECTLY-LINKED-OBJECTS-ITERATOR)
     (CL:PROGN
      (CL:WHEN (CL:NOT (CL:EQ TRUTHVALUE NULL))
       (CL:SETF (%ROOT-TRUTH-VALUE ITERATOR) TRUTHVALUE))
      ITERATOR))
    (CL:T NULL))))

;;; (DEFUN (HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (CONS OF CONS)) ...)

(CL:DEFUN HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (SELF)
  (CL:LET*
   ((SUBCOLLECTIONS NIL)
    (CLOSUREITERATOR
     (ALLOCATE-SUPPORTED-CLOSURE-ITERATOR
      (CONS SELF (CONS TRUE-TRUTH-VALUE NIL))
      (CL:FUNCTION ALL-DIRECTLY-LINKED-SUBCOLLECTIONS) NULL)))
   (CL:LET* ((SUB NULL) (ITER-000 CLOSUREITERATOR) (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ SUB (%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (ISA? (%%VALUE SUB) SGT-SPECIALIZE-LOGIC-NAMED-DESCRIPTION)
       (CL:NOT (CL:EQ (%%VALUE SUB) SELF)))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS SUB NIL))
        (CL:IF (CL:EQ SUBCOLLECTIONS NIL) (CL:SETQ SUBCOLLECTIONS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST SUBCOLLECTIONS COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS SUB NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   SUBCOLLECTIONS))

;;; (DEFUN (VALUE-CLASHES-WITH-SKOLEM? BOOLEAN) ...)

(CL:DEFUN VALUE-CLASHES-WITH-SKOLEM? (SKOLEM VALUE)
  (CL:LET* ((TYPE (%SKOLEM-TYPE SKOLEM)))
   (CL:COND ((CL:EQ TYPE NULL) CL:NIL)
    ((CL:NOT
      (CL:OR
       (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
        (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
       (CHECK-STRICT-TYPE? VALUE TYPE CL:T)))
     CL:T)
    ((CL:AND (LITERAL-TYPE? TYPE)
      (LOGICAL-SUBTYPE-OF? TYPE SGT-SPECIALIZE-STELLA-NUMBER))
     (CL:NOT (|/PL-KERNEL-KB/SATISFIES-INTERVAL-BOUNDS?| SKOLEM VALUE)))
    (CL:T CL:NIL))))

;;; (DEFUN (CLASHES-WITH-FUNCTION-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN CLASHES-WITH-FUNCTION-PROPOSITION? (NEXTPROPOSITION REFERENCEPROPOSITION)
  (CL:LET* ((ALWAYS?-000 CL:T))
   (CL:LET*
    ((SUPERARG NULL) (ITER-000 (BUT-LAST (%ARGUMENTS REFERENCEPROPOSITION)))
     (SUBARG NULL) (ITER-001 (BUT-LAST (%ARGUMENTS NEXTPROPOSITION))))
    (CL:LOOP WHILE (CL:AND (NEXT? ITER-000) (NEXT? ITER-001)) DO
     (CL:SETQ SUPERARG (%VALUE ITER-000)) (CL:SETQ SUBARG (%VALUE ITER-001))
     (CL:WHEN (CL:NOT (EQL? (ARGUMENT-BOUND-TO SUPERARG) (VALUE-OF SUBARG)))
      (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
   (CL:WHEN ALWAYS?-000
    (CL:LET*
     ((LASTSUPERVALUE
       (ARGUMENT-BOUND-TO (LAST (%ARGUMENTS REFERENCEPROPOSITION))))
      (LASTSUBVALUE (VALUE-OF (LAST (%ARGUMENTS NEXTPROPOSITION)))))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ LASTSUPERVALUE NULL))
       (CL:NOT (CL:EQ LASTSUBVALUE NULL)))
      (CL:IF (ISA? LASTSUBVALUE SGT-SPECIALIZE-LOGIC-SKOLEM)
       (CL:IF (ISA? LASTSUPERVALUE SGT-SPECIALIZE-LOGIC-SKOLEM)
        (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION? CL:NIL)
        (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION?
         (VALUE-CLASHES-WITH-SKOLEM? LASTSUBVALUE LASTSUPERVALUE)))
       (CL:IF (ISA? LASTSUPERVALUE SGT-SPECIALIZE-LOGIC-SKOLEM)
        (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION?
         (VALUE-CLASHES-WITH-SKOLEM? LASTSUPERVALUE LASTSUBVALUE))
        (CL:RETURN-FROM CLASHES-WITH-FUNCTION-PROPOSITION?
         (CL:NOT (EQL? LASTSUPERVALUE LASTSUBVALUE)))))))))
  CL:NIL)

;;; (DEFCLASS CLASHING-PROPOSITIONS-ITERATOR ...)

(CL:DEFCLASS CLASHING-PROPOSITIONS-ITERATOR (TRUE-PROPOSITIONS-ITERATOR)
  ((REFERENCE-PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR
    %REFERENCE-PROPOSITION)))

(CL:DEFUN NEW-CLASHING-PROPOSITIONS-ITERATOR ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CLASHING-PROPOSITIONS-ITERATOR)))
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%EQUIVALENTS-STACK SELF) NULL)
   (CL:SETF (%PROPOSITION-CURSOR SELF) NULL)
   (CL:SETF (%SELECTION-PATTERN SELF) NULL) (CL:SETF (%TRUTH-VALUE SELF) NULL)
   (CL:SETF (%REFERENCE-PROPOSITION SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CLASHING-PROPOSITIONS-ITERATOR))
  SGT-SPECIALIZE-LOGIC-CLASHING-PROPOSITIONS-ITERATOR)

(CL:DEFUN ACCESS-CLASHING-PROPOSITIONS-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALIZE-LOGIC-REFERENCE-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%REFERENCE-PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%REFERENCE-PROPOSITION SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((SELF CLASHING-PROPOSITIONS-ITERATOR))
  (CL:LET* ((REFERENCEPROP (%REFERENCE-PROPOSITION SELF)))
   (CL:LOOP WHILE (TRUE-PROPOSITIONS-ITERATOR.NEXT? SELF) DO
    (CL:WHEN (CLASHES-WITH-FUNCTION-PROPOSITION? (%VALUE SELF) REFERENCEPROP)
     (CL:RETURN-FROM NEXT? CL:T)))
   (CL:SETF (%VALUE SELF) NULL) CL:NIL))

;;; (DEFUN (ALL-CLASHING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-CLASHING-PROPOSITIONS (SELF)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS SELF)) (LASTARG (LAST ARGUMENTS))
    (BACKLINKEDARG NULL))
   (LAST-SETTER ARGUMENTS NULL)
   (CL:SETQ BACKLINKEDARG (SELECT-ARGUMENT-WITH-BACKLINKS SELF))
   (LAST-SETTER ARGUMENTS LASTARG)
   (CL:WHEN (CL:EQ BACKLINKEDARG NULL)
    (CL:RETURN-FROM ALL-CLASHING-PROPOSITIONS EMPTY-PROPOSITIONS-ITERATOR))
   (CL:LET*
    ((PATTERN
      (CONS KWD-SPECIALIZE-RELATION
       (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL)
        (CONS (%OPERATOR SELF) (CONS (VALUE-OF BACKLINKEDARG) NIL)))))
     (INDEX (SELECT-PROPOSITIONS PATTERN)))
    (CL:WHEN (EMPTY-PROPOSITIONS-INDEX? INDEX BACKLINKEDARG CL:NIL)
     (CL:RETURN-FROM ALL-CLASHING-PROPOSITIONS EMPTY-PROPOSITIONS-ITERATOR))
    (CL:LET* ((SELF-000 (NEW-CLASHING-PROPOSITIONS-ITERATOR)))
     (CL:SETF (%SELECTION-PATTERN SELF-000) PATTERN)
     (CL:SETF (%PROPOSITION-CURSOR SELF-000) (ALLOCATE-ITERATOR INDEX))
     (CL:SETF (%REFERENCE-PROPOSITION SELF-000) SELF)
     (CL:LET* ((VALUE-000 SELF-000)) VALUE-000)))))

;;; (DEFGLOBAL *IMPLICATION-SUBSUMPTION-GRAPH* ...)

(CL:DEFVAR *IMPLICATION-SUBSUMPTION-GRAPH* NULL)

;;; (DEFUN (RELATIONS-WITH-DESCRIPTIONS (LIST OF RELATION)) ...)

(CL:DEFUN RELATIONS-WITH-DESCRIPTIONS ()
  (CL:LET* ((RESULT (NEW-LIST)))
   (CL:LET*
    ((CLASS NULL) (ITER-000 (ALL-CLASSES NULL CL:NIL)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ CLASS (%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CLASS)
         SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL)
        NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS CLASS NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST RESULT) NIL)
         (CL:SETF (%THE-CONS-LIST RESULT) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST RESULT) COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS CLASS NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
   (CL:LET*
    ((SLOT NULL) (ITER-001 (ALL-SLOTS NULL CL:NIL)) (COLLECT-001 NULL))
    (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ SLOT (%VALUE ITER-001))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SLOT)
         SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL)
        NULL))
      (CL:IF (CL:EQ COLLECT-001 NULL)
       (CL:PROGN (CL:SETQ COLLECT-001 (CONS SLOT NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST RESULT) NIL)
         (CL:SETF (%THE-CONS-LIST RESULT) COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST RESULT) COLLECT-001)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS SLOT NIL))
        (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))))
   RESULT))

;;; (DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ...)

(CL:DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ()
  (CL:LET* ((RELATIONSWITHDESCRIPTIONS (RELATIONS-WITH-DESCRIPTIONS)))
   (CL:LET* ((R NULL) (ITER-000 (%THE-CONS-LIST RELATIONSWITHDESCRIPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ R (%%VALUE ITER-000))
     (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS R) SYM-SPECIALIZE-LOGIC-DESCRIPTION
       NULL)
      NULL)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET* ((R NULL) (ITER-001 (%THE-CONS-LIST RELATIONSWITHDESCRIPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ R (%%VALUE ITER-001))
     (CL:LET* ((SUPER NULL) (ITER-002 (DIRECT-SUPERRELATIONS R)))
      (CL:LOOP WHILE (NEXT? ITER-002) DO (CL:SETQ SUPER (%VALUE ITER-002))
       (CL:WHEN (MEMBER? RELATIONSWITHDESCRIPTIONS SUPER)
        (CREATE-TAXONOMY-LINK *IMPLICATION-SUBSUMPTION-GRAPH*
         (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SUPER)
           SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))
         (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS R)
           SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))))

;;; (DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ...)

(CL:DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ()
  (CL:LET*
   ((R NULL) (ITER-000 (%THE-CONS-LIST (RELATIONS-WITH-DESCRIPTIONS))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ R (%%VALUE ITER-000))
    (SET-DYNAMIC-SLOT-VALUE
     (%DYNAMIC-SLOTS
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS R) SYM-SPECIALIZE-LOGIC-DESCRIPTION
       NULL))
     SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NULL NULL)
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ...)

(CL:DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ()
  (CLEAR-IMPLICATION-SUBSUMPTION-GRAPH)
  (CL:SETQ *IMPLICATION-SUBSUMPTION-GRAPH* (NEW-TAXONOMY-GRAPH))
  (FINALIZE-TAXONOMY-GRAPH *IMPLICATION-SUBSUMPTION-GRAPH*))

;;; (DEFUN (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION)
  (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DESCRIPTION)
   SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NULL))

;;; (DEFUN (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION PARENTNODE)
  (CL:LET*
   ((NODE
     (CREATE-TAXONOMY-NODE *IMPLICATION-SUBSUMPTION-GRAPH* PARENTNODE
      DESCRIPTION (CL:EQ PARENTNODE NULL))))
   (LINK-TAXONOMY-NODES *IMPLICATION-SUBSUMPTION-GRAPH* PARENTNODE NODE)
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DESCRIPTION)
    SYM-SPECIALIZE-STELLA-TAXONOMY-NODE NODE NULL)
   NODE))

;;; (DEFUN (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ...)

(CL:DEFUN FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE (DESCRIPTION)
  (CL:LET*
   ((RESULT (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE DESCRIPTION)))
   (CL:WHEN (CL:NOT (CL:EQ RESULT NULL))
    (CL:RETURN-FROM FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE
     RESULT))
   (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE DESCRIPTION NULL)))

;;; (DEFUN (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS DESCRIPTION) ...)

(CL:DEFUN CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS (SELF)
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS NULL))
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION SELF))
    (TAXONOMYNODE
     (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE DESCRIPTION)))
   (CL:LET* ((SUPER NULL) (ITER-000 (DIRECT-SUPERRELATIONS SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ SUPER (%VALUE ITER-000))
     (CL:LET*
      ((SUPERDESCRIPTION
        (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS SUPER))
       (SUPERTAXONOMYNODE
        (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE SUPERDESCRIPTION)))
      (CREATE-TAXONOMY-LINK *IMPLICATION-SUBSUMPTION-GRAPH* SUPERTAXONOMYNODE
       TAXONOMYNODE))))
   DESCRIPTION))

;;; (DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK ...)

(CL:DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK (TAILDESCRIPTION HEADDESCRIPTION)
  NULL)

;;; (DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK ...)

(CL:DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK (TAILDESCRIPTION HEADDESCRIPTION)
  (CL:PROGN (CL:SETQ HEADDESCRIPTION HEADDESCRIPTION)
   (CL:SETQ TAILDESCRIPTION TAILDESCRIPTION))
  NULL)

;;; (DEFUN (TAXONOMY-IMPLIES-OR-IS-SUBSUMED? BOOLEAN) ...)

(CL:DEFUN TAXONOMY-IMPLIES-OR-IS-SUBSUMED? (PREMISE CONCLUSION)
  (CL:LET*
   ((PREMISEDESCRIPTION
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PREMISE)
      SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))
    (CONCLUSIONDESCRIPTION NULL))
   (CL:WHEN
    (CL:OR (CL:EQ PREMISEDESCRIPTION NULL)
     (CL:EQ (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE PREMISEDESCRIPTION)
      NULL))
    (CL:SETQ PREMISEDESCRIPTION
     (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS PREMISE)))
   (CL:SETQ CONCLUSIONDESCRIPTION
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONCLUSION)
     SYM-SPECIALIZE-LOGIC-DESCRIPTION NULL))
   (CL:WHEN (CL:EQ CONCLUSIONDESCRIPTION NULL)
    (CL:RETURN-FROM TAXONOMY-IMPLIES-OR-IS-SUBSUMED? CL:NIL))
   (CL:WHEN
    (CL:EQ
     (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE CONCLUSIONDESCRIPTION)
     NULL)
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "'taxonomy-implies-or-is-subsumed?' conclusionDescription should have taxonomy-node")))
   (TAXONOMY-SUBNODE-OF?
    (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE PREMISEDESCRIPTION)
    (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE CONCLUSIONDESCRIPTION))))

(CL:DEFUN HELP-STARTUP-SPECIALIZE1 ()
  (CL:PROGN
   (CL:SETQ SGT-SPECIALIZE-LOGIC-ABSTRACT-PROPOSITIONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABSTRACT-PROPOSITIONS-ITERATOR" NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-SELECTION-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SELECTION-PATTERN" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-PROPOSITION-CURSOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION-CURSOR" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-EQUIVALENTS-STACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENTS-STACK" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-TRUE-PROPOSITIONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE-PROPOSITIONS-ITERATOR" NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-SPECIALIZING-PROPOSITIONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIALIZING-PROPOSITIONS-ITERATOR" NULL
     1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-SPECIALIZING-RELATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIALIZING-RELATIONS" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-DESCRIPTION-EXTENSION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION-EXTENSION-ITERATOR" NULL 1))
   (CL:SETQ KWD-SPECIALIZE-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION" NULL 2))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ KWD-SPECIALIZE-DEPENDENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPENDENTS" NULL 2))
   (CL:SETQ KWD-SPECIALIZE-ISA (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ KWD-SPECIALIZE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-F-TEST-PROPERTY?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-TEST-PROPERTY?-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-TEST-ISA?-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-F-TEST-ISA?-MEMO-TABLE-001
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-TEST-ISA?-MEMO-TABLE-001" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-F-ACCESS-BINARY-VALUE-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-ACCESS-BINARY-VALUE-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-COLLECTIONOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTIONOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-TRANSITIVE-CLOSURE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSITIVE-CLOSURE-ITERATOR" NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-ALLOCATE-ADJACENCY-ITERATOR-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALLOCATE-ADJACENCY-ITERATOR-FUNCTION"
     NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-FILTER?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILTER?" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-ADJACENCY-ITERATOR-STACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADJACENCY-ITERATOR-STACK" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-BEEN-THERE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BEEN-THERE-LIST" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-SUPPORTED-CLOSURE-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPORTED-CLOSURE-ITERATOR" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-DIRECTLY-LINKED-OBJECTS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECTLY-LINKED-OBJECTS-ITERATOR" NULL
     1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-INVERSE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE?" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-ROOT-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROOT-TRUTH-VALUE" NULL 0))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-SUBSET-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-ALL-SUPERCOLLECTIONS-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ SGT-SPECIALIZE-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ
    SGT-SPECIALIZE-LOGIC-F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-STELLA-NUMBER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-SPECIALIZE-LOGIC-CLASHING-PROPOSITIONS-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASHING-PROPOSITIONS-ITERATOR" NULL 1))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-REFERENCE-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFERENCE-PROPOSITION" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-STELLA-TAXONOMY-NODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TAXONOMY-NODE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-SPECIALIZE-LOGIC-STARTUP-SPECIALIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-SPECIALIZE" NULL 0))
   (CL:SETQ SYM-SPECIALIZE-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-SPECIALIZE2 ()
  (CL:PROGN
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "ABSTRACT-PROPOSITIONS-ITERATOR"
       "(DEFCLASS ABSTRACT-PROPOSITIONS-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator class that can generate sets of propositions matching
its `selection-pattern'.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((SELECTION-PATTERN :TYPE SELECTION-PATTERN) (PROPOSITION-CURSOR :TYPE (ITERATOR OF PROPOSITION)) (EQUIVALENTS-STACK :TYPE CONS :INITIALLY NULL)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-ABSTRACT-PROPOSITIONS-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-ABSTRACT-PROPOSITIONS-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TRUE-PROPOSITIONS-ITERATOR"
       "(DEFCLASS TRUE-PROPOSITIONS-ITERATOR (ABSTRACT-PROPOSITIONS-ITERATOR) :DOCUMENTATION \"Iterator class that can generate sets of true propositions
matching its `selection-pattern'.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((TRUTH-VALUE :TYPE TRUTH-VALUE :DOCUMENTATION \"Truth-value of the most recently generated proposition (or
projected argument thereof).  This truth value is not necessarily the strictest
and might have involved defaults.\")))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TRUE-PROPOSITIONS-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TRUE-PROPOSITIONS-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "SPECIALIZING-PROPOSITIONS-ITERATOR"
       "(DEFCLASS SPECIALIZING-PROPOSITIONS-ITERATOR (TRUE-PROPOSITIONS-ITERATOR) :DOCUMENTATION \"Iterator class that can generate sets of true propositions
matching its `selection-pattern' or a more specific pattern that substitutes
one of the relations in `specializing-relations'.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((SPECIALIZING-RELATIONS :TYPE (CONS OF CONS) :INITIALLY NULL)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-SPECIALIZING-PROPOSITIONS-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-SPECIALIZING-PROPOSITIONS-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "TRANSITIVE-CLOSURE-ITERATOR"
       "(DEFCLASS TRANSITIVE-CLOSURE-ITERATOR (ITERATOR) :DOCUMENTATION \"Iterator that visits all nodes reachable using an
embedded adjacency function.\" :SLOTS ((ALLOCATE-ADJACENCY-ITERATOR-FUNCTION :TYPE FUNCTION-CODE) (FILTER? :TYPE FUNCTION-CODE) (ADJACENCY-ITERATOR-STACK :TYPE (CONS OF ITERATOR) :INITIALLY NIL) (BEEN-THERE-LIST :TYPE CONS)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-TRANSITIVE-CLOSURE-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-TRANSITIVE-CLOSURE-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SUPPORTED-CLOSURE-ITERATOR"
       "(DEFCLASS SUPPORTED-CLOSURE-ITERATOR (TRANSITIVE-CLOSURE-ITERATOR) :DOCUMENTATION \"Iterator that visits all objects reachable via true link propositions
generated by an embedded link proposition iterator.  Each new object reached
is represented as an `(<object> <truth-value>)' pair, where <truth-value> is
the cumulative truth value of the links followed from the start to reach it.
The embedded `allocate-adjacency-iterator-function' needs to be able to take
an `(<object> <truth-value>)' pair as an argument which is different than the
requirement for TRANSITIVE-CLOSURE-ITERATOR's.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((ADJACENCY-ITERATOR-STACK :TYPE (CONS OF TRUE-PROPOSITIONS-ITERATOR))))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-SUPPORTED-CLOSURE-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-SUPPORTED-CLOSURE-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "DIRECTLY-LINKED-OBJECTS-ITERATOR"
       "(DEFCLASS DIRECTLY-LINKED-OBJECTS-ITERATOR (TRUE-PROPOSITIONS-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((INVERSE? :TYPE BOOLEAN) (ROOT-TRUTH-VALUE :TYPE TRUTH-VALUE :INITIALLY TRUE-TRUTH-VALUE)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-DIRECTLY-LINKED-OBJECTS-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-DIRECTLY-LINKED-OBJECTS-ITERATOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CLASHING-PROPOSITIONS-ITERATOR"
       "(DEFCLASS CLASHING-PROPOSITIONS-ITERATOR (TRUE-PROPOSITIONS-ITERATOR) :PARAMETERS ((ANY-VALUE :TYPE PROPOSITION)) :SLOTS ((REFERENCE-PROPOSITION :TYPE PROPOSITION)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-CLASHING-PROPOSITIONS-ITERATOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-CLASHING-PROPOSITIONS-ITERATOR-SLOT-VALUE)))))

(CL:DEFUN HELP-STARTUP-SPECIALIZE3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "PROPOSITIONS-ITERATOR-TRUTH-VALUE"
    "(DEFUN (PROPOSITIONS-ITERATOR-TRUTH-VALUE TRUTH-VALUE) ((SELF (ITERATOR OF PROPOSITION))))"
    (CL:FUNCTION PROPOSITIONS-ITERATOR-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "NEXT-EQUIVALENT-SELECTION-PATTERN"
    "(DEFUN (NEXT-EQUIVALENT-SELECTION-PATTERN CONS) ((SELF ABSTRACT-PROPOSITIONS-ITERATOR)))"
    (CL:FUNCTION NEXT-EQUIVALENT-SELECTION-PATTERN) NULL)
   (DEFINE-FUNCTION-OBJECT "PROPOSITION-TRUTH-VALUE"
    "(DEFUN (PROPOSITION-TRUTH-VALUE TRUTH-VALUE) ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION PROPOSITION-TRUTH-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "TRUE-PROPOSITION?"
    "(DEFUN (TRUE-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (AND (NOT (DELETED? PROPOSITION)) (CHOOSE *REVERSEPOLARITY?* (FALSE? PROPOSITION) (OR (TRUE? PROPOSITION) (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION))))))"
    (CL:FUNCTION TRUE-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRUE-PROPOSITIONS-ITERATOR.NEXT?"
    "(DEFUN (TRUE-PROPOSITIONS-ITERATOR.NEXT? BOOLEAN) ((SELF TRUE-PROPOSITIONS-ITERATOR)) :PUBLIC? TRUE)"
    (CL:FUNCTION TRUE-PROPOSITIONS-ITERATOR.NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF TRUE-PROPOSITIONS-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT?"
    "(DEFUN (SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT? BOOLEAN) ((SELF SPECIALIZING-PROPOSITIONS-ITERATOR)))"
    (CL:FUNCTION SPECIALIZING-PROPOSITIONS-ITERATOR.NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF SPECIALIZING-PROPOSITIONS-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "EMPTY-PROPOSITIONS-INDEX?"
    "(DEFUN (EMPTY-PROPOSITIONS-INDEX? BOOLEAN) ((INDEX PROPOSITIONS-INDEX) (PRIMARYKEY OBJECT) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION EMPTY-PROPOSITIONS-INDEX?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-TRUE-DEPENDENT-PROPOSITIONS"
    "(DEFUN (ALL-TRUE-DEPENDENT-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF OBJECT) (RELATION SURROGATE) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION ALL-TRUE-DEPENDENT-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS"
    "(DEFUN (ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF OBJECT)))"
    (CL:FUNCTION ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENTS-UNIFY-WITH-ARGUMENTS?"
    "(DEFUN (ARGUMENTS-UNIFY-WITH-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
    (CL:FUNCTION ARGUMENTS-UNIFY-WITH-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENTS-EQUAL-ARGUMENTS?"
    "(DEFUN (ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
    (CL:FUNCTION ARGUMENTS-EQUAL-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "ARGUMENTS-MATCH-ARGUMENTS?"
    "(DEFUN (ARGUMENTS-MATCH-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
    (CL:FUNCTION ARGUMENTS-MATCH-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "PREFIX-ARGUMENTS-EQUAL-ARGUMENTS?"
    "(DEFUN (PREFIX-ARGUMENTS-EQUAL-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
    (CL:FUNCTION PREFIX-ARGUMENTS-EQUAL-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-MATCHING-PROPOSITIONS"
    "(DEFUN (ALL-MATCHING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF PROPOSITION)))"
    (CL:FUNCTION ALL-MATCHING-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-PROPOSITIONS-MATCHING-ARGUMENTS"
    "(DEFUN (ALL-PROPOSITIONS-MATCHING-ARGUMENTS (CONS OF PROPOSITION)) ((ARGUMENTS CONS) (RELATION SURROGATE) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION ALL-PROPOSITIONS-MATCHING-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DEFINING-PROPOSITIONS"
    "(DEFUN (ALL-DEFINING-PROPOSITIONS (CONS OF PROPOSITION)) ((OUTPUTARGUMENT OBJECT) (RELATION SURROGATE) (SPECIALIZE? BOOLEAN)))"
    (CL:FUNCTION ALL-DEFINING-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-TEST-PROPERTY?"
    "(DEFUN (HELP-MEMOIZE-TEST-PROPERTY? BOOLEAN) ((SELF OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION HELP-MEMOIZE-TEST-PROPERTY?) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-PROPERTY?"
    "(DEFUN (TEST-PROPERTY? BOOLEAN) ((SELF OBJECT) (RELATION SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION TEST-PROPERTY?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-TEST-ISA?"
    "(DEFUN (HELP-MEMOIZE-TEST-ISA? BOOLEAN) ((MEMBER OBJECT) (TYPE SURROGATE)))"
    (CL:FUNCTION HELP-MEMOIZE-TEST-ISA?) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-ISA?"
    "(DEFUN (TEST-ISA? BOOLEAN) ((MEMBER OBJECT) (TYPE SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION TEST-ISA?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-ACCESS-BINARY-VALUE"
    "(DEFUN (HELP-MEMOIZE-ACCESS-BINARY-VALUE OBJECT) ((SELF OBJECT) (RELATION SURROGATE)))"
    (CL:FUNCTION HELP-MEMOIZE-ACCESS-BINARY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "ACCESS-BINARY-VALUE"
    "(DEFUN (ACCESS-BINARY-VALUE OBJECT) ((SELF OBJECT) (RELATION SURROGATE)) :PUBLIC? TRUE)"
    (CL:FUNCTION ACCESS-BINARY-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-COLLECTIONOF-MEMBER-OF?"
    "(DEFUN (TEST-COLLECTIONOF-MEMBER-OF? BOOLEAN) ((MEMBER OBJECT) (TYPE SURROGATE)))"
    (CL:FUNCTION TEST-COLLECTIONOF-MEMBER-OF?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSITIVE-CLOSURE-ITERATOR.NEXT?"
    "(DEFUN (TRANSITIVE-CLOSURE-ITERATOR.NEXT? BOOLEAN) ((SELF TRANSITIVE-CLOSURE-ITERATOR)))"
    (CL:FUNCTION TRANSITIVE-CLOSURE-ITERATOR.NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF TRANSITIVE-CLOSURE-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR"
    "(DEFUN (ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR ITERATOR) ((STARTNODE OBJECT) (ALLOCATEADJACENCYITERATOR FUNCTION-CODE) (FILTERFUNCTION FUNCTION-CODE)) :DOCUMENTATION \"Return an iterator that generates the transitive
closure of applying iterators generated by 'allocateAdjacencyIterator'
to 'startNode'.  If 'filterFunction' is non-null, that function is applied
as a filter to each node generated (nodes filtered out still generate
descendants, but they don't get returned).\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALLOCATE-TRANSITIVE-CLOSURE-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "ALLOCATE-SUPPORTED-CLOSURE-ITERATOR"
    "(DEFUN (ALLOCATE-SUPPORTED-CLOSURE-ITERATOR SUPPORTED-CLOSURE-ITERATOR) ((STARTNODE CONS) (ALLOCATEADJACENCYITERATOR FUNCTION-CODE) (FILTERFUNCTION FUNCTION-CODE)) :DOCUMENTATION \"Similar to `allocate-transitive-closure-iterator' (which see),
but return a SUPPORTED-CLOSURE-ITERATOR instead.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALLOCATE-SUPPORTED-CLOSURE-ITERATOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF SUPPORTED-CLOSURE-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF DIRECTLY-LINKED-OBJECTS-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECTLY-LINKED-OBJECTS"
    "(DEFUN (ALL-DIRECTLY-LINKED-OBJECTS ITERATOR) ((SELF OBJECT) (RELATION SURROGATE) (INVERSE? BOOLEAN)))"
    (CL:FUNCTION ALL-DIRECTLY-LINKED-OBJECTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUPERCOLLECTIONS"
    "(DEFUN (ALL-DIRECT-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT) (PERFORMFILTERING? BOOLEAN)))"
    (CL:FUNCTION ALL-DIRECT-SUPERCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS"
    "(DEFUN (ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-DIRECT-SUPERCOLLECTIONS-WITH-EQUIVALENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUBCOLLECTIONS"
    "(DEFUN (ALL-DIRECT-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT) (PERFORMFILTERING? BOOLEAN)))"
    (CL:FUNCTION ALL-DIRECT-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS"
    "(DEFUN (ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-DIRECT-SUBCOLLECTIONS-WITH-EQUIVALENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SUPERCOLLECTIONS"
    "(DEFUN (ALL-SUPERCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-SUPERCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SUBCOLLECTIONS"
    "(DEFUN (ALL-SUBCOLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-ISA-COLLECTIONS"
    "(DEFUN (ALL-ISA-COLLECTIONS (CONS OF LOGIC-OBJECT)) ((SELF OBJECT)))"
    (CL:FUNCTION ALL-ISA-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SUPPORTED-NAMED-SUBCOLLECTIONS"
    "(DEFUN (ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (CONS OF CONS)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-SUPPORTED-NAMED-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-DIRECTLY-LINKED-SUBCOLLECTIONS"
    "(DEFUN (ALL-DIRECTLY-LINKED-SUBCOLLECTIONS TRUE-PROPOSITIONS-ITERATOR) ((SELF OBJECT)))"
    (CL:FUNCTION ALL-DIRECTLY-LINKED-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS"
    "(DEFUN (HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS (CONS OF CONS)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION HELP-ALL-SUPPORTED-NAMED-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "VALUE-CLASHES-WITH-SKOLEM?"
    "(DEFUN (VALUE-CLASHES-WITH-SKOLEM? BOOLEAN) ((SKOLEM SKOLEM) (VALUE OBJECT)))"
    (CL:FUNCTION VALUE-CLASHES-WITH-SKOLEM?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASHES-WITH-FUNCTION-PROPOSITION?"
    "(DEFUN (CLASHES-WITH-FUNCTION-PROPOSITION? BOOLEAN) ((NEXTPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
    (CL:FUNCTION CLASHES-WITH-FUNCTION-PROPOSITION?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((SELF CLASHING-PROPOSITIONS-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-CLASHING-PROPOSITIONS"
    "(DEFUN (ALL-CLASHING-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF PROPOSITION)))"
    (CL:FUNCTION ALL-CLASHING-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "RELATIONS-WITH-DESCRIPTIONS"
    "(DEFUN (RELATIONS-WITH-DESCRIPTIONS (LIST OF RELATION)) ())"
    (CL:FUNCTION RELATIONS-WITH-DESCRIPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-SUBSUMPTION-TAXONOMY-GRAPH"
    "(DEFUN BUILD-SUBSUMPTION-TAXONOMY-GRAPH ())"
    (CL:FUNCTION BUILD-SUBSUMPTION-TAXONOMY-GRAPH) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-IMPLICATION-SUBSUMPTION-GRAPH"
    "(DEFUN CLEAR-IMPLICATION-SUBSUMPTION-GRAPH ())"
    (CL:FUNCTION CLEAR-IMPLICATION-SUBSUMPTION-GRAPH) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH"
    "(DEFUN INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH ())"
    (CL:FUNCTION INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
    "(DEFUN (FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION FIND-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
    "(DEFUN (CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION) (PARENTNODE TAXONOMY-NODE)))"
    (CL:FUNCTION CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE) NULL)
   (DEFINE-FUNCTION-OBJECT
    "FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE"
    "(DEFUN (FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE TAXONOMY-NODE) ((DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION FIND-OR-CREATE-DESCRIPTION-IMPLICATION-SUBSUMPTION-NODE)
    NULL)
   (DEFINE-FUNCTION-OBJECT
    "CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS"
    "(DEFUN (CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS DESCRIPTION) ((SELF RELATION)))"
    (CL:FUNCTION CREATE-DESCRIPTION-FOR-STELLA-RELATION-AND-ANCESTORS) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK"
    "(DEFUN ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK ((TAILDESCRIPTION DESCRIPTION) (HEADDESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION ADD-TAXONOMY-IMPLIES-SUBSUMES-LINK) NULL)
   (DEFINE-FUNCTION-OBJECT "DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK"
    "(DEFUN DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK ((TAILDESCRIPTION DESCRIPTION) (HEADDESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION DROP-TAXONOMY-IMPLIES-SUBSUMES-LINK) NULL)
   (DEFINE-FUNCTION-OBJECT "TAXONOMY-IMPLIES-OR-IS-SUBSUMED?"
    "(DEFUN (TAXONOMY-IMPLIES-OR-IS-SUBSUMED? BOOLEAN) ((PREMISE RELATION) (CONCLUSION RELATION)))"
    (CL:FUNCTION TAXONOMY-IMPLIES-OR-IS-SUBSUMED?) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-SPECIALIZE"
    "(DEFUN STARTUP-SPECIALIZE () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-SPECIALIZE) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-SPECIALIZE-LOGIC-STARTUP-SPECIALIZE)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
     SYM-SPECIALIZE-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupSpecialize") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-SPECIALIZE ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-SPECIALIZE1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ EMPTY-PROPOSITIONS-ITERATOR (NEW-TRUE-PROPOSITIONS-ITERATOR)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5) (HELP-STARTUP-SPECIALIZE2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-SPECIALIZE3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFCONSTANT EMPTY-PROPOSITIONS-ITERATOR (ITERATOR OF PROPOSITION) (NEW TRUE-PROPOSITIONS-ITERATOR) :DOCUMENTATION \"This iterator returns no values whenever its called.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *IMPLICATION-SUBSUMPTION-GRAPH* TAXONOMY-GRAPH NULL)")
    (INITIALIZE-IMPLICATION-SUBSUMPTION-GRAPH))))
