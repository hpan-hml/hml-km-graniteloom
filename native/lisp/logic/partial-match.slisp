;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; partial-match.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2010      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-PARTIAL-MATCH-BASIC NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SET-PARTIAL-MATCH-MODE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-COMMON-LISP NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-FUNCTION NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-MAX NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-KIND NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-CONTROL-FRAME NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-PARENT NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-CHILD NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-POSITIVE-SCORE NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-NEGATIVE-SCORE NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-DYNAMIC-CUTOFF NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-SCORES NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-WEIGHTS NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-UNBOUND-VARS NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SUCCESS? NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SET-RULE-COMBINATION NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SET-GREEDY-NETWORK-PRUNING NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SET-MAXIMUM-SCORE-CUTOFF NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SET-MINIMUM-SCORE-CUTOFF NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-WEIGHT NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-CONTROL-FRAME NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-KIND NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-DOWN NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-UP-TRUE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-UP-FAIL NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-TRUE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-FAIL NULL)
(CL:DEFVAR SGT-PARTIAL-MATCH-LOGIC-INCREMENTAL-PARTIAL-MATCH NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-SCORE NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-WEIGHT NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-TOTAL-WEIGHT NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-MAXIMUM-SCORE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-AND NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-SKIPPED-CONJUNCT NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-FAILURE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-POPPED NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-STELLA-ARGUMENTS NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-GOAL-TREE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-MOVE-DOWN NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-NOISY-OR NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-CONTINUING-SUCCESS NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ANTECEDENTS-RULE NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-INFERENCE-CUTOFF-REASON NULL)
(CL:DEFVAR SGT-PARTIAL-MATCH-LOGIC-NN-PARTIAL-MATCH NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-RULES NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-STELLA-ARITY NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-OR NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-ATOMIC-GOAL NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-FULL-SUBQUERY NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-STELLA-ITERATOR NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-MATCH-MODE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-INCREMENTAL NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-NN NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-NEURAL-NETWORK NULL)
(CL:DEFVAR SGT-PARTIAL-MATCH-STELLA-CLASS NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-ERROR NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-MINIMUM-SCORE NULL)
(CL:DEFVAR SGT-PARTIAL-MATCH-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-RETRIEVE-PARTIAL NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-SORT-BY NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-SCORE NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-MAXIMIZE-SCORE? NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-ASK-PARTIAL NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-SUPPORT NULL)
(CL:DEFVAR SGT-PARTIAL-MATCH-PL-KERNEL-KB-NULL NULL)
(CL:DEFVAR KWD-PARTIAL-MATCH-RELATION NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-LOGIC-STARTUP-PARTIAL-MATCH NULL)
(CL:DEFVAR SYM-PARTIAL-MATCH-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *ACTIVATED-NETWORKS* *MOST-RECENT-QUERY*
  STANDARD-ERROR *MODULE* FALSE-TRUTH-VALUE DEFAULT-FALSE-TRUTH-VALUE
  TRUE-TRUTH-VALUE NULL-INTEGER UNKNOWN-TRUTH-VALUE NIL *QUERYITERATOR*
  NULL-FLOAT-WRAPPER STANDARD-OUTPUT NULL-FLOAT EOL TRUE-WRAPPER
  FALSE-WRAPPER))

;;; (DEFGLOBAL *PARTIAL-MATCH-MODE* ...)

(CL:DEFVAR *PARTIAL-MATCH-MODE* NULL)

;;; (DEFGLOBAL *GREEDY-NETWORK-PRUNING* ...)

(CL:DEFVAR *GREEDY-NETWORK-PRUNING* CL:T)

;;; (DEFUN SET-PARTIAL-MATCH-MODE ...)

(CL:DEFUN %SET-PARTIAL-MATCH-MODE (K)
  (CL:SETQ *PARTIAL-MATCH-MODE* K))

(CL:DEFMACRO SET-PARTIAL-MATCH-MODE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-PARTIAL-MATCH-MODE|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-PARTIAL-MATCH-MODE)))

;;; (DEFGLOBAL *RULE-COMBINATION* ...)

(CL:DEFVAR *RULE-COMBINATION* NULL)

;;; (DEFGLOBAL *PLANNING-MODE* ...)

(CL:DEFVAR *PLANNING-MODE* CL:NIL)

;;; (DEFGLOBAL *PLANABLE-PREDICATES* ...)

(CL:DEFVAR *PLANABLE-PREDICATES* NULL)

(CL:DEFUN ACCESS-PARTIAL-MATCH-FRAME-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-KIND)
    (CL:IF SETVALUE? (CL:SETF (%PARTIAL-MATCH-FRAME.KIND SELF) VALUE)
     (CL:SETQ VALUE (%PARTIAL-MATCH-FRAME.KIND SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-CONTROL-FRAME)
    (CL:IF SETVALUE? (CL:SETF (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-PARENT)
    (CL:IF SETVALUE? (CL:SETF (%PARTIAL-MATCH-FRAME.PARENT SELF) VALUE)
     (CL:SETQ VALUE (%PARTIAL-MATCH-FRAME.PARENT SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-CHILD)
    (CL:IF SETVALUE? (CL:SETF (%PARTIAL-MATCH-FRAME.CHILD SELF) VALUE)
     (CL:SETQ VALUE (%PARTIAL-MATCH-FRAME.CHILD SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-POSITIVE-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-NEGATIVE-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-DYNAMIC-CUTOFF)
    (CL:IF SETVALUE?
     (CL:SETF (%PARTIAL-MATCH-FRAME.DYNAMIC-CUTOFF SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%PARTIAL-MATCH-FRAME.DYNAMIC-CUTOFF SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-SCORES)
    (CL:IF SETVALUE?
     (CL:SETF (%PARTIAL-MATCH-FRAME.ARGUMENT-SCORES SELF) VALUE)
     (CL:SETQ VALUE (%PARTIAL-MATCH-FRAME.ARGUMENT-SCORES SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-WEIGHTS)
    (CL:IF SETVALUE?
     (CL:SETF (%PARTIAL-MATCH-FRAME.ARGUMENT-WEIGHTS SELF) VALUE)
     (CL:SETQ VALUE (%PARTIAL-MATCH-FRAME.ARGUMENT-WEIGHTS SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-UNBOUND-VARS)
    (CL:IF SETVALUE? (CL:SETF (%PARTIAL-MATCH-FRAME.UNBOUND-VARS SELF) VALUE)
     (CL:SETQ VALUE (%PARTIAL-MATCH-FRAME.UNBOUND-VARS SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-SUCCESS?)
    (CL:IF SETVALUE?
     (CL:SETF (%PARTIAL-MATCH-FRAME.SUCCESS? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%PARTIAL-MATCH-FRAME.SUCCESS? SELF) TRUE-WRAPPER
       FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *FAIL-UNBOUND-CLAUSES?* ...)

(CL:DEFVAR *FAIL-UNBOUND-CLAUSES?* CL:NIL)

;;; (DEFGLOBAL *MINIMUM-SCORE-CUTOFF* ...)

(CL:DEFVAR *MINIMUM-SCORE-CUTOFF* 0.0d0
  "Positive scores below *minimum-score-cutoff* get trimmed
to 0.0 during partial match operations.")
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *MINIMUM-SCORE-CUTOFF*))

;;; (DEFGLOBAL *MAXIMUM-SCORE-CUTOFF* ...)

(CL:DEFVAR *MAXIMUM-SCORE-CUTOFF* 0.0d0
  "Positive scores above *maximum-score-cutoff* get trimmed
to 1.0 during partial match operations.")
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *MAXIMUM-SCORE-CUTOFF*))

;;; (DEFUN SET-RULE-COMBINATION ...)

(CL:DEFUN %SET-RULE-COMBINATION (K)
  (CL:SETQ *RULE-COMBINATION* K))

(CL:DEFMACRO SET-RULE-COMBINATION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-RULE-COMBINATION|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-RULE-COMBINATION)))

;;; (DEFUN SET-GREEDY-NETWORK-PRUNING ...)

(CL:DEFUN %SET-GREEDY-NETWORK-PRUNING (B)
  (CL:SETQ *GREEDY-NETWORK-PRUNING* B))

(CL:DEFUN SET-GREEDY-NETWORK-PRUNING-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-GREEDY-NETWORK-PRUNING
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-GREEDY-NETWORK-PRUNING (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-GREEDY-NETWORK-PRUNING|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-GREEDY-NETWORK-PRUNING)))

;;; (DEFUN SET-MAXIMUM-SCORE-CUTOFF ...)

(CL:DEFUN %SET-MAXIMUM-SCORE-CUTOFF (C)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT C))
  #+MCL
  (CL:CHECK-TYPE C CL:DOUBLE-FLOAT)
  (CL:SETQ *MAXIMUM-SCORE-CUTOFF* C))

(CL:DEFUN SET-MAXIMUM-SCORE-CUTOFF-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-MAXIMUM-SCORE-CUTOFF
   (%FLOAT-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-MAXIMUM-SCORE-CUTOFF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-MAXIMUM-SCORE-CUTOFF|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-MAXIMUM-SCORE-CUTOFF)))

;;; (DEFUN SET-MINIMUM-SCORE-CUTOFF ...)

(CL:DEFUN %SET-MINIMUM-SCORE-CUTOFF (C)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT C))
  #+MCL
  (CL:CHECK-TYPE C CL:DOUBLE-FLOAT)
  (CL:SETQ *MAXIMUM-SCORE-CUTOFF* C))

(CL:DEFUN SET-MINIMUM-SCORE-CUTOFF-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-MINIMUM-SCORE-CUTOFF
   (%FLOAT-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-MINIMUM-SCORE-CUTOFF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-MINIMUM-SCORE-CUTOFF|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-MINIMUM-SCORE-CUTOFF)))

;;; (DEFGLOBAL *AND-MISSED-A-BINDING* ...)

(CL:DEFVAR *AND-MISSED-A-BINDING* CL:NIL)

;;; (DEFUN LINK-TO-PARENT-PARTIAL-MATCH-FRAME ...)

(CL:DEFUN LINK-TO-PARENT-PARTIAL-MATCH-FRAME (SELF)
  (CL:LET*
   ((CONTROLFRAME
     (%CONTROL-FRAME.UP (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF))))
   (CL:LOOP WHILE
    (CL:AND (CL:NOT (CL:EQ CONTROLFRAME NULL))
     (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME CONTROLFRAME) NULL))
    DO (CL:SETQ CONTROLFRAME (%CONTROL-FRAME.UP CONTROLFRAME)))
   (CL:WHEN (CL:NOT (CL:EQ CONTROLFRAME NULL))
    (CL:SETF (%PARTIAL-MATCH-FRAME.PARENT SELF)
     (%CONTROL-FRAME.PARTIAL-MATCH-FRAME CONTROLFRAME))
    (CL:SETF
     (%PARTIAL-MATCH-FRAME.CHILD
      (%CONTROL-FRAME.PARTIAL-MATCH-FRAME CONTROLFRAME))
     SELF))))

;;; (DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ...)

(CL:DEFMETHOD CREATE-PARTIAL-MATCH-FRAME ((SELF PARTIAL-MATCH-FRAME) FRAME KIND)
  (CL:PROGN (CL:SETQ FRAME FRAME) (CL:SETQ KIND KIND))
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "Missing concrete method named 'create-partial-match-frame' on the" EOL
    "   class `" (PRIMARY-TYPE SELF) "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (COMPUTE-DYNAMIC-CUTOFF PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-DYNAMIC-CUTOFF ((SELF PARTIAL-MATCH-FRAME))
  NULL-FLOAT)

;;; (DEFMETHOD SET-DYNAMIC-CUTOFF ...)

(CL:DEFMETHOD SET-DYNAMIC-CUTOFF ((SELF PARTIAL-MATCH-FRAME))
  (CL:LET* ((CUTOFF (COMPUTE-DYNAMIC-CUTOFF SELF)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT CUTOFF))
   (CL:WHEN (CL:NOT (CL:= CUTOFF NULL-FLOAT))
    (CL:WHEN (CL:OR (CL:< CUTOFF -100) (CL:> CUTOFF 100))
     (CL:WARN "*** fishy dynamic cutoff=`~A' computed, resetting to 0.0"
      CUTOFF)
     (CL:SETQ CUTOFF 0.0d0))
    (CL:SETF (%PARTIAL-MATCH-FRAME.DYNAMIC-CUTOFF SELF) CUTOFF))))

;;; (DEFMETHOD (CUTOFF-PARTIAL-MATCH? BOOLEAN) ...)

(CL:DEFMETHOD CUTOFF-PARTIAL-MATCH? ((SELF PARTIAL-MATCH-FRAME) TRACE?)
  (CL:LET*
   ((SCORE (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SELF))
    (CUTOFF (%PARTIAL-MATCH-FRAME.DYNAMIC-CUTOFF SELF)) (CUTOFF? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE CUTOFF))
   (CL:COND
    ((CL:OR (CL:= SCORE NULL-FLOAT) (CL:= CUTOFF NULL-FLOAT)
      (CL:= CUTOFF 0.0d0))
     (CL:SETQ CUTOFF? CL:NIL))
    ((CL:< CUTOFF 0.0d0) (CL:SETQ CUTOFF? (> SCORE CUTOFF)))
    (CL:T (CL:SETQ CUTOFF? (< SCORE CUTOFF))))
   (CL:WHEN (CL:AND CUTOFF? TRACE?)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "*** Cutting off search, cutoff=" CUTOFF EOL))
   CUTOFF?))

;;; (DEFMETHOD (PROPOSITION-WEIGHT FLOAT) ...)

(CL:DEFMETHOD PROPOSITION-WEIGHT ((SELF PARTIAL-MATCH-FRAME) PROPOSITION)
  (CL:IF (CL:NOT (CL:EQ PROPOSITION NULL))
   (CL:LET*
    ((WEIGHT
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
        SYM-PARTIAL-MATCH-LOGIC-WEIGHT NULL-FLOAT-WRAPPER))))
    (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT WEIGHT))
    (CL:IF (CL:= WEIGHT NULL-FLOAT) 1.0d0 WEIGHT))
   1.0d0))

;;; (DEFMETHOD CLEAR-FRAME-PARTIAL-TRUTH ...)

(CL:DEFMETHOD CLEAR-FRAME-PARTIAL-TRUTH ((SELF PARTIAL-MATCH-FRAME))
  (CL:SETF (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SELF) NULL-FLOAT)
  (CL:SETF (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE SELF) NULL-FLOAT))

;;; (DEFMETHOD (DEFINED-FRAME-PARTIAL-TRUTH? BOOLEAN) ...)

(CL:DEFMETHOD DEFINED-FRAME-PARTIAL-TRUTH? ((SELF CONTROL-FRAME))
  (CL:AND (CL:NOT (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF) NULL))
   (CL:OR
    (CL:NOT
     (CL:=
      (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF))
      NULL-FLOAT))
    (CL:NOT
     (CL:=
      (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF))
      NULL-FLOAT)))))

;;; (DEFMETHOD (DEFINED-FRAME-PARTIAL-TRUTH? BOOLEAN) ...)

(CL:DEFMETHOD DEFINED-FRAME-PARTIAL-TRUTH? ((SELF PARTIAL-MATCH-FRAME))
  (CL:OR (CL:NOT (CL:= (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SELF) NULL-FLOAT))
   (CL:NOT (CL:= (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE SELF) NULL-FLOAT))))

;;; (DEFMETHOD SET-FRAME-PARTIAL-TRUTH ...)

(CL:DEFMETHOD SET-FRAME-PARTIAL-TRUTH ((SELF PARTIAL-MATCH-FRAME) TRUTHVALUE POSSCORE NEGSCORE IGNOREPOLARITY?)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT POSSCORE NEGSCORE))
  #+MCL
  (CL:CHECK-TYPE POSSCORE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE NEGSCORE CL:DOUBLE-FLOAT)
  (CL:LET*
   ((FLIPPOLARITY?
     (CL:AND
      (%CONTROL-FRAME.REVERSE-POLARITY?
       (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF))
      (CL:NOT IGNOREPOLARITY?))))
   (CL:WHEN
    (CL:AND (CL:= POSSCORE NULL-FLOAT) (CL:NOT (CL:EQ TRUTHVALUE NULL)))
    (CL:SETQ POSSCORE (%TRUTH-VALUE.POSITIVE-SCORE TRUTHVALUE)))
   (CL:WHEN
    (CL:AND (CL:= NEGSCORE NULL-FLOAT) (CL:NOT (CL:EQ TRUTHVALUE NULL)))
    (CL:SETQ NEGSCORE
     (%TRUTH-VALUE.POSITIVE-SCORE (INVERT-TRUTH-VALUE TRUTHVALUE))))
   (CL:WHEN FLIPPOLARITY?
    (CL:LET* ((AUX POSSCORE)) (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT AUX))
     (CL:SETQ POSSCORE (CL:- 0 POSSCORE)) (CL:SETQ NEGSCORE AUX)))
   (CL:SETF (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SELF) POSSCORE)
   (CL:SETF (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE SELF) NEGSCORE)
   (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
    SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT POSSCORE)
    NULL-FLOAT-WRAPPER)))

;;; (DEFMETHOD PROPAGATE-FRAME-PARTIAL-TRUTH ...)

(CL:DEFMETHOD PROPAGATE-FRAME-PARTIAL-TRUTH ((SOURCE PARTIAL-MATCH-FRAME) TARGET)
  (CL:LET*
   ((TARGETPMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME TARGET))
    (FLIPPOLARITY?
     (CL:NOT
      (CL:EQ
       (%CONTROL-FRAME.REVERSE-POLARITY?
        (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SOURCE))
       (%CONTROL-FRAME.REVERSE-POLARITY? TARGET)))))
   (CL:WHEN (CL:EQ TARGETPMF NULL)
    (CL:COND
     (FLIPPOLARITY?
      (CL:SETQ TARGETPMF
       (CREATE-OBJECT (PRIMARY-TYPE SOURCE) KWD-PARTIAL-MATCH-CONTROL-FRAME
        TARGET KWD-PARTIAL-MATCH-KIND (%CONTROL-FRAME.STATE TARGET)))
      (CL:SETF (%PARTIAL-MATCH-FRAME.PARENT TARGETPMF)
       (%PARTIAL-MATCH-FRAME.PARENT SOURCE))
      (CL:SETF (%PARTIAL-MATCH-FRAME.CHILD TARGETPMF) SOURCE))
     (CL:T (CL:SETQ TARGETPMF SOURCE)))
    (CL:SETF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME TARGET) TARGETPMF))
   (CL:COND
    (FLIPPOLARITY?
     (CL:SETF (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE TARGETPMF)
      (CL:- 0 (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SOURCE)))
     (CL:SETF (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE TARGETPMF)
      (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SOURCE)))
    (CL:T
     (CL:SETF (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE TARGETPMF)
      (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SOURCE))
     (CL:SETF (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE TARGETPMF)
      (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE SOURCE))))
   (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
    SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE
    (WRAP-FLOAT (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE TARGETPMF))
    NULL-FLOAT-WRAPPER)))

;;; (DEFMETHOD TRACE-FRAME-PARTIAL-TRUTH ...)

(CL:DEFMETHOD TRACE-FRAME-PARTIAL-TRUTH ((SELF PARTIAL-MATCH-FRAME) LASTMOVE STREAM)
  (CL:LET*
   ((WEIGHT
     (PROPOSITION-WEIGHT SELF
      (%CONTROL-FRAME.PROPOSITION
       (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF)))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT WEIGHT))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-PARTIAL-MATCH-DOWN)
     (CL:LET* ((CUTOFF (COMPUTE-DYNAMIC-CUTOFF SELF)))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT CUTOFF))
      (CL:WHEN (CL:NOT (CL:= CUTOFF NULL-FLOAT))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "cutoff="
        CUTOFF))))
    ((CL:OR (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-TRUE)
      (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL))
     (CL:LET* ((SCORE (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SELF)))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) "score=" SCORE)
      (CL:WHEN
       (CL:AND (CL:NOT (CL:= WEIGHT NULL-FLOAT)) (CL:NOT (CL:= WEIGHT 1.0d0)))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STREAM) " weight="
        WEIGHT))))
    (CL:T))))

;;; (DEFMETHOD SET-CACHE-PARTIAL-TRUTH ...)

(CL:DEFMETHOD SET-CACHE-PARTIAL-TRUTH ((SELF CONTROL-FRAME) CACHE)
  (CL:LET* ((PMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF)))
   (CL:WHEN (CL:NOT (CL:EQ PMF NULL)) (SET-CACHE-PARTIAL-TRUTH PMF CACHE))))

;;; (DEFMETHOD SET-CACHE-PARTIAL-TRUTH ...)

(CL:DEFMETHOD SET-CACHE-PARTIAL-TRUTH ((SELF PARTIAL-MATCH-FRAME) CACHE)
  (CL:SETF (%ATOMIC-GOAL-CACHE.POSITIVE-SCORE CACHE)
   (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SELF))
  (CL:SETF (%ATOMIC-GOAL-CACHE.NEGATIVE-SCORE CACHE)
   (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE SELF)))

;;; (DEFMETHOD SET-JUSTIFICATION-PARTIAL-TRUTH ...)

(CL:DEFMETHOD SET-JUSTIFICATION-PARTIAL-TRUTH ((SELF CONTROL-FRAME) JUSTIFICATION)
  (CL:LET* ((PMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME SELF)))
   (CL:WHEN (CL:NOT (CL:EQ PMF NULL))
    (SET-JUSTIFICATION-PARTIAL-TRUTH PMF JUSTIFICATION))))

;;; (DEFMETHOD SET-JUSTIFICATION-PARTIAL-TRUTH ...)

(CL:DEFMETHOD SET-JUSTIFICATION-PARTIAL-TRUTH ((SELF PARTIAL-MATCH-FRAME) JUSTIFICATION)
  (CL:SETF (%JUSTIFICATION.POSITIVE-SCORE JUSTIFICATION)
   (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE SELF))
  (CL:SETF (%JUSTIFICATION.NEGATIVE-SCORE JUSTIFICATION)
   (%PARTIAL-MATCH-FRAME.NEGATIVE-SCORE SELF)))

;;; (DEFMETHOD (ALLOW-UNBOUND-VARIABLES? BOOLEAN) ...)

(CL:DEFMETHOD ALLOW-UNBOUND-VARIABLES? ((SELF PARTIAL-MATCH-FRAME))
  CL:NIL)

;;; (DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-AND-SCORE ((SELF PARTIAL-MATCH-FRAME))
  NULL-FLOAT)

;;; (DEFMETHOD (CONTINUE-PARTIAL-AND-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-AND-PROOF ((SELF PARTIAL-MATCH-FRAME) FRAME LASTMOVE)
  (CL:SETQ LASTMOVE (OLD-INTERPRET-AND-SCORES FRAME LASTMOVE))
  (CONTINUE-AND-PROOF FRAME LASTMOVE))

;;; (DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-OR-SCORE ((SELF PARTIAL-MATCH-FRAME))
  NULL-FLOAT)

;;; (DEFMETHOD (CONTINUE-PARTIAL-OR-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-OR-PROOF ((SELF PARTIAL-MATCH-FRAME) LASTMOVE)
  (CL:SETQ LASTMOVE
   (OLD-INTERPRET-OR-SCORES (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF)
    LASTMOVE))
  (CONTINUE-OR-PROOF (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF) LASTMOVE))

;;; (DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-NOT-SCORE ((SELF PARTIAL-MATCH-FRAME))
  NULL-FLOAT)

;;; (DEFMETHOD (CONTINUE-PARTIAL-NOT-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-NOT-PROOF ((SELF PARTIAL-MATCH-FRAME) LASTMOVE)
  (CONTINUE-NOT-PROOF (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF) LASTMOVE))

;;; (DEFMETHOD (CONTINUE-PARTIAL-FAIL-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-FAIL-PROOF ((SELF PARTIAL-MATCH-FRAME) LASTMOVE)
  (CL:SETQ LASTMOVE
   (OLD-INTERPRET-FAIL-SCORE (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF)
    LASTMOVE))
  (CONTINUE-FAIL-PROOF (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF) LASTMOVE))

;;; (DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-GOAL-SCORE ((SELF PARTIAL-MATCH-FRAME))
  NULL-FLOAT)

;;; (DEFMETHOD (CONTINUE-PARTIAL-STRATEGIES-PROOFS KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-STRATEGIES-PROOFS ((SELF PARTIAL-MATCH-FRAME) LASTMOVE)
  (OLD-INTERPRET-GOAL-SCORES (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF)
   LASTMOVE))

;;; (DEFMETHOD (CONTINUE-PARTIAL-ANTECEDENTS-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-ANTECEDENTS-PROOF ((SELF PARTIAL-MATCH-FRAME) LASTMOVE)
  (CONTINUE-ANTECEDENTS-PROOF (%PARTIAL-MATCH-FRAME.CONTROL-FRAME SELF)
   LASTMOVE))

;;; (DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ...)

(CL:DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ((SELF PARTIAL-MATCH-FRAME) PROP TRUTH)
  (CL:SETQ PROP PROP)
  (CL:COND
   ((CL:EQ TRUTH KWD-PARTIAL-MATCH-TRUE)
    (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
     SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT 1.0d0)
     NULL-FLOAT-WRAPPER))
   ((CL:EQ TRUTH KWD-PARTIAL-MATCH-FAIL)
    (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
     SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT 0.0d0)
     NULL-FLOAT-WRAPPER))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      TRUTH "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ((SELF PARTIAL-MATCH-FRAME) SCORE WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE WEIGHT))
  #+MCL
  (CL:CHECK-TYPE SCORE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE WEIGHT CL:DOUBLE-FLOAT)
  (CL:PROGN (CL:SETQ SCORE SCORE) (CL:SETQ WEIGHT WEIGHT)))

;;; (DEFMETHOD POP-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD POP-PARTIAL-MATCH-SCORE ((SELF PARTIAL-MATCH-FRAME)))

;;; (DEFMETHOD (EARLY-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ...)

(CL:DEFMETHOD EARLY-PARTIAL-MATCH-AND-FAILURE? ((SELF PARTIAL-MATCH-FRAME))
  CL:NIL)

;;; (DEFMETHOD (EARLY-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ...)

(CL:DEFMETHOD EARLY-PARTIAL-MATCH-OR-SUCCESS? ((SELF PARTIAL-MATCH-FRAME))
  CL:NIL)

(CL:DEFUN NEW-INCREMENTAL-PARTIAL-MATCH (KIND CONTROL-FRAME)
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-INCREMENTAL-PARTIAL-MATCH))
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.KIND SELF) KIND)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF) CONTROL-FRAME)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.SUCCESS? SELF) CL:NIL)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.UNBOUND-VARS SELF) NIL)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF) NIL)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES SELF) NIL)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.DYNAMIC-CUTOFF SELF) NULL-FLOAT)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.MAXIMUM-SCORE SELF) 0.0d0)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.TOTAL-WEIGHT SELF) NULL-FLOAT)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-WEIGHT SELF) 0.0d0)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-SCORE SELF) 0.0d0)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.CHILD SELF) NULL)
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.PARENT SELF) NULL)
   (INITIALIZE-INCREMENTAL-PARTIAL-MATCH SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF INCREMENTAL-PARTIAL-MATCH))
  SGT-PARTIAL-MATCH-LOGIC-INCREMENTAL-PARTIAL-MATCH)

(CL:DEFUN ACCESS-INCREMENTAL-PARTIAL-MATCH-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-PARENT)
    (CL:IF SETVALUE? (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.PARENT SELF) VALUE)
     (CL:SETQ VALUE (%INCREMENTAL-PARTIAL-MATCH.PARENT SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-CHILD)
    (CL:IF SETVALUE? (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.CHILD SELF) VALUE)
     (CL:SETQ VALUE (%INCREMENTAL-PARTIAL-MATCH.CHILD SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FLOAT (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-WEIGHT)
    (CL:IF SETVALUE?
     (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-WEIGHT SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FLOAT (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-WEIGHT SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-TOTAL-WEIGHT)
    (CL:IF SETVALUE?
     (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.TOTAL-WEIGHT SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FLOAT (%INCREMENTAL-PARTIAL-MATCH.TOTAL-WEIGHT SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-MAXIMUM-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.MAXIMUM-SCORE SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-FLOAT (%INCREMENTAL-PARTIAL-MATCH.MAXIMUM-SCORE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN INITIALIZE-INCREMENTAL-PARTIAL-MATCH ...)

(CL:DEFUN INITIALIZE-INCREMENTAL-PARTIAL-MATCH (SELF)
  (CL:LET*
   ((FRAME (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF))
    (KIND (%INCREMENTAL-PARTIAL-MATCH.KIND SELF)))
   (CL:COND
    ((CL:EQ KIND KWD-PARTIAL-MATCH-AND)
     (CL:LET*
      ((ARGUMENTWEIGHT NULL-FLOAT) (TOTALWEIGHT 0.0d0) (NOFWEIGHTEDARGS 0))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ARGUMENTWEIGHT TOTALWEIGHT)
       (CL:TYPE CL:FIXNUM NOFWEIGHTEDARGS))
      (CL:LET*
       ((ARG NULL)
        (VECTOR-000
         (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION FRAME)))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:COND
         ((CL:AND (CL:EQ (%PROPOSITION.KIND ARG) KWD-PARTIAL-MATCH-AND)
           (CL:=
            (%FLOAT-WRAPPER.WRAPPER-VALUE
             (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS ARG)
              SYM-PARTIAL-MATCH-LOGIC-WEIGHT NULL-FLOAT-WRAPPER))
            NULL-FLOAT))
          (CL:SETQ NOFWEIGHTEDARGS 0)
          (CL:LET*
           ((SUBARG NULL) (VECTOR-001 (%PROPOSITION.ARGUMENTS ARG))
            (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
           (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
            (CL:SETQ SUBARG
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
              INDEX-001))
            (CL:WHEN
             (CL:OR (CL:= (PROPOSITION-WEIGHT SELF SUBARG) NULL-FLOAT)
              (CL:> (PROPOSITION-WEIGHT SELF SUBARG) 0.0d0))
             (CL:SETQ NOFWEIGHTEDARGS (CL:1+ NOFWEIGHTEDARGS)))
            (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
          (CL:SETQ ARGUMENTWEIGHT (CL:* 1.0d0 NOFWEIGHTEDARGS))
          (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS ARG)
           SYM-PARTIAL-MATCH-LOGIC-WEIGHT (WRAP-FLOAT ARGUMENTWEIGHT)
           NULL-FLOAT-WRAPPER))
         (CL:T (CL:SETQ ARGUMENTWEIGHT (PROPOSITION-WEIGHT SELF ARG))))
        (CL:SETQ TOTALWEIGHT (CL:+ TOTALWEIGHT ARGUMENTWEIGHT))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:IF (CL:> TOTALWEIGHT 0.0d0)
       (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.TOTAL-WEIGHT SELF) TOTALWEIGHT)
       (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.TOTAL-WEIGHT SELF)
        (CL:FLOAT
         (LENGTH (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION FRAME)))
         0.0d0)))))
    (CL:T))
   (LINK-TO-PARENT-PARTIAL-MATCH-FRAME SELF)))

;;; (DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ...)

(CL:DEFMETHOD CREATE-PARTIAL-MATCH-FRAME ((SELF INCREMENTAL-PARTIAL-MATCH) FRAME KIND)
  (NEW-INCREMENTAL-PARTIAL-MATCH KIND FRAME))

;;; (DEFMETHOD (COMPUTE-DYNAMIC-CUTOFF PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-DYNAMIC-CUTOFF ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:LET* ((PARENT (%INCREMENTAL-PARTIAL-MATCH.PARENT SELF)) (CUTOFF 0.0d0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT CUTOFF))
   (CL:WHEN (CL:NOT (CL:EQ PARENT NULL))
    (CL:COND
     ((CL:EQ (%INCREMENTAL-PARTIAL-MATCH.KIND PARENT) KWD-PARTIAL-MATCH-AND)
      (CL:LET*
       ((PCUTOFF (%INCREMENTAL-PARTIAL-MATCH.DYNAMIC-CUTOFF PARENT))
        (TOTWEIGHT (%INCREMENTAL-PARTIAL-MATCH.TOTAL-WEIGHT PARENT))
        (PROPWEIGHT
         (PROPOSITION-WEIGHT SELF
          (%CONTROL-FRAME.PROPOSITION
           (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF))))
        (WEIGHT
         (CL:IF (CL:= PROPWEIGHT NULL-FLOAT) 1.0d0
          (CL:IF (CL:< PROPWEIGHT 0.1d0) 0.1d0 PROPWEIGHT)))
        (MAXOTHER
         (CL:- TOTWEIGHT
          (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-WEIGHT PARENT) WEIGHT))
        (UNSCALEDCUTOFF
         (CL:- (CL:* PCUTOFF TOTWEIGHT)
          (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-SCORE PARENT) MAXOTHER)))
       (CL:DECLARE
        (CL:TYPE CL:DOUBLE-FLOAT PCUTOFF TOTWEIGHT PROPWEIGHT WEIGHT MAXOTHER
         UNSCALEDCUTOFF))
       (CL:SETQ CUTOFF (CL:/ UNSCALEDCUTOFF WEIGHT))))
     (CL:T
      (CL:SETQ CUTOFF (%INCREMENTAL-PARTIAL-MATCH.DYNAMIC-CUTOFF PARENT))))
    (CL:COND
     ((CL:AND (CL:< CUTOFF 0.0d0)
       (CL:NOT
        (%CONTROL-FRAME.REVERSE-POLARITY?
         (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF))))
      (CL:SETQ CUTOFF 0.0d0))
     ((CL:AND (CL:> CUTOFF 0.0d0)
       (%CONTROL-FRAME.REVERSE-POLARITY?
        (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF)))
      (CL:SETQ CUTOFF 0.0d0))
     ((CL:NOT
       (CL:EQ
        (%CONTROL-FRAME.REVERSE-POLARITY?
         (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF))
        (%CONTROL-FRAME.REVERSE-POLARITY?
         (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME PARENT))))
      (CL:SETQ CUTOFF (CL:- 0 CUTOFF)))))
   CUTOFF))

;;; (DEFMETHOD CLEAR-FRAME-PARTIAL-TRUTH ...)

(CL:DEFMETHOD CLEAR-FRAME-PARTIAL-TRUTH ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.POSITIVE-SCORE SELF) NULL-FLOAT)
  (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.NEGATIVE-SCORE SELF) NULL-FLOAT)
  (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.MAXIMUM-SCORE SELF) 0.0d0))

;;; (DEFMETHOD (PROPOSITION-WEIGHT FLOAT) ...)

(CL:DEFMETHOD PROPOSITION-WEIGHT ((SELF INCREMENTAL-PARTIAL-MATCH) PROPOSITION)
  (CL:COND ((CL:EQ PROPOSITION NULL) 1.0d0)
   ((COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? PROPOSITION)) 0.0d0)
   ((AUXILIARY-EQUIVALENCE-PROPOSITION? PROPOSITION) 0.0d0)
   ((CL:NOT
     (CL:=
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
        SYM-PARTIAL-MATCH-LOGIC-WEIGHT NULL-FLOAT-WRAPPER))
      NULL-FLOAT))
    (%FLOAT-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
      SYM-PARTIAL-MATCH-LOGIC-WEIGHT NULL-FLOAT-WRAPPER)))
   ((CL:NOT
     (CL:EQ
      (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE PROPOSITION)
       (%PROPOSITION.HOME-CONTEXT PROPOSITION) CL:NIL)
      NULL))
    (%TRUTH-VALUE.POSITIVE-SCORE
     (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE PROPOSITION)
      (%PROPOSITION.HOME-CONTEXT PROPOSITION) CL:NIL)))
   (CL:T 1.0d0)))

;;; (DEFMETHOD PUSH-AND-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD PUSH-AND-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH) SCORE WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE WEIGHT))
  #+MCL
  (CL:CHECK-TYPE SCORE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE WEIGHT CL:DOUBLE-FLOAT)
  (CL:WHEN (CL:= WEIGHT NULL-FLOAT) (CL:SETQ WEIGHT 1.0d0))
  (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES SELF)
   (CONS (WRAP-FLOAT SCORE) (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES SELF)))
  (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF)
   (CONS (WRAP-FLOAT WEIGHT)
    (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF)))
  (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
   (CL:+ (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
    (CL:* SCORE WEIGHT)))
  (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-WEIGHT SELF)
   (CL:+ (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-WEIGHT SELF) WEIGHT)))

;;; (DEFMETHOD POP-AND-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD POP-AND-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
   (CL:- (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
    (CL:*
     (%FLOAT-WRAPPER.WRAPPER-VALUE
      (%%VALUE (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES SELF)))
     (%FLOAT-WRAPPER.WRAPPER-VALUE
      (%%VALUE (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF))))))
  (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-WEIGHT SELF)
   (CL:- (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-WEIGHT SELF)
    (%FLOAT-WRAPPER.WRAPPER-VALUE
     (%%VALUE (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF)))))
  (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES SELF)
   (%%REST (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES SELF)))
  (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF)
   (%%REST (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF))))

;;; (DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-AND-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:/ (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
   (%INCREMENTAL-PARTIAL-MATCH.TOTAL-WEIGHT SELF)))

;;; (DEFMETHOD (SKIP-AND-CLAUSE? BOOLEAN) ...)

(CL:DEFMETHOD SKIP-AND-CLAUSE? ((SELF INCREMENTAL-PARTIAL-MATCH) FRAME FORBIDDENVARS)
  (CL:LET*
   ((FORBIDDENVARS? (CL:NOT (CL:EQ FORBIDDENVARS NIL)))
    (FAILUNCONSTRAINEDCLAUSES? *FAIL-UNBOUND-CLAUSES?*)
    (CONJUNCT
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR
       (%VECTOR.THE-ARRAY
        (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION FRAME))))
      (CL:THE CL:FIXNUM (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))))
   (CL:LET* ((TEST-VALUE-000 CL:NIL)) (CL:SETQ TEST-VALUE-000 FORBIDDENVARS?)
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET* ((VAR NULL) (ITER-000 (GET-UNBOUND-VARIABLES CONJUNCT)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ VAR (%%VALUE ITER-000))
        (CL:WHEN (MEMBER? FORBIDDENVARS VAR) (CL:SETQ FOUND?-000 CL:T)
         (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:SETQ TEST-VALUE-000 FOUND?-000)))
    (CL:WHEN (CL:NOT TEST-VALUE-000)
     (CL:SETQ TEST-VALUE-000
      (CL:AND FAILUNCONSTRAINEDCLAUSES? (ALL-VARIABLES-UNBOUND? CONJUNCT))))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((RESULT (CREATE-DOWN-FRAME FRAME CONJUNCT)))
      (SET-FRAME-TRUTH-VALUE RESULT UNKNOWN-TRUTH-VALUE)
      (CL:WHEN (CL:EQ (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT) NULL)
       (CREATE-AND-LINK-PARTIAL-MATCH-FRAME RESULT NULL))
      (SET-FRAME-PARTIAL-TRUTH (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT)
       UNKNOWN-TRUTH-VALUE 0.0d0 NULL-FLOAT CL:T)
      (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
       (CL:SETF (%PRIMITIVE-STRATEGY.INFERENCE-RULE SELF-000)
        KWD-PARTIAL-MATCH-SKIPPED-CONJUNCT)
       (CL:SETF (%PRIMITIVE-STRATEGY.STRATEGY SELF-000)
        KWD-PARTIAL-MATCH-FAILURE)
       (RECORD-GOAL-JUSTIFICATION RESULT SELF-000))
      (CL:SETF (%CONTROL-FRAME.STATE RESULT) KWD-PARTIAL-MATCH-POPPED)
      (CL:LET
       ((SELF
         (%VECTOR.THE-ARRAY
          (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
           SYM-PARTIAL-MATCH-STELLA-ARGUMENTS NULL)))
        (VALUE RESULT) (POSITION (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETF (%CONTROL-FRAME.RESULT FRAME) RESULT)
      (CL:WHEN (TRACE-KEYWORD? KWD-PARTIAL-MATCH-GOAL-TREE)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "*** Skipping clause " CONJUNCT EOL))
      (CL:RETURN-FROM SKIP-AND-CLAUSE? CL:T))))
   CL:NIL))

;;; (DEFMETHOD (CONTINUE-PARTIAL-AND-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-AND-PROOF ((SELF INCREMENTAL-PARTIAL-MATCH) FRAME LASTMOVE)
  (CL:LET* ((FORBIDDENVARS NIL))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-PARTIAL-MATCH-DOWN) (SET-DYNAMIC-CUTOFF SELF))
    ((CL:OR (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-TRUE)
      (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL))
     (CL:LET*
      ((SUCCESS? (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-TRUE))
       (ANDPROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
       (CONJUNCTFRAME (%CONTROL-FRAME.RESULT FRAME))
       (CONJUNCT (%CONTROL-FRAME.PROPOSITION CONJUNCTFRAME))
       (SCORE
        (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE
         (%CONTROL-FRAME.PARTIAL-MATCH-FRAME CONJUNCTFRAME)))
       (WEIGHT (PROPOSITION-WEIGHT SELF CONJUNCT)))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE WEIGHT))
      (CL:SETQ LASTMOVE KWD-PARTIAL-MATCH-UP-TRUE)
      (PUSH-AND-PARTIAL-MATCH-SCORE SELF SCORE WEIGHT)
      (CL:COND
       ((CUTOFF-PARTIAL-MATCH?
         (%CONTROL-FRAME.PARTIAL-MATCH-FRAME CONJUNCTFRAME)
         (TRACE-KEYWORD? KWD-PARTIAL-MATCH-GOAL-TREE))
        (CL:SETQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL))
       ((CL:AND
         (CL:OR
          (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE CONJUNCTFRAME) FALSE-TRUTH-VALUE)
          (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE CONJUNCTFRAME)
           DEFAULT-FALSE-TRUTH-VALUE))
         (CL:OR
          (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE CONJUNCTFRAME) TRUE-TRUTH-VALUE)
          (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE CONJUNCTFRAME)
           FALSE-TRUTH-VALUE)))
        (CL:SETQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL))
       ((CL:AND (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? CONJUNCT))
         (CL:NOT SUCCESS?))
        (CL:SETQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL))
       (CL:T
        (CL:WHEN
         (CL:= (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)
          (CL:1- (LENGTH (%PROPOSITION.ARGUMENTS ANDPROPOSITION))))
         (CL:SETQ SCORE (COMPUTE-AND-SCORE SELF))
         (CL:IF
          (CL:OR (CL:<= SCORE *MINIMUM-SCORE-CUTOFF*)
           (CL:AND (CL:NOT (ALL-ARGUMENTS-BOUND? ANDPROPOSITION))
            (CL:NOT (ALLOW-UNBOUND-VARIABLES? SELF))))
          (CL:SETQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL)
          (SET-FRAME-PARTIAL-TRUTH SELF NULL SCORE NULL-FLOAT CL:NIL)))))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
       LASTMOVE "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:WHEN (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL)
    (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL))
   (CL:LET* ((RESULT (CONTINUE-AND-PROOF FRAME LASTMOVE)))
    (CL:COND
     ((CL:EQ RESULT KWD-PARTIAL-MATCH-MOVE-DOWN)
      (CL:LET*
       ((I NULL-INTEGER) (ITER-000 (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME))
        (UPPER-BOUND-000
         (CL:1- (LENGTH (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES SELF)))))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
       (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
        (CL:SETQ I I) (POP-AND-PARTIAL-MATCH-SCORE SELF)
        (CL:SETQ ITER-000 (CL:1+ ITER-000))))
      (CL:WHEN (SKIP-AND-CLAUSE? SELF FRAME FORBIDDENVARS)
       (CL:SETQ RESULT
        (CONTINUE-PARTIAL-AND-PROOF SELF FRAME KWD-PARTIAL-MATCH-UP-FAIL))))
     ((CL:EQ RESULT KWD-PARTIAL-MATCH-FAILURE)
      (SET-FRAME-PARTIAL-TRUTH SELF (%CONTROL-FRAME.TRUTH-VALUE FRAME)
       NULL-FLOAT NULL-FLOAT CL:NIL))
     (CL:T))
    RESULT)))

;;; (DEFMETHOD PUSH-OR-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD PUSH-OR-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH) SCORE WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE WEIGHT))
  #+MCL
  (CL:CHECK-TYPE SCORE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE WEIGHT CL:DOUBLE-FLOAT)
  (CL:WHEN (CL:= WEIGHT NULL-FLOAT) (CL:SETQ WEIGHT 1.0d0))
  (PUSH-AND-PARTIAL-MATCH-SCORE SELF SCORE WEIGHT)
  (CL:SETQ SCORE (CL:* SCORE WEIGHT))
  (CL:WHEN (CL:> SCORE (%INCREMENTAL-PARTIAL-MATCH.MAXIMUM-SCORE SELF))
   (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.MAXIMUM-SCORE SELF) SCORE)))

;;; (DEFMETHOD POP-OR-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD POP-OR-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:LET*
   ((LATESTSCORE
     (CL:*
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (%%VALUE (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES SELF)))
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (%%VALUE (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF)))))
    (MAXIMUMSCORE (%INCREMENTAL-PARTIAL-MATCH.MAXIMUM-SCORE SELF)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT LATESTSCORE MAXIMUMSCORE))
   (POP-AND-PARTIAL-MATCH-SCORE SELF)
   (CL:WHEN (CL:= LATESTSCORE MAXIMUMSCORE) (CL:SETQ MAXIMUMSCORE 0.0d0)
    (CL:LET*
     ((SCORE NULL)
      (ITER-000 (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES SELF))
      (WEIGHT NULL)
      (ITER-001 (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF)))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-001 NIL))) DO
      (CL:SETQ SCORE (%%VALUE ITER-000)) (CL:SETQ WEIGHT (%%VALUE ITER-001))
      (CL:WHEN
       (CL:>
        (CL:* (%FLOAT-WRAPPER.WRAPPER-VALUE SCORE)
         (%FLOAT-WRAPPER.WRAPPER-VALUE WEIGHT))
        MAXIMUMSCORE)
       (CL:SETQ MAXIMUMSCORE
        (CL:* (%FLOAT-WRAPPER.WRAPPER-VALUE SCORE)
         (%FLOAT-WRAPPER.WRAPPER-VALUE WEIGHT))))
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (%%REST ITER-001))))
    (CL:SETF (%INCREMENTAL-PARTIAL-MATCH.MAXIMUM-SCORE SELF) MAXIMUMSCORE))))

;;; (DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-OR-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH))
  (%INCREMENTAL-PARTIAL-MATCH.MAXIMUM-SCORE SELF))

;;; (DEFMETHOD (CONTINUE-PARTIAL-OR-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-OR-PROOF ((SELF INCREMENTAL-PARTIAL-MATCH) LASTMOVE)
  (CL:LET*
   ((FRAME (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF))
    (ORPROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME)) (RESULT NULL))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-PARTIAL-MATCH-DOWN) (SET-DYNAMIC-CUTOFF SELF))
    ((CL:OR (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-TRUE)
      (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL))
     (CL:LET*
      ((SUCESS? (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-TRUE))
       (RESULT (%CONTROL-FRAME.RESULT FRAME))
       (DISJUNCTS (%PROPOSITION.ARGUMENTS ORPROPOSITION))
       (DISJUNCT
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY DISJUNCTS))
         (CL:THE CL:FIXNUM (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME))))
       (SCORE NULL-FLOAT))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
      (CL:SETQ SCORE
       (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE
        (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT)))
      (PUSH-OR-PARTIAL-MATCH-SCORE SELF SCORE
       (PROPOSITION-WEIGHT SELF DISJUNCT))
      (CL:SETQ SCORE (COMPUTE-OR-SCORE SELF))
      (SET-FRAME-PARTIAL-TRUTH SELF NULL SCORE NULL-FLOAT CL:NIL)
      (CL:COND
       ((CL:OR
         (CL:AND (CL:NOT (ALL-ARGUMENTS-BOUND? DISJUNCT))
          (CL:NOT (ALLOW-UNBOUND-VARIABLES? SELF)))
         (CUTOFF-PARTIAL-MATCH? SELF
          (TRACE-KEYWORD? KWD-PARTIAL-MATCH-GOAL-TREE))
         (CL:AND (CL:NOT SUCESS?)
          (CL:= (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)
           (CL:1- (LENGTH DISJUNCTS)))))
        (SET-FRAME-PARTIAL-TRUTH SELF UNKNOWN-TRUTH-VALUE 0.0d0 NULL-FLOAT
         CL:T)
        (CL:SETQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL))
       (CL:T (CL:SETQ LASTMOVE KWD-PARTIAL-MATCH-UP-TRUE)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
       LASTMOVE "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:SETQ RESULT (CONTINUE-OR-PROOF FRAME LASTMOVE))
   (CL:COND
    ((CL:EQ RESULT KWD-PARTIAL-MATCH-MOVE-DOWN)
     (CL:LET*
      ((I NULL-INTEGER) (ITER-000 (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME))
       (UPPER-BOUND-000
        (CL:1- (LENGTH (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES SELF)))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
      (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
       (CL:SETQ I I) (POP-OR-PARTIAL-MATCH-SCORE SELF)
       (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
    ((CL:EQ RESULT KWD-PARTIAL-MATCH-FAILURE)
     (SET-FRAME-PARTIAL-TRUTH SELF NULL (COMPUTE-OR-SCORE SELF) NULL-FLOAT
      CL:NIL))
    (CL:T))
   RESULT))

;;; (DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-NOT-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:- 0.0d0
   (CL:/ (%INCREMENTAL-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
    (%INCREMENTAL-PARTIAL-MATCH.TOTAL-WEIGHT SELF))))

;;; (DEFMETHOD (CONTINUE-PARTIAL-NOT-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-NOT-PROOF ((SELF INCREMENTAL-PARTIAL-MATCH) LASTMOVE)
  (CL:LET* ((FRAME (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-PARTIAL-MATCH-DOWN) (SET-DYNAMIC-CUTOFF SELF))
    ((CL:OR (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-TRUE)
      (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL))
     (CL:LET*
      ((RESULT (%CONTROL-FRAME.RESULT FRAME))
       (RESULTPMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT)))
      (CL:SETF (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE RESULTPMF)
       (CL:* (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE RESULTPMF)
        (PROPOSITION-WEIGHT RESULTPMF (%CONTROL-FRAME.PROPOSITION RESULT))))
      (PROPAGATE-FRAME-PARTIAL-TRUTH RESULTPMF FRAME)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
       LASTMOVE "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CONTINUE-NOT-PROOF (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF)
    LASTMOVE)))

;;; (DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-GOAL-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH))
  (CL:LET* ((SCORE 0.0d0)) (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
   (CL:COND
    ((CL:EQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-MAX)
     (CL:SETQ SCORE (%INCREMENTAL-PARTIAL-MATCH.MAXIMUM-SCORE SELF)))
    ((CL:EQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-NOISY-OR)
     (CL:SETQ SCORE
      (PROBABILISTIC-SUM-N
       (%INCREMENTAL-PARTIAL-MATCH.ARGUMENT-SCORES SELF))))
    (CL:T))
   SCORE))

;;; (DEFMETHOD (CONTINUE-PARTIAL-STRATEGIES-PROOFS KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-STRATEGIES-PROOFS ((SELF INCREMENTAL-PARTIAL-MATCH) LASTMOVE)
  (CL:LET*
   ((FRAME (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF)) (RESULT NULL))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-PARTIAL-MATCH-DOWN) (SET-DYNAMIC-CUTOFF SELF))
    ((CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL)
     (CL:WHEN (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL))
      (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL)))
    (CL:T))
   (CL:LOOP (CL:SETQ RESULT (CONTINUE-STRATEGIES-PROOFS FRAME LASTMOVE))
    (CL:COND
     ((CL:EQ RESULT KWD-PARTIAL-MATCH-CONTINUING-SUCCESS)
      (CL:IF
       (CUTOFF-PARTIAL-MATCH? SELF
        (TRACE-KEYWORD? KWD-PARTIAL-MATCH-GOAL-TREE))
       (CL:SETQ LASTMOVE KWD-PARTIAL-MATCH-DOWN) (CL:RETURN)))
     (CL:T (CL:RETURN))))
   RESULT))

;;; (DEFMETHOD (CONTINUE-PARTIAL-ANTECEDENTS-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-ANTECEDENTS-PROOF ((SELF INCREMENTAL-PARTIAL-MATCH) LASTMOVE)
  (CL:LET*
   ((FRAME (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF))
    (GOAL (EXTRACT-SUBGOAL-OF-FRAME FRAME)) (SCORE NULL-FLOAT) (RESULT NULL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-PARTIAL-MATCH-DOWN) (SET-DYNAMIC-CUTOFF SELF))
    ((CL:OR (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-TRUE)
      (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL))
     (CL:SETQ SCORE
      (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE
       (%CONTROL-FRAME.PARTIAL-MATCH-FRAME (%CONTROL-FRAME.RESULT FRAME))))
     (PUSH-OR-PARTIAL-MATCH-SCORE SELF SCORE
      (PROPOSITION-WEIGHT SELF
       (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
        SYM-PARTIAL-MATCH-LOGIC-ANTECEDENTS-RULE NULL)))
     (CL:SETQ SCORE (COMPUTE-GOAL-SCORE SELF))
     (SET-FRAME-PARTIAL-TRUTH SELF NULL SCORE NULL-FLOAT CL:NIL)
     (CL:WHEN
      (CL:OR
       (CL:AND (CL:NOT (ALL-ARGUMENTS-BOUND? GOAL))
        (CL:NOT (ALLOW-UNBOUND-VARIABLES? SELF)))
       (CUTOFF-PARTIAL-MATCH? SELF
        (TRACE-KEYWORD? KWD-PARTIAL-MATCH-GOAL-TREE)))
      (SET-FRAME-PARTIAL-TRUTH SELF UNKNOWN-TRUTH-VALUE 0.0d0 NULL-FLOAT CL:T)
      (CL:SETQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
       LASTMOVE "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:WHEN
    (CL:AND (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL)
     (CL:NOT (CL:EQ (%CONTROL-FRAME.DOWN FRAME) NULL)))
    (CL:SETF (%CONTROL-FRAME.DOWN FRAME) NULL))
   (CL:SETQ RESULT (CONTINUE-ANTECEDENTS-PROOF FRAME LASTMOVE))
   (CL:WHEN
    (CL:AND (CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-TRUE)
     (CL:EQ (%CONTROL-FRAME.TRUTH-VALUE FRAME) NULL))
    (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME) UNKNOWN-TRUTH-VALUE))
   RESULT))

;;; (DEFMETHOD (CONTINUE-PARTIAL-FAIL-PROOF KEYWORD) ...)

(CL:DEFMETHOD CONTINUE-PARTIAL-FAIL-PROOF ((SELF INCREMENTAL-PARTIAL-MATCH) LASTMOVE)
  (CL:LET* ((FRAME (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-PARTIAL-MATCH-DOWN) (SET-DYNAMIC-CUTOFF SELF))
    ((CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-TRUE)
     (CL:LET*
      ((RESULT (%CONTROL-FRAME.RESULT FRAME))
       (RESULTPMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT)))
      (CL:SETF (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE RESULTPMF)
       (CL:* (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE RESULTPMF)
        (PROPOSITION-WEIGHT RESULTPMF (%CONTROL-FRAME.PROPOSITION RESULT))
        -1.0d0))
      (PROPAGATE-FRAME-PARTIAL-TRUTH RESULTPMF FRAME)))
    ((CL:EQ LASTMOVE KWD-PARTIAL-MATCH-UP-FAIL)
     (CL:LET*
      ((RESULT (%CONTROL-FRAME.RESULT FRAME))
       (RESULTPMF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME RESULT)))
      (CL:SETF (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE RESULTPMF)
       (CL:IF
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
           SYM-PARTIAL-MATCH-LOGIC-INFERENCE-CUTOFF-REASON NULL)
          NULL))
        0.0d0
        (CL:* (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE RESULTPMF)
         (PROPOSITION-WEIGHT RESULTPMF (%CONTROL-FRAME.PROPOSITION RESULT))
         -1.0d0)))
      (PROPAGATE-FRAME-PARTIAL-TRUTH RESULTPMF FRAME)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
       LASTMOVE "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CONTINUE-FAIL-PROOF (%INCREMENTAL-PARTIAL-MATCH.CONTROL-FRAME SELF)
    LASTMOVE)))

(CL:DEFUN NEW-NN-PARTIAL-MATCH (KIND CONTROL-FRAME)
  (CL:LET* ((SELF NULL)) (CL:SETQ SELF (%MAKE-NN-PARTIAL-MATCH))
   (CL:SETF (%NN-PARTIAL-MATCH.KIND SELF) KIND)
   (CL:SETF (%NN-PARTIAL-MATCH.CONTROL-FRAME SELF) CONTROL-FRAME)
   (CL:SETF (%NN-PARTIAL-MATCH.SUCCESS? SELF) CL:NIL)
   (CL:SETF (%NN-PARTIAL-MATCH.UNBOUND-VARS SELF) NIL)
   (CL:SETF (%NN-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF) NIL)
   (CL:SETF (%NN-PARTIAL-MATCH.ARGUMENT-SCORES SELF) NIL)
   (CL:SETF (%NN-PARTIAL-MATCH.DYNAMIC-CUTOFF SELF) NULL-FLOAT)
   (CL:SETF (%NN-PARTIAL-MATCH.NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%NN-PARTIAL-MATCH.POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%NN-PARTIAL-MATCH.ARITY SELF) NULL-INTEGER)
   (CL:SETF (%NN-PARTIAL-MATCH.RULES SELF) NIL)
   (CL:SETF (%NN-PARTIAL-MATCH.MAXIMUM-SCORE SELF) 0.0d0)
   (CL:SETF (%NN-PARTIAL-MATCH.ACCUMULATED-SCORE SELF) 0.0d0)
   (CL:SETF (%NN-PARTIAL-MATCH.CHILD SELF) NULL)
   (CL:SETF (%NN-PARTIAL-MATCH.PARENT SELF) NULL)
   (INITIALIZE-NN-PARTIAL-MATCH SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF NN-PARTIAL-MATCH))
  SGT-PARTIAL-MATCH-LOGIC-NN-PARTIAL-MATCH)

(CL:DEFUN ACCESS-NN-PARTIAL-MATCH-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-PARENT)
    (CL:IF SETVALUE? (CL:SETF (%NN-PARTIAL-MATCH.PARENT SELF) VALUE)
     (CL:SETQ VALUE (%NN-PARTIAL-MATCH.PARENT SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-CHILD)
    (CL:IF SETVALUE? (CL:SETF (%NN-PARTIAL-MATCH.CHILD SELF) VALUE)
     (CL:SETQ VALUE (%NN-PARTIAL-MATCH.CHILD SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%NN-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%NN-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-MAXIMUM-SCORE)
    (CL:IF SETVALUE?
     (CL:SETF (%NN-PARTIAL-MATCH.MAXIMUM-SCORE SELF)
      (%FLOAT-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%NN-PARTIAL-MATCH.MAXIMUM-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-LOGIC-RULES)
    (CL:IF SETVALUE? (CL:SETF (%NN-PARTIAL-MATCH.RULES SELF) VALUE)
     (CL:SETQ VALUE (%NN-PARTIAL-MATCH.RULES SELF))))
   ((CL:EQ SLOTNAME SYM-PARTIAL-MATCH-STELLA-ARITY)
    (CL:IF SETVALUE?
     (CL:SETF (%NN-PARTIAL-MATCH.ARITY SELF)
      (%INTEGER-WRAPPER.WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%NN-PARTIAL-MATCH.ARITY SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      SLOTNAME "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD INITIALIZE-NN-PARTIAL-MATCH ...)

(CL:DEFMETHOD INITIALIZE-NN-PARTIAL-MATCH ((SELF NN-PARTIAL-MATCH))
  (CL:LET*
   ((PROP
     (%CONTROL-FRAME.PROPOSITION (%NN-PARTIAL-MATCH.CONTROL-FRAME SELF))))
   (CL:SETF (%NN-PARTIAL-MATCH.ARITY SELF)
    (LENGTH (%PROPOSITION.ARGUMENTS PROP)))
   (CL:LET* ((TEST-VALUE-000 (%NN-PARTIAL-MATCH.KIND SELF)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-AND)
       (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-OR))
      (CL:WHEN
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
         SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK NULL)
        NULL)
       (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
        SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK (CREATE-NEURAL-NETWORK PROP)
        NULL)))
     (CL:T)))
   (LINK-TO-PARENT-PARTIAL-MATCH-FRAME SELF) (SET-DYNAMIC-CUTOFF SELF)))

;;; (DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ...)

(CL:DEFMETHOD CREATE-PARTIAL-MATCH-FRAME ((SELF NN-PARTIAL-MATCH) FRAME KIND)
  (NEW-NN-PARTIAL-MATCH KIND FRAME))

;;; (DEFMETHOD (COMPUTE-DYNAMIC-CUTOFF PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-DYNAMIC-CUTOFF ((SELF NN-PARTIAL-MATCH))
  (CL:WHEN (CL:NOT (CL:EQ (%NN-PARTIAL-MATCH.PARENT SELF) NULL))
   (CL:LET* ((TEST-VALUE-000 (%NN-PARTIAL-MATCH.KIND SELF)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-ATOMIC-GOAL)
      (CL:RETURN-FROM COMPUTE-DYNAMIC-CUTOFF
       (%NN-PARTIAL-MATCH.DYNAMIC-CUTOFF (%NN-PARTIAL-MATCH.PARENT SELF))))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-AND)
       (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-OR))
      (CL:LET*
       ((PARENT (%NN-PARTIAL-MATCH.PARENT SELF))
        (NET
         (DYNAMIC-SLOT-VALUE
          (%PROPOSITION.DYNAMIC-SLOTS
           (%CONTROL-FRAME.PROPOSITION
            (%NN-PARTIAL-MATCH.CONTROL-FRAME SELF)))
          SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK NULL))
        (ACTIVE -1.0d0))
       (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ACTIVE))
       (CL:WHEN (CL:> (%NN-PARTIAL-MATCH.DYNAMIC-CUTOFF PARENT) 0.1d0)
        (CL:LET*
         ((INPUT NULL) (VECTOR-000 (%PROPOSITION-NEURAL-NETWORK.INPUT NET))
          (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ INPUT
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:SETQ ACTIVE (CL:+ ACTIVE (%FLOAT-WRAPPER.WRAPPER-VALUE INPUT)))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
        (CL:RETURN-FROM COMPUTE-DYNAMIC-CUTOFF ACTIVE))))
     (CL:T))))
  0.0d0)

;;; (DEFMETHOD (PROPOSITION-WEIGHT FLOAT) ...)

(CL:DEFMETHOD PROPOSITION-WEIGHT ((SELF NN-PARTIAL-MATCH) PROPOSITION)
  (CL:WHEN (CL:EQ PROPOSITION NULL) (CL:RETURN-FROM PROPOSITION-WEIGHT 1.0d0))
  (CL:WHEN (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? PROPOSITION))
   (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
    SYM-PARTIAL-MATCH-LOGIC-WEIGHT (WRAP-FLOAT 0.0d0) NULL-FLOAT-WRAPPER))
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE PROPOSITION)
      (%PROPOSITION.HOME-CONTEXT PROPOSITION) CL:NIL)
     NULL))
   (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
    SYM-PARTIAL-MATCH-LOGIC-WEIGHT
    (WRAP-FLOAT
     (%TRUTH-VALUE.POSITIVE-SCORE
      (ACCESS-IN-CONTEXT (%PROPOSITION.TRUTH-VALUE PROPOSITION)
       (%PROPOSITION.HOME-CONTEXT PROPOSITION) CL:NIL)))
    NULL-FLOAT-WRAPPER))
  (CL:WHEN
   (CL:=
    (%FLOAT-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
      SYM-PARTIAL-MATCH-LOGIC-WEIGHT NULL-FLOAT-WRAPPER))
    NULL-FLOAT)
   (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
    SYM-PARTIAL-MATCH-LOGIC-WEIGHT (WRAP-FLOAT 1.0d0) NULL-FLOAT-WRAPPER))
  (%FLOAT-WRAPPER.WRAPPER-VALUE
   (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
    SYM-PARTIAL-MATCH-LOGIC-WEIGHT NULL-FLOAT-WRAPPER)))

;;; (DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ...)

(CL:DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ((SELF NN-PARTIAL-MATCH) PROP TRUTH)
  (CL:COND
   ((CL:EQ TRUTH KWD-PARTIAL-MATCH-TRUE)
    (CL:IF (CL:NOT (CL:EQ PROP NULL))
     (CL:PROGN
      (CL:IF
       (CL:NOT
        (CL:=
         (%FLOAT-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
           SYM-PARTIAL-MATCH-LOGIC-WEIGHT NULL-FLOAT-WRAPPER))
         NULL-FLOAT))
       (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
        SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE
        (WRAP-FLOAT
         (%FLOAT-WRAPPER.WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
           SYM-PARTIAL-MATCH-LOGIC-WEIGHT NULL-FLOAT-WRAPPER)))
        NULL-FLOAT-WRAPPER)
       (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
        SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE (WRAP-FLOAT 1.0d0)
        NULL-FLOAT-WRAPPER))
      (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
       SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE
       (WRAP-FLOAT
        (%FLOAT-WRAPPER.WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
          SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER)))
       NULL-FLOAT-WRAPPER))
     (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
      SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT 1.0d0)
      NULL-FLOAT-WRAPPER)))
   ((CL:EQ TRUTH KWD-PARTIAL-MATCH-FAIL)
    (CL:WHEN (CL:NOT (CL:EQ PROP NULL))
     (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
      SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE (WRAP-FLOAT 0.0d0)
      NULL-FLOAT-WRAPPER))
    (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
     SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT 0.0d0)
     NULL-FLOAT-WRAPPER))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
      TRUTH "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFMETHOD SET-CACHE-PARTIAL-TRUTH ...)

(CL:DEFMETHOD SET-CACHE-PARTIAL-TRUTH ((SELF NN-PARTIAL-MATCH) CACHE)
  (CL:SETF (%ATOMIC-GOAL-CACHE.POSITIVE-SCORE CACHE)
   (%FLOAT-WRAPPER.WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
     SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE NULL-FLOAT-WRAPPER))))

;;; (DEFMETHOD SET-JUSTIFICATION-PARTIAL-TRUTH ...)

(CL:DEFMETHOD SET-JUSTIFICATION-PARTIAL-TRUTH ((SELF NN-PARTIAL-MATCH) JUSTIFICATION)
  (CL:SETF (%JUSTIFICATION.POSITIVE-SCORE JUSTIFICATION)
   (%FLOAT-WRAPPER.WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
     SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE NULL-FLOAT-WRAPPER))))

;;; (DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ((SELF NN-PARTIAL-MATCH) SCORE WEIGHT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE WEIGHT))
  #+MCL
  (CL:CHECK-TYPE SCORE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE WEIGHT CL:DOUBLE-FLOAT)
  (CL:WHEN (CL:= WEIGHT NULL-FLOAT) (CL:SETQ WEIGHT 1.0d0))
  (CL:SETF (%NN-PARTIAL-MATCH.ARGUMENT-SCORES SELF)
   (CONS (WRAP-FLOAT SCORE) (%NN-PARTIAL-MATCH.ARGUMENT-SCORES SELF)))
  (CL:SETF (%NN-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF)
   (CONS (WRAP-FLOAT WEIGHT) (%NN-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF)))
  (CL:SETF (%NN-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
   (CL:+ (%NN-PARTIAL-MATCH.ACCUMULATED-SCORE SELF) (CL:* SCORE WEIGHT)))
  (CL:WHEN (CL:> SCORE (%NN-PARTIAL-MATCH.MAXIMUM-SCORE SELF))
   (CL:SETF (%NN-PARTIAL-MATCH.MAXIMUM-SCORE SELF) SCORE))
  (CL:LET* ((FRAME (%NN-PARTIAL-MATCH.CONTROL-FRAME SELF)))
   (CL:WHEN
    (CL:AND
     (CL:EQ (%NN-PARTIAL-MATCH.KIND SELF) KWD-PARTIAL-MATCH-ATOMIC-GOAL)
     (CL:EQ (%CONTROL-FRAME.CURRENT-STRATEGY FRAME)
      KWD-PARTIAL-MATCH-FULL-SUBQUERY))
    (CL:LET*
     ((R
       (%ITERATOR.VALUE
        (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
         SYM-PARTIAL-MATCH-STELLA-ITERATOR NULL)))
      (ANTE
       (%DESCRIPTION.PROPOSITION
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%VECTOR.THE-ARRAY (%PROPOSITION.ARGUMENTS R)))
         0))))
     (CL:SETF (%NN-PARTIAL-MATCH.RULES SELF)
      (CONS R (%NN-PARTIAL-MATCH.RULES SELF)))
     (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS ANTE)
      SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE (WRAP-FLOAT SCORE)
      NULL-FLOAT-WRAPPER)))))

;;; (DEFMETHOD POP-PARTIAL-MATCH-SCORE ...)

(CL:DEFMETHOD POP-PARTIAL-MATCH-SCORE ((SELF NN-PARTIAL-MATCH))
  (CL:SETF (%NN-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
   (CL:- (%NN-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
    (CL:*
     (%FLOAT-WRAPPER.WRAPPER-VALUE
      (%%VALUE (%NN-PARTIAL-MATCH.ARGUMENT-SCORES SELF)))
     (%FLOAT-WRAPPER.WRAPPER-VALUE
      (%%VALUE (%NN-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF))))))
  (CL:SETF (%NN-PARTIAL-MATCH.ARGUMENT-SCORES SELF)
   (%%REST (%NN-PARTIAL-MATCH.ARGUMENT-SCORES SELF)))
  (CL:SETF (%NN-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF)
   (%%REST (%NN-PARTIAL-MATCH.ARGUMENT-WEIGHTS SELF))))

;;; (DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-AND-SCORE ((SELF NN-PARTIAL-MATCH))
  (CL:LET*
   ((NET
     (DYNAMIC-SLOT-VALUE
      (%PROPOSITION.DYNAMIC-SLOTS
       (%CONTROL-FRAME.PROPOSITION (%NN-PARTIAL-MATCH.CONTROL-FRAME SELF)))
      SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK NULL)))
   (CL:LET*
    ((SCORE NULL)
     (ITER-000
      (REVERSE (COPY-CONS-LIST (%NN-PARTIAL-MATCH.ARGUMENT-SCORES SELF))))
     (ARG NULL)
     (VECTOR-000
      (%PROPOSITION.ARGUMENTS
       (%CONTROL-FRAME.PROPOSITION (%NN-PARTIAL-MATCH.CONTROL-FRAME SELF))))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:< INDEX-000 LENGTH-000)) DO
     (CL:SETQ SCORE (%%VALUE ITER-000))
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS ARG)
      SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE
      (WRAP-FLOAT (%FLOAT-WRAPPER.WRAPPER-VALUE SCORE)) NULL-FLOAT-WRAPPER)
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:WHEN (CL:NOT (CL:EQ NET NULL))
    (CL:RETURN-FROM COMPUTE-AND-SCORE
     (ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK NET)))
   0.0d0))

;;; (DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-OR-SCORE ((SELF NN-PARTIAL-MATCH))
  (CL:LET*
   ((NET
     (DYNAMIC-SLOT-VALUE
      (%PROPOSITION.DYNAMIC-SLOTS
       (%CONTROL-FRAME.PROPOSITION (%NN-PARTIAL-MATCH.CONTROL-FRAME SELF)))
      SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK NULL)))
   (CL:LET*
    ((SCORE NULL)
     (ITER-000
      (REVERSE (COPY-CONS-LIST (%NN-PARTIAL-MATCH.ARGUMENT-SCORES SELF))))
     (ARG NULL)
     (VECTOR-000
      (%PROPOSITION.ARGUMENTS
       (%CONTROL-FRAME.PROPOSITION (%NN-PARTIAL-MATCH.CONTROL-FRAME SELF))))
     (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:< INDEX-000 LENGTH-000)) DO
     (CL:SETQ SCORE (%%VALUE ITER-000))
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS ARG)
      SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE
      (WRAP-FLOAT (%FLOAT-WRAPPER.WRAPPER-VALUE SCORE)) NULL-FLOAT-WRAPPER)
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:WHEN (CL:NOT (CL:EQ NET NULL))
    (CL:RETURN-FROM COMPUTE-OR-SCORE
     (ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK NET)))
   0.0d0))

;;; (DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-NOT-SCORE ((SELF NN-PARTIAL-MATCH))
  0.0d0)

;;; (DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ...)

(CL:DEFMETHOD COMPUTE-GOAL-SCORE ((SELF NN-PARTIAL-MATCH))
  (CL:LET* ((SCORE 0.0d0)) (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
   (CL:COND
    ((CL:EQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-MAX)
     (CL:SETQ SCORE (%NN-PARTIAL-MATCH.MAXIMUM-SCORE SELF)))
    ((CL:EQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-NOISY-OR)
     (CL:SETQ SCORE
      (PROBABILISTIC-SUM-N (%NN-PARTIAL-MATCH.ARGUMENT-SCORES SELF))))
    (CL:T))
   SCORE))

;;; (DEFUN (PROBABILISTIC-SUM-N FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT) PROBABILISTIC-SUM-N))
(CL:DEFUN PROBABILISTIC-SUM-N (FORM)
  (CL:CASE (LENGTH FORM) (0 0.0d0)
   (1 (%FLOAT-WRAPPER.WRAPPER-VALUE (%%VALUE FORM)))
   (CL:OTHERWISE
    (CL:LET* ((SUM (PROBABILISTIC-SUM-N (%%REST FORM))))
     (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SUM))
     (CL:+ (%FLOAT-WRAPPER.WRAPPER-VALUE (%%VALUE FORM)) SUM
      (CL:- 0 (CL:* (%FLOAT-WRAPPER.WRAPPER-VALUE (%%VALUE FORM)) SUM)))))))

;;; (DEFUN (PROBABILISTIC-SUM FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:DOUBLE-FLOAT CL:DOUBLE-FLOAT) CL:DOUBLE-FLOAT)
  PROBABILISTIC-SUM))
(CL:DEFUN PROBABILISTIC-SUM (X Y)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT X Y))
  #+MCL
  (CL:CHECK-TYPE X CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE Y CL:DOUBLE-FLOAT)
  (CL:+ X Y (CL:- 0 (CL:* X Y))))

;;; (DEFMETHOD (EARLY-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ...)

(CL:DEFMETHOD EARLY-PARTIAL-MATCH-AND-FAILURE? ((SELF NN-PARTIAL-MATCH))
  (PRUNE-NN-SEARCH? SELF))

;;; (DEFMETHOD (EARLY-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ...)

(CL:DEFMETHOD EARLY-PARTIAL-MATCH-OR-SUCCESS? ((SELF NN-PARTIAL-MATCH))
  (PRUNE-NN-SEARCH? SELF))

;;; (DEFUN (PRUNE-NN-SEARCH? BOOLEAN) ...)

(CL:DEFUN PRUNE-NN-SEARCH? (SELF)
  (CL:LET*
   ((MAX-POSSIBLE-ACTIVE
     (CL:+ (%NN-PARTIAL-MATCH.ACCUMULATED-SCORE SELF)
      (CL:- (%NN-PARTIAL-MATCH.ARITY SELF)
       (LENGTH (%NN-PARTIAL-MATCH.ARGUMENT-SCORES SELF))))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MAX-POSSIBLE-ACTIVE))
   (CL:IF
    (CL:AND *GREEDY-NETWORK-PRUNING*
     (CL:NOT (CL:EQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-NOISY-OR))
     (CL:< MAX-POSSIBLE-ACTIVE (%NN-PARTIAL-MATCH.DYNAMIC-CUTOFF SELF)))
    (CL:PROGN
     (CL:WHEN (TRACE-KEYWORD? KWD-PARTIAL-MATCH-GOAL-TREE)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "*** Cutting off search, cutoff: "
       (%NN-PARTIAL-MATCH.DYNAMIC-CUTOFF SELF) "+, Max possible score: "
       MAX-POSSIBLE-ACTIVE EOL))
     CL:T)
    CL:NIL)))

;;; (DEFUN (MAKE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ...)

(CL:DEFUN MAKE-PARTIAL-MATCH-FRAME (QUERY)
  (CL:LET*
   ((MATCHMODE
     (LOOKUP (%QUERY-ITERATOR.OPTIONS QUERY) KWD-PARTIAL-MATCH-MATCH-MODE))
    (FRAME (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERY))
    (KIND (%CONTROL-FRAME.STATE FRAME)))
   (CL:WHEN (CL:EQ MATCHMODE NULL) (CL:SETQ MATCHMODE *PARTIAL-MATCH-MODE*))
   (CL:COND
    ((CL:OR (CL:EQ MATCHMODE KWD-PARTIAL-MATCH-BASIC)
      (CL:EQ MATCHMODE KWD-PARTIAL-MATCH-INCREMENTAL))
     (NEW-INCREMENTAL-PARTIAL-MATCH KIND FRAME))
    ((CL:OR (CL:EQ MATCHMODE KWD-PARTIAL-MATCH-NN)
      (CL:EQ MATCHMODE KWD-PARTIAL-MATCH-NEURAL-NETWORK))
     (NEW-NN-PARTIAL-MATCH KIND FRAME))
    (CL:T
     (CL:LET*
      ((CLASS NULL)
       (CLASSNAME
        (CONCATENATE (%GENERALIZED-SYMBOL.SYMBOL-NAME MATCHMODE)
         "-PARTIAL-MATCH")))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING CLASSNAME))
      (CL:LET* ((TEMP-000 (HOME-MODULE MATCHMODE)))
       (CL:LET*
        ((MODULE (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 *MODULE*)))
        (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
         (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
         (CL:SETQ CLASS (LOOKUP-CLASS CLASSNAME))
         (CL:WHEN (CL:EQ CLASS NULL)
          (CL:SETQ CLASS (GET-OBJECT CLASSNAME NULL))))
        (CL:IF
         (CL:AND (CL:NOT (CL:EQ CLASS NULL))
          (ISA? CLASS SGT-PARTIAL-MATCH-STELLA-CLASS))
         (CREATE-OBJECT (%CLASS.CLASS-TYPE CLASS)
          KWD-PARTIAL-MATCH-CONTROL-FRAME FRAME KWD-PARTIAL-MATCH-KIND KIND)
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
            "PARSING ERROR: Unknown partial match mode: `" MATCHMODE "'." EOL)
           (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-PARTIAL-MATCH-ERROR))
          (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000))))))))))))

;;; (DEFUN INITIALIZE-PARTIAL-QUERY ...)

(CL:DEFUN INITIALIZE-PARTIAL-QUERY (QUERY)
  (CL:LET*
   ((PARTIALMATCHFRAME (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY QUERY)))
   (CL:WHEN (CL:EQ PARTIALMATCHFRAME NULL)
    (CL:SETQ PARTIALMATCHFRAME (MAKE-PARTIAL-MATCH-FRAME QUERY))
    (CL:SETF (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY QUERY)
     PARTIALMATCHFRAME))
   (INITIALIZE-PARTIAL-MATCH-STRATEGY PARTIALMATCHFRAME QUERY)))

;;; (DEFMETHOD INITIALIZE-PARTIAL-MATCH-STRATEGY ...)

(CL:DEFMETHOD INITIALIZE-PARTIAL-MATCH-STRATEGY ((SELF PARTIAL-MATCH-FRAME) QUERY)
  (CL:LET*
   ((MINIMUMSCORE
     (LOOKUP (%QUERY-ITERATOR.OPTIONS QUERY) KWD-PARTIAL-MATCH-MINIMUM-SCORE))
    (EPSILON 0.001d0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT EPSILON))
   (CL:SETF (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY QUERY) SELF)
   (CL:SETF (%PARTIAL-MATCH-FRAME.DYNAMIC-CUTOFF SELF)
    (CL:IF (CL:NOT (CL:EQ MINIMUMSCORE NULL))
     (%FLOAT-WRAPPER.WRAPPER-VALUE MINIMUMSCORE) EPSILON))
   (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS QUERY)
    SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT 0.0d0)
    NULL-FLOAT-WRAPPER)))

;;; (DEFUN CREATE-AND-LINK-PARTIAL-MATCH-FRAME ...)

(CL:DEFUN CREATE-AND-LINK-PARTIAL-MATCH-FRAME (FRAME KIND)
  (CL:LET*
   ((STRATEGY (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY *QUERYITERATOR*))
    (PARTIALMATCHFRAME (CREATE-PARTIAL-MATCH-FRAME STRATEGY FRAME KIND)))
   (CL:SETF (%PARTIAL-MATCH-FRAME.KIND PARTIALMATCHFRAME) KIND)
   (CL:SETF (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME) PARTIALMATCHFRAME)
   (CL:SETF (%PARTIAL-MATCH-FRAME.CONTROL-FRAME PARTIALMATCHFRAME) FRAME)))

;;; (DEFUN (GET-UNBOUND-VARIABLES CONS) ...)

(CL:DEFUN GET-UNBOUND-VARIABLES (PROP)
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROP)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:LET* ((BIND (ARGUMENT-BOUND-TO ARG)))
      (CL:WHEN (CL:EQ BIND NULL) (CL:SETQ RESULT (CONS ARG RESULT))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   RESULT))

;;; (DEFUN (ALL-VARIABLES-UNBOUND? BOOLEAN) ...)

(CL:DEFUN ALL-VARIABLES-UNBOUND? (PROP)
  (CL:LET* ((FOUND?-000 CL:NIL))
   (CL:LET*
    ((VAR NULL) (VECTOR-000 (%PROPOSITION.ARGUMENTS PROP)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ VAR
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:WHEN (CL:NOT (CL:EQ (ARGUMENT-BOUND-TO VAR) NULL))
      (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:IF FOUND?-000 CL:NIL CL:T)))

;;; (DEFUN (UNBOUND-VARIABLES-IN-FRAME? BOOLEAN) ...)

(CL:DEFUN UNBOUND-VARIABLES-IN-FRAME? (FRAME)
  (CL:NOT
   (CL:EQ (GET-UNBOUND-VARIABLES (%CONTROL-FRAME.PROPOSITION FRAME)) NIL)))

;;; (DEFUN RECORD-LATEST-PARTIAL-MATCH-SCORE ...)

(CL:DEFUN RECORD-LATEST-PARTIAL-MATCH-SCORE (FRAME)
  (CL:LET*
   ((PROP NULL)
    (SCORE
     (%FLOAT-WRAPPER.WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
       SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE NULL-FLOAT-WRAPPER)))
    (PFRAME (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
   (CL:LET* ((TEST-VALUE-000 (%CONTROL-FRAME.STATE FRAME)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-AND)
       (CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-OR))
      (CL:SETQ PROP
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%VECTOR.THE-ARRAY
          (%PROPOSITION.ARGUMENTS (%CONTROL-FRAME.PROPOSITION FRAME))))
        (CL:THE CL:FIXNUM (%CONTROL-FRAME.ARGUMENT-CURSOR FRAME)))))
     (CL:T (CL:SETQ PROP (%CONTROL-FRAME.PROPOSITION FRAME)))))
   (CL:WHEN
    (CL:AND (CL:EQ (%PARTIAL-MATCH-FRAME.KIND PFRAME) KWD-PARTIAL-MATCH-AND)
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN (VARIABLE-TYPE? PROP))
     (CL:NOT (%PARTIAL-MATCH-FRAME.SUCCESS? PFRAME)))
    (CL:SETQ *AND-MISSED-A-BINDING* CL:T))
   (CL:WHEN
    (CL:AND (CL:EQ (%PARTIAL-MATCH-FRAME.KIND PFRAME) KWD-PARTIAL-MATCH-AND)
     (CL:= SCORE 0.0d0)
     (CL:EQ (%PROPOSITION.KIND PROP) KWD-PARTIAL-MATCH-FUNCTION)
     (CL:AND
      (ISA? (LAST (%PROPOSITION.ARGUMENTS PROP))
       SGT-PARTIAL-MATCH-LOGIC-PATTERN-VARIABLE)
      (CL:EQ (ARGUMENT-BOUND-TO (LAST (%PROPOSITION.ARGUMENTS PROP))) NULL)))
    (CL:SETF (%PARTIAL-MATCH-FRAME.UNBOUND-VARS PFRAME)
     (CONS (LAST (%PROPOSITION.ARGUMENTS PROP))
      (%PARTIAL-MATCH-FRAME.UNBOUND-VARS PFRAME))))
   (RECORD-PARTIAL-MATCH-SCORE PFRAME
    (%FLOAT-WRAPPER.WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
      SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE NULL-FLOAT-WRAPPER))
    (PROPOSITION-WEIGHT PFRAME PROP))))

;;; (DEFUN (COMPUTE-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ...)

(CL:DEFUN COMPUTE-PARTIAL-MATCH-AND-FAILURE? (FRAME)
  (EARLY-PARTIAL-MATCH-AND-FAILURE? (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))

;;; (DEFUN (COMPUTE-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ...)

(CL:DEFUN COMPUTE-PARTIAL-MATCH-OR-SUCCESS? (FRAME)
  (EARLY-PARTIAL-MATCH-OR-SUCCESS? (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)))

;;; (DEFUN (COMPUTE-PARTIAL-MATCH-SCORE? BOOLEAN) ...)

(CL:DEFUN COMPUTE-PARTIAL-MATCH-SCORE? (FRAME)
  (CL:LET*
   ((PARTIALMATCHFRAME (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME))
    (SCORE NULL-FLOAT))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE))
   (CL:LET* ((TEST-VALUE-000 (%PARTIAL-MATCH-FRAME.KIND PARTIALMATCHFRAME)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-AND)
      (CL:SETQ SCORE (COMPUTE-AND-SCORE PARTIALMATCHFRAME)))
     ((CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-OR)
      (CL:SETQ SCORE (COMPUTE-OR-SCORE PARTIALMATCHFRAME)))
     ((CL:EQ TEST-VALUE-000 KWD-PARTIAL-MATCH-ATOMIC-GOAL)
      (CL:SETQ SCORE (COMPUTE-GOAL-SCORE PARTIALMATCHFRAME)))
     (CL:T)))
   (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS *QUERYITERATOR*)
    SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT SCORE)
    NULL-FLOAT-WRAPPER)
   (CL:SETF (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE PARTIALMATCHFRAME) SCORE)
   (SET-DYNAMIC-SLOT-VALUE
    (%PROPOSITION.DYNAMIC-SLOTS (%CONTROL-FRAME.PROPOSITION FRAME))
    SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE (WRAP-FLOAT SCORE) NULL-FLOAT-WRAPPER)
   (CL:IF (UNBOUND-VARIABLES-IN-FRAME? FRAME) CL:NIL
    (> SCORE *MINIMUM-SCORE-CUTOFF*))))

;;; (DEFUN (RETRIEVE-PARTIAL QUERY-ITERATOR) ...)

(CL:DEFUN %RETRIEVE-PARTIAL (TREE)
  "Partial-match version of `retrieve' (which see) that generates scored
partial solutions based on the current partial match strategy.  By supplying
`BEST' instead of `ALL', or by adding the option `:SORT-BY :SCORE', the generated
solutions will be sorted so that solutions with higher scores come first.
Use the `:MATCH-MODE' option to override the global default setting established
by `set-partial-match-mode', e.g., use `:MATCH-MODE :NN' to use the neural
net partial match mode.  The `:MINIMUM-SCORE' option can be used to only
retrieve solutions that have at least the specified minimum match score.
By default, `retrieve-partial' does not maximize the match scores of its returned
bindings.  To only get maximal scores use `:MAXIMIZE-SCORE? TRUE' (this is not
yet implemented - you can use `ask-partial' to maximize scores for individual
solutions by hand)."
  (CL:HANDLER-CASE
   (CL:RETURN-FROM %RETRIEVE-PARTIAL
    (CL:SETQ *MOST-RECENT-QUERY* (CALL-RETRIEVE-PARTIAL TREE)))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))
    (CL:SETQ *MOST-RECENT-QUERY* NULL))))

(CL:DEFUN RETRIEVE-PARTIAL-EVALUATOR-WRAPPER (ARGUMENTS)
  (%RETRIEVE-PARTIAL ARGUMENTS))

(CL:DEFMACRO RETRIEVE-PARTIAL (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Partial-match version of `retrieve' (which see) that generates scored
partial solutions based on the current partial match strategy.  By supplying
`BEST' instead of `ALL', or by adding the option `:SORT-BY :SCORE', the generated
solutions will be sorted so that solutions with higher scores come first.
Use the `:MATCH-MODE' option to override the global default setting established
by `set-partial-match-mode', e.g., use `:MATCH-MODE :NN' to use the neural
net partial match mode.  The `:MINIMUM-SCORE' option can be used to only
retrieve solutions that have at least the specified minimum match score.
By default, `retrieve-partial' does not maximize the match scores of its returned
bindings.  To only get maximal scores use `:MAXIMIZE-SCORE? TRUE' (this is not
yet implemented - you can use `ask-partial' to maximize scores for individual
solutions by hand)."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/RETRIEVE-PARTIAL|)) (CL:MACRO-FUNCTION (CL:QUOTE RETRIEVE-PARTIAL)))

;;; (DEFUN (CALL-RETRIEVE-PARTIAL QUERY-ITERATOR) ...)

(CL:DEFUN CALL-RETRIEVE-PARTIAL (QUERY)
  "Callable version of `retrieve-partial' (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to `retrieve-partial'.  Raises LOGIC-EXCEPTIONs in case of
illegal queries and logical expressions."
  (CL:LET* ((THEQUERY (CREATE-RETRIEVE-QUERY QUERY)))
   (INITIALIZE-PARTIAL-QUERY THEQUERY)
   (RETRIEVE-PARTIAL-SOLUTIONS
    (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY THEQUERY) THEQUERY)
   (CL:WHEN
    (CL:EQ (LOOKUP-QUERY-OPTION THEQUERY KWD-PARTIAL-MATCH-SORT-BY)
     KWD-PARTIAL-MATCH-SCORE)
    (SORT-SOLUTIONS-BY-SCORE THEQUERY))
   THEQUERY))

;;; (DEFMETHOD (RETRIEVE-PARTIAL-SOLUTIONS QUERY-ITERATOR) ...)

(CL:DEFMETHOD RETRIEVE-PARTIAL-SOLUTIONS ((SELF PARTIAL-MATCH-FRAME) QUERY)
  (CL:SETQ QUERY QUERY)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "Don't know how to retrieve partial solutions for `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (RETRIEVE-PARTIAL-SOLUTIONS QUERY-ITERATOR) ...)

(CL:DEFMETHOD RETRIEVE-PARTIAL-SOLUTIONS ((SELF INCREMENTAL-PARTIAL-MATCH) QUERY)
  (CL:LET*
   ((MAXIMIZESCORE?
     (LOOKUP-QUERY-OPTION QUERY KWD-PARTIAL-MATCH-MAXIMIZE-SCORE?)))
   (CL:WHEN (CL:EQ MAXIMIZESCORE? TRUE-WRAPPER)
    (CL:WARN
     ":MAXIMIZE-SCORE? option not yet implemented for partial retrieval in incremental partial match mode - ignoring it."))
   (CL:LET*
    ((*QUERYITERATOR* QUERY) (*REVERSEPOLARITY?* CL:NIL)
     (*GENERATE-ALL-PROOFS?* CL:NIL)
     (*INFERENCELEVEL* (CURRENT-INFERENCE-LEVEL)))
    (CL:DECLARE
     (CL:SPECIAL *QUERYITERATOR* *REVERSEPOLARITY?* *GENERATE-ALL-PROOFS?*
      *INFERENCELEVEL*))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-000 1)
      (UPPER-BOUND-000 (LOOKUP-HOW-MANY-SOLUTIONS QUERY))
      (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)) (SOLUTION NULL)
      (ITER-001 QUERY))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:AND (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000))
       (NEXT? ITER-001))
      DO (CL:SETQ I ITER-000)
      (CL:SETQ SOLUTION (%QUERY-ITERATOR.VALUE ITER-001))
      (CL:PROGN (CL:SETQ SOLUTION SOLUTION) (CL:SETQ I I))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    QUERY)))

;;; (DEFUN SORT-SOLUTIONS-BY-SCORE ...)

(CL:DEFUN SORT-SOLUTIONS-BY-SCORE (QUERY)
  (SORT (%QUERY-ITERATOR.SOLUTIONS QUERY)
   (CL:FUNCTION SOLUTION-SCORE-GREATER-THAN?)))

;;; (DEFUN (SOLUTION-SCORE-GREATER-THAN? BOOLEAN) ...)

(CL:DEFUN SOLUTION-SCORE-GREATER-THAN? (S1 S2)
  (> (%QUERY-SOLUTION.MATCH-SCORE S1) (%QUERY-SOLUTION.MATCH-SCORE S2)))

;;; (DEFUN (ASK-PARTIAL FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:&REST CL:T) CL:DOUBLE-FLOAT) %ASK-PARTIAL))
(CL:DEFUN %ASK-PARTIAL (|PROPOSITION&OPTIONS|)
  "Similar to `ask' (which see), but return the highest partial match score
for the supplied proposition instead of a truth value.  If the option
:MAXIMIZE-SCORE? is set to FALSE, return after the first partial match score
has been generated."
  (CL:SETQ *MOST-RECENT-QUERY* NULL)
  (CL:HANDLER-CASE
   (CL:RETURN-FROM %ASK-PARTIAL (CALL-ASK-PARTIAL |PROPOSITION&OPTIONS|))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-ERROR)
     (EXCEPTION-MESSAGE E))
    (CL:SETQ *MOST-RECENT-QUERY* NULL) NULL-FLOAT)))

(CL:DEFUN ASK-PARTIAL-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET* ((RESULT (%ASK-PARTIAL ARGUMENTS)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:IF (CL:NOT (CL:= RESULT NULL-FLOAT)) (WRAP-FLOAT RESULT) NULL)))

(CL:DEFMACRO ASK-PARTIAL (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Similar to `ask' (which see), but return the highest partial match score
for the supplied proposition instead of a truth value.  If the option
:MAXIMIZE-SCORE? is set to FALSE, return after the first partial match score
has been generated."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ASK-PARTIAL|)) (CL:MACRO-FUNCTION (CL:QUOTE ASK-PARTIAL)))

;;; (DEFUN (RETURN-PARTIAL-TRUTH FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:DOUBLE-FLOAT) RETURN-PARTIAL-TRUTH))
(CL:DEFUN RETURN-PARTIAL-TRUTH (QUERY TOP?)
  (CL:WHEN (CL:NOT TOP?)
   (INSERT-AT (%QUERY-ITERATOR.OPTIONS QUERY)
    KWD-PARTIAL-MATCH-MAXIMIZE-SCORE? (CL:IF TOP? TRUE-WRAPPER FALSE-WRAPPER)))
  (CALL-ASK-PARTIAL QUERY))

;;; (DEFUN (CALL-ASK-PARTIAL FLOAT) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT) CALL-ASK-PARTIAL))
(CL:DEFUN CALL-ASK-PARTIAL (QUERY)
  (CL:LET* ((THEQUERY (CREATE-ASK-QUERY QUERY)))
   (INITIALIZE-PARTIAL-QUERY THEQUERY)
   (CL:WHEN (CL:EQ *MOST-RECENT-QUERY* NULL)
    (CL:SETQ *MOST-RECENT-QUERY* THEQUERY))
   (COMPUTE-PARTIAL-TRUTH (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY THEQUERY)
    THEQUERY)))

;;; (DEFMETHOD (COMPUTE-PARTIAL-TRUTH FLOAT) ...)

(CL:DEFMETHOD COMPUTE-PARTIAL-TRUTH ((SELF PARTIAL-MATCH-FRAME) QUERY)
  (CL:SETQ QUERY QUERY)
  (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
   (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
    "Don't know how to compute partial truth for `" SELF "'")
   (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))

;;; (DEFMETHOD (COMPUTE-PARTIAL-TRUTH FLOAT) ...)

(CL:DEFMETHOD COMPUTE-PARTIAL-TRUTH ((SELF INCREMENTAL-PARTIAL-MATCH) QUERY)
  (CL:LET*
   ((BASEFRAME (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERY))
    (PARTIALMATCHFRAME (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY QUERY))
    (MINIMUMSCORE
     (LOOKUP (%QUERY-ITERATOR.OPTIONS QUERY) KWD-PARTIAL-MATCH-MINIMUM-SCORE))
    (MAXIMIZESCORE?
     (CL:NOT
      (EQL?
       (LOOKUP (%QUERY-ITERATOR.OPTIONS QUERY)
        KWD-PARTIAL-MATCH-MAXIMIZE-SCORE?)
       FALSE-WRAPPER)))
    (EPSILON 0.001d0) (LATESTSCORE 0.0d0) (HIGHESTSCORE 0.0d0)
    (BESTJUSTIFICATION NULL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT EPSILON LATESTSCORE HIGHESTSCORE))
   (CL:WHEN (CL:EQ PARTIALMATCHFRAME NULL) (CL:SETQ PARTIALMATCHFRAME SELF)
    (CL:SETF (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY QUERY) SELF))
   (CL:SETF (%PARTIAL-MATCH-FRAME.DYNAMIC-CUTOFF PARTIALMATCHFRAME)
    (CL:IF (CL:NOT (CL:EQ MINIMUMSCORE NULL))
     (%FLOAT-WRAPPER.WRAPPER-VALUE MINIMUMSCORE) EPSILON))
   (CL:LET*
    ((*QUERYITERATOR* QUERY) (*GENERATE-ALL-PROOFS?* CL:T)
     (*INFERENCELEVEL* (CURRENT-INFERENCE-LEVEL)) (*REVERSEPOLARITY?* CL:NIL))
    (CL:DECLARE
     (CL:SPECIAL *QUERYITERATOR* *GENERATE-ALL-PROOFS?* *INFERENCELEVEL*
      *REVERSEPOLARITY?*))
    (CL:LOOP (CL:WHEN (CL:NOT (NEXT? QUERY)) (CL:RETURN))
     (CL:SETQ LATESTSCORE
      (%PARTIAL-MATCH-FRAME.POSITIVE-SCORE PARTIALMATCHFRAME))
     (CL:WHEN (CL:<= LATESTSCORE HIGHESTSCORE) (CL:RETURN))
     (CL:SETQ BESTJUSTIFICATION
      (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS BASEFRAME)
       SYM-PARTIAL-MATCH-LOGIC-JUSTIFICATION NULL))
     (CL:SETQ HIGHESTSCORE LATESTSCORE)
     (CL:SETF (%PARTIAL-MATCH-FRAME.DYNAMIC-CUTOFF PARTIALMATCHFRAME)
      (CL:+ HIGHESTSCORE EPSILON))
     (CL:WHEN
      (CL:OR (CL:NOT MAXIMIZESCORE?)
       (KNOWN-TRUTH-VALUE? (%CONTROL-FRAME.TRUTH-VALUE BASEFRAME)))
      (CL:RETURN))))
   (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS BASEFRAME)
    SYM-PARTIAL-MATCH-LOGIC-JUSTIFICATION BESTJUSTIFICATION NULL)
   HIGHESTSCORE))

;;; (DEFMETHOD (COMPUTE-PARTIAL-TRUTH FLOAT) ...)

(CL:DEFMETHOD COMPUTE-PARTIAL-TRUTH ((SELF NN-PARTIAL-MATCH) QUERY)
  (CL:LET*
   ((PROPOSITION
     (%CONTROL-FRAME.PROPOSITION (%QUERY-ITERATOR.BASE-CONTROL-FRAME QUERY)))
    (PARTIALMATCHFRAME (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY QUERY))
    (MINIMUMSCORE
     (LOOKUP (%QUERY-ITERATOR.OPTIONS QUERY) KWD-PARTIAL-MATCH-MINIMUM-SCORE))
    (MAXIMIZESCORE?
     (CL:NOT
      (EQL?
       (LOOKUP (%QUERY-ITERATOR.OPTIONS QUERY)
        KWD-PARTIAL-MATCH-MAXIMIZE-SCORE?)
       FALSE-WRAPPER)))
    (EPSILON 0.001d0) (LATESTSCORE 0.0d0) (HIGHESTSCORE 0.0d0)
    (SCORELIST (NEW-LIST)) (WEIGHT 0.0d0) (NETLIST NULL) (ACTIVATIONLIST NULL)
    (SUPPORT NULL))
   (CL:DECLARE
    (CL:TYPE CL:DOUBLE-FLOAT EPSILON LATESTSCORE HIGHESTSCORE WEIGHT))
   (CL:WHEN (CL:EQ PARTIALMATCHFRAME NULL) (CL:SETQ PARTIALMATCHFRAME SELF)
    (CL:SETF (%QUERY-ITERATOR.PARTIAL-MATCH-STRATEGY QUERY) SELF))
   (CL:SETF (%PARTIAL-MATCH-FRAME.DYNAMIC-CUTOFF PARTIALMATCHFRAME)
    (CL:IF (CL:NOT (CL:EQ MINIMUMSCORE NULL))
     (%FLOAT-WRAPPER.WRAPPER-VALUE MINIMUMSCORE) EPSILON))
   (CL:SETQ *ACTIVATED-NETWORKS* (NEW-LIST))
   (CL:LET* ((*QUERYITERATOR* QUERY))
    (CL:DECLARE (CL:SPECIAL *QUERYITERATOR*))
    (CL:LOOP
     (SET-DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS QUERY)
      SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE (WRAP-FLOAT 0.0d0)
      NULL-FLOAT-WRAPPER)
     (CL:WHEN (CL:NOT (NEXT? QUERY)) (CL:RETURN))
     (CL:SETQ LATESTSCORE
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%QUERY-ITERATOR.DYNAMIC-SLOTS QUERY)
        SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE NULL-FLOAT-WRAPPER)))
     (CL:WHEN (MEMBER? SCORELIST (WRAP-FLOAT LATESTSCORE)) (CL:RETURN))
     (CL:WHEN (CL:> LATESTSCORE HIGHESTSCORE)
      (CL:SETQ SUPPORT (SUPPORT PROPOSITION))
      (CL:SETQ ACTIVATIONLIST (NEW-LIST))
      (CL:SETQ NETLIST *ACTIVATED-NETWORKS*)
      (CL:LET*
       ((NET NULL) (ITER-000 (%LIST.THE-CONS-LIST *ACTIVATED-NETWORKS*)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ NET (%%VALUE ITER-000))
        (CL:LET* ((PROPSCORES (NEW-LIST)))
         (CL:LET*
          ((PROP NULL)
           (VECTOR-000
            (%PROPOSITION.ARGUMENTS
             (%PROPOSITION-NEURAL-NETWORK.PROPOSITION NET)))
           (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
          (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
           (CL:SETQ PROP
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:IF (CL:EQ COLLECT-000 NULL)
            (CL:PROGN
             (CL:SETQ COLLECT-000
              (CONS
               (WRAP-FLOAT
                (%FLOAT-WRAPPER.WRAPPER-VALUE
                 (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
                  SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER)))
               NIL))
             (CL:IF (CL:EQ (%LIST.THE-CONS-LIST PROPSCORES) NIL)
              (CL:SETF (%LIST.THE-CONS-LIST PROPSCORES) COLLECT-000)
              (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST PROPSCORES)
               COLLECT-000)))
            (CL:PROGN
             (CL:SETF (%%REST COLLECT-000)
              (CONS
               (WRAP-FLOAT
                (%FLOAT-WRAPPER.WRAPPER-VALUE
                 (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
                  SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER)))
               NIL))
             (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
         (PUSH ACTIVATIONLIST PROPSCORES))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:SETQ ACTIVATIONLIST (REVERSE ACTIVATIONLIST)))
     (CL:SETQ WEIGHT
      (%FLOAT-WRAPPER.WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
        SYM-PARTIAL-MATCH-LOGIC-WEIGHT NULL-FLOAT-WRAPPER)))
     (CL:WHEN (CL:NOT (CL:= WEIGHT NULL-FLOAT))
      (CL:SETQ LATESTSCORE (CL:* LATESTSCORE WEIGHT)))
     (CL:WHEN (CL:> LATESTSCORE HIGHESTSCORE)
      (CL:SETQ HIGHESTSCORE LATESTSCORE))
     (CL:SETF (%PARTIAL-MATCH-FRAME.DYNAMIC-CUTOFF PARTIALMATCHFRAME)
      (CL:+ HIGHESTSCORE EPSILON))
     (CL:WHEN (CL:OR (CL:NOT MAXIMIZESCORE?) (CL:= HIGHESTSCORE 1.0d0))
      (CL:RETURN))
     (PUSH SCORELIST (WRAP-FLOAT LATESTSCORE))))
   (CL:WHEN (CL:NOT (CL:EQ SUPPORT NULL))
    (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROPOSITION)
     SYM-PARTIAL-MATCH-LOGIC-SUPPORT SUPPORT NULL)
    (CL:LET*
     ((NET NULL) (ITER-001 (%LIST.THE-CONS-LIST (REVERSE NETLIST)))
      (SCORELIST NULL)
      (ITER-002 (%LIST.THE-CONS-LIST (REVERSE ACTIVATIONLIST))))
     (CL:LOOP WHILE
      (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL))) DO
      (CL:SETQ NET (%%VALUE ITER-001)) (CL:SETQ SCORELIST (%%VALUE ITER-002))
      (CL:LET*
       ((PROP NULL)
        (VECTOR-001
         (%PROPOSITION.ARGUMENTS
          (%PROPOSITION-NEURAL-NETWORK.PROPOSITION NET)))
        (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)) (K NULL)
        (ITER-003 (%LIST.THE-CONS-LIST SCORELIST)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:NOT (CL:EQ ITER-003 NIL))) DO
        (CL:SETQ PROP
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:SETQ K (%%VALUE ITER-003))
        (SET-DYNAMIC-SLOT-VALUE (%PROPOSITION.DYNAMIC-SLOTS PROP)
         SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE
         (WRAP-FLOAT (%FLOAT-WRAPPER.WRAPPER-VALUE K)) NULL-FLOAT-WRAPPER)
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
        (CL:SETQ ITER-003 (%%REST ITER-003))))
      (CL:SETQ ITER-001 (%%REST ITER-001))
      (CL:SETQ ITER-002 (%%REST ITER-002)))))
   HIGHESTSCORE))

;;; (DEFUN (NULL-INSTANCE? BOOLEAN) ...)

(CL:DEFUN NULL-INSTANCE? (X)
  (CL:EQ (OBJECT-SURROGATE X) SGT-PARTIAL-MATCH-PL-KERNEL-KB-NULL))

;;; (DEFUN (GET-NULL-INSTANCE LOGIC-OBJECT) ...)

(CL:DEFUN GET-NULL-INSTANCE ()
  (%SURROGATE.SURROGATE-VALUE SGT-PARTIAL-MATCH-PL-KERNEL-KB-NULL))

;;; (DEFUN (NULL-INSTANCE-PROPOSITIONS-EXIST? BOOLEAN) ...)

(CL:DEFUN NULL-INSTANCE-PROPOSITIONS-EXIST? ()
  (CL:LET* ((INDEX (GET-BACKLINKS-INDEX (GET-NULL-INSTANCE))))
   (CL:OR
    (CL:NOT
     (CL:EQ (%BACKLINKS-INDEX.PREDICATE-PROPOSITIONS-TABLE INDEX) NULL))
    (CL:NOT (EMPTY? (%BACKLINKS-INDEX.DEPENDENT-PROPOSITIONS-LIST INDEX))))))

;;; (DEFUN (ALL-MATCHING-PARTIAL-PROPOSITIONS (ITERATOR OF PROPOSITION)) ...)

(CL:DEFUN ALL-MATCHING-PARTIAL-PROPOSITIONS (SELF)
  (CL:LET*
   ((PATTERN
     (CONS KWD-PARTIAL-MATCH-RELATION
      (CONS (CL:IF (CL:EQ NIL NULL) NIL NIL)
       (CONS (%PROPOSITION.OPERATOR SELF) (CONS (GET-NULL-INSTANCE) NIL))))))
   (CL:LET* ((SELF-000 (NEW-SPECIALIZING-PROPOSITIONS-ITERATOR)))
    (CL:SETF (%SPECIALIZING-PROPOSITIONS-ITERATOR.SELECTION-PATTERN SELF-000)
     PATTERN)
    (CL:SETF (%SPECIALIZING-PROPOSITIONS-ITERATOR.PROPOSITION-CURSOR SELF-000)
     (ALLOCATE-ITERATOR (SELECT-PROPOSITIONS PATTERN)))
    (CL:LET* ((VALUE-000 SELF-000)) VALUE-000))))

;;; (DEFUN (PARTIAL-ARGUMENTS-UNIFY-WITH-ARGUMENTS? BOOLEAN) ...)

(CL:DEFUN PARTIAL-ARGUMENTS-UNIFY-WITH-ARGUMENTS? (SUBPROPOSITION REFERENCEPROPOSITION)
  (CL:LET*
   ((PATTERNRECORD (%QUERY-ITERATOR.CURRENT-PATTERN-RECORD *QUERYITERATOR*))
    (UBSTACKOFFSET (%PATTERN-RECORD.TOP-UNBINDING-STACK-OFFSET PATTERNRECORD))
    (SUCCESS? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET*
      ((SUPERARG NULL)
       (VECTOR-000 (%PROPOSITION.ARGUMENTS REFERENCEPROPOSITION))
       (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (SUBARG NULL)
       (VECTOR-001 (%PROPOSITION.ARGUMENTS SUBPROPOSITION)) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)))
      (CL:DECLARE
       (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
      (CL:LOOP WHILE
       (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
       (CL:SETQ SUPERARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:SETQ SUBARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
         INDEX-001))
       (CL:WHEN
        (CL:NOT
         (CL:OR (NULL-INSTANCE? SUBARG) (NULL-INSTANCE? SUPERARG)
          (BIND-ARGUMENT-TO-VALUE? SUPERARG (VALUE-OF SUBARG) CL:NIL)))
        (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
     (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
    (CL:WHEN TEST-VALUE-000
     (CL:SETQ TEST-VALUE-000
      (CL:= (LENGTH (%PROPOSITION.ARGUMENTS REFERENCEPROPOSITION))
       (LENGTH (%PROPOSITION.ARGUMENTS SUBPROPOSITION)))))
    (CL:SETQ SUCCESS? TEST-VALUE-000))
   (CL:WHEN (CL:NOT SUCCESS?)
    (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD (CL:1+ UBSTACKOFFSET)))
   SUCCESS?))

;;; (DEFUN (TRY-SCAN-PARTIAL-PROPOSITIONS-PROOF KEYWORD) ...)

(CL:DEFUN TRY-SCAN-PARTIAL-PROPOSITIONS-PROOF (FRAME)
  (CL:LET*
   ((PROPOSITION (%CONTROL-FRAME.PROPOSITION FRAME))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
      SYM-PARTIAL-MATCH-STELLA-ITERATOR NULL))
    (RESULT KWD-PARTIAL-MATCH-FAILURE))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:SETQ ITERATOR (ALL-MATCHING-PARTIAL-PROPOSITIONS PROPOSITION))
    (SET-DYNAMIC-SLOT-VALUE (%CONTROL-FRAME.DYNAMIC-SLOTS FRAME)
     SYM-PARTIAL-MATCH-STELLA-ITERATOR ITERATOR NULL))
   (CL:WHEN (CL:NOT (CL:EQ ITERATOR NULL))
    (CL:LOOP WHILE (NEXT? ITERATOR) DO
     (CL:WHEN
      (PARTIAL-ARGUMENTS-UNIFY-WITH-ARGUMENTS? (%ITERATOR.VALUE ITERATOR)
       PROPOSITION)
      (CL:SETQ RESULT KWD-PARTIAL-MATCH-CONTINUING-SUCCESS) (CL:RETURN))))
   (CL:WHEN (CL:NOT (CL:EQ RESULT KWD-PARTIAL-MATCH-FAILURE))
    (CL:LET*
     ((TRUTHVALUE (PROPOSITIONS-ITERATOR-TRUTH-VALUE ITERATOR))
      (WEIGHT
       (%FLOAT-WRAPPER.WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         (%PROPOSITION.DYNAMIC-SLOTS (%ITERATOR.VALUE ITERATOR))
         SYM-PARTIAL-MATCH-LOGIC-WEIGHT NULL-FLOAT-WRAPPER))))
     (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT WEIGHT))
     (CL:SETF (%CONTROL-FRAME.TRUTH-VALUE FRAME) UNKNOWN-TRUTH-VALUE)
     (CL:WHEN (CL:= WEIGHT NULL-FLOAT) (CL:SETQ WEIGHT 1.0d0))
     (SET-FRAME-PARTIAL-TRUTH (%CONTROL-FRAME.PARTIAL-MATCH-FRAME FRAME)
      UNKNOWN-TRUTH-VALUE
      (CL:* (%TRUTH-VALUE.POSITIVE-SCORE TRUTHVALUE) WEIGHT) NULL-FLOAT
      CL:T)))
   RESULT))

(CL:DEFUN HELP-STARTUP-PARTIAL-MATCH1 ()
  (CL:PROGN
   (CL:SETQ KWD-PARTIAL-MATCH-BASIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BASIC" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SET-PARTIAL-MATCH-MODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-PARTIAL-MATCH-MODE" NULL 0))
   (CL:SETQ KWD-PARTIAL-MATCH-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-MAX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAX" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-KIND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIND" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-PARENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARENT" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-CHILD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHILD" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SCORE" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-NEGATIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEGATIVE-SCORE" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-DYNAMIC-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DYNAMIC-CUTOFF" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-SCORES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-SCORES" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ARGUMENT-WEIGHTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENT-WEIGHTS" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-UNBOUND-VARS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNBOUND-VARS" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SUCCESS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUCCESS?" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SET-RULE-COMBINATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-RULE-COMBINATION" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SET-GREEDY-NETWORK-PRUNING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-GREEDY-NETWORK-PRUNING" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SET-MAXIMUM-SCORE-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-MAXIMUM-SCORE-CUTOFF" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SET-MINIMUM-SCORE-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-MINIMUM-SCORE-CUTOFF" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-LATEST-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LATEST-POSITIVE-SCORE" NULL 0))
   (CL:SETQ KWD-PARTIAL-MATCH-CONTROL-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTROL-FRAME" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-KIND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIND" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-UP-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-UP-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FAIL" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ SGT-PARTIAL-MATCH-LOGIC-INCREMENTAL-PARTIAL-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCREMENTAL-PARTIAL-MATCH" NULL 1))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACCUMULATED-SCORE" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ACCUMULATED-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ACCUMULATED-WEIGHT" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-TOTAL-WEIGHT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOTAL-WEIGHT" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-MAXIMUM-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMUM-SCORE" NULL 0))
   (CL:SETQ KWD-PARTIAL-MATCH-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-SKIPPED-CONJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKIPPED-CONJUNCT" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-POPPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POPPED" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-STELLA-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-PARTIAL-MATCH-GOAL-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-MOVE-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MOVE-DOWN" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-NOISY-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOISY-OR" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-CONTINUING-SUCCESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUING-SUCCESS" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ANTECEDENTS-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS-RULE" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-INFERENCE-CUTOFF-REASON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-CUTOFF-REASON" NULL 0))
   (CL:SETQ SGT-PARTIAL-MATCH-LOGIC-NN-PARTIAL-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NN-PARTIAL-MATCH" NULL 1))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RULES" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-STELLA-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARITY" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ KWD-PARTIAL-MATCH-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-NEURAL-NETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEURAL-NETWORK" NULL 0))
   (CL:SETQ KWD-PARTIAL-MATCH-ATOMIC-GOAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ATOMIC-GOAL" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-MATCH-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-SCORE" NULL 0))
   (CL:SETQ KWD-PARTIAL-MATCH-FULL-SUBQUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULL-SUBQUERY" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-STELLA-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-PARTIAL-MATCH-MATCH-MODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-MODE" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-INCREMENTAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCREMENTAL" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-NN (INTERN-RIGID-SYMBOL-WRT-MODULE "NN" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-NEURAL-NETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEURAL-NETWORK" NULL 2))
   (CL:SETQ SGT-PARTIAL-MATCH-STELLA-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASS" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ KWD-PARTIAL-MATCH-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))))

(CL:DEFUN HELP-STARTUP-PARTIAL-MATCH2 ()
  (CL:PROGN
   (CL:SETQ KWD-PARTIAL-MATCH-MINIMUM-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MINIMUM-SCORE" NULL 2))
   (CL:SETQ SGT-PARTIAL-MATCH-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-RETRIEVE-PARTIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRIEVE-PARTIAL" NULL 0))
   (CL:SETQ KWD-PARTIAL-MATCH-SORT-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SORT-BY" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCORE" NULL 2))
   (CL:SETQ KWD-PARTIAL-MATCH-MAXIMIZE-SCORE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMIZE-SCORE?" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-ASK-PARTIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASK-PARTIAL" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-SUPPORT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPORT" NULL 0))
   (CL:SETQ SGT-PARTIAL-MATCH-PL-KERNEL-KB-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PARTIAL-MATCH-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION" NULL 2))
   (CL:SETQ SYM-PARTIAL-MATCH-LOGIC-STARTUP-PARTIAL-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-PARTIAL-MATCH" NULL 0))
   (CL:SETQ SYM-PARTIAL-MATCH-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-PARTIAL-MATCH3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "SET-PARTIAL-MATCH-MODE"
    "(DEFUN SET-PARTIAL-MATCH-MODE ((K KEYWORD)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-PARTIAL-MATCH-MODE) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-RULE-COMBINATION"
    "(DEFUN SET-RULE-COMBINATION ((K KEYWORD)) :COMMAND? TRUE)"
    (CL:FUNCTION %SET-RULE-COMBINATION) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-GREEDY-NETWORK-PRUNING"
    "(DEFUN SET-GREEDY-NETWORK-PRUNING ((B BOOLEAN)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-GREEDY-NETWORK-PRUNING)
    (CL:FUNCTION SET-GREEDY-NETWORK-PRUNING-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-MAXIMUM-SCORE-CUTOFF"
    "(DEFUN SET-MAXIMUM-SCORE-CUTOFF ((C FLOAT)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-MAXIMUM-SCORE-CUTOFF)
    (CL:FUNCTION SET-MAXIMUM-SCORE-CUTOFF-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-MINIMUM-SCORE-CUTOFF"
    "(DEFUN SET-MINIMUM-SCORE-CUTOFF ((C FLOAT)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-MINIMUM-SCORE-CUTOFF)
    (CL:FUNCTION SET-MINIMUM-SCORE-CUTOFF-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "LINK-TO-PARENT-PARTIAL-MATCH-FRAME"
    "(DEFUN LINK-TO-PARENT-PARTIAL-MATCH-FRAME ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION LINK-TO-PARENT-PARTIAL-MATCH-FRAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ((SELF PARTIAL-MATCH-FRAME) (FRAME CONTROL-FRAME) (KIND KEYWORD)))"
    (CL:FUNCTION CREATE-PARTIAL-MATCH-FRAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-DYNAMIC-CUTOFF PARTIAL-MATCH-SCORE) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION COMPUTE-DYNAMIC-CUTOFF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-DYNAMIC-CUTOFF ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION SET-DYNAMIC-CUTOFF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CUTOFF-PARTIAL-MATCH? BOOLEAN) ((SELF PARTIAL-MATCH-FRAME) (TRACE? BOOLEAN)))"
    (CL:FUNCTION CUTOFF-PARTIAL-MATCH?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PROPOSITION-WEIGHT FLOAT) ((SELF PARTIAL-MATCH-FRAME) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION PROPOSITION-WEIGHT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR-FRAME-PARTIAL-TRUTH ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION CLEAR-FRAME-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED-FRAME-PARTIAL-TRUTH? BOOLEAN) ((SELF CONTROL-FRAME)) :GLOBALLY-INLINE? TRUE (RETURN (AND (DEFINED? (PARTIAL-MATCH-FRAME SELF)) (DEFINED-FRAME-PARTIAL-TRUTH? (PARTIAL-MATCH-FRAME SELF)))))"
    (CL:FUNCTION DEFINED-FRAME-PARTIAL-TRUTH?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (DEFINED-FRAME-PARTIAL-TRUTH? BOOLEAN) ((SELF PARTIAL-MATCH-FRAME)) :GLOBALLY-INLINE? TRUE (RETURN (OR (DEFINED? (POSITIVE-SCORE SELF)) (DEFINED? (NEGATIVE-SCORE SELF)))))"
    (CL:FUNCTION DEFINED-FRAME-PARTIAL-TRUTH?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-FRAME-PARTIAL-TRUTH ((SELF PARTIAL-MATCH-FRAME) (TRUTHVALUE TRUTH-VALUE) (POSSCORE PARTIAL-MATCH-SCORE) (NEGSCORE PARTIAL-MATCH-SCORE) (IGNOREPOLARITY? BOOLEAN)))"
    (CL:FUNCTION SET-FRAME-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PROPAGATE-FRAME-PARTIAL-TRUTH ((SOURCE PARTIAL-MATCH-FRAME) (TARGET CONTROL-FRAME)))"
    (CL:FUNCTION PROPAGATE-FRAME-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD TRACE-FRAME-PARTIAL-TRUTH ((SELF PARTIAL-MATCH-FRAME) (LASTMOVE KEYWORD) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION TRACE-FRAME-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-CACHE-PARTIAL-TRUTH ((SELF CONTROL-FRAME) (CACHE ATOMIC-GOAL-CACHE)))"
    (CL:FUNCTION SET-CACHE-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-CACHE-PARTIAL-TRUTH ((SELF PARTIAL-MATCH-FRAME) (CACHE ATOMIC-GOAL-CACHE)))"
    (CL:FUNCTION SET-CACHE-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-JUSTIFICATION-PARTIAL-TRUTH ((SELF CONTROL-FRAME) (JUSTIFICATION JUSTIFICATION)))"
    (CL:FUNCTION SET-JUSTIFICATION-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-JUSTIFICATION-PARTIAL-TRUTH ((SELF PARTIAL-MATCH-FRAME) (JUSTIFICATION JUSTIFICATION)))"
    (CL:FUNCTION SET-JUSTIFICATION-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (ALLOW-UNBOUND-VARIABLES? BOOLEAN) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION ALLOW-UNBOUND-VARIABLES?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION COMPUTE-AND-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-AND-PROOF KEYWORD) ((SELF PARTIAL-MATCH-FRAME) (FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-AND-PROOF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION COMPUTE-OR-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-OR-PROOF KEYWORD) ((SELF PARTIAL-MATCH-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-OR-PROOF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION COMPUTE-NOT-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-NOT-PROOF KEYWORD) ((SELF PARTIAL-MATCH-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-NOT-PROOF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-FAIL-PROOF KEYWORD) ((SELF PARTIAL-MATCH-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-FAIL-PROOF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION COMPUTE-GOAL-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-STRATEGIES-PROOFS KEYWORD) ((SELF PARTIAL-MATCH-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-STRATEGIES-PROOFS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-ANTECEDENTS-PROOF KEYWORD) ((SELF PARTIAL-MATCH-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-ANTECEDENTS-PROOF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ((SELF PARTIAL-MATCH-FRAME) (PROP PROPOSITION) (TRUTH KEYWORD)))"
    (CL:FUNCTION SET-BASE-PARTIAL-MATCH-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ((SELF PARTIAL-MATCH-FRAME) (SCORE PARTIAL-MATCH-SCORE) (WEIGHT FLOAT)))"
    (CL:FUNCTION RECORD-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD POP-PARTIAL-MATCH-SCORE ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION POP-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EARLY-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION EARLY-PARTIAL-MATCH-AND-FAILURE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EARLY-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ((SELF PARTIAL-MATCH-FRAME)))"
    (CL:FUNCTION EARLY-PARTIAL-MATCH-OR-SUCCESS?) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-INCREMENTAL-PARTIAL-MATCH"
    "(DEFUN INITIALIZE-INCREMENTAL-PARTIAL-MATCH ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION INITIALIZE-INCREMENTAL-PARTIAL-MATCH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ((SELF INCREMENTAL-PARTIAL-MATCH) (FRAME CONTROL-FRAME) (KIND KEYWORD)))"
    (CL:FUNCTION CREATE-PARTIAL-MATCH-FRAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-DYNAMIC-CUTOFF PARTIAL-MATCH-SCORE) ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-DYNAMIC-CUTOFF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR-FRAME-PARTIAL-TRUTH ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION CLEAR-FRAME-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PROPOSITION-WEIGHT FLOAT) ((SELF INCREMENTAL-PARTIAL-MATCH) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION PROPOSITION-WEIGHT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PUSH-AND-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH) (SCORE PARTIAL-MATCH-SCORE) (WEIGHT FLOAT)))"
    (CL:FUNCTION PUSH-AND-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD POP-AND-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION POP-AND-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-AND-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (SKIP-AND-CLAUSE? BOOLEAN) ((SELF INCREMENTAL-PARTIAL-MATCH) (FRAME CONTROL-FRAME) (FORBIDDENVARS (CONS OF PATTERN-VARIABLE))))"
    (CL:FUNCTION SKIP-AND-CLAUSE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-AND-PROOF KEYWORD) ((SELF INCREMENTAL-PARTIAL-MATCH) (FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-AND-PROOF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PUSH-OR-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH) (SCORE PARTIAL-MATCH-SCORE) (WEIGHT FLOAT)))"
    (CL:FUNCTION PUSH-OR-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD POP-OR-PARTIAL-MATCH-SCORE ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION POP-OR-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-OR-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-OR-PROOF KEYWORD) ((SELF INCREMENTAL-PARTIAL-MATCH) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-OR-PROOF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-NOT-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-NOT-PROOF KEYWORD) ((SELF INCREMENTAL-PARTIAL-MATCH) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-NOT-PROOF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ((SELF INCREMENTAL-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-GOAL-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-STRATEGIES-PROOFS KEYWORD) ((SELF INCREMENTAL-PARTIAL-MATCH) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-STRATEGIES-PROOFS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-ANTECEDENTS-PROOF KEYWORD) ((SELF INCREMENTAL-PARTIAL-MATCH) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-ANTECEDENTS-PROOF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CONTINUE-PARTIAL-FAIL-PROOF KEYWORD) ((SELF INCREMENTAL-PARTIAL-MATCH) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION CONTINUE-PARTIAL-FAIL-PROOF) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-NN-PARTIAL-MATCH ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION INITIALIZE-NN-PARTIAL-MATCH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (CREATE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ((SELF NN-PARTIAL-MATCH) (FRAME CONTROL-FRAME) (KIND KEYWORD)))"
    (CL:FUNCTION CREATE-PARTIAL-MATCH-FRAME) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-DYNAMIC-CUTOFF PARTIAL-MATCH-SCORE) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-DYNAMIC-CUTOFF) NULL)))

(CL:DEFUN HELP-STARTUP-PARTIAL-MATCH4 ()
  (CL:PROGN
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (PROPOSITION-WEIGHT FLOAT) ((SELF NN-PARTIAL-MATCH) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION PROPOSITION-WEIGHT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-BASE-PARTIAL-MATCH-TRUTH ((SELF NN-PARTIAL-MATCH) (PROP PROPOSITION) (TRUTH KEYWORD)))"
    (CL:FUNCTION SET-BASE-PARTIAL-MATCH-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-CACHE-PARTIAL-TRUTH ((SELF NN-PARTIAL-MATCH) (CACHE ATOMIC-GOAL-CACHE)))"
    (CL:FUNCTION SET-CACHE-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-JUSTIFICATION-PARTIAL-TRUTH ((SELF NN-PARTIAL-MATCH) (JUSTIFICATION JUSTIFICATION)))"
    (CL:FUNCTION SET-JUSTIFICATION-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD RECORD-PARTIAL-MATCH-SCORE ((SELF NN-PARTIAL-MATCH) (SCORE PARTIAL-MATCH-SCORE) (WEIGHT FLOAT)))"
    (CL:FUNCTION RECORD-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD POP-PARTIAL-MATCH-SCORE ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION POP-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-AND-SCORE PARTIAL-MATCH-SCORE) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-AND-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-OR-SCORE PARTIAL-MATCH-SCORE) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-OR-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-NOT-SCORE PARTIAL-MATCH-SCORE) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-NOT-SCORE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-GOAL-SCORE PARTIAL-MATCH-SCORE) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION COMPUTE-GOAL-SCORE) NULL)
   (DEFINE-FUNCTION-OBJECT "PROBABILISTIC-SUM-N"
    "(DEFUN (PROBABILISTIC-SUM-N FLOAT) ((FORM (CONS OF FLOAT-WRAPPER))))"
    (CL:FUNCTION PROBABILISTIC-SUM-N) NULL)
   (DEFINE-FUNCTION-OBJECT "PROBABILISTIC-SUM"
    "(DEFUN (PROBABILISTIC-SUM FLOAT) ((X FLOAT) (Y FLOAT)))"
    (CL:FUNCTION PROBABILISTIC-SUM) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EARLY-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION EARLY-PARTIAL-MATCH-AND-FAILURE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EARLY-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION EARLY-PARTIAL-MATCH-OR-SUCCESS?) NULL)
   (DEFINE-FUNCTION-OBJECT "PRUNE-NN-SEARCH?"
    "(DEFUN (PRUNE-NN-SEARCH? BOOLEAN) ((SELF NN-PARTIAL-MATCH)))"
    (CL:FUNCTION PRUNE-NN-SEARCH?) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-PARTIAL-MATCH-FRAME"
    "(DEFUN (MAKE-PARTIAL-MATCH-FRAME PARTIAL-MATCH-FRAME) ((QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION MAKE-PARTIAL-MATCH-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-PARTIAL-QUERY"
    "(DEFUN INITIALIZE-PARTIAL-QUERY ((QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION INITIALIZE-PARTIAL-QUERY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD INITIALIZE-PARTIAL-MATCH-STRATEGY ((SELF PARTIAL-MATCH-FRAME) (QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION INITIALIZE-PARTIAL-MATCH-STRATEGY) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-AND-LINK-PARTIAL-MATCH-FRAME"
    "(DEFUN CREATE-AND-LINK-PARTIAL-MATCH-FRAME ((FRAME CONTROL-FRAME) (KIND KEYWORD)))"
    (CL:FUNCTION CREATE-AND-LINK-PARTIAL-MATCH-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-UNBOUND-VARIABLES"
    "(DEFUN (GET-UNBOUND-VARIABLES CONS) ((PROP PROPOSITION)))"
    (CL:FUNCTION GET-UNBOUND-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-VARIABLES-UNBOUND?"
    "(DEFUN (ALL-VARIABLES-UNBOUND? BOOLEAN) ((PROP PROPOSITION)))"
    (CL:FUNCTION ALL-VARIABLES-UNBOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "UNBOUND-VARIABLES-IN-FRAME?"
    "(DEFUN (UNBOUND-VARIABLES-IN-FRAME? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION UNBOUND-VARIABLES-IN-FRAME?) NULL)
   (DEFINE-FUNCTION-OBJECT "RECORD-LATEST-PARTIAL-MATCH-SCORE"
    "(DEFUN RECORD-LATEST-PARTIAL-MATCH-SCORE ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION RECORD-LATEST-PARTIAL-MATCH-SCORE) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-PARTIAL-MATCH-AND-FAILURE?"
    "(DEFUN (COMPUTE-PARTIAL-MATCH-AND-FAILURE? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COMPUTE-PARTIAL-MATCH-AND-FAILURE?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-PARTIAL-MATCH-OR-SUCCESS?"
    "(DEFUN (COMPUTE-PARTIAL-MATCH-OR-SUCCESS? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COMPUTE-PARTIAL-MATCH-OR-SUCCESS?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-PARTIAL-MATCH-SCORE?"
    "(DEFUN (COMPUTE-PARTIAL-MATCH-SCORE? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COMPUTE-PARTIAL-MATCH-SCORE?) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRIEVE-PARTIAL"
    "(DEFUN (RETRIEVE-PARTIAL QUERY-ITERATOR) (|&REST| (TREE PARSE-TREE)) :DOCUMENTATION \"Partial-match version of `retrieve' (which see) that generates scored
partial solutions based on the current partial match strategy.  By supplying
`BEST' instead of `ALL', or by adding the option `:SORT-BY :SCORE', the generated
solutions will be sorted so that solutions with higher scores come first.
Use the `:MATCH-MODE' option to override the global default setting established
by `set-partial-match-mode', e.g., use `:MATCH-MODE :NN' to use the neural
net partial match mode.  The `:MINIMUM-SCORE' option can be used to only
retrieve solutions that have at least the specified minimum match score.
By default, `retrieve-partial' does not maximize the match scores of its returned
bindings.  To only get maximal scores use `:MAXIMIZE-SCORE? TRUE' (this is not
yet implemented - you can use `ask-partial' to maximize scores for individual
solutions by hand).\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %RETRIEVE-PARTIAL)
    (CL:FUNCTION RETRIEVE-PARTIAL-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "CALL-RETRIEVE-PARTIAL"
    "(DEFUN (CALL-RETRIEVE-PARTIAL QUERY-ITERATOR) ((QUERY OBJECT)) :DOCUMENTATION \"Callable version of `retrieve-partial' (which see).  Accepts queries
specified by a query iterator, or specified as a CONS-list of arguments as they
would be supplied to `retrieve-partial'.  Raises LOGIC-EXCEPTIONs in case of
illegal queries and logical expressions.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CALL-RETRIEVE-PARTIAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (RETRIEVE-PARTIAL-SOLUTIONS QUERY-ITERATOR) ((SELF PARTIAL-MATCH-FRAME) (QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION RETRIEVE-PARTIAL-SOLUTIONS) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (RETRIEVE-PARTIAL-SOLUTIONS QUERY-ITERATOR) ((SELF INCREMENTAL-PARTIAL-MATCH) (QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION RETRIEVE-PARTIAL-SOLUTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "SORT-SOLUTIONS-BY-SCORE"
    "(DEFUN SORT-SOLUTIONS-BY-SCORE ((QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION SORT-SOLUTIONS-BY-SCORE) NULL)
   (DEFINE-FUNCTION-OBJECT "SOLUTION-SCORE-GREATER-THAN?"
    "(DEFUN (SOLUTION-SCORE-GREATER-THAN? BOOLEAN) ((S1 QUERY-SOLUTION) (S2 QUERY-SOLUTION)))"
    (CL:FUNCTION SOLUTION-SCORE-GREATER-THAN?) NULL)
   (DEFINE-FUNCTION-OBJECT "ASK-PARTIAL"
    "(DEFUN (ASK-PARTIAL FLOAT) (|&REST| (|PROPOSITION&OPTIONS| PARSE-TREE)) :DOCUMENTATION \"Similar to `ask' (which see), but return the highest partial match score
for the supplied proposition instead of a truth value.  If the option
:MAXIMIZE-SCORE? is set to FALSE, return after the first partial match score
has been generated.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %ASK-PARTIAL) (CL:FUNCTION ASK-PARTIAL-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "RETURN-PARTIAL-TRUTH"
    "(DEFUN (RETURN-PARTIAL-TRUTH FLOAT) ((QUERY QUERY-ITERATOR) (TOP? BOOLEAN)))"
    (CL:FUNCTION RETURN-PARTIAL-TRUTH) NULL)
   (DEFINE-FUNCTION-OBJECT "CALL-ASK-PARTIAL"
    "(DEFUN (CALL-ASK-PARTIAL FLOAT) ((QUERY OBJECT)))"
    (CL:FUNCTION CALL-ASK-PARTIAL) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-PARTIAL-TRUTH FLOAT) ((SELF PARTIAL-MATCH-FRAME) (QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION COMPUTE-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-PARTIAL-TRUTH FLOAT) ((SELF INCREMENTAL-PARTIAL-MATCH) (QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION COMPUTE-PARTIAL-TRUTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COMPUTE-PARTIAL-TRUTH FLOAT) ((SELF NN-PARTIAL-MATCH) (QUERY QUERY-ITERATOR)))"
    (CL:FUNCTION COMPUTE-PARTIAL-TRUTH) NULL)
   (DEFINE-FUNCTION-OBJECT "NULL-INSTANCE?"
    "(DEFUN (NULL-INSTANCE? BOOLEAN) ((X OBJECT)))"
    (CL:FUNCTION NULL-INSTANCE?) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-NULL-INSTANCE"
    "(DEFUN (GET-NULL-INSTANCE LOGIC-OBJECT) ())"
    (CL:FUNCTION GET-NULL-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "NULL-INSTANCE-PROPOSITIONS-EXIST?"
    "(DEFUN (NULL-INSTANCE-PROPOSITIONS-EXIST? BOOLEAN) ())"
    (CL:FUNCTION NULL-INSTANCE-PROPOSITIONS-EXIST?) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-MATCHING-PARTIAL-PROPOSITIONS"
    "(DEFUN (ALL-MATCHING-PARTIAL-PROPOSITIONS (ITERATOR OF PROPOSITION)) ((SELF PROPOSITION)))"
    (CL:FUNCTION ALL-MATCHING-PARTIAL-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "PARTIAL-ARGUMENTS-UNIFY-WITH-ARGUMENTS?"
    "(DEFUN (PARTIAL-ARGUMENTS-UNIFY-WITH-ARGUMENTS? BOOLEAN) ((SUBPROPOSITION PROPOSITION) (REFERENCEPROPOSITION PROPOSITION)))"
    (CL:FUNCTION PARTIAL-ARGUMENTS-UNIFY-WITH-ARGUMENTS?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRY-SCAN-PARTIAL-PROPOSITIONS-PROOF"
    "(DEFUN (TRY-SCAN-PARTIAL-PROPOSITIONS-PROOF KEYWORD) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION TRY-SCAN-PARTIAL-PROPOSITIONS-PROOF) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-PARTIAL-MATCH"
    "(DEFUN STARTUP-PARTIAL-MATCH () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-PARTIAL-MATCH) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-PARTIAL-MATCH-LOGIC-STARTUP-PARTIAL-MATCH)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-PARTIAL-MATCH-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupPartialMatch") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-PARTIAL-MATCH ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-PARTIAL-MATCH1)
    (HELP-STARTUP-PARTIAL-MATCH2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *PARTIAL-MATCH-MODE* KWD-PARTIAL-MATCH-BASIC)
    (CL:SETQ *RULE-COMBINATION* KWD-PARTIAL-MATCH-MAX)
    (CL:SETQ *PLANABLE-PREDICATES* NIL))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PARTIAL-MATCH-FRAME"
        "(DEFCLASS PARTIAL-MATCH-FRAME (STANDARD-OBJECT) :DOCUMENTATION \"Abstract class acting as placeholder for system and
user-defined partial match implementations.\" :ABSTRACT? TRUE :SLOTS ((KIND :TYPE KEYWORD :REQUIRED? TRUE) (CONTROL-FRAME :TYPE CONTROL-FRAME :REQUIRED? TRUE) (PARENT :TYPE PARTIAL-MATCH-FRAME) (CHILD :TYPE PARTIAL-MATCH-FRAME) (POSITIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :INITIALLY NULL) (NEGATIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :INITIALLY NULL) (DYNAMIC-CUTOFF :TYPE FLOAT) (ARGUMENT-SCORES :TYPE (CONS OF FLOAT-WRAPPER) :INITIALLY NIL) (ARGUMENT-WEIGHTS :TYPE (CONS OF FLOAT-WRAPPER) :INITIALLY NIL) (UNBOUND-VARS :TYPE CONS :INITIALLY NIL) (SUCCESS? :TYPE BOOLEAN :INITIALLY FALSE)))")))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PARTIAL-MATCH-FRAME-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INCREMENTAL-PARTIAL-MATCH"
        "(DEFCLASS INCREMENTAL-PARTIAL-MATCH (PARTIAL-MATCH-FRAME) :SLOTS ((PARENT :TYPE INCREMENTAL-PARTIAL-MATCH) (CHILD :TYPE INCREMENTAL-PARTIAL-MATCH) (ACCUMULATED-SCORE :TYPE PARTIAL-MATCH-SCORE :INITIALLY 0.0) (ACCUMULATED-WEIGHT :TYPE FLOAT :INITIALLY 0.0) (TOTAL-WEIGHT :TYPE FLOAT) (MAXIMUM-SCORE :TYPE PARTIAL-MATCH-SCORE :INITIALLY 0.0)) :INITIALIZER INITIALIZE-INCREMENTAL-PARTIAL-MATCH)")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-INCREMENTAL-PARTIAL-MATCH))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-INCREMENTAL-PARTIAL-MATCH-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "NN-PARTIAL-MATCH"
        "(DEFCLASS NN-PARTIAL-MATCH (PARTIAL-MATCH-FRAME) :SLOTS ((PARENT :TYPE NN-PARTIAL-MATCH) (CHILD :TYPE NN-PARTIAL-MATCH) (ACCUMULATED-SCORE :TYPE PARTIAL-MATCH-SCORE :INITIALLY 0.0) (MAXIMUM-SCORE :TYPE PARTIAL-MATCH-SCORE :INITIALLY 0.0) (RULES :TYPE (CONS OF PROPOSITION) :INITIALLY NIL) (ARITY :TYPE INTEGER)) :INITIALIZER INITIALIZE-NN-PARTIAL-MATCH)")))
     (CL:SETF (%CLASS.CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-NN-PARTIAL-MATCH))
     (CL:SETF (%CLASS.CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-NN-PARTIAL-MATCH-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-PARTIAL-MATCH3)
    (HELP-STARTUP-PARTIAL-MATCH4))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PARTIAL-MATCH-MODE* KEYWORD :BASIC)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *GREEDY-NETWORK-PRUNING* BOOLEAN TRUE)")
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-SET-PARTIAL-MATCH-MODE
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *RULE-COMBINATION* KEYWORD :MAX)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PLANNING-MODE* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PLANABLE-PREDICATES* CONS NIL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *FAIL-UNBOUND-CLAUSES?* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MINIMUM-SCORE-CUTOFF* PARTIAL-MATCH-SCORE 0.0 :DOCUMENTATION \"Positive scores below *minimum-score-cutoff* get trimmed
to 0.0 during partial match operations.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAXIMUM-SCORE-CUTOFF* PARTIAL-MATCH-SCORE 0.0 :DOCUMENTATION \"Positive scores above *maximum-score-cutoff* get trimmed
to 1.0 during partial match operations.\")")
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-SET-RULE-COMBINATION
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-SET-GREEDY-NETWORK-PRUNING
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-SET-MAXIMUM-SCORE-CUTOFF
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-SET-MINIMUM-SCORE-CUTOFF
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *AND-MISSED-A-BINDING* BOOLEAN FALSE)")
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-RETRIEVE-PARTIAL
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PARTIAL-MATCH-LOGIC-ASK-PARTIAL
     KWD-PARTIAL-MATCH-COMMON-LISP KWD-PARTIAL-MATCH-FUNCTION)
    (CL:LET* ((*MODULE* *PL-KERNEL-MODULE*) (*CONTEXT* *MODULE*))
     (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
     (CREATE-LOGIC-INSTANCE SGT-PARTIAL-MATCH-PL-KERNEL-KB-NULL NULL)))))
