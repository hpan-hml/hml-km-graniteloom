;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; specialists.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2010      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-SPECIALISTS-LOGIC-COMPUTED-PROCEDURE NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-PROCEDURE-NAME NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-PROCEDURE-CODE NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-SPECIALIST NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-HANDLES-REVERSE-POLARITY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-CONSTRAINT NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-COMPUTATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-EVALUATOR NULL)
(CL:DEFVAR KWD-SPECIALISTS-FAIL NULL)
(CL:DEFVAR KWD-SPECIALISTS-TERMINAL-FAILURE NULL)
(CL:DEFVAR KWD-SPECIALISTS-FAILURE NULL)
(CL:DEFVAR KWD-SPECIALISTS-TRUE NULL)
(CL:DEFVAR KWD-SPECIALISTS-FINAL-SUCCESS NULL)
(CL:DEFVAR KWD-SPECIALISTS-CONTINUING-SUCCESS NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-THING NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-FUNCTION-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-METHOD-CODE-WRAPPER NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-SUBSTRING-POSITION-ITERATOR NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-SUPER-STRING NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-SUB-STRING NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-START NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-SUB-LENGTH NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-TOTAL NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-SKOLEM NULL)
(CL:DEFVAR KWD-SPECIALISTS-ERROR NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-ITERATOR NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-COLLECTIONOF NULL)
(CL:DEFVAR KWD-SPECIALISTS-UP-TRUE NULL)
(CL:DEFVAR KWD-SPECIALISTS-UP-FAIL NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-ISA NULL)
(CL:DEFVAR KWD-SPECIALISTS-MOVE-DOWN NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-COLLECTION NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR KWD-SPECIALISTS-SCAN-COLLECTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-DOWN NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-PREDICATE NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-FUNCTION NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-DUMMY NULL)
(CL:DEFVAR KWD-SPECIALISTS-FULL-SUBQUERY NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-FUNCTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-PREDICATE NULL)
(CL:DEFVAR KWD-SPECIALISTS-ISA NULL)
(CL:DEFVAR KWD-SPECIALISTS-AND NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-ARGUMENTS NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-FORK-PROOF-ADJUNCT NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-CONDITION-JUSTIFICATION NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-DOWN-FRAME NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT NULL)
(CL:DEFVAR KWD-SPECIALISTS-FAIL-INTRODUCTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-FORK-ELSE NULL)
(CL:DEFVAR KWD-SPECIALISTS-FORK-THEN NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR KWD-SPECIALISTS-TECHNICAL NULL)
(CL:DEFVAR KWD-SPECIALISTS-LAY NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR KWD-SPECIALISTS-HOW-MANY NULL)
(CL:DEFVAR KWD-SPECIALISTS-INHERIT NULL)
(CL:DEFVAR KWD-SPECIALISTS-ALL NULL)
(CL:DEFVAR KWD-SPECIALISTS-CURRENT NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-QUERY-SPECIALIST-IO-VARIABLES NULL)
(CL:DEFVAR KWD-SPECIALISTS-MATCH-MODE NULL)
(CL:DEFVAR KWD-SPECIALISTS-DESCRIPTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-SORT-BY NULL)
(CL:DEFVAR KWD-SPECIALISTS-GOAL-TREE NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-INFERENCE-LEVEL NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-ASSERTION-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SHALLOW-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SUBSUMPTION-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-BACKTRACKING-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-NORMAL-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-REFUTATION-QUERY NULL)
(CL:DEFVAR KWD-SPECIALISTS-LEVELED-QUERY NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-CONCEPT-PROTOTYPE NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-HYPOTHESIZED-INSTANCE? NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-MONOTONIC? NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-F-CLOSED-TERM?-MEMO-TABLE-000 NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-EQUIVALENT-VALUE NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-F-CLOSED-PROPOSITION?-MEMO-TABLE-000 NULL)
(CL:DEFVAR KWD-SPECIALISTS-OR NULL)
(CL:DEFVAR KWD-SPECIALISTS-NOT NULL)
(CL:DEFVAR KWD-SPECIALISTS-FORALL NULL)
(CL:DEFVAR KWD-SPECIALISTS-EXISTS NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SINGLE-VALUED NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-F-SINGLE-VALUED-TERM?-MEMO-TABLE-000 NULL)
(CL:DEFVAR KWD-SPECIALISTS-EQUIVALENT NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-LIST NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-ORDERED-SET NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-INFERENCE-CUTOFF-REASON NULL)
(CL:DEFVAR KWD-SPECIALISTS-COLLECT-MEMBERS NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-?SUPER NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-?MDC NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-AND NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-MEMBER-OF NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-MUTUALLY-DISJOINT-COLLECTION NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-F-HELP-DERIVE-PARTITION-MEMBERSHIPS-QUERY-000 NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-MUTUALLY-DISJOINT-COLLECTION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-PARTITION-MEMBERSHIP NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-DISJOINT NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP NULL)
(CL:DEFVAR KWD-SPECIALISTS-ASSERT-TRUE NULL)
(CL:DEFVAR KWD-SPECIALISTS-ASSERT-FALSE NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-EMPTY NULL)
(CL:DEFVAR SGT-SPECIALISTS-LOGIC-SAVED-CONTEXT-PROOF-ADJUNCT NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-SAVED-CONTEXT NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-CONTEXT NULL)
(CL:DEFVAR KWD-SPECIALISTS-IST-INTRODUCTION NULL)
(CL:DEFVAR KWD-SPECIALISTS-PARTIAL NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-THE-ROLESET NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-CARDINALITY NULL)
(CL:DEFVAR KWD-SPECIALISTS-LOWER NULL)
(CL:DEFVAR KWD-SPECIALISTS-UPPER NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-SURROGATE NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUBRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUPERRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SUBRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SUPERRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUBRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUPERRELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-EQUIVALENT-RELATION NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-CONS NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-LIST NULL)
(CL:DEFVAR SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM NULL)
(CL:DEFVAR SGT-SPECIALISTS-STELLA-CS-VALUE NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-REGISTER-SPECIALIST-FUNCTION-NAME NULL)
(CL:DEFVAR KWD-SPECIALISTS-COMMON-LISP NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-REGISTER-COMPUTATION-FUNCTION-NAME NULL)
(CL:DEFVAR SYM-SPECIALISTS-LOGIC-STARTUP-SPECIALISTS NULL)
(CL:DEFVAR SYM-SPECIALISTS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* DEFAULT-TRUE-TRUTH-VALUE
  DEFAULT-FALSE-TRUTH-VALUE UNKNOWN-TRUTH-VALUE *CYC-KLUDGES-ENABLED?*
  *MEMOIZATION-ENABLED?* MEMOIZED-NULL-VALUE *CONTEXT* *INFERENCELEVEL*
  ASSERTION-INFERENCE SHALLOW-INFERENCE SUBSUMPTION-INFERENCE
  BACKTRACKING-INFERENCE NORMAL-INFERENCE *TRACED-KEYWORDS* NIL-LIST
  *RECORD-JUSTIFICATIONS?* EMPTY-PROPOSITIONS-ITERATOR REFUTATION-INFERENCE
  FALSE-WRAPPER NIL NULL-INTEGER TRUE-WRAPPER NULL-INTEGER-WRAPPER
  NULL-STRING-WRAPPER NULL-FLOAT-WRAPPER NULL-CHARACTER-WRAPPER
  NULL-FUNCTION-CODE-WRAPPER NULL-METHOD-CODE-WRAPPER FALSE-TRUTH-VALUE
  *QUERYITERATOR* TRUE-TRUTH-VALUE *REVERSEPOLARITY?* STANDARD-OUTPUT EOL))

;;; (DEFCLASS COMPUTED-PROCEDURE ...)

(CL:DEFCLASS COMPUTED-PROCEDURE (THING)
  ((PROCEDURE-NAME :ALLOCATION :INSTANCE :ACCESSOR %PROCEDURE-NAME)
   (PROCEDURE-CODE :ALLOCATION :INSTANCE :ACCESSOR %PROCEDURE-CODE))
  (:DOCUMENTATION "Each instance denotes a programming language 
function that computes some procedure.  The slot 'procedure-name'
provides the name of the procedure.  The slot 'procedure-code'
points directly to the procedure itself.  Both slots are optional;
if neither is supplied, the procedure will be invoked by extracting
its name from the name of the instance."))

(CL:DEFUN NEW-COMPUTED-PROCEDURE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE COMPUTED-PROCEDURE)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%PROCEDURE-CODE SELF) NULL) (CL:SETF (%PROCEDURE-NAME SELF) NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF COMPUTED-PROCEDURE))
  SGT-SPECIALISTS-LOGIC-COMPUTED-PROCEDURE)

(CL:DEFUN ACCESS-COMPUTED-PROCEDURE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-PROCEDURE-NAME)
    (CL:IF SETVALUE? (CL:SETF (%PROCEDURE-NAME SELF) VALUE)
     (CL:SETQ VALUE (%PROCEDURE-NAME SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-PROCEDURE-CODE)
    (CL:IF SETVALUE? (CL:SETF (%PROCEDURE-CODE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FUNCTION-CODE (%PROCEDURE-CODE SELF)))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFUN (FUNCTION-CODE-FROM-PROCEDURE FUNCTION-CODE) ...)

(CL:DEFUN FUNCTION-CODE-FROM-PROCEDURE (P)
  (CL:LET* ((PROCEDURE P))
   (CL:WHEN (CL:NOT (CL:EQ (%PROCEDURE-CODE PROCEDURE) NULL))
    (CL:RETURN-FROM FUNCTION-CODE-FROM-PROCEDURE (%PROCEDURE-CODE PROCEDURE)))
   (CL:LET*
    ((PROCEDURENAME (%PROCEDURE-NAME PROCEDURE)) (STELLAFUNCTION NULL))
    (CL:WHEN (CL:EQ PROCEDURENAME NULL)
     (CL:SETQ PROCEDURENAME
      (INTERN-SYMBOL-IN-MODULE
       (%SYMBOL-NAME (%SURROGATE-VALUE-INVERSE PROCEDURE))
       (%HOME-CONTEXT (%SURROGATE-VALUE-INVERSE PROCEDURE)) CL:T))
     (CL:SETF (%PROCEDURE-NAME PROCEDURE) PROCEDURENAME))
    (CL:SETQ STELLAFUNCTION (LOOKUP-FUNCTION PROCEDURENAME))
    (CL:WHEN (CL:EQ STELLAFUNCTION NULL)
     (CL:LET*
      ((KERNELNAME
        (LOOKUP-SYMBOL-IN-MODULE (%SYMBOL-NAME PROCEDURENAME)
         (GET-STELLA-MODULE "PL-KERNEL" CL:T) CL:NIL)))
      (CL:WHEN (CL:NOT (CL:EQ KERNELNAME NULL))
       (CL:SETQ STELLAFUNCTION (LOOKUP-FUNCTION KERNELNAME)))))
    (CL:WHEN (CL:EQ STELLAFUNCTION NULL)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "   Missing specialist -- no STELLA function is named `" PROCEDURENAME
      "'" EOL EOL)
     (CL:RETURN-FROM FUNCTION-CODE-FROM-PROCEDURE NULL))
    (%FUNCTION-CODE STELLAFUNCTION))))

;;; (DEFUN (LOOKUP-SPECIALIST FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-SPECIALIST (DESCRIPTION)
  (CL:LET*
   ((SPECIALISTPROCEDURE
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-SPECIALIST))
    (FUNCTIONCODE NULL))
   (CL:WHEN (CL:NOT (CL:EQ SPECIALISTPROCEDURE NULL))
    (CL:IF
     (CL:AND *REVERSEPOLARITY?*
      (CL:NOT
       (TEST-PROPERTY? SPECIALISTPROCEDURE
        SGT-SPECIALISTS-PL-KERNEL-KB-HANDLES-REVERSE-POLARITY)))
     (CL:RETURN-FROM LOOKUP-SPECIALIST NULL)
     (CL:SETQ FUNCTIONCODE
      (FUNCTION-CODE-FROM-PROCEDURE SPECIALISTPROCEDURE))))
   (CL:WHEN (CL:EQ FUNCTIONCODE NULL)
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ (NATIVE-RELATION DESCRIPTION) NULL))
      (CL:NOT (CLASS-DESCRIPTION? DESCRIPTION)))
     (CL:SETQ FUNCTIONCODE (CL:FUNCTION NATIVE-SLOT-READER-SPECIALIST))))
   FUNCTIONCODE))

;;; (DEFUN (LOOKUP-CONSTRAINT FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-CONSTRAINT (DESCRIPTION)
  (CL:LET*
   ((COMPUTATIONPROCEDURE
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-CONSTRAINT))
    (FUNCTIONCODE NULL))
   (CL:WHEN (CL:NOT (CL:EQ COMPUTATIONPROCEDURE NULL))
    (CL:SETQ FUNCTIONCODE
     (FUNCTION-CODE-FROM-PROCEDURE COMPUTATIONPROCEDURE)))
   FUNCTIONCODE))

;;; (DEFUN (LOOKUP-COMPUTATION FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-COMPUTATION (DESCRIPTION)
  (CL:LET*
   ((COMPUTATIONPROCEDURE
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-COMPUTATION))
    (FUNCTIONCODE NULL))
   (CL:WHEN (CL:NOT (CL:EQ COMPUTATIONPROCEDURE NULL))
    (CL:SETQ FUNCTIONCODE
     (FUNCTION-CODE-FROM-PROCEDURE COMPUTATIONPROCEDURE)))
   FUNCTIONCODE))

;;; (DEFUN (LOOKUP-EVALUATOR FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-EVALUATOR (DESCRIPTION)
  (CL:LET*
   ((EVALUATORPROCEDURE
     (ACCESS-BINARY-VALUE DESCRIPTION
      SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-EVALUATOR))
    (FUNCTIONCODE NULL))
   (CL:WHEN (CL:NOT (CL:EQ EVALUATORPROCEDURE NULL))
    (CL:SETQ FUNCTIONCODE (FUNCTION-CODE-FROM-PROCEDURE EVALUATORPROCEDURE)))
   FUNCTIONCODE))

;;; (DEFUN (SELECT-TEST-RESULT KEYWORD) ...)

(CL:DEFUN SELECT-TEST-RESULT (SUCCESS? TERMINAL? FRAME)
  "Helping function for specialists testing the validity of a
fully bound inference frame.  Based on the test result `success?'
and `reversePolarity?*', set the truth value of `frame' and return
an appropriate keyword.  The keyword will be either `:final-success'
`:terminal-failure' if `terminal?' is true.  Otherwise it will be
`:final-success' or `:failure'."
  (CL:COND
   ((CL:EQ SUCCESS? *REVERSEPOLARITY?*)
    (SET-FRAME-TRUTH-VALUE FRAME FALSE-TRUTH-VALUE)
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
     (SET-BASE-PARTIAL-MATCH-TRUTH (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
      (%PROPOSITION FRAME) KWD-SPECIALISTS-FAIL))
    (CL:IF TERMINAL? KWD-SPECIALISTS-TERMINAL-FAILURE
     KWD-SPECIALISTS-FAILURE))
   (CL:T (SET-FRAME-TRUTH-VALUE FRAME TRUE-TRUTH-VALUE)
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
      (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
     (SET-BASE-PARTIAL-MATCH-TRUTH (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*)
      (%PROPOSITION FRAME) KWD-SPECIALISTS-TRUE))
    KWD-SPECIALISTS-FINAL-SUCCESS)))

;;; (DEFUN (SELECT-PROOF-RESULT KEYWORD) ...)

(CL:DEFUN SELECT-PROOF-RESULT (SUCCESS? CONTINUING? TERMINAL?)
  "Helping function for specialists.   Return the appropriate
keyword indicating success or failure of a proof."
  (CL:IF SUCCESS?
   (CL:IF CONTINUING? KWD-SPECIALISTS-CONTINUING-SUCCESS
    KWD-SPECIALISTS-FINAL-SUCCESS)
   (CL:IF TERMINAL? KWD-SPECIALISTS-TERMINAL-FAILURE KWD-SPECIALISTS-FAILURE)))

;;; (DEFUN (NULL-WRAPPER? BOOLEAN) ...)

(CL:DEFUN NULL-WRAPPER? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-THING)
     (CL:PROGN (CL:RETURN-FROM NULL-WRAPPER? (CL:EQ SELF NULL))))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM NULL-WRAPPER? (EQL? SELF NULL-INTEGER-WRAPPER))))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM NULL-WRAPPER? (EQL? SELF NULL-STRING-WRAPPER))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN (CL:RETURN-FROM NULL-WRAPPER? (EQL? SELF NULL-FLOAT-WRAPPER))))
    ((SUBTYPE-OF-CHARACTER? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM NULL-WRAPPER? (EQL? SELF NULL-CHARACTER-WRAPPER))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-FUNCTION-CODE-WRAPPER)
     (CL:PROGN
      (CL:RETURN-FROM NULL-WRAPPER? (EQL? SELF NULL-FUNCTION-CODE-WRAPPER))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-METHOD-CODE-WRAPPER)
     (CL:PROGN
      (CL:RETURN-FROM NULL-WRAPPER? (EQL? SELF NULL-METHOD-CODE-WRAPPER))))
    (CL:T
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "Not prepared to handle native slots with type " (PRIMARY-TYPE SELF)
      EOL))))
  CL:NIL)

;;; (DEFUN (NATIVE-SLOT-READER-SPECIALIST KEYWORD) ...)

(CL:DEFUN NATIVE-SLOT-READER-SPECIALIST (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION)))
    (ARGUMENTVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (SLOT
     (CL:IF (CL:NOT (CLASS-DESCRIPTION? DESCRIPTION))
      (NATIVE-RELATION DESCRIPTION) NULL))
    (SUCCESS? CL:NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ ARGUMENTVALUE NULL)) (CL:NOT (CL:EQ SLOT NULL))
     (ISA? ARGUMENTVALUE SGT-SPECIALISTS-STELLA-THING)
     (CL:NOT (%ABSTRACT? SLOT)))
    (CL:LET* ((VALUE (READ-SLOT-VALUE ARGUMENTVALUE SLOT)))
     (CL:WHEN (CL:EQ VALUE NULL)
      (CL:RETURN-FROM NATIVE-SLOT-READER-SPECIALIST KWD-SPECIALISTS-FAILURE))
     (CL:WHEN (CL:NOT (NULL-WRAPPER? VALUE))
      (CL:IF (FUNCTION-DESCRIPTION? DESCRIPTION)
       (CL:SETQ SUCCESS?
        (BIND-VARIABLE-TO-VALUE?
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS PROPOSITION)))))
         VALUE CL:T))
       (CL:SETQ SUCCESS? (EQL? VALUE TRUE-WRAPPER)))
      (CL:RETURN-FROM NATIVE-SLOT-READER-SPECIALIST
       (SELECT-TEST-RESULT SUCCESS? CL:T FRAME)))))
   KWD-SPECIALISTS-FAILURE))

;;; (DEFCLASS SUBSTRING-POSITION-ITERATOR ...)

(CL:DEFCLASS SUBSTRING-POSITION-ITERATOR (ITERATOR)
  ((SUPER-STRING :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %SUPER-STRING)
   (SUB-STRING :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %SUB-STRING)
   (START :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %START)
   (SUB-LENGTH :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %SUB-LENGTH)))

(CL:DEFUN NEW-SUBSTRING-POSITION-ITERATOR (SUPER-STRING SUB-STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SUPER-STRING SUB-STRING))
  #+MCL
  (CL:CHECK-TYPE SUPER-STRING CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SUB-STRING CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SUBSTRING-POSITION-ITERATOR)))
   (CL:SETF (%SUPER-STRING SELF) SUPER-STRING)
   (CL:SETF (%SUB-STRING SELF) SUB-STRING)
   (CL:SETF (%FIRST-ITERATION? SELF) CL:T) (CL:SETF (%VALUE SELF) NULL)
   (CL:SETF (%SUB-LENGTH SELF)
    (CL:THE CL:FIXNUM
     (CL:LENGTH (CL:THE CL:SIMPLE-STRING (%SUB-STRING SELF)))))
   (CL:SETF (%START SELF) 0) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SUBSTRING-POSITION-ITERATOR))
  SGT-SPECIALISTS-LOGIC-SUBSTRING-POSITION-ITERATOR)

(CL:DEFUN ACCESS-SUBSTRING-POSITION-ITERATOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-SUPER-STRING)
    (CL:IF SETVALUE? (CL:SETF (%SUPER-STRING SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%SUPER-STRING SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-SUB-STRING)
    (CL:IF SETVALUE? (CL:SETF (%SUB-STRING SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%SUB-STRING SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-STELLA-START)
    (CL:IF SETVALUE? (CL:SETF (%START SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%START SELF)))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-SUB-LENGTH)
    (CL:IF SETVALUE? (CL:SETF (%SUB-LENGTH SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%SUB-LENGTH SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFMETHOD (NEXT? BOOLEAN) ...)

(CL:DEFMETHOD NEXT? ((IT SUBSTRING-POSITION-ITERATOR))
  (CL:LET*
   ((P1 (STRING-SEARCH (%SUPER-STRING IT) (%SUB-STRING IT) (%START IT))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM P1))
   (CL:IF (CL:NOT (CL:= P1 NULL-INTEGER))
    (CL:PROGN
     (CL:SETF (%VALUE IT)
      (CONS (WRAP-INTEGER P1)
       (CONS (WRAP-INTEGER (CL:+ P1 (%SUB-LENGTH IT))) NIL)))
     (CL:SETF (%START IT) (CL:1+ P1)) CL:T)
    (CL:PROGN (CL:SETF (%VALUE IT) NULL) CL:NIL))))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((IT SUBSTRING-POSITION-ITERATOR))
  (CL:LET*
   ((COUNT 0) (SUPER (%SUPER-STRING IT)) (SUB (%SUB-STRING IT))
    (P1 (STRING-SEARCH SUPER SUB 0)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COUNT P1)
    (CL:TYPE CL:SIMPLE-STRING SUPER SUB))
   (CL:LOOP WHILE (CL:NOT (CL:= P1 NULL-INTEGER)) DO
    (CL:SETQ COUNT (CL:1+ COUNT))
    (CL:SETQ P1 (STRING-SEARCH SUPER SUB (CL:1+ P1))))
   COUNT))

;;; (DEFUN (COMPUTATION-INPUT-BOUND? BOOLEAN) ...)

(CL:DEFUN COMPUTATION-INPUT-BOUND? (VALUE)
  (CL:WHEN (CL:EQ VALUE NULL) (CL:RETURN-FROM COMPUTATION-INPUT-BOUND? CL:NIL))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE VALUE) SGT-SPECIALISTS-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:WHEN (LOGICAL-COLLECTION? VALUE)
      (CL:RETURN-FROM COMPUTATION-INPUT-BOUND? CL:T))
     (CL:LET* ((PROP (%DEFINING-PROPOSITION VALUE)))
      (CL:AND (CL:NOT (CL:EQ PROP NULL))
       (TEST-PROPERTY? (GET-DESCRIPTION (%OPERATOR PROP))
        SGT-SPECIALISTS-PL-KERNEL-KB-TOTAL)))))
   (CL:T CL:T)))

;;; (DEFUN (COMPUTE-RELATION-VALUE OBJECT) ...)

(CL:DEFUN COMPUTE-RELATION-VALUE (PROPOSITION CODE ERROR?)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS PROPOSITION))
    (DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION)))
    (FUNCTION? (FUNCTION-DESCRIPTION? DESCRIPTION))
    (COMPUTATIONCODE
     (CL:IF (CL:NOT (CL:EQ CODE NULL)) CODE (LOOKUP-COMPUTATION DESCRIPTION)))
    (ARGTYPES (%THE-CONS-LIST (%IO-VARIABLE-TYPES DESCRIPTION)))
    (ARGTYPESITER NULL) (ARGTYPE NULL) (VALUE NULL) (BOUNDARGUMENTS NIL)
    (VARIABLEARITY? (VARIABLE-ARITY? DESCRIPTION)))
   (CL:WHEN VARIABLEARITY?
    (CL:SETQ ARGTYPESITER
     (CL:IF FUNCTION? (ALL-DOMAIN-TYPES DESCRIPTION)
      (ALL-ARGUMENT-TYPES DESCRIPTION))))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER)
     (ITER-000 (CL:IF FUNCTION? 2 1)) (UPPER-BOUND-000 (LENGTH ARGUMENTS))
     (COLLECT-000 NULL))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:SETQ I ITER-000) (CL:SETQ I I)
     (CL:IF (CL:NOT (CL:EQ ARGTYPESITER NULL))
      (CL:LET* ((TEMP-000 (POP ARGTYPESITER)))
       (CL:SETQ ARGTYPE
        (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 ARGTYPE)))
      (CL:LET* ((HEAD-000 (%%VALUE ARGTYPES)))
       (CL:SETQ ARGTYPES (%%REST ARGTYPES)) (CL:SETQ ARGTYPE HEAD-000)))
     (CL:SETQ VALUE (SAFE-ARGUMENT-BOUND-TO ARG))
     (CL:WHEN (CL:NOT (COMPUTATION-INPUT-BOUND? VALUE))
      (CL:RETURN-FROM COMPUTE-RELATION-VALUE NULL))
     (CL:WHEN (CL:NOT (CHECK-STRICT-TYPE? VALUE ARGTYPE CL:T))
      (CL:IF ERROR?
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (CL:LET* ((*PRINTREADABLY?* CL:T))
         (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
          "ERROR: compute-relation-value: incorrect argument type for `" VALUE
          "' in `" PROPOSITION "'; should be `" ARGTYPE "'." EOL)
         (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-SPECIALISTS-ERROR))
        (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))
       (CL:RETURN-FROM COMPUTE-RELATION-VALUE NULL)))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS VALUE NIL))
       (CL:IF (CL:EQ BOUNDARGUMENTS NIL) (CL:SETQ BOUNDARGUMENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST BOUNDARGUMENTS COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VALUE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN VARIABLEARITY?
    (CL:LET* ((NFIXED (CL:- (LENGTH ARGTYPES) (CL:IF FUNCTION? 2 1))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM NFIXED))
     (CL:COND
      ((CL:= NFIXED 0) (CL:SETQ BOUNDARGUMENTS (CONS BOUNDARGUMENTS NIL)))
      ((CL:>= (LENGTH BOUNDARGUMENTS) NFIXED)
       (NTH-REST-SETTER BOUNDARGUMENTS
        (CONS (NTH-REST BOUNDARGUMENTS NFIXED) NIL) NFIXED))
      (CL:T (CL:RETURN-FROM COMPUTE-RELATION-VALUE NULL)))))
   (CL:SETQ VALUE (APPLY COMPUTATIONCODE BOUNDARGUMENTS)) VALUE))

;;; (DEFUN (/PL-KERNEL-KB/COMPUTATION-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/COMPUTATION-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (VALUE (COMPUTE-RELATION-VALUE PROPOSITION NULL CL:NIL)) (SUCCESS? NULL))
   (CL:WHEN (CL:EQ VALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/COMPUTATION-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:IF (FUNCTION-DESCRIPTION? (GET-DESCRIPTION (%OPERATOR PROPOSITION)))
    (CL:SETQ SUCCESS?
     (CL:IF
      (BIND-ARGUMENT-TO-VALUE?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS PROPOSITION)))))
       VALUE CL:T)
      TRUE-WRAPPER FALSE-WRAPPER))
    (CL:SETQ SUCCESS? VALUE))
   (SELECT-TEST-RESULT (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN SUCCESS?) CL:T
    FRAME)))

;;; (DEFUN (COMPUTE-SIMPLE-RELATION-CONSTRAINT OBJECT INTEGER) ...)

(CL:DEFUN COMPUTE-SIMPLE-RELATION-CONSTRAINT (PROPOSITION CODE ERROR?)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS PROPOSITION))
    (DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION)))
    (CONSTRAINTCODE
     (CL:IF (CL:NOT (CL:EQ CODE NULL)) CODE (LOOKUP-CONSTRAINT DESCRIPTION)))
    (ARGTYPES (%THE-CONS-LIST (%IO-VARIABLE-TYPES DESCRIPTION)))
    (ARGTYPESITER NULL) (ARGTYPE NULL) (VALUE NULL) (NULLCOUNT 0)
    (VARIABLEINDEX -1) (BOUNDARGUMENTS NIL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NULLCOUNT VARIABLEINDEX))
   (CL:WHEN (VARIABLE-ARITY? DESCRIPTION)
    (CL:SETQ ARGTYPESITER (ALL-ARGUMENT-TYPES DESCRIPTION)))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0)
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:IF (CL:NOT (CL:EQ ARGTYPESITER NULL))
      (CL:LET* ((TEMP-000 (POP ARGTYPESITER)))
       (CL:SETQ ARGTYPE
        (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 ARGTYPE)))
      (CL:LET* ((HEAD-000 (%%VALUE ARGTYPES)))
       (CL:SETQ ARGTYPES (%%REST ARGTYPES)) (CL:SETQ ARGTYPE HEAD-000)))
     (CL:SETQ VALUE (SAFE-ARGUMENT-BOUND-TO ARG))
     (CL:COND
      ((CL:OR (CL:EQ VALUE NULL) (SKOLEM? VALUE)) (CL:SETQ VALUE NULL)
       (CL:SETQ NULLCOUNT (CL:1+ NULLCOUNT)) (CL:SETQ VARIABLEINDEX I))
      ((CL:NOT (CHECK-STRICT-TYPE? VALUE ARGTYPE CL:T))
       (CL:IF ERROR?
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
           "ERROR: compute-relation-value: incorrect argument type for `"
           VALUE "' in `" PROPOSITION "'; should be `" ARGTYPE "'." EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-SPECIALISTS-ERROR))
         (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000))))
        (CL:RETURN-FROM COMPUTE-SIMPLE-RELATION-CONSTRAINT
         (CL:VALUES NULL -1)))))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS VALUE NIL))
       (CL:IF (CL:EQ BOUNDARGUMENTS NIL) (CL:SETQ BOUNDARGUMENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST BOUNDARGUMENTS COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS VALUE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:CASE NULLCOUNT
    (0
     (CL:SETQ VALUE
      (APPLY CONSTRAINTCODE
       (CONS (WRAP-INTEGER VARIABLEINDEX) BOUNDARGUMENTS))))
    (1
     (CL:WHEN *REVERSEPOLARITY?*
      (CL:RETURN-FROM COMPUTE-SIMPLE-RELATION-CONSTRAINT (CL:VALUES NULL -1)))
     (CL:SETQ VALUE
      (APPLY CONSTRAINTCODE
       (CONS (WRAP-INTEGER VARIABLEINDEX) BOUNDARGUMENTS))))
    (CL:OTHERWISE
     (CL:RETURN-FROM COMPUTE-SIMPLE-RELATION-CONSTRAINT (CL:VALUES NULL -1))))
   (CL:VALUES VALUE VARIABLEINDEX)))

;;; (DEFUN (/PL-KERNEL-KB/CONSTRAINT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/CONSTRAINT-SPECIALIST| (FRAME LASTMOVE)
  (CL:SETQ LASTMOVE LASTMOVE)
  (CL:LET* ((VALUE NULL) (VARIABLEINDEX NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM VARIABLEINDEX))
   (CL:MULTIPLE-VALUE-SETQ (VALUE VARIABLEINDEX)
    (COMPUTE-SIMPLE-RELATION-CONSTRAINT (%PROPOSITION FRAME) NULL CL:NIL))
   (CL:WHEN (CL:EQ VALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/CONSTRAINT-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:CASE VARIABLEINDEX
    (-1 (SELECT-TEST-RESULT (CL:EQ VALUE TRUE-WRAPPER) CL:T FRAME))
    (CL:OTHERWISE
     (SELECT-TEST-RESULT
      (BIND-ARGUMENT-TO-VALUE?
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR
         (%THE-ARRAY (%ARGUMENTS (%PROPOSITION FRAME))))
        VARIABLEINDEX)
       VALUE CL:T)
      CL:T FRAME)))))

;;; (DEFUN (/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (MAINARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (MAINARGVALUE (ARGUMENT-BOUND-TO MAINARG))
    (ROOTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (ROOTARGVALUE (ARGUMENT-BOUND-TO ROOTARG))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL))
    (COLLECTION NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:IF (CL:EQ MAINARGVALUE NULL)
     (CL:IF (CL:EQ ROOTARGVALUE NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE)
      (CL:IF (ISA? ROOTARGVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:IF *REVERSEPOLARITY?*
        (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
         KWD-SPECIALISTS-FAILURE)
        (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
         (SELECT-PROOF-RESULT
          (BIND-ARGUMENT-TO-VALUE? MAINARG
           (|/PL-KERNEL-KB/TIMES-COMPUTATION| ROOTARGVALUE ROOTARGVALUE) CL:T)
          CL:NIL CL:T)))
       (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE)))
     (CL:IF (ISA? MAINARGVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
      (CL:IF
       (|/PL-KERNEL-KB/ARITHMETIC-LESS-TEST| MAINARGVALUE (WRAP-INTEGER 0))
       (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE)
       (CL:IF (CL:AND (CL:EQ ROOTARGVALUE NULL) *REVERSEPOLARITY?*)
        (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
         KWD-SPECIALISTS-FAILURE)
        (CL:LET* ((SQRT (|/PL-KERNEL-KB/SQRT-COMPUTATION| MAINARGVALUE)))
         (CL:SETQ COLLECTION
          (CONS-LIST SQRT (|/PL-KERNEL-KB/NEGATE-COMPUTATION| SQRT))))))
      (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE))))
   (CL:WHEN (CL:NOT (CL:EQ ROOTARGVALUE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|
     (SELECT-TEST-RESULT
      (CL:OR
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| ROOTARGVALUE
        (%%VALUE COLLECTION))
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| ROOTARGVALUE
        (%%VALUE (%%REST COLLECTION))))
      CL:T FRAME)))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:SETQ ITERATOR (ALLOCATE-ITERATOR COLLECTION))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
   (CL:IF
    (CL:AND (NEXT? ITERATOR)
     (BIND-ARGUMENT-TO-VALUE? ROOTARG (%VALUE ITERATOR) CL:T))
    KWD-SPECIALISTS-CONTINUING-SUCCESS KWD-SPECIALISTS-TERMINAL-FAILURE)))

;;; (DEFUN (/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (MAINARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (MAINARGVALUE (ARGUMENT-BOUND-TO MAINARG))
    (ABSARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (ABSARGVALUE (ARGUMENT-BOUND-TO ABSARG))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL))
    (COLLECTION NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:IF (CL:EQ ABSARGVALUE NULL)
     (CL:IF (CL:EQ MAINARGVALUE NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE)
      (CL:IF (ISA? MAINARGVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:IF *REVERSEPOLARITY?*
        (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
         KWD-SPECIALISTS-FAILURE)
        (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
         (SELECT-PROOF-RESULT
          (BIND-ARGUMENT-TO-VALUE? ABSARG
           (|/PL-KERNEL-KB/ABS-COMPUTATION| MAINARGVALUE) CL:T)
          CL:NIL CL:T)))
       (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE)))
     (CL:IF (ISA? ABSARGVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
      (CL:IF
       (|/PL-KERNEL-KB/ARITHMETIC-LESS-TEST| ABSARGVALUE (WRAP-INTEGER 0))
       (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE)
       (CL:IF *REVERSEPOLARITY?*
        (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
         KWD-SPECIALISTS-FAILURE)
        (CL:SETQ COLLECTION
         (CONS-LIST ABSARGVALUE
          (|/PL-KERNEL-KB/NEGATE-COMPUTATION| ABSARGVALUE)))))
      (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE))))
   (CL:WHEN (CL:NOT (CL:EQ MAINARGVALUE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|
     (SELECT-TEST-RESULT
      (CL:OR
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| MAINARGVALUE
        (%%VALUE COLLECTION))
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| MAINARGVALUE
        (%%VALUE (%%REST COLLECTION))))
      CL:T FRAME)))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:SETQ ITERATOR (ALLOCATE-ITERATOR COLLECTION))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
   (CL:IF
    (CL:AND (NEXT? ITERATOR)
     (BIND-ARGUMENT-TO-VALUE? MAINARG (%VALUE ITERATOR) CL:T))
    KWD-SPECIALISTS-CONTINUING-SUCCESS KWD-SPECIALISTS-TERMINAL-FAILURE)))

;;; (DEFUN (ENUMERATIONS-CONTAINING-MEMBER LIST) ...)

(CL:DEFUN ENUMERATIONS-CONTAINING-MEMBER (SELF)
  (CL:LET* ((LIST (NEW-LIST)))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF
       SGT-SPECIALISTS-PL-KERNEL-KB-COLLECTIONOF CL:T)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:LET*
      ((SKOLEMLIST
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
         (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS P)))))))
      (CL:WHEN (CL:NOT (EQL? SELF SKOLEMLIST)) (PUSH LIST SKOLEMLIST)))))
   LIST))

;;; (DEFUN (/PL-KERNEL-KB/MEMBER-OF-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME)) (ARGUMENTS (%ARGUMENTS PROPOSITION))
    (MEMBERARG (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
    (MEMBER (ARGUMENT-BOUND-TO MEMBERARG))
    (COLLECTIONARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1))
    (COLLECTION (ARGUMENT-BOUND-TO COLLECTIONARG))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
      (CL:IF (CL:NOT (CL:EQ (%DOWN FRAME) NULL))
       KWD-SPECIALISTS-CONTINUING-SUCCESS KWD-SPECIALISTS-FINAL-SUCCESS)))
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
      KWD-SPECIALISTS-FAILURE))
    (CL:T))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:COND
     ((CL:EQ COLLECTION NULL)
      (CL:WHEN (CL:EQ MEMBER NULL)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))
      (CL:SETQ ITERATOR
       (ALLOCATE-ITERATOR (ENUMERATIONS-CONTAINING-MEMBER MEMBER))))
     (CL:T
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE COLLECTION)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION)
         (CL:PROGN
          (CL:LET*
           ((ISAPROP (CREATE-PROPOSITION SYM-SPECIALISTS-STELLA-ISA 1)))
           (CL:SETF (%OPERATOR ISAPROP) (%SURROGATE-VALUE-INVERSE COLLECTION))
           (CL:LET
            ((SELF (%THE-ARRAY (%ARGUMENTS ISAPROP))) (VALUE MEMBERARG)
             (POSITION 0))
            (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
             (CL:TYPE CL:FIXNUM POSITION))
            (CL:SETF (CL:AREF SELF POSITION) VALUE))
           (CREATE-DOWN-FRAME FRAME ISAPROP)
           (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
            KWD-SPECIALISTS-MOVE-DOWN))))
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
         (CL:PROGN
          (CL:LET* ((TEST-VALUE-000 CL:NIL))
           (CL:SETQ TEST-VALUE-000 (CL:= (ARITY COLLECTION) 1))
           (CL:WHEN TEST-VALUE-000
            (CL:IF
             (CL:EQ
              (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS COLLECTION)
               SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL)
              NULL)
             (CL:SETQ TEST-VALUE-000 CL:T)
             (CL:LET* ((ALWAYS?-000 CL:T))
              (CL:LET*
               ((VAR NULL)
                (VECTOR-000
                 (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS COLLECTION)
                  SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL))
                (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
               (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
               (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
                (CL:SETQ VAR
                 (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
                  INDEX-000))
                (CL:WHEN (CL:EQ (ARGUMENT-BOUND-TO VAR) NULL)
                 (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
                (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
              (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
           (CL:IF TEST-VALUE-000
            (CL:PROGN
             (CL:IF
              (OVERLAY-WITH-PATTERN-FRAME? (CREATE-DOWN-FRAME FRAME NULL)
               COLLECTION (VECTOR MEMBERARG))
              (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
               KWD-SPECIALISTS-MOVE-DOWN)
              (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
               KWD-SPECIALISTS-FAILURE)))
            (CL:PROGN
             (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
              KWD-SPECIALISTS-FAILURE))))))
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-STELLA-COLLECTION)
         (CL:PROGN
          (CL:IF (CL:EQ MEMBER NULL)
           (CL:SETQ ITERATOR
            (ALLOCATE-ITERATOR
             (ASSERTED-COLLECTION-MEMBERS COLLECTION CL:NIL)))
           (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
            (SELECT-TEST-RESULT (MEMBER-OF-COLLECTION? MEMBER COLLECTION)
             CL:NIL FRAME)))))
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
         (CL:PROGN
          (CL:IF (CL:EQ MEMBER NULL)
           (CL:SETQ ITERATOR
            (ALLOCATE-ITERATOR
             (ASSERTED-COLLECTION-MEMBERS COLLECTION CL:NIL)))
           (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
            (SELECT-TEST-RESULT (MEMBER-OF-COLLECTION? MEMBER COLLECTION)
             CL:NIL FRAME)))))
        (CL:T
         (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
          KWD-SPECIALISTS-FAILURE))))))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
   (CL:LOOP WHILE (NEXT? ITERATOR) DO
    (CL:IF (CL:EQ COLLECTION NULL)
     (CL:WHEN
      (BIND-VARIABLE-TO-VALUE? COLLECTIONARG (VALUE-OF (%VALUE ITERATOR))
       CL:T)
      (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
       KWD-SPECIALISTS-CONTINUING-SUCCESS))
     (CL:WHEN
      (BIND-VARIABLE-TO-VALUE? MEMBERARG (VALUE-OF (%VALUE ITERATOR)) CL:T)
      (CL:RETURN-FROM |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|
       KWD-SPECIALISTS-CONTINUING-SUCCESS))))
   KWD-SPECIALISTS-FAILURE))

;;; (DEFUN /PL-KERNEL-KB/MEMBER-OF-EVALUATOR ...)

(CL:DEFUN |/PL-KERNEL-KB/MEMBER-OF-EVALUATOR| (SELF)
  (CL:LET*
   ((MEMBER
     (VALUE-OF
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0)))
    (COLLECTION
     (VALUE-OF
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 1))))
   (CL:WHEN (TRUE? SELF)
    (CL:WHEN
     (CL:AND (ISA? COLLECTION SGT-SPECIALISTS-LOGIC-DESCRIPTION)
      (ISA? MEMBER SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
      (CL:NOT (NAMED-DESCRIPTION? COLLECTION)))
     (INHERIT-UNNAMED-DESCRIPTION MEMBER COLLECTION (DEFAULT-TRUE? SELF)))
    (CL:WHEN (LOGICAL-COLLECTION? COLLECTION)
     (CL:LET* ((*REVERSEPOLARITY?* CL:T))
      (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
      (CL:WHEN
       (CL:AND (MEMBER-OF-COLLECTION? MEMBER COLLECTION)
        (CL:NOT (SKOLEM? MEMBER)))
       (SIGNAL-TRUTH-VALUE-CLASH SELF)))))))

;;; (DEFUN (/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME)) (ARGUMENTS (%ARGUMENTS PROPOSITION))
    (MEMBERARG (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
    (MEMBER (ARGUMENT-BOUND-TO MEMBERARG))
    (COLLECTIONARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1))
    (COLLECTION (ARGUMENT-BOUND-TO COLLECTIONARG))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
      (CL:IF (CL:NOT (CL:EQ (%DOWN FRAME) NULL))
       KWD-SPECIALISTS-CONTINUING-SUCCESS KWD-SPECIALISTS-FINAL-SUCCESS)))
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
      KWD-SPECIALISTS-FAILURE))
    (CL:T))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:COND
     ((CL:NOT (CL:EQ COLLECTION NULL))
      (CL:COND
       ((CL:AND (CLASS? COLLECTION)
         (ISA? COLLECTION SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
        (CL:LET*
         ((ISAPROPOSITION (CREATE-PROPOSITION SYM-SPECIALISTS-STELLA-ISA 1)))
         (CL:SETF (%OPERATOR ISAPROPOSITION)
          (%SURROGATE-VALUE-INVERSE COLLECTION))
         (CL:LET
          ((SELF (%THE-ARRAY (%ARGUMENTS ISAPROPOSITION))) (VALUE MEMBERARG)
           (POSITION 0))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CREATE-SUBGOAL-FRAME FRAME ISAPROPOSITION NULL)
         (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
          KWD-SPECIALISTS-MOVE-DOWN)))
       ((CL:EQ MEMBER NULL)
        (CREATE-SUBGOAL-FRAME FRAME (%PROPOSITION FRAME)
         KWD-SPECIALISTS-SCAN-COLLECTION)
        (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
         KWD-SPECIALISTS-MOVE-DOWN))
       (CL:T
        (CL:IF (MEMBER-OF-COLLECTION? MEMBER COLLECTION)
         (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
          KWD-SPECIALISTS-FINAL-SUCCESS)
         (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
          KWD-SPECIALISTS-FAILURE)))))
     ((CL:NOT (CL:EQ MEMBER NULL))
      (CL:SETQ ITERATOR (ALLOCATE-ITERATOR (ALL-TYPES MEMBER)))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
       SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
     (CL:T
      (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
       KWD-SPECIALISTS-FAILURE))))
   (CL:WHEN (CL:NOT (CL:EQ ITERATOR NULL))
    (CL:WHEN (NEXT? ITERATOR)
     (BIND-VARIABLE-TO-VALUE? COLLECTIONARG (%VALUE ITERATOR) CL:T)
     (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
      KWD-SPECIALISTS-CONTINUING-SUCCESS))
    (CL:RETURN-FROM |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   KWD-SPECIALISTS-FAILURE))

;;; (DEFUN (TEST-DISJOINT-TERMS? BOOLEAN) ...)

(CL:DEFUN TEST-DISJOINT-TERMS? (TERM1 TERM2)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM1) SGT-SPECIALISTS-LOGIC-DESCRIPTION)
    (CL:PROGN
     (CL:COND
      ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE TERM2)
        SGT-SPECIALISTS-LOGIC-DESCRIPTION)
       (CL:PROGN
        (CL:IF (CL:EQ (CURRENT-INFERENCE-LEVEL) REFUTATION-INFERENCE)
         (EXPENSIVE-DISJOINT-TERMS? TERM1 TERM2)
         (DISJOINT-TERMS? TERM1 TERM2))))
      (CL:T CL:NIL))))
   (CL:T CL:NIL)))

;;; (DEFUN (/PL-KERNEL-KB/SUBSET-OF-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (SUBCOLLECTIONARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (SUPERCOLLECTIONARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (SUBCOLLECTION (EQUIVALENT-VALUE-OF (ARGUMENT-BOUND-TO SUBCOLLECTIONARG)))
    (SUPERCOLLECTION
     (EQUIVALENT-VALUE-OF (ARGUMENT-BOUND-TO SUPERCOLLECTIONARG)))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:COND
     ((CL:AND (CL:NOT (CL:EQ SUBCOLLECTION NULL))
       (CL:NOT (CL:EQ SUPERCOLLECTION NULL)))
      (CL:COND
       ((COLLECTION-IMPLIES-COLLECTION? SUBCOLLECTION SUPERCOLLECTION)
        (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
         (SELECT-TEST-RESULT CL:T CL:T FRAME)))
       ((TEST-DISJOINT-TERMS? SUBCOLLECTION SUPERCOLLECTION)
        (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
         (SELECT-TEST-RESULT CL:NIL CL:T FRAME)))
       (CL:T
        (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
         KWD-SPECIALISTS-FAILURE))))
     ((CL:NOT (CL:EQ SUBCOLLECTION NULL))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SUBCOLLECTION)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
         (CL:PROGN
          (CL:SETQ ITERATOR
           (CONCATENATE (ALLOCATE-ITERATOR (CONS SUBCOLLECTION NIL))
            (ALL-SUPERCOLLECTIONS SUBCOLLECTION)))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-COLLECTION)
         (CL:PROGN
          (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
           KWD-SPECIALISTS-FAILURE)))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
           "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
     ((CL:NOT (CL:EQ SUPERCOLLECTION NULL))
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE SUPERCOLLECTION)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
         (CL:PROGN
          (CL:SETQ ITERATOR
           (CONCATENATE (ALLOCATE-ITERATOR (CONS SUPERCOLLECTION NIL))
            (ALL-SUBCOLLECTIONS SUPERCOLLECTION)))))
        ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-STELLA-COLLECTION)
         (CL:PROGN
          (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
           KWD-SPECIALISTS-FAILURE)))
        (CL:T
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-001
           "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
     (CL:T
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
       " Found 'subset-of' goal with two unbound arguments." EOL
       "   Possibly the query needs rewriting." EOL EOL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
       KWD-SPECIALISTS-FAILURE)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
   (CL:LOOP WHILE (NEXT? ITERATOR) DO
    (CL:LET* ((VALUE (VALUE-OF (%VALUE ITERATOR))))
     (CL:WHEN
      (CL:AND CL:T
       (CL:IF (CL:NOT (CL:EQ SUBCOLLECTION NULL))
        (BIND-VARIABLE-TO-VALUE? SUPERCOLLECTIONARG VALUE CL:T)
        (BIND-VARIABLE-TO-VALUE? SUBCOLLECTIONARG VALUE CL:T)))
      (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|
       KWD-SPECIALISTS-CONTINUING-SUCCESS))))
   KWD-SPECIALISTS-FAILURE))

;;; (DEFUN (/PL-KERNEL-KB/HOLDS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/HOLDS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((HOLDSPROPOSITION (%PROPOSITION FRAME))
    (HOLDSARGUMENTS (%ARGUMENTS HOLDSPROPOSITION))
    (HOLDSARITY (CL:1- (LENGTH HOLDSARGUMENTS)))
    (DESCRIPTION
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HOLDSARGUMENTS)) 0))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM HOLDSARITY))
   (CL:COND
    ((CL:NOT (CL:EQ DESCRIPTION NULL))
     (CL:COND
      ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
       (CL:RETURN-FROM |/PL-KERNEL-KB/HOLDS-SPECIALIST|
        (CL:IF (CL:NOT (CL:EQ (%DOWN FRAME) NULL))
         KWD-SPECIALISTS-CONTINUING-SUCCESS KWD-SPECIALISTS-FINAL-SUCCESS)))
      ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
       (CL:RETURN-FROM |/PL-KERNEL-KB/HOLDS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))
      ((CL:EQ LASTMOVE KWD-SPECIALISTS-DOWN))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
         "' is not a valid case option")
        (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE DESCRIPTION)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION)
        (CL:PROGN
         (CL:LET*
          ((ARGCOUNTMINUS1 (CL:1- (LENGTH HOLDSARGUMENTS)))
           (KIND SYM-SPECIALISTS-STELLA-PREDICATE) (RELATIONPROPOSITION NULL)
           (RELATIONREF (%SURROGATE-VALUE-INVERSE DESCRIPTION)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM ARGCOUNTMINUS1))
          (CL:COND
           ((CLASS-DESCRIPTION? DESCRIPTION)
            (CL:SETQ KIND SYM-SPECIALISTS-STELLA-ISA))
           ((FUNCTION-DESCRIPTION? DESCRIPTION)
            (CL:SETQ KIND SYM-SPECIALISTS-STELLA-FUNCTION)))
          (CL:SETQ RELATIONPROPOSITION
           (CREATE-PROPOSITION KIND ARGCOUNTMINUS1))
          (CL:SETF (%OPERATOR RELATIONPROPOSITION) RELATIONREF)
          (CL:LET*
           ((I NULL-INTEGER) (ITER-000 0)
            (UPPER-BOUND-000 (CL:1- ARGCOUNTMINUS1)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
           (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
            (CL:SETQ I ITER-000)
            (CL:LET
             ((SELF (%THE-ARRAY (%ARGUMENTS RELATIONPROPOSITION)))
              (VALUE
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HOLDSARGUMENTS))
                (CL:THE CL:FIXNUM (CL:1+ I))))
              (POSITION I))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
              (CL:TYPE CL:FIXNUM POSITION))
             (CL:SETF (CL:AREF SELF POSITION) VALUE))
            (CL:SETQ ITER-000 (CL:1+ ITER-000))))
          (CREATE-SUBGOAL-FRAME FRAME RELATIONPROPOSITION NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/HOLDS-SPECIALIST|
           KWD-SPECIALISTS-MOVE-DOWN))))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
        (CL:PROGN
         (CL:LET*
          ((ARGCOUNTMINUS1 (CL:1- (LENGTH HOLDSARGUMENTS)))
           (DUMMYPROPOSITION
            (CREATE-PROPOSITION SYM-SPECIALISTS-STELLA-DUMMY ARGCOUNTMINUS1))
           (SUBGOALFRAME
            (CREATE-SUBGOAL-FRAME FRAME DUMMYPROPOSITION
             KWD-SPECIALISTS-FULL-SUBQUERY)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM ARGCOUNTMINUS1))
          (CL:LET*
           ((I NULL-INTEGER) (ITER-001 0)
            (UPPER-BOUND-001 (CL:1- ARGCOUNTMINUS1)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
           (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
            (CL:SETQ I ITER-001)
            (CL:LET
             ((SELF (%THE-ARRAY (%ARGUMENTS DUMMYPROPOSITION)))
              (VALUE
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HOLDSARGUMENTS))
                (CL:THE CL:FIXNUM (CL:1+ I))))
              (POSITION I))
             (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
              (CL:TYPE CL:FIXNUM POSITION))
             (CL:SETF (CL:AREF SELF POSITION) VALUE))
            (CL:SETQ ITER-001 (CL:1+ ITER-001))))
          (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SUBGOALFRAME)
           SYM-SPECIALISTS-LOGIC-DESCRIPTION DESCRIPTION NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/HOLDS-SPECIALIST|
           KWD-SPECIALISTS-MOVE-DOWN))))
       (CL:T))))
    (CL:T
     (CL:LET*
      ((ITERATOR
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
         SYM-SPECIALISTS-STELLA-ITERATOR NULL))
       (BACKLINKEDARG NULL) (BACKLINKEDARGPOSITION -1) (NOMATCHES? CL:NIL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM BACKLINKEDARGPOSITION))
      (CL:SETQ NOMATCHES? NOMATCHES?)
      (CL:WHEN (CL:EQ ITERATOR NULL)
       (CL:MULTIPLE-VALUE-SETQ (BACKLINKEDARG NOMATCHES?)
        (SELECT-ARGUMENT-WITH-BACKLINKS HOLDSPROPOSITION))
       (CL:WHEN (CL:NOT (CL:EQ BACKLINKEDARG NULL))
        (CL:LET* ((VALUE-000 NULL-INTEGER))
         (CL:DECLARE (CL:TYPE CL:FIXNUM VALUE-000))
         (CL:LET*
          ((I NULL-INTEGER) (ITER-002 (INTERVAL -1 NULL-INTEGER)) (ARG NULL)
           (VECTOR-000 HOLDSARGUMENTS) (INDEX-000 0)
           (LENGTH-000 (LENGTH VECTOR-000)))
          (CL:DECLARE (CL:TYPE CL:FIXNUM I INDEX-000 LENGTH-000))
          (CL:LOOP WHILE (CL:AND (NEXT? ITER-002) (CL:< INDEX-000 LENGTH-000))
           DO (CL:SETQ I (%VALUE ITER-002))
           (CL:SETQ ARG
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:WHEN
            (CL:AND (CL:>= I 0) (EQL? BACKLINKEDARG (ARGUMENT-BOUND-TO ARG)))
            (CL:SETQ VALUE-000 I) (CL:RETURN))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
         (CL:SETQ BACKLINKEDARGPOSITION VALUE-000))
        (CL:LET* ((VALUE-001 NIL))
         (CL:LET*
          ((PROP NULL)
           (ITER-003
            (ALLOCATE-ITERATOR
             (UNFILTERED-DEPENDENT-PROPOSITIONS BACKLINKEDARG NULL)))
           (COLLECT-000 NULL))
          (CL:LOOP WHILE (NEXT? ITER-003) DO (CL:SETQ PROP (%VALUE ITER-003))
           (CL:WHEN
            (CL:AND
             (CL:OR (CL:EQ (%KIND PROP) KWD-SPECIALISTS-FUNCTION)
              (CL:EQ (%KIND PROP) KWD-SPECIALISTS-PREDICATE)
              (CL:EQ (%KIND PROP) KWD-SPECIALISTS-ISA))
             (CL:= (LENGTH (%ARGUMENTS PROP)) HOLDSARITY)
             (CL:AND (CL:NOT (DELETED? PROP))
              (CL:IF *REVERSEPOLARITY?* (FALSE? PROP)
               (CL:OR (TRUE? PROP) (FUNCTION-WITH-DEFINED-VALUE? PROP))))
             (CL:= (POSITION (%ARGUMENTS PROP) BACKLINKEDARG 0)
              BACKLINKEDARGPOSITION))
            (CL:IF (CL:EQ COLLECT-000 NULL)
             (CL:PROGN (CL:SETQ COLLECT-000 (CONS PROP NIL))
              (CL:IF (CL:EQ VALUE-001 NIL) (CL:SETQ VALUE-001 COLLECT-000)
               (ADD-CONS-TO-END-OF-CONS-LIST VALUE-001 COLLECT-000)))
             (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS PROP NIL))
              (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))
         (CL:SETQ ITERATOR (ALLOCATE-ITERATOR VALUE-001))))
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
        SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
      (CL:WHEN (CL:NOT (CL:EQ ITERATOR NULL))
       (CL:LET*
        ((PATTERNRECORD (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))
         (UBSTACKOFFSET (%TOP-UNBINDING-STACK-OFFSET PATTERNRECORD)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM UBSTACKOFFSET))
        (CL:LET* ((PROP NULL) (ITER-004 ITERATOR))
         (CL:LOOP WHILE (NEXT? ITER-004) DO (CL:SETQ PROP (%VALUE ITER-004))
          (CL:TAGBODY
           (CL:WHEN
            (CL:NOT
             (BIND-VARIABLE-TO-VALUE?
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HOLDSARGUMENTS))
               0)
              (GET-DESCRIPTION (%OPERATOR PROP)) CL:T))
            (CL:GO :CONTINUE))
           (CL:LET* ((ALWAYS?-000 CL:T))
            (CL:LET*
             ((ARG NULL) (VECTOR-001 HOLDSARGUMENTS) (INDEX-001 0)
              (LENGTH-001 (LENGTH VECTOR-001)) (I NULL-INTEGER) (ITER-005 -1))
             (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 I ITER-005))
             (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
              (CL:SETQ ARG
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
                INDEX-001))
              (CL:SETQ I ITER-005)
              (CL:WHEN (CL:>= I 0)
               (CL:WHEN
                (CL:NOT
                 (BIND-ARGUMENT-TO-VALUE? ARG
                  (CL:AREF
                   (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP))) I)
                  CL:T))
                (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN)))
              (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
              (CL:SETQ ITER-005 (CL:1+ ITER-005))))
            (CL:WHEN ALWAYS?-000
             (CL:RETURN-FROM |/PL-KERNEL-KB/HOLDS-SPECIALIST|
              KWD-SPECIALISTS-CONTINUING-SUCCESS)))
           (UNBIND-VARIABLES-BEGINNING-AT PATTERNRECORD (CL:1+ UBSTACKOFFSET))
           :CONTINUE))))))))
   KWD-SPECIALISTS-FAILURE))

;;; (DEFUN (/PL-KERNEL-KB/PROPOSITION-RELATION-COMPUTATION OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/PROPOSITION-RELATION-COMPUTATION| (P)
  (CL:LET* ((OPERATOR (%OPERATOR P)))
   (CL:COND
    ((SUBTYPE-OF-SURROGATE? (SAFE-PRIMARY-TYPE OPERATOR))
     (CL:PROGN (%SURROGATE-VALUE OPERATOR)))
    (CL:T NULL))))

;;; (DEFUN (/PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION| (P I)
  (CL:LET* ((ARGUMENTS (%ARGUMENTS P)))
   (CL:IF
    (CL:AND (CL:>= (%WRAPPER-VALUE I) 0)
     (CL:< (%WRAPPER-VALUE I) (LENGTH ARGUMENTS)))
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS))
     (CL:THE CL:FIXNUM (%WRAPPER-VALUE I)))
    NULL)))

;;; (DEFUN (/PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION SKOLEM) ...)

(CL:DEFUN |/PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION| (P)
  (CREATE-LOGICAL-LIST (LISTIFY (%ARGUMENTS P))))

;;; (DEFUN (/PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION| (P)
  (WRAP-INTEGER (LENGTH (%ARGUMENTS P))))

;;; (DEFUN (/PL-KERNEL-KB/CUT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/CUT-SPECIALIST| (FRAME LASTMOVE)
  (CL:SETQ LASTMOVE LASTMOVE)
  (CL:COND
   ((CL:EQ
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)
     NULL)
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR EMPTY-PROPOSITIONS-ITERATOR NULL)
    KWD-SPECIALISTS-CONTINUING-SUCCESS)
   (CL:T
    (CL:LET* ((PARENTFRAME (%UP FRAME)))
     (CL:WHEN
      (CL:OR (CL:EQ PARENTFRAME NULL)
       (CL:NOT (CL:EQ (%STATE PARENTFRAME) KWD-SPECIALISTS-AND)))
      (CL:RETURN-FROM |/PL-KERNEL-KB/CUT-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE))
     (CL:LET*
      ((CONJUNCTS
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PARENTFRAME)
         SYM-SPECIALISTS-STELLA-ARGUMENTS NULL)))
      (CL:WHEN (CL:NOT (CL:EQ CONJUNCTS NULL))
       (CL:LET*
        ((CONJUNCT NULL) (VECTOR-000 CONJUNCTS) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ CONJUNCT
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:IF (CL:EQ CONJUNCT FRAME) (CL:RETURN)
          (POP-CONTROL-FRAME CONJUNCT))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))))
     KWD-SPECIALISTS-TERMINAL-FAILURE))))

;;; (DEFUN (/PL-KERNEL-KB/BOUND-VARIABLES-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/BOUND-VARIABLES-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET* ((ALWAYS?-000 CL:T))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS (%PROPOSITION FRAME))) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:WHEN (CL:EQ (ARGUMENT-BOUND-TO ARG) NULL)
      (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET* ((ALLBOUND? ALWAYS?-000)) (CL:SETQ LASTMOVE LASTMOVE)
    (SELECT-TEST-RESULT ALLBOUND? CL:T FRAME))))

;;; (DEFCLASS FORK-PROOF-ADJUNCT ...)

(CL:DEFCLASS FORK-PROOF-ADJUNCT (PROOF-ADJUNCT)
  ((CONDITION-JUSTIFICATION :ALLOCATION :INSTANCE :ACCESSOR
    %CONDITION-JUSTIFICATION)
   (DOWN-FRAME :ALLOCATION :INSTANCE :ACCESSOR %DOWN-FRAME)))

(CL:DEFUN NEW-FORK-PROOF-ADJUNCT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FORK-PROOF-ADJUNCT)))
   (CL:SETF (%DOWN-FRAME SELF) NULL)
   (CL:SETF (%CONDITION-JUSTIFICATION SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORK-PROOF-ADJUNCT))
  SGT-SPECIALISTS-LOGIC-FORK-PROOF-ADJUNCT)

(CL:DEFUN ACCESS-FORK-PROOF-ADJUNCT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-CONDITION-JUSTIFICATION)
    (CL:IF SETVALUE? (CL:SETF (%CONDITION-JUSTIFICATION SELF) VALUE)
     (CL:SETQ VALUE (%CONDITION-JUSTIFICATION SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-DOWN-FRAME)
    (CL:IF SETVALUE? (CL:SETF (%DOWN-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%DOWN-FRAME SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (/PL-KERNEL-KB/FORK-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/FORK-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((RECORDJUSTIFICATIONS? *RECORD-JUSTIFICATIONS?*)
    (ADJUNCT
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT NULL)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-DOWN)
     (CL:WHEN RECORDJUSTIFICATIONS?
      (CL:WHEN (CL:EQ ADJUNCT NULL) (CL:SETQ ADJUNCT (NEW-FORK-PROOF-ADJUNCT))
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
        SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT ADJUNCT NULL))
      (CL:SETF (%DOWN FRAME) (%DOWN-FRAME ADJUNCT)))
     KWD-SPECIALISTS-MOVE-DOWN)
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
     (CL:WHEN (CL:> (%ARGUMENT-CURSOR FRAME) 0)
      (CL:WHEN RECORDJUSTIFICATIONS?
       (CL:SETF (%DOWN-FRAME ADJUNCT) (%DOWN FRAME))
       (PROPAGATE-FRAME-TRUTH-VALUE (%RESULT FRAME) FRAME)
       (CL:LET* ((SELF-001 (NEW-JUSTIFICATION)))
        (CL:SETF (%INFERENCE-RULE SELF-001)
         (CL:IF
          (CL:EQ (%INFERENCE-RULE (%CONDITION-JUSTIFICATION ADJUNCT))
           KWD-SPECIALISTS-FAIL-INTRODUCTION)
          KWD-SPECIALISTS-FORK-ELSE KWD-SPECIALISTS-FORK-THEN))
        (CL:SETF (%ANTECEDENTS SELF-001)
         (CONS (%CONDITION-JUSTIFICATION ADJUNCT)
          (CONS
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%RESULT FRAME))
            SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)
           NIL)))
        (RECORD-GOAL-JUSTIFICATION FRAME SELF-001)))
      (CL:COND
       ((CL:NOT (CL:EQ (%DOWN FRAME) NULL))
        (CL:WHEN RECORDJUSTIFICATIONS? (CL:SETF (%DOWN FRAME) NULL))
        (CL:RETURN-FROM |/PL-KERNEL-KB/FORK-SPECIALIST|
         KWD-SPECIALISTS-CONTINUING-SUCCESS))
       (CL:T
        (CL:RETURN-FROM |/PL-KERNEL-KB/FORK-SPECIALIST|
         KWD-SPECIALISTS-FINAL-SUCCESS))))
     (CL:WHEN RECORDJUSTIFICATIONS?
      (CL:SETF (%CONDITION-JUSTIFICATION ADJUNCT)
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%RESULT FRAME))
        SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)))
     (CL:SETF (%DOWN FRAME) NULL) (CL:SETF (%ARGUMENT-CURSOR FRAME) 1)
     KWD-SPECIALISTS-MOVE-DOWN)
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
     (CL:WHEN (CL:> (%ARGUMENT-CURSOR FRAME) 0)
      (CL:RETURN-FROM |/PL-KERNEL-KB/FORK-SPECIALIST|
       KWD-SPECIALISTS-FAILURE))
     (CL:WHEN RECORDJUSTIFICATIONS?
      (RECORD-FAIL-JUSTIFICATION (%RESULT FRAME) KWD-SPECIALISTS-UP-FAIL)
      (CL:SETF (%CONDITION-JUSTIFICATION ADJUNCT)
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%RESULT FRAME))
        SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)))
     (CL:SETF (%DOWN FRAME) NULL) (CL:SETF (%ARGUMENT-CURSOR FRAME) 2)
     KWD-SPECIALISTS-MOVE-DOWN)
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (COMPUTE-SUBQUERY-OPTIONS PROPOSITION PROPERTY-LIST) ...)

(CL:DEFUN COMPUTE-SUBQUERY-OPTIONS (FRAME)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS (%PROPOSITION FRAME))) (ARG NULL) (PROPARG NULL)
    (LASTOPTIONARGINDEX (CL:1- (LENGTH ARGUMENTS))) (CURSOR 1) (KEY NULL)
    (VALUE NULL) (SUBQUERYOPTIONS (NEW-PROPERTY-LIST))
    (PARENTOPTIONS (%OPTIONS *QUERYITERATOR*)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LASTOPTIONARGINDEX CURSOR))
   (CL:WHEN (CL:< LASTOPTIONARGINDEX 0)
    (CL:RETURN-FROM COMPUTE-SUBQUERY-OPTIONS (CL:VALUES NULL NULL)))
   (CL:SETQ ARG
    (ARGUMENT-BOUND-TO
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0)))
   (CL:COND
    ((CL:AND (CL:NOT (CL:EQ ARG NULL))
      (ISA? ARG SGT-SPECIALISTS-LOGIC-PROPOSITION))
     (CL:SETQ PROPARG ARG))
    ((CL:>= LASTOPTIONARGINDEX 1) (CL:SETQ CURSOR 0)
     (CL:SETQ KEY KWD-SPECIALISTS-HOW-MANY) (CL:SETQ VALUE ARG)
     (CL:SETQ ARG
      (ARGUMENT-BOUND-TO
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1)))
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ ARG NULL))
       (ISA? ARG SGT-SPECIALISTS-LOGIC-PROPOSITION))
      (CL:SETQ PROPARG ARG)
      (CL:RETURN-FROM COMPUTE-SUBQUERY-OPTIONS (CL:VALUES NULL NULL))))
    (CL:T (CL:RETURN-FROM COMPUTE-SUBQUERY-OPTIONS (CL:VALUES NULL NULL))))
   (CL:WHEN
    (CL:LET ((X (CL:- LASTOPTIONARGINDEX CURSOR)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM X)) (CL:NOT (CL:LOGBITP 0 X)))
    (CL:SETQ LASTOPTIONARGINDEX (CL:1- LASTOPTIONARGINDEX)))
   (CL:LOOP WHILE (CL:< CURSOR LASTOPTIONARGINDEX) DO
    (CL:COND ((CL:= CURSOR 0))
     (CL:T
      (CL:SETQ KEY
       (GENERATE-TERM
        (ARGUMENT-BOUND-TO
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) CURSOR))))
      (CL:SETQ VALUE
       (GENERATE-TERM
        (ARGUMENT-BOUND-TO
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS))
          (CL:THE CL:FIXNUM (CL:1+ CURSOR))))))))
    (CL:SETQ CURSOR (CL:+ CURSOR 2))
    (CL:WHEN (CL:OR (CL:EQ KEY NULL) (CL:EQ VALUE NULL))
     (CL:RETURN-FROM COMPUTE-SUBQUERY-OPTIONS (CL:VALUES NULL NULL)))
    (CL:COND
     ((CL:EQ KEY KWD-SPECIALISTS-INHERIT)
      (CL:WHEN
       (CL:OR (CL:EQ VALUE KWD-SPECIALISTS-ALL)
        (CL:EQ VALUE KWD-SPECIALISTS-CURRENT))
       (CL:LET*
        ((PKEY NULL) (PVALUE NULL) (ITER-000 (%THE-PLIST PARENTOPTIONS)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ PKEY (%%VALUE ITER-000))
         (CL:SETQ PVALUE (%%VALUE (%%REST ITER-000)))
         (INSERT-AT SUBQUERYOPTIONS PKEY PVALUE)
         (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))))
     ((CL:OR (CL:EQ VALUE KWD-SPECIALISTS-INHERIT)
       (CL:EQ VALUE KWD-SPECIALISTS-CURRENT))
      (CL:WHEN (CL:NOT (CL:EQ (LOOKUP-QUERY-OPTION PARENTOPTIONS KEY) NULL))
       (INSERT-AT SUBQUERYOPTIONS KEY
        (LOOKUP-QUERY-OPTION PARENTOPTIONS KEY))))
     (CL:T (INSERT-AT SUBQUERYOPTIONS KEY VALUE))))
   (CL:VALUES PROPARG SUBQUERYOPTIONS)))

(CL:DEFMETHOD QUERY-SPECIALIST-IO-VARIABLES ((SELF CONTROL-FRAME))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-SPECIALISTS-LOGIC-QUERY-SPECIALIST-IO-VARIABLES NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFUN (CREATE-QUERY-SPECIALIST-ITERATOR QUERY-ITERATOR BOOLEAN BOOLEAN) ...)

(CL:DEFUN CREATE-QUERY-SPECIALIST-ITERATOR (FRAME)
  (CL:LET* ((PROPOSITION NULL) (SUBQUERYOPTIONS NULL))
   (CL:MULTIPLE-VALUE-SETQ (PROPOSITION SUBQUERYOPTIONS)
    (COMPUTE-SUBQUERY-OPTIONS FRAME))
   (CL:LET*
    ((SUBQUERYITERATOR (ALLOCATE-QUERY-ITERATOR)) (SUBQUERYDESCRIPTION NULL)
     (MATCHMODE NULL) (TRUEFALSEQUERY? CL:NIL) (PARTIALQUERY? CL:NIL)
     (IOVARIABLES (NEW-LIST)) (IOVARIABLEBINDINGS NULL))
    (CL:IF (CL:EQ PROPOSITION NULL)
     (CL:RETURN-FROM CREATE-QUERY-SPECIALIST-ITERATOR
      (CL:VALUES NULL CL:NIL CL:NIL))
     (PROCESS-QUERY-OPTIONS SUBQUERYITERATOR SUBQUERYOPTIONS))
    (CL:SETQ MATCHMODE
     (LOOKUP-QUERY-OPTION SUBQUERYITERATOR KWD-SPECIALISTS-MATCH-MODE))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ MATCHMODE NULL))
      (CL:NOT (STRING-EQUAL? (COERCE-TO-STRING MATCHMODE) "STRICT")))
     (CL:SETQ PARTIALQUERY? CL:T))
    (COLLECT-FREE-VARIABLES PROPOSITION IOVARIABLES (LIST) (LIST))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-LOGIC-QUERY-SPECIALIST-IO-VARIABLES IOVARIABLES NULL)
    (CL:LET* ((*EVALUATIONMODE* KWD-SPECIALISTS-DESCRIPTION))
     (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
     (CL:LET* ((SELF-001 (NEW-DESCRIPTION)))
      (CL:SETF (%IO-VARIABLES SELF-001)
       (COPY-LIST-TO-ARGUMENTS-VECTOR IOVARIABLES))
      (CL:SETF (%PROPOSITION SELF-001) PROPOSITION)
      (CL:SETQ SUBQUERYDESCRIPTION SELF-001))
     (CL:LET* ((TEMP-000 (FIND-DUPLICATE-DESCRIPTION SUBQUERYDESCRIPTION)))
      (CL:SETQ SUBQUERYDESCRIPTION
       (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 SUBQUERYDESCRIPTION))))
    (COMPUTE-INTERNAL-VARIABLES SUBQUERYDESCRIPTION)
    (CL:SETQ IOVARIABLEBINDINGS (NEW-VECTOR (LENGTH IOVARIABLES)))
    (CL:SETQ TRUEFALSEQUERY? CL:T)
    (CL:LET*
     ((VAR NULL) (ITER-000 (%THE-CONS-LIST IOVARIABLES)) (I NULL-INTEGER)
      (ITER-001 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ VAR (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
      (CL:LET
       ((SELF (%THE-ARRAY IOVARIABLEBINDINGS)) (VALUE (ARGUMENT-BOUND-TO VAR))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:WHEN
       (CL:EQ
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY IOVARIABLEBINDINGS)) I)
        NULL)
       (CL:SETQ TRUEFALSEQUERY? CL:NIL))
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (INITIALIZE-QUERY-ITERATOR SUBQUERYITERATOR SUBQUERYDESCRIPTION
     IOVARIABLEBINDINGS)
    (CL:VALUES SUBQUERYITERATOR TRUEFALSEQUERY? PARTIALQUERY?))))

;;; (DEFUN (/PL-KERNEL-KB/QUERY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/QUERY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((SUBQUERYITERATOR
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL))
    (TRUEFALSEQUERY? CL:NIL) (PARTIALQUERY? CL:NIL) (SORTEDQUERY? CL:NIL)
    (SUCCESS? CL:NIL) (RESULT NULL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:COND
    ((CL:EQ SUBQUERYITERATOR NULL)
     (CL:MULTIPLE-VALUE-SETQ (SUBQUERYITERATOR TRUEFALSEQUERY? PARTIALQUERY?)
      (CREATE-QUERY-SPECIALIST-ITERATOR FRAME))
     (CL:IF (CL:EQ SUBQUERYITERATOR NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/QUERY-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE)
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
       SYM-SPECIALISTS-STELLA-ITERATOR SUBQUERYITERATOR NULL))
     (CL:COND
      (PARTIALQUERY?
       (CL:IF TRUEFALSEQUERY? (CALL-ASK-PARTIAL SUBQUERYITERATOR)
        (CALL-RETRIEVE-PARTIAL SUBQUERYITERATOR)))
      ((CL:AND (CL:NOT TRUEFALSEQUERY?)
        (CL:NOT
         (CL:EQ (LOOKUP-QUERY-OPTION SUBQUERYITERATOR KWD-SPECIALISTS-SORT-BY)
          NULL)))
       (CL:SETQ SORTEDQUERY? CL:T) (CALL-RETRIEVE SUBQUERYITERATOR))))
    (CL:T
     (CL:SETQ PARTIALQUERY?
      (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY SUBQUERYITERATOR) NULL)))
     (CL:SETQ SORTEDQUERY?
      (CL:NOT
       (CL:EQ (LOOKUP-QUERY-OPTION SUBQUERYITERATOR KWD-SPECIALISTS-SORT-BY)
        NULL)))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-SPECIALISTS-GOAL-TREE))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL))
   (CL:LOOP
    (CL:TAGBODY
     (CL:COND
      ((CL:OR PARTIALQUERY? SORTEDQUERY?)
       (CL:SETQ SUCCESS? (QUERY-SUCCEEDED? SUBQUERYITERATOR))
       (CL:WHEN SUCCESS?
        (CL:LET* ((SOLUTION (POP (%SOLUTIONS SUBQUERYITERATOR))))
         (CL:SETQ RESULT (%BASE-CONTROL-FRAME SUBQUERYITERATOR))
         (CL:WHEN (CL:NOT TRUEFALSEQUERY?)
          (CL:SETF (%VALUE SUBQUERYITERATOR) SOLUTION))
         (CL:SETF (%TRUTH-VALUE RESULT) (%TRUTH-VALUE SOLUTION))
         (CL:WHEN *RECORD-JUSTIFICATIONS?*
          (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS RESULT)
           SYM-SPECIALISTS-LOGIC-JUSTIFICATION (%JUSTIFICATION SOLUTION)
           NULL))
         (CL:WHEN PARTIALQUERY?
          (CL:SETF (%POSITIVE-SCORE (%PARTIAL-MATCH-FRAME RESULT))
           (%MATCH-SCORE SOLUTION))))))
      (CL:T
       (CL:LET*
        ((*QUERYITERATOR* SUBQUERYITERATOR)
         (*REVERSEPOLARITY?* (%REVERSE-POLARITY? FRAME))
         (*INFERENCELEVEL* (CURRENT-INFERENCE-LEVEL))
         (*GENERATE-ALL-PROOFS?* CL:NIL))
        (CL:DECLARE
         (CL:SPECIAL *QUERYITERATOR* *REVERSEPOLARITY?* *INFERENCELEVEL*
          *GENERATE-ALL-PROOFS?*))
        (CL:LET* ((HOWMANY (LOOKUP-HOW-MANY-SOLUTIONS SUBQUERYITERATOR)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM HOWMANY))
         (CL:WHEN (CL:OR (CL:= HOWMANY NULL-INTEGER) (CL:>= HOWMANY 1))
          (CL:SETQ SUCCESS? (NEXT? SUBQUERYITERATOR)))
         (CL:COND ((CL:= HOWMANY NULL-INTEGER))
          ((CL:<= HOWMANY 1) (CL:SETF (%EXHAUSTED? SUBQUERYITERATOR) CL:T))
          (CL:T
           (INSERT-AT (%OPTIONS SUBQUERYITERATOR) KWD-SPECIALISTS-HOW-MANY
            (WRAP-INTEGER (CL:1- HOWMANY)))))
         (CL:WHEN SUCCESS?
          (CL:SETQ RESULT (%BASE-CONTROL-FRAME SUBQUERYITERATOR)))))))
     (CL:WHEN SUCCESS?
      (CL:LET*
       ((VAR NULL)
        (ITER-000 (%THE-CONS-LIST (QUERY-SPECIALIST-IO-VARIABLES FRAME)))
        (VALUE NULL) (VECTOR-000 (%BINDINGS (%VALUE SUBQUERYITERATOR)))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:< INDEX-000 LENGTH-000)) DO
        (CL:SETQ VAR (%%VALUE ITER-000))
        (CL:SETQ VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:WHEN (CL:NOT (BIND-VARIABLE-TO-VALUE? VAR VALUE CL:T))
         (CL:SETQ SUCCESS? CL:NIL) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:WHEN (CL:AND (CL:NOT SUCCESS?) (CL:NOT TRUEFALSEQUERY?))
       (CL:GO :CONTINUE)))
     (CL:RETURN) :CONTINUE))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-SPECIALISTS-GOAL-TREE))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL))
   (CL:COND
    (SUCCESS? (PROPAGATE-FRAME-TRUTH-VALUE RESULT FRAME)
     (CL:WHEN
      (CL:AND
       (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
        (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
       PARTIALQUERY?)
      (PROPAGATE-FRAME-PARTIAL-TRUTH (%PARTIAL-MATCH-FRAME RESULT) FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (RECORD-GOAL-JUSTIFICATION FRAME
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS RESULT)
        SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)))
     (CL:IF TRUEFALSEQUERY? KWD-SPECIALISTS-FINAL-SUCCESS
      KWD-SPECIALISTS-CONTINUING-SUCCESS))
    (CL:T KWD-SPECIALISTS-TERMINAL-FAILURE))))

;;; (DEFCLASS SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT ...)

(CL:DEFCLASS SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT (PROOF-ADJUNCT)
  ((SAVED-INFERENCE-LEVEL :ALLOCATION :INSTANCE :ACCESSOR
    %SAVED-INFERENCE-LEVEL)
   (INFERENCE-LEVEL :ALLOCATION :INSTANCE :ACCESSOR %INFERENCE-LEVEL)
   (DOWN-FRAME :ALLOCATION :INSTANCE :ACCESSOR %DOWN-FRAME)))

(CL:DEFUN NEW-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT)))
   (CL:SETF (%DOWN-FRAME SELF) NULL) (CL:SETF (%INFERENCE-LEVEL SELF) NULL)
   (CL:SETF (%SAVED-INFERENCE-LEVEL SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT))
  SGT-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT)

(CL:DEFUN ACCESS-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL)
    (CL:IF SETVALUE? (CL:SETF (%SAVED-INFERENCE-LEVEL SELF) VALUE)
     (CL:SETQ VALUE (%SAVED-INFERENCE-LEVEL SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-INFERENCE-LEVEL)
    (CL:IF SETVALUE? (CL:SETF (%INFERENCE-LEVEL SELF) VALUE)
     (CL:SETQ VALUE (%INFERENCE-LEVEL SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-DOWN-FRAME)
    (CL:IF SETVALUE? (CL:SETF (%DOWN-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%DOWN-FRAME SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL INFERENCE-LEVEL) ...)

(CL:DEFUN LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL (RELATION)
  (CL:COND
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-ASSERTION-QUERY)
    ASSERTION-INFERENCE)
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SHALLOW-QUERY)
    SHALLOW-INFERENCE)
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUBSUMPTION-QUERY)
    SUBSUMPTION-INFERENCE)
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-BACKTRACKING-QUERY)
    BACKTRACKING-INFERENCE)
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-NORMAL-QUERY)
    NORMAL-INFERENCE)
   ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-REFUTATION-QUERY)
    REFUTATION-INFERENCE)
   (CL:T
    (GET-INFERENCE-LEVEL
     (KEYWORDIFY (%%VALUE (SPLIT-STRING (%SYMBOL-NAME RELATION) #\-)))))))

;;; (DEFUN (/PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (ADJUNCT
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT NULL)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-DOWN)
     (CL:WHEN (CL:EQ ADJUNCT NULL)
      (CL:LET*
       ((ARGPROPVALUE
         (ARGUMENT-BOUND-TO
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
           0))))
       (CL:WHEN
        (CL:OR (CL:EQ ARGPROPVALUE NULL)
         (CL:NOT (ISA? ARGPROPVALUE SGT-SPECIALISTS-LOGIC-PROPOSITION)))
        (CL:RETURN-FROM |/PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST|
         KWD-SPECIALISTS-TERMINAL-FAILURE))
       (CL:LET* ((SELF-000 (NEW-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT)))
        (CL:SETF (%SAVED-INFERENCE-LEVEL SELF-000) (CURRENT-INFERENCE-LEVEL))
        (CL:SETF (%INFERENCE-LEVEL SELF-000)
         (LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL (%OPERATOR PROPOSITION)))
        (CL:SETF (%DOWN-FRAME SELF-000)
         (CREATE-DOWN-FRAME FRAME ARGPROPVALUE))
        (CL:SETQ ADJUNCT SELF-000))
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
        SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT ADJUNCT NULL)))
     (CL:SETF (%DOWN FRAME) (%DOWN-FRAME ADJUNCT))
     (CALL-SET-INFERENCE-LEVEL (%KEYWORD (%INFERENCE-LEVEL ADJUNCT)) NULL)
     (CL:SETQ *INFERENCELEVEL* (%INFERENCE-LEVEL ADJUNCT))
     KWD-SPECIALISTS-MOVE-DOWN)
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
     (PROPAGATE-FRAME-TRUTH-VALUE (%RESULT FRAME) FRAME)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
      (PROPAGATE-FRAME-PARTIAL-TRUTH (%PARTIAL-MATCH-FRAME (%RESULT FRAME))
       FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (CL:LET* ((SELF-001 (NEW-JUSTIFICATION)))
       (CL:SETF (%INFERENCE-RULE SELF-001) KWD-SPECIALISTS-LEVELED-QUERY)
       (CL:SETF (%ANTECEDENTS SELF-001)
        (CONS
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%RESULT FRAME))
          SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)
         NIL))
       (RECORD-GOAL-JUSTIFICATION FRAME SELF-001)))
     (CALL-SET-INFERENCE-LEVEL (%KEYWORD (%SAVED-INFERENCE-LEVEL ADJUNCT))
      NULL)
     (CL:SETQ *INFERENCELEVEL* (%SAVED-INFERENCE-LEVEL ADJUNCT))
     (CL:COND
      ((CL:NOT (CL:EQ (%DOWN FRAME) NULL))
       (CL:SETF (%DOWN-FRAME ADJUNCT) (%DOWN FRAME))
       (CL:SETF (%DOWN FRAME) NULL) KWD-SPECIALISTS-CONTINUING-SUCCESS)
      (CL:T KWD-SPECIALISTS-FINAL-SUCCESS)))
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
     (PROPAGATE-FRAME-TRUTH-VALUE (%RESULT FRAME) FRAME)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
      (PROPAGATE-FRAME-PARTIAL-TRUTH (%PARTIAL-MATCH-FRAME (%RESULT FRAME))
       FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (RECORD-PRIMITIVE-JUSTIFICATION FRAME KWD-SPECIALISTS-UP-FAIL))
     (CALL-SET-INFERENCE-LEVEL (%KEYWORD (%SAVED-INFERENCE-LEVEL ADJUNCT))
      NULL)
     (CL:SETQ *INFERENCELEVEL* (%SAVED-INFERENCE-LEVEL ADJUNCT))
     KWD-SPECIALISTS-FAILURE)
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFGLOBAL *PROTOTYPE-ID-COUNTER* ...)

(CL:DEFVAR *PROTOTYPE-ID-COUNTER* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *PROTOTYPE-ID-COUNTER*))

;;; (DEFUN (/PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (CLASS
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (PROTOTYPEARGUMENT
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (PROTOTYPE NULL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:OR (CL:EQ CLASS NULL)
     (CL:NOT (ISA? CLASS SGT-SPECIALISTS-LOGIC-DESCRIPTION)))
    (CL:RETURN-FROM |/PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:SETQ PROTOTYPE
    (ACCESS-BINARY-VALUE CLASS
     SGT-SPECIALISTS-PL-KERNEL-KB-CONCEPT-PROTOTYPE))
   (CL:WHEN (CL:EQ PROTOTYPE NULL)
    (CL:LET* ((EQUIVALENCE NULL))
     (CL:LET*
      ((*CONTEXT* (%HOME-CONTEXT CLASS)) (*MODULE* (%BASE-MODULE *CONTEXT*)))
      (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
      (CL:SETQ PROTOTYPE
       (CREATE-HYPOTHESIZED-INSTANCE
        (CL:IF (ISA? CLASS SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION)
         (CONCATENATE "proto-" (OBJECT-NAME-STRING CLASS)) "prototype")))
      (CL:LET* ((*INVISIBLEASSERTION?* CL:T))
       (CL:DECLARE (CL:SPECIAL *INVISIBLEASSERTION?*))
       (ASSERT-MEMBER-OF-PROPOSITION PROTOTYPE CLASS)
       (CL:SETQ EQUIVALENCE
        (ASSERT-BINARY-VALUE SGT-SPECIALISTS-PL-KERNEL-KB-CONCEPT-PROTOTYPE
         CLASS PROTOTYPE))))
     (REACT-TO-INFERENCE-UPDATE EQUIVALENCE)))
   (SELECT-PROOF-RESULT
    (BIND-ARGUMENT-TO-VALUE? PROTOTYPEARGUMENT PROTOTYPE CL:T) CL:NIL CL:T)))

;;; (DEFUN (CONCEPT-PROTOTYPE-OF NAMED-DESCRIPTION) ...)

(CL:DEFUN CONCEPT-PROTOTYPE-OF (SELF)
  (CL:WHEN
   (%WRAPPER-VALUE
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-SPECIALISTS-LOGIC-HYPOTHESIZED-INSTANCE? FALSE-WRAPPER))
   (CL:LET*
    ((PROP NULL) (ITER-000 (ALL-TRUE-DEPENDENT-ISA-PROPOSITIONS SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (ACCESS-BINARY-VALUE (SURROGATE-TO-DESCRIPTION (%OPERATOR PROP))
         SGT-SPECIALISTS-PL-KERNEL-KB-CONCEPT-PROTOTYPE)
        NULL))
      (CL:RETURN-FROM CONCEPT-PROTOTYPE-OF
       (SURROGATE-TO-DESCRIPTION (%OPERATOR PROP)))))))
  NULL)

;;; (DEFUN (CONCEPT-PROTOTYPE? BOOLEAN) ...)

(CL:DEFUN CONCEPT-PROTOTYPE? (SELF)
  (CL:NOT (CL:EQ (CONCEPT-PROTOTYPE-OF SELF) NULL)))

;;; (DEFUN (/PL-KERNEL-KB/CLOSED-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/CLOSED-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (ARGVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (CLOSED? (CLOSED-TERM? ARGVALUE)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ARGVALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/CLOSED-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:WHEN *REVERSEPOLARITY?* (CL:SETQ CLOSED? (CL:NOT CLOSED?)))
   (SELECT-PROOF-RESULT CLOSED? CL:NIL CL:T)))

;;; (DEFUN (CLOSED-BY-ASSERTION? BOOLEAN) ...)

(CL:DEFUN CLOSED-BY-ASSERTION? (SELF)
  (CL:AND (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
   (CL:NOT
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *CONTEXT*)
      SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER)))))

;;; (DEFUN (CLOSED-TERM? BOOLEAN) ...)

(CL:DEFUN CLOSED-TERM? (SELF)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE SGT-SPECIALISTS-LOGIC-F-CLOSED-TERM?-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALISTS-LOGIC-F-CLOSED-TERM?-MEMO-TABLE-000
      "(:MAX-VALUES 500 :TIMESTAMPS (:KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE-VALUE SGT-SPECIALISTS-LOGIC-F-CLOSED-TERM?-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF *CONTEXT*
      MEMOIZED-NULL-VALUE NULL 2))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (CL:IF (HELP-CLOSED-TERM? SELF NIL) TRUE-WRAPPER FALSE-WRAPPER))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000))))

;;; (DEFUN (HELP-CLOSED-TERM? BOOLEAN) ...)

(CL:DEFUN HELP-CLOSED-TERM? (SELF ACTIVETERMS)
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM HELP-CLOSED-TERM? CL:NIL))
  (CL:IF (MEMB? ACTIVETERMS SELF) (CL:RETURN-FROM HELP-CLOSED-TERM? CL:NIL)
   (CL:SETQ ACTIVETERMS (CONS SELF ACTIVETERMS)))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:OR
       (CL:AND (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
        (CL:NOT
         (%WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *CONTEXT*)
           SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER))))
       (CL:AND
        (CL:NOT
         (CL:EQ
          (ACCESS-IN-CONTEXT
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
            SYM-SPECIALISTS-LOGIC-EQUIVALENT-VALUE NULL)
           (%HOME-CONTEXT SELF) CL:NIL)
          NULL))
        (HELP-CLOSED-TERM?
         (ACCESS-IN-CONTEXT
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
           SYM-SPECIALISTS-LOGIC-EQUIVALENT-VALUE NULL)
          (%HOME-CONTEXT SELF) CL:NIL)
         ACTIVETERMS)))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:OR
       (CL:AND (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
        (CL:NOT
         (%WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *CONTEXT*)
           SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER))))
       (HELP-CLOSED-PROPOSITION? (%PROPOSITION SELF) ACTIVETERMS))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN (HELP-CLOSED-TERM? (VALUE-OF SELF) ACTIVETERMS)))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN CL:NIL))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-SKOLEM)
     (CL:PROGN
      (CL:LET* ((DEFININGPROP (%DEFINING-PROPOSITION SELF)))
       (CL:OR
        (CL:AND (CL:NOT (CL:EQ DEFININGPROP NULL))
         (COLLECTIONOF-PROPOSITION? DEFININGPROP))
        (CL:AND (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
         (CL:NOT
          (%WRAPPER-VALUE
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *CONTEXT*)
            SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER))))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:AND (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
       (CL:NOT
        (%WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *CONTEXT*)
          SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-THING)
     (CL:PROGN
      (CL:AND (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED)
       (CL:NOT
        (%WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *CONTEXT*)
          SYM-SPECIALISTS-LOGIC-MONOTONIC? FALSE-WRAPPER))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-COLLECTION)
     (CL:PROGN CL:T))
    (CL:T CL:NIL))))

;;; (DEFUN (CLOSED-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN CLOSED-PROPOSITION? (SELF)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL) (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-SPECIALISTS-LOGIC-F-CLOSED-PROPOSITION?-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-SPECIALISTS-LOGIC-F-CLOSED-PROPOSITION?-MEMO-TABLE-000
      "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE-VALUE
       SGT-SPECIALISTS-LOGIC-F-CLOSED-PROPOSITION?-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF *CONTEXT*
      MEMOIZED-NULL-VALUE NULL -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (CL:IF (HELP-CLOSED-PROPOSITION? SELF NIL) TRUE-WRAPPER FALSE-WRAPPER))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
    (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000))))

;;; (DEFUN (HELP-CLOSED-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN HELP-CLOSED-PROPOSITION? (SELF ACTIVETERMS)
  (CL:IF (MEMB? ACTIVETERMS SELF)
   (CL:RETURN-FROM HELP-CLOSED-PROPOSITION? CL:NIL)
   (CL:SETQ ACTIVETERMS (CONS SELF ACTIVETERMS)))
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-AND)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-OR)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-NOT)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-FORALL)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-EXISTS))
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:WHEN (CL:NOT (HELP-CLOSED-PROPOSITION? ARG ACTIVETERMS))
         (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:LET* ((VALUE-000 ALWAYS?-000)) VALUE-000)))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-ISA))
     (CL:COND
      ((CL:EQ (%OPERATOR SELF) SGT-SPECIALISTS-PL-KERNEL-KB-MEMBER-OF)
       (CL:LET*
        ((COLLECTIONARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
           1))
         (COLLECTIONVALUE (SAFE-ARGUMENT-BOUND-TO COLLECTIONARG)))
        (CL:IF (CL:NOT (CL:EQ COLLECTIONVALUE NULL))
         (HELP-CLOSED-TERM? COLLECTIONVALUE ACTIVETERMS)
         (CL:LET* ((FOUND?-000 CL:NIL))
          (CL:LET*
           ((PROP NULL)
            (ITER-000
             (ALLOCATE-ITERATOR
              (UNFILTERED-DEPENDENT-PROPOSITIONS COLLECTIONARG NULL))))
           (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
            (CL:WHEN
             (CL:AND (EQL? COLLECTIONARG (LAST (%ARGUMENTS PROP)))
              (COLLECTIONOF-PROPOSITION? PROP))
             (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))))
          (CL:LET* ((VALUE-001 FOUND?-000)) VALUE-001)))))
      (CL:T
       (HELP-CLOSED-TERM? (GET-DESCRIPTION (%OPERATOR SELF)) ACTIVETERMS))))
    ((CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-FAIL) CL:T) (CL:T CL:NIL))))

;;; (DEFUN (/PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (ARGVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (SINGLEVALUED? (SINGLE-VALUED-TERM? ARGVALUE)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ARGVALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:WHEN *REVERSEPOLARITY?* (CL:SETQ SINGLEVALUED? (CL:NOT SINGLEVALUED?)))
   (CL:IF SINGLEVALUED? KWD-SPECIALISTS-FINAL-SUCCESS
    KWD-SPECIALISTS-TERMINAL-FAILURE)))

;;; (DEFUN (SINGLE-VALUED-TERM? BOOLEAN) ...)

(CL:DEFUN SINGLE-VALUED-TERM? (SELF)
  (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:WHEN *CYC-KLUDGES-ENABLED?*
    (CL:RETURN-FROM SINGLE-VALUED-TERM?
     (CL:OR (FUNCTION? SELF)
      (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-SINGLE-VALUED))))
   (CL:LET*
    ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
     (MEMOIZED-VALUE-000 NULL))
    (CL:WHEN *MEMOIZATION-ENABLED?*
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE-VALUE
       SGT-SPECIALISTS-LOGIC-F-SINGLE-VALUED-TERM?-MEMO-TABLE-000))
     (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
      (INITIALIZE-MEMOIZATION-TABLE
       SGT-SPECIALISTS-LOGIC-F-SINGLE-VALUED-TERM?-MEMO-TABLE-000
       "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))")
      (CL:SETQ MEMO-TABLE-000
       (%SURROGATE-VALUE
        SGT-SPECIALISTS-LOGIC-F-SINGLE-VALUED-TERM?-MEMO-TABLE-000)))
     (CL:SETQ MEMOIZED-ENTRY-000
      (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF *CONTEXT*
       MEMOIZED-NULL-VALUE NULL 2))
     (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
    (CL:COND
     ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
      (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
       (CL:SETQ MEMOIZED-VALUE-000 NULL)))
     (CL:T
      (CL:LET* ((TEST-VALUE-001 CL:NIL))
       (CL:IF (NON-RECURSIVE-SINGLE-VALUED-TERM? SELF)
        (CL:SETQ TEST-VALUE-001 CL:T)
        (CL:PROGN (CL:SETQ TEST-VALUE-001 (CL:NOT (CLASS? SELF)))
         (CL:WHEN TEST-VALUE-001
          (CL:LET* ((FOUND?-001 CL:NIL))
           (CL:LET* ((D NULL) (ITER-001 (ALL-SUPERCOLLECTIONS SELF)))
            (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ D (%VALUE ITER-001))
             (CL:WHEN (NON-RECURSIVE-SINGLE-VALUED-TERM? D)
              (CL:SETQ FOUND?-001 CL:T) (CL:RETURN))))
           (CL:SETQ TEST-VALUE-001 FOUND?-001)))))
       (CL:SETQ MEMOIZED-VALUE-000
        (CL:IF TEST-VALUE-001 TRUE-WRAPPER FALSE-WRAPPER)))
      (CL:WHEN *MEMOIZATION-ENABLED?*
       (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
        (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
         MEMOIZED-VALUE-000)))))
    (CL:LET* ((VALUE-000 MEMOIZED-VALUE-000))
     (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE-000)))))

;;; (DEFUN (NON-RECURSIVE-SINGLE-VALUED-TERM? BOOLEAN) ...)

(CL:DEFUN NON-RECURSIVE-SINGLE-VALUED-TERM? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:OR (FUNCTION-DESCRIPTION? SELF)
       (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-SINGLE-VALUED))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((PROPOSITION (%PROPOSITION SELF)) (IOVARIABLES NIL))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 (%IO-VARIABLES SELF)) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
        (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ IOVARIABLES (CONS ARG IOVARIABLES))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
       (HELP-SINGLE-VALUED-GOAL? PROPOSITION IOVARIABLES
        (COPY-CONS-LIST (%%REST IOVARIABLES)) CL:NIL))))
    (CL:T CL:NIL))))

;;; (DEFUN (SINGLE-VALUED-GOAL? BOOLEAN) ...)

(CL:DEFUN SINGLE-VALUED-GOAL? (PROPOSITION IOVARIABLES BOUNDVARIABLES)
  (HELP-SINGLE-VALUED-GOAL? PROPOSITION IOVARIABLES BOUNDVARIABLES CL:T))

;;; (DEFUN (HELP-SINGLE-VALUED-GOAL? BOOLEAN) ...)

(CL:DEFUN HELP-SINGLE-VALUED-GOAL? (PROPOSITION IOVARIABLES BOUNDVARIABLES RECURSIVE?)
  (CL:LET*
   ((BOUNDVARIABLESLIST (LISTIFY BOUNDVARIABLES))
    (OLDCOUNT (LENGTH BOUNDVARIABLESLIST)) (NEWCOUNT NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM OLDCOUNT NEWCOUNT))
   (CL:LOOP
    (HELP-COLLECT-SINGLY-BOUND-VARIABLES PROPOSITION BOUNDVARIABLESLIST
     RECURSIVE?)
    (CL:SETQ NEWCOUNT (LENGTH BOUNDVARIABLESLIST))
    (CL:WHEN (CL:= OLDCOUNT NEWCOUNT) (CL:RETURN))
    (CL:SETQ OLDCOUNT NEWCOUNT))
   (CL:LET* ((ALWAYS?-000 CL:T))
    (CL:LET* ((VBL NULL) (ITER-000 IOVARIABLES))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ VBL (%%VALUE ITER-000))
      (CL:WHEN (CL:NOT (MEMBER? BOUNDVARIABLESLIST VBL))
       (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:LET* ((VALUE-000 ALWAYS?-000)) VALUE-000))))

;;; (DEFUN HELP-COLLECT-SINGLY-BOUND-VARIABLES ...)

(CL:DEFUN HELP-COLLECT-SINGLY-BOUND-VARIABLES (PROPOSITION BOUNDVARIABLES RECURSIVE?)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-AND)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
       (HELP-COLLECT-SINGLY-BOUND-VARIABLES ARG BOUNDVARIABLES RECURSIVE?)
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-PREDICATE))
     (CL:WHEN (CL:> (LENGTH (%ARGUMENTS PROPOSITION)) 0)
      (CL:LET*
       ((LASTARG
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
          (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS PROPOSITION)))))))
       (CL:LET* ((TEST-VALUE-001 CL:NIL))
        (CL:SETQ TEST-VALUE-001 (VARIABLE? LASTARG))
        (CL:WHEN TEST-VALUE-001
         (CL:SETQ TEST-VALUE-001 (CL:NOT (MEMBER? BOUNDVARIABLES LASTARG)))
         (CL:WHEN TEST-VALUE-001
          (CL:SETQ TEST-VALUE-001
           (CL:OR (CL:EQ (%KIND PROPOSITION) KWD-SPECIALISTS-FUNCTION)
            (CL:AND RECURSIVE?
             (SINGLE-VALUED-TERM? (GET-DESCRIPTION (%OPERATOR PROPOSITION))))
            (CL:AND (CL:NOT RECURSIVE?)
             (NON-RECURSIVE-SINGLE-VALUED-TERM?
              (GET-DESCRIPTION (%OPERATOR PROPOSITION))))))
          (CL:WHEN TEST-VALUE-001
           (CL:LET* ((ALWAYS?-000 CL:T))
            (CL:LET*
             ((ARG NULL) (ITER-000 (BUT-LAST (%ARGUMENTS PROPOSITION))))
             (CL:LOOP WHILE (NEXT? ITER-000) DO
              (CL:SETQ ARG (%VALUE ITER-000))
              (CL:WHEN
               (CL:NOT
                (CL:OR (CL:NOT (VARIABLE? ARG)) (MEMBER? BOUNDVARIABLES ARG)))
               (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))))
            (CL:SETQ TEST-VALUE-001 ALWAYS?-000)))))
        (CL:WHEN TEST-VALUE-001 (PUSH BOUNDVARIABLES LASTARG))))))
    ((CL:EQ TEST-VALUE-000 KWD-SPECIALISTS-EQUIVALENT)
     (CL:LET* ((UNBOUNDVARIABLES NIL))
      (CL:LET*
       ((ARG NULL) (VECTOR-001 (%ARGUMENTS PROPOSITION)) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:WHEN
         (CL:AND (VARIABLE? ARG) (CL:NOT (MEMBER? BOUNDVARIABLES ARG)))
         (CL:SETQ UNBOUNDVARIABLES (CONS ARG UNBOUNDVARIABLES)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:WHEN (CL:= (LENGTH UNBOUNDVARIABLES) 1)
       (PUSH BOUNDVARIABLES (%%VALUE UNBOUNDVARIABLES)))))
    (CL:T))))

;;; (DEFUN CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME ...)

(CL:DEFUN CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME (FRAME DESCRIPTION)
  (CL:LET* ((DOWNFRAME (CREATE-DOWN-FRAME FRAME NULL)))
   (OVERLAY-WITH-PATTERN-FRAME? DOWNFRAME DESCRIPTION NULL)
   (CL:SETF (%COLLECTION-LIST (%PATTERN-RECORD DOWNFRAME)) (NEW-LIST))))

;;; (DEFUN (COLLECT-DESCRIPTION-EXTENSION-FRAME? BOOLEAN) ...)

(CL:DEFUN COLLECT-DESCRIPTION-EXTENSION-FRAME? (FRAME)
  (CL:AND (CL:NOT (CL:EQ (%PATTERN-RECORD FRAME) NULL))
   (CL:NOT (CL:EQ (%COLLECTION-LIST (%PATTERN-RECORD FRAME)) NULL))))

;;; (DEFUN (/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (COLLECTIONARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (COLLECTIONVALUE (ARGUMENT-BOUND-TO COLLECTIONARG))
    (LISTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (LIST? CL:NIL) (UNIQUE? CL:T) (MEMBERS NULL) (RESULT NULL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ COLLECTIONVALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((TEST-VALUE-000 (%OPERATOR PROPOSITION)))
    (CL:COND
     ((CL:EQ TEST-VALUE-000 SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-LIST)
      (CL:SETQ LIST? CL:T) (CL:SETQ UNIQUE? CL:NIL))
     ((CL:EQ TEST-VALUE-000
       SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-ORDERED-SET)
      (CL:SETQ LIST? CL:T))
     (CL:T)))
   (CL:COND
    ((CL:AND
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
        SYM-SPECIALISTS-STELLA-ITERATOR NULL)
       NULL)
      (CL:OR (CL:AND (ENUMERATED-SET? COLLECTIONVALUE) (CL:NOT LIST?))
       (CL:AND (ENUMERATED-LIST? COLLECTIONVALUE) (CL:NOT UNIQUE?)))
      (CL:EQ (VARIABLE-VALUE-INVERSE COLLECTIONVALUE) NIL))
     (CL:SETQ RESULT COLLECTIONVALUE))
    ((CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
       SYM-SPECIALISTS-STELLA-ITERATOR NULL)
      NULL)
     (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE COLLECTIONVALUE)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-002 SGT-SPECIALISTS-STELLA-COLLECTION)
        (CL:PROGN
         (CL:SETQ MEMBERS
          (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))
         (CL:WHEN (CL:EQ MEMBERS NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
           KWD-SPECIALISTS-TERMINAL-FAILURE))))
       ((SUBTYPE-OF? TEST-VALUE-002 SGT-SPECIALISTS-LOGIC-SKOLEM)
        (CL:PROGN
         (CL:SETQ MEMBERS
          (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))
         (CL:WHEN (CL:EQ MEMBERS NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
           KWD-SPECIALISTS-TERMINAL-FAILURE))))
       ((SUBTYPE-OF? TEST-VALUE-002 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
        (CL:PROGN
         (CL:LET* ((TEST-VALUE-001 CL:NIL))
          (CL:SETQ TEST-VALUE-001
           (CL:NOT
            (CL:EQ
             (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS COLLECTIONVALUE)
              SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL)
             NULL)))
          (CL:WHEN TEST-VALUE-001
           (CL:LET* ((FOUND?-000 CL:NIL))
            (CL:LET*
             ((V NULL)
              (VECTOR-000
               (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS COLLECTIONVALUE)
                SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL))
              (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
             (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
             (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
              (CL:SETQ V
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
                INDEX-000))
              (CL:WHEN (CL:EQ (ARGUMENT-BOUND-TO V) NULL)
               (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
              (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
            (CL:SETQ TEST-VALUE-001 FOUND?-000)))
          (CL:WHEN TEST-VALUE-001
           (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
            KWD-SPECIALISTS-TERMINAL-FAILURE)))
         (CL:COND
          ((INFERABLE? COLLECTIONVALUE)
           (CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME FRAME COLLECTIONVALUE)
           (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
            SYM-SPECIALISTS-STELLA-ITERATOR EMPTY-PROPOSITIONS-ITERATOR NULL)
           (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
            KWD-SPECIALISTS-MOVE-DOWN))
          (CL:T
           (CL:SETQ MEMBERS
            (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))
           (CL:WHEN (CL:EQ MEMBERS NULL)
            (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
             KWD-SPECIALISTS-TERMINAL-FAILURE))
           (CL:SETQ UNIQUE? CL:NIL)))))
       (CL:T
        (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
         KWD-SPECIALISTS-FAILURE)))))
    (CL:T
     (CL:WHEN (CL:EQ (%DOWN FRAME) NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
       KWD-SPECIALISTS-FAILURE))
     (CL:LET* ((PATTERNFRAME (%DOWN FRAME)))
      (CL:SETQ MEMBERS
       (REVERSE (%COLLECTION-LIST (%PATTERN-RECORD PATTERNFRAME))))
      (POP-FRAMES-UP-TO PATTERNFRAME)
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PATTERNFRAME)
          SYM-SPECIALISTS-LOGIC-INFERENCE-CUTOFF-REASON NULL)
         NULL))
       (CL:RETURN-FROM |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE)))))
   (CL:WHEN (CL:EQ RESULT NULL)
    (CL:WHEN UNIQUE?
     (CL:SETQ MEMBERS
      (CL:IF (CONS? (FIRST MEMBERS)) (REMOVE-DUPLICATES-EQUAL MEMBERS)
       (REMOVE-DUPLICATES MEMBERS))))
    (CL:SETQ RESULT
     (CL:IF LIST? (CREATE-LOGICAL-LIST MEMBERS)
      (CREATE-ENUMERATED-SET MEMBERS))))
   (CL:LET*
    ((SUCCESS
      (SELECT-TEST-RESULT (BIND-ARGUMENT-TO-VALUE? LISTARG RESULT CL:T) CL:T
       FRAME)))
    (CL:WHEN
     (CL:AND *RECORD-JUSTIFICATIONS?*
      (CL:NOT (CL:EQ SUCCESS KWD-SPECIALISTS-TERMINAL-FAILURE)))
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%INFERENCE-RULE SELF-000) KWD-SPECIALISTS-COLLECT-MEMBERS)
      (CL:LET*
       ((JUSTIFICATION SELF-000)
        (ANTECEDENTS
         (CL:IF (CL:NOT (CL:EQ (%RESULT FRAME) NULL))
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%RESULT FRAME))
           SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)
          NULL)))
       (CL:WHEN (CL:NOT (CL:EQ ANTECEDENTS NULL))
        (CL:SETF (%ANTECEDENTS JUSTIFICATION) (CONS ANTECEDENTS NIL)))
       (RECORD-GOAL-JUSTIFICATION FRAME JUSTIFICATION))))
    SUCCESS)))

;;; (DEFUN (/PL-KERNEL-KB/LENGTH-OF-LIST-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/LENGTH-OF-LIST-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (LISTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (LENGTHARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'LENGTH-OF-LIST'" EOL EOL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/LENGTH-OF-LIST-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET*
    ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T))
     (LEN NULL-INTEGER))
    (CL:DECLARE (CL:TYPE CL:FIXNUM LEN))
    (CL:WHEN (CL:EQ LISTVALUE NULL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/LENGTH-OF-LIST-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:SETQ LEN (LENGTH LISTVALUE))
    (SELECT-TEST-RESULT
     (BIND-ARGUMENT-TO-VALUE? LENGTHARG (WRAP-INTEGER LEN) CL:T) CL:T FRAME))))

;;; (DEFUN (/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (COLLECTIONARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (COLLECTION (ARGUMENT-BOUND-TO COLLECTIONARG))
    (NARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (N (ARGUMENT-BOUND-TO NARG))
    (ELEMENTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      2))
    (ELEMENT (ARGUMENT-BOUND-TO ELEMENTARG)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (LOGICAL-COLLECTION? COLLECTION)
    (CL:LET*
     ((THEN NULL-INTEGER)
      (ARGUMENTS (%ARGUMENTS (%DEFINING-PROPOSITION COLLECTION)))
      (NARGS (CL:1- (LENGTH ARGUMENTS))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM THEN NARGS))
     (CL:COND
      ((INTEGER? N) (CL:SETQ THEN (UNWRAP-INTEGER N))
       (CL:WHEN (CL:< THEN 0) (CL:SETQ THEN (CL:+ NARGS THEN)))
       (CL:WHEN (CL:AND (CL:>= THEN 0) (CL:< THEN NARGS))
        (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST|
         (SELECT-TEST-RESULT
          (BIND-ARGUMENT-TO-VALUE? ELEMENTARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) THEN)
           CL:T)
          CL:T FRAME))))
      ((CL:AND (CL:EQ N NULL) (CL:NOT (CL:EQ ELEMENT NULL)))
       (CL:LET*
        ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0)
         (UPPER-BOUND-000 (CL:1- NARGS)))
        (CL:DECLARE
         (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000 UPPER-BOUND-000))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:<= ITER-000 UPPER-BOUND-000))
         DO
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ I ITER-000)
         (CL:WHEN (EQL? (ARGUMENT-BOUND-TO ARG) ELEMENT)
          (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST|
           (SELECT-TEST-RESULT
            (BIND-ARGUMENT-TO-VALUE? NARG (WRAP-INTEGER I) CL:T) CL:T FRAME)))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
         (CL:SETQ ITER-000 (CL:1+ ITER-000)))))
      ((CL:AND (CL:EQ N NULL) (CL:EQ ELEMENT NULL))
       (CL:LET*
        ((ITERATOR
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
           SYM-SPECIALISTS-STELLA-ITERATOR NULL)))
        (CL:WHEN (CL:EQ ITERATOR NULL)
         (CL:SETQ ITERATOR (ALLOCATE-ITERATOR ARGUMENTS))
         (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
          SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
        (CL:SETQ THEN (%ITERATOR-INTEGER ITERATOR))
        (CL:WHEN (CL:AND (CL:< THEN NARGS) (NEXT? ITERATOR))
         (CL:SETQ ELEMENT (%VALUE ITERATOR))
         (CL:WHEN
          (CL:AND (BIND-ARGUMENT-TO-VALUE? NARG (WRAP-INTEGER THEN) CL:T)
           (BIND-ARGUMENT-TO-VALUE? ELEMENTARG ELEMENT CL:T))
          (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST|
           KWD-SPECIALISTS-CONTINUING-SUCCESS))))))))
   KWD-SPECIALISTS-TERMINAL-FAILURE))

;;; (DEFUN (/PL-KERNEL-KB/NTH-HEAD-COMPUTATION SKOLEM) ...)

(CL:DEFUN |/PL-KERNEL-KB/NTH-HEAD-COMPUTATION| (LIST NARG)
  (CL:WHEN (CL:NOT (ENUMERATED-LIST? LIST))
   (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-HEAD-COMPUTATION| NULL))
  (CL:LET*
   ((N (%WRAPPER-VALUE NARG))
    (ELEMENTS (%ARGUMENTS (%DEFINING-PROPOSITION LIST)))
    (NELEMENTS (CL:1- (LENGTH ELEMENTS))) (HEADELEMENTS (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM N NELEMENTS))
   (CL:WHEN (CL:< N 0) (CL:SETQ N (CL:+ NELEMENTS N)))
   (CL:WHEN (CL:OR (CL:< N 0) (CL:> N NELEMENTS))
    (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-HEAD-COMPUTATION| NULL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- N))
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ELEMENTS)) I)
         NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST HEADELEMENTS) NIL)
        (CL:SETF (%THE-CONS-LIST HEADELEMENTS) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST HEADELEMENTS)
         COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ELEMENTS)) I)
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CREATE-LOGICAL-LIST HEADELEMENTS)))

;;; (DEFUN (/PL-KERNEL-KB/NTH-REST-COMPUTATION SKOLEM) ...)

(CL:DEFUN |/PL-KERNEL-KB/NTH-REST-COMPUTATION| (LIST NARG)
  (CL:WHEN (CL:NOT (ENUMERATED-LIST? LIST))
   (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-REST-COMPUTATION| NULL))
  (CL:LET*
   ((N (%WRAPPER-VALUE NARG))
    (ELEMENTS (%ARGUMENTS (%DEFINING-PROPOSITION LIST)))
    (NELEMENTS (CL:1- (LENGTH ELEMENTS))) (RESTELEMENTS (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM N NELEMENTS))
   (CL:WHEN (CL:< N 0) (CL:SETQ N (CL:+ NELEMENTS N)))
   (CL:WHEN (CL:OR (CL:< N 0) (CL:> N NELEMENTS))
    (CL:RETURN-FROM |/PL-KERNEL-KB/NTH-REST-COMPUTATION| NULL))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 N) (UPPER-BOUND-000 (CL:1- NELEMENTS))
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ELEMENTS)) I)
         NIL))
       (CL:IF (CL:EQ (%THE-CONS-LIST RESTELEMENTS) NIL)
        (CL:SETF (%THE-CONS-LIST RESTELEMENTS) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST RESTELEMENTS)
         COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ELEMENTS)) I)
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CREATE-LOGICAL-LIST RESTELEMENTS)))

;;; (DEFUN (/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION SKOLEM) ...)

(CL:DEFUN |/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION| (LIST NARG ELEMENT)
  (CL:WHEN (CL:NOT (ENUMERATED-LIST? LIST))
   (CL:RETURN-FROM |/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION| NULL))
  (CL:LET*
   ((N (%WRAPPER-VALUE NARG))
    (ELEMENTS (%ARGUMENTS (%DEFINING-PROPOSITION LIST)))
    (NELEMENTS (CL:1- (LENGTH ELEMENTS))) (NEWELEMENTS (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM N NELEMENTS))
   (CL:WHEN (CL:< N 0) (CL:SETQ N (CL:+ NELEMENTS N 1)))
   (CL:WHEN (CL:OR (CL:< N 0) (CL:> N NELEMENTS))
    (CL:RETURN-FROM |/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION| NULL))
   (CL:LET*
    ((ELT NULL) (VECTOR-000 ELEMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- NELEMENTS)))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ ELT
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:SETQ I ITER-000) (CL:WHEN (CL:= I N) (PUSH NEWELEMENTS ELEMENT))
     (PUSH NEWELEMENTS ELT) (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN (CL:= N NELEMENTS) (PUSH NEWELEMENTS ELEMENT))
   (CREATE-LOGICAL-LIST (REVERSE NEWELEMENTS))))

;;; (DEFUN (/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (LISTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (MINARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (MINVALUE (ARGUMENT-BOUND-TO MINARG)) (MINIMUM NULL)
    (MISSINGNUMBERS? CL:NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'MINIMUM-OF-NUMBERS'" EOL EOL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:WHEN (EMPTY? LISTVALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:LET* ((V NULL) (ITER-000 (%THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:IF (ISA? V SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:WHEN
        (CL:OR (CL:EQ MINIMUM NULL)
         (|/PL-KERNEL-KB/ARITHMETIC-LESS-TEST| V MINIMUM))
        (CL:SETQ MINIMUM V))
       (CL:SETQ MISSINGNUMBERS? CL:T))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:WHEN (CL:EQ MINIMUM NULL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:WHEN MISSINGNUMBERS?
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ MINVALUE NULL))
       (ISA? MINVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (|/PL-KERNEL-KB/ARITHMETIC-GREATER-TEST| MINVALUE MINIMUM))
      (CL:PROGN (SET-FRAME-TRUTH-VALUE FRAME FALSE-TRUTH-VALUE)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE))
      (CL:PROGN (SET-FRAME-TRUTH-VALUE FRAME UNKNOWN-TRUTH-VALUE)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))))
    (SELECT-TEST-RESULT (BIND-ARGUMENT-TO-VALUE? MINARG MINIMUM CL:T) CL:T
     FRAME))))

;;; (DEFUN (/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (LISTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (MAXARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (MAXVALUE (ARGUMENT-BOUND-TO MAXARG)) (MAXIMUM NULL)
    (MISSINGNUMBERS? CL:NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'MAXIMUM-OF-NUMBERS'" EOL EOL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:WHEN (EMPTY? LISTVALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:LET* ((V NULL) (ITER-000 (%THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:IF (ISA? V SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:WHEN
        (CL:OR (CL:EQ MAXIMUM NULL)
         (|/PL-KERNEL-KB/ARITHMETIC-GREATER-TEST| V MAXIMUM))
        (CL:SETQ MAXIMUM V))
       (CL:SETQ MISSINGNUMBERS? CL:T))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:WHEN (CL:EQ MAXIMUM NULL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:WHEN MISSINGNUMBERS?
     (CL:IF
      (CL:AND (CL:NOT (CL:EQ MAXVALUE NULL))
       (ISA? MAXVALUE SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (|/PL-KERNEL-KB/ARITHMETIC-LESS-TEST| MAXVALUE MAXIMUM))
      (CL:PROGN (SET-FRAME-TRUTH-VALUE FRAME FALSE-TRUTH-VALUE)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE))
      (CL:PROGN (SET-FRAME-TRUTH-VALUE FRAME UNKNOWN-TRUTH-VALUE)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))))
    (SELECT-TEST-RESULT (BIND-ARGUMENT-TO-VALUE? MAXARG MAXIMUM CL:T) CL:T
     FRAME))))

;;; (DEFUN (/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (LISTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (SUMARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (SUM (WRAP-INTEGER 0)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'SUM-OF-NUMBERS'" EOL EOL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:LET* ((V NULL) (ITER-000 (%THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:IF (ISA? V SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:SETQ SUM (|/PL-KERNEL-KB/PLUS-COMPUTATION| V SUM))
       (CL:RETURN-FROM |/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-TERMINAL-FAILURE))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (SELECT-TEST-RESULT (BIND-ARGUMENT-TO-VALUE? SUMARG SUM CL:T) CL:T FRAME))))

;;; (DEFUN (/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (LISTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (MEANARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (SUM (WRAP-INTEGER 0)) (NUMBERCOUNT 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUMBERCOUNT)) (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'MEAN-OF-NUMBERS'" EOL EOL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:WHEN (EMPTY? LISTVALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:LET* ((V NULL) (ITER-000 (%THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:IF (ISA? V SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER)
       (CL:PROGN (CL:SETQ SUM (|/PL-KERNEL-KB/PLUS-COMPUTATION| V SUM))
        (CL:SETQ NUMBERCOUNT (CL:1+ NUMBERCOUNT)))
       (CL:RETURN-FROM |/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:IF (CL:= NUMBERCOUNT 0) KWD-SPECIALISTS-TERMINAL-FAILURE
     (SELECT-TEST-RESULT
      (BIND-ARGUMENT-TO-VALUE? MEANARG
       (|/PL-KERNEL-KB/DIVIDE-COMPUTATION| SUM (WRAP-INTEGER NUMBERCOUNT))
       CL:T)
      CL:T FRAME)))))

;;; (DEFUN (/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (LISTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (SORTLIST (NEW-LIST)) (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (MEDIANARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (NUMBERCOUNT 0) (RESULT NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUMBERCOUNT)) (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'MEDIAN-OF-NUMBERS'" EOL EOL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:WHEN (EMPTY? LISTVALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:LET* ((V NULL) (ITER-000 (%THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:IF (ISA? V SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER) (PUSH SORTLIST V)
       (CL:RETURN-FROM |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST|
        KWD-SPECIALISTS-FAILURE))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETQ NUMBERCOUNT (LENGTH SORTLIST))
    (CL:WHEN (CL:= NUMBERCOUNT 0)
     (CL:RETURN-FROM |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (SORT SORTLIST (CL:FUNCTION |/PL-KERNEL-KB/ARITHMETIC-LESS-TEST|))
    (CL:IF (CL:LOGBITP 0 NUMBERCOUNT)
     (CL:SETQ RESULT
      (NTH SORTLIST (CL:TRUNCATE (CL:/ (CL:1- NUMBERCOUNT) 2.0d0))))
     (CL:SETQ RESULT
      (|/PL-KERNEL-KB/DIVIDE-COMPUTATION|
       (|/PL-KERNEL-KB/PLUS-COMPUTATION|
        (NTH SORTLIST (CL:TRUNCATE (CL:1- (CL:/ NUMBERCOUNT 2.0d0))))
        (NTH SORTLIST (CL:TRUNCATE (CL:/ NUMBERCOUNT 2.0d0))))
       (WRAP-INTEGER 2))))
    (SELECT-TEST-RESULT (BIND-ARGUMENT-TO-VALUE? MEDIANARG RESULT CL:T) CL:T
     FRAME))))

;;; (DEFUN (COMPUTE-VARIANCE-OR-STANDARD-DEVIATION KEYWORD) ...)

(CL:DEFUN COMPUTE-VARIANCE-OR-STANDARD-DEVIATION (FRAME LASTMOVE STANDARD-DEVIATION?)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (LISTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (LISTSKOLEM (ARGUMENT-BOUND-TO LISTARG))
    (RESULTARGG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (SUM 0.0d0) (SUM2 0.0d0) (X 0.0d0) (NUMBERCOUNT 0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SUM SUM2 X)
    (CL:TYPE CL:FIXNUM NUMBERCOUNT))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LISTSKOLEM NULL))
     (CL:NOT (LOGICAL-COLLECTION? LISTSKOLEM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
     "Non list appears in second argument to 'VARIANCE or STANDARD-DEVIATION'"
     EOL EOL)
    (CL:RETURN-FROM COMPUTE-VARIANCE-OR-STANDARD-DEVIATION
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS LISTSKOLEM CL:T)))
    (CL:WHEN (EMPTY? LISTVALUE)
     (CL:RETURN-FROM COMPUTE-VARIANCE-OR-STANDARD-DEVIATION
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:LET* ((V NULL) (ITER-000 (%THE-CONS-LIST LISTVALUE)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ V (%%VALUE ITER-000))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE V)))
       (CL:COND
        ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
         (CL:PROGN (CL:SETQ X (CL:FLOAT (%WRAPPER-VALUE V) 0.0d0))))
        ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
         (CL:PROGN (CL:SETQ X (%WRAPPER-VALUE V))))
        (CL:T (SET-FRAME-TRUTH-VALUE FRAME UNKNOWN-TRUTH-VALUE)
         (CL:RETURN-FROM COMPUTE-VARIANCE-OR-STANDARD-DEVIATION
          KWD-SPECIALISTS-FAILURE))))
      (CL:SETQ SUM (CL:+ SUM X)) (CL:SETQ SUM2 (CL:+ SUM2 (CL:* X X)))
      (CL:SETQ NUMBERCOUNT (CL:1+ NUMBERCOUNT))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:CASE NUMBERCOUNT (0 KWD-SPECIALISTS-TERMINAL-FAILURE)
     (1
      (SELECT-TEST-RESULT
       (BIND-ARGUMENT-TO-VALUE? RESULTARGG (WRAP-FLOAT 0.0d0) CL:T) CL:T
       FRAME))
     (CL:OTHERWISE
      (CL:SETQ X
       (CL:/ (CL:- SUM2 (CL:/ (CL:* SUM SUM) NUMBERCOUNT))
        (CL:1- NUMBERCOUNT)))
      (CL:WHEN STANDARD-DEVIATION?
       (CL:SETQ X (CL:THE CL:DOUBLE-FLOAT (CL:SQRT X))))
      (SELECT-TEST-RESULT
       (BIND-ARGUMENT-TO-VALUE? RESULTARGG (WRAP-FLOAT X) CL:T) CL:T FRAME))))))

;;; (DEFUN (/PL-KERNEL-KB/STANDARD-DEVIATION-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/STANDARD-DEVIATION-SPECIALIST| (FRAME LASTMOVE)
  (COMPUTE-VARIANCE-OR-STANDARD-DEVIATION FRAME LASTMOVE CL:T))

;;; (DEFUN (/PL-KERNEL-KB/VARIANCE-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/VARIANCE-SPECIALIST| (FRAME LASTMOVE)
  (COMPUTE-VARIANCE-OR-STANDARD-DEVIATION FRAME LASTMOVE CL:NIL))

;;; (DEFUN HELP-DERIVE-PARTITION-MEMBERSHIPS ...)

(CL:DEFUN HELP-DERIVE-PARTITION-MEMBERSHIPS (SELF SUPER TUPLES)
  (CL:LET*
   ((MC NULL)
    (ITER-000
     (APPLY-CACHED-RETRIEVE
      (LIST* SYM-SPECIALISTS-LOGIC-?SUPER SYM-SPECIALISTS-LOGIC-?MDC NIL)
      (LIST* SYM-SPECIALISTS-STELLA-AND
       (LIST* SYM-SPECIALISTS-LOGIC-MEMBER-OF SYM-SPECIALISTS-LOGIC-?SUPER
        SYM-SPECIALISTS-LOGIC-?MDC NIL)
       (LIST* SYM-SPECIALISTS-LOGIC-MUTUALLY-DISJOINT-COLLECTION
        SYM-SPECIALISTS-LOGIC-?MDC NIL)
       NIL)
      (CONS-LIST SUPER NULL) (CONS-LIST)
      SYM-SPECIALISTS-LOGIC-F-HELP-DERIVE-PARTITION-MEMBERSHIPS-QUERY-000)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ MC (%%VALUE ITER-000))
    (CL:LET*
     ((MDCPROPOSITION
       (%%VALUE
        (CONSIFY
         (ALL-TRUE-DEPENDENT-PROPOSITIONS MC
          SGT-SPECIALISTS-PL-KERNEL-KB-MUTUALLY-DISJOINT-COLLECTION
          CL:NIL)))))
     (PUSH TUPLES
      (ASSERT-TUPLE SGT-SPECIALISTS-PL-KERNEL-KB-PARTITION-MEMBERSHIP
       (CONS-LIST SELF MDCPROPOSITION SUPER))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET*
   ((P NULL)
    (ITER-001
     (ALL-TRUE-DEPENDENT-PROPOSITIONS SUPER
      SGT-SPECIALISTS-PL-KERNEL-KB-DISJOINT CL:NIL)))
   (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ P (%VALUE ITER-001))
    (PUSH TUPLES
     (ASSERT-TUPLE SGT-SPECIALISTS-PL-KERNEL-KB-PARTITION-MEMBERSHIP
      (CONS-LIST SELF P SUPER))))))

;;; (DEFUN (DERIVE-PARTITION-MEMBERSHIPS? BOOLEAN) ...)

(CL:DEFUN DERIVE-PARTITION-MEMBERSHIPS? (SELF)
  (CL:LET* ((TUPLES (LIST)))
   (HELP-DERIVE-PARTITION-MEMBERSHIPS SELF SELF TUPLES)
   (CL:LET* ((SUPER NULL) (ITER-000 (ALL-SUPERCOLLECTIONS SELF)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ SUPER (%VALUE ITER-000))
     (HELP-DERIVE-PARTITION-MEMBERSHIPS SELF SUPER TUPLES)))
   (NON-EMPTY? TUPLES)))

;;; (DEFUN (/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (ARGUMENTVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0))))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:OR (CL:EQ ARGUMENTVALUE NULL)
     (CL:NOT (ISA? ARGUMENTVALUE SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)))
    (CL:RETURN-FROM |/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:LET* ((VALUE-000 NULL))
    (CL:LET*
     ((P NULL)
      (ITER-000
       (ALLOCATE-ITERATOR
        (UNFILTERED-DEPENDENT-PROPOSITIONS ARGUMENTVALUE
         SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP))))
     (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
      (CL:WHEN
       (CL:EQ (%OPERATOR P)
        SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP)
       (CL:SETQ VALUE-000 P) (CL:RETURN))))
    (CL:LET* ((HASPARTITIONPROPOSITION VALUE-000))
     (CL:WHEN (CL:NOT (CL:EQ HASPARTITIONPROPOSITION NULL))
      (CL:COND
       ((TRUE? HASPARTITIONPROPOSITION)
        (CL:RETURN-FROM |/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST|
         KWD-SPECIALISTS-FINAL-SUCCESS))
       ((FALSE? HASPARTITIONPROPOSITION)
        (CL:RETURN-FROM |/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST|
         KWD-SPECIALISTS-TERMINAL-FAILURE))))
     (CL:IF (DERIVE-PARTITION-MEMBERSHIPS? ARGUMENTVALUE)
      (CL:PROGN
       (UPDATE-PROPERTY ARGUMENTVALUE
        SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP
        KWD-SPECIALISTS-ASSERT-TRUE)
       KWD-SPECIALISTS-FINAL-SUCCESS)
      (CL:PROGN
       (UPDATE-PROPERTY ARGUMENTVALUE
        SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP
        KWD-SPECIALISTS-ASSERT-FALSE)
       KWD-SPECIALISTS-TERMINAL-FAILURE))))))

;;; (DEFUN (/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (ARG1
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (ARG2
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       1))))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:OR (CL:EQ ARG1 NULL) (CL:EQ ARG2 NULL)
     (CL:NOT (ISA? ARG1 SGT-SPECIALISTS-LOGIC-DESCRIPTION))
     (CL:NOT (ISA? ARG2 SGT-SPECIALISTS-LOGIC-DESCRIPTION))
     (CL:> (LENGTH (%ARGUMENTS PROPOSITION)) 2))
    (CL:RETURN-FROM |/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (PUSH-MONOTONIC-WORLD) (INITIALIZE-INFERENCE-WORLD *CONTEXT*)
   (CL:HANDLER-CASE
    (CL:LET* ((SKOLEM (CREATE-HYPOTHESIZED-INSTANCE "refutation-disjoint")))
     (CL:LET* ((C NULL) (ITER-000 (CONS-LIST ARG1 ARG2)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ C (%%VALUE ITER-000)) (ASSERT-MEMBER-OF-PROPOSITION SKOLEM C)
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (ELABORATE-INSTANCE SKOLEM))
    (CLASH () (POP-WORLD)
     (CL:RETURN-FROM |/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST|
      KWD-SPECIALISTS-FINAL-SUCCESS)))
   (POP-WORLD) KWD-SPECIALISTS-FAILURE))

;;; (DEFUN (/PL-KERNEL-KB/EMPTY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/EMPTY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (ARGVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (EMPTY? (EMPTY-TERM? ARGVALUE)))
   (CL:SETQ LASTMOVE LASTMOVE) (SELECT-PROOF-RESULT EMPTY? CL:NIL CL:T)))

;;; (DEFUN (EMPTY-TERM? BOOLEAN) ...)

(CL:DEFUN EMPTY-TERM? (SELF)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
     (CL:PROGN (CL:OR (CHEAP-EMPTY-TERM? SELF) (EXPENSIVE-EMPTY-TERM? SELF))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-COLLECTION)
     (CL:PROGN (CL:= (LENGTH SELF) 0)))
    (CL:T CL:NIL))))

;;; (DEFUN (CHEAP-EMPTY-TERM? BOOLEAN) ...)

(CL:DEFUN CHEAP-EMPTY-TERM? (SELF)
  (CL:WHEN (SKOLEM? SELF)
   (CL:LET* ((DEFININGPROPOSITION (%DEFINING-PROPOSITION SELF)))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ DEFININGPROPOSITION NULL))
      (COLLECTIONOF-PROPOSITION? DEFININGPROPOSITION)
      (CL:= (LENGTH (%ARGUMENTS DEFININGPROPOSITION)) 1))
     (CL:RETURN-FROM CHEAP-EMPTY-TERM? CL:T))))
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:IF (TEST-PROPERTY? SELF SGT-SPECIALISTS-PL-KERNEL-KB-EMPTY)
    (CL:SETQ TEST-VALUE-000 CL:T)
    (CL:LET* ((FOUND?-000 CL:NIL))
     (CL:LET*
      ((SUPER NULL) (ITER-000 (ALL-DIRECT-SUPERCOLLECTIONS SELF CL:NIL)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ SUPER (%VALUE ITER-000))
       (CL:WHEN (CHEAP-EMPTY-TERM? SUPER) (CL:SETQ FOUND?-000 CL:T)
        (CL:RETURN))))
     (CL:SETQ TEST-VALUE-000 FOUND?-000)))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (EXPENSIVE-EMPTY-TERM? BOOLEAN) ...)

(CL:DEFUN EXPENSIVE-EMPTY-TERM? (SELF)
  (CL:LET*
   ((SUPER1 NULL) (ITER-000 (ALL-DIRECT-SUPERCOLLECTIONS SELF CL:NIL)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ SUPER1 (%VALUE ITER-000))
    (CL:LET*
     ((SUPER2 NULL) (ITER-001 (ALL-DIRECT-SUPERCOLLECTIONS SELF CL:NIL)))
     (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ SUPER2 (%VALUE ITER-001))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ SUPER1 SUPER2)) (DISJOINT-TERMS? SUPER1 SUPER2))
       (CL:RETURN-FROM EXPENSIVE-EMPTY-TERM? CL:T))))))
  CL:NIL)

;;; (DEFUN (/PL-KERNEL-KB/CONTEXT-OF-COMPUTATION CONTEXT) ...)

(CL:DEFUN |/PL-KERNEL-KB/CONTEXT-OF-COMPUTATION| (INSTANCE)
  (HOME-MODULE INSTANCE))

;;; (DEFCLASS SAVED-CONTEXT-PROOF-ADJUNCT ...)

(CL:DEFCLASS SAVED-CONTEXT-PROOF-ADJUNCT (PROOF-ADJUNCT)
  ((SAVED-CONTEXT :ALLOCATION :INSTANCE :ACCESSOR %SAVED-CONTEXT)
   (DOWN-FRAME :ALLOCATION :INSTANCE :ACCESSOR %DOWN-FRAME)))

(CL:DEFUN NEW-SAVED-CONTEXT-PROOF-ADJUNCT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE SAVED-CONTEXT-PROOF-ADJUNCT)))
   (CL:SETF (%DOWN-FRAME SELF) NULL) (CL:SETF (%SAVED-CONTEXT SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF SAVED-CONTEXT-PROOF-ADJUNCT))
  SGT-SPECIALISTS-LOGIC-SAVED-CONTEXT-PROOF-ADJUNCT)

(CL:DEFUN ACCESS-SAVED-CONTEXT-PROOF-ADJUNCT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-SAVED-CONTEXT)
    (CL:IF SETVALUE? (CL:SETF (%SAVED-CONTEXT SELF) VALUE)
     (CL:SETQ VALUE (%SAVED-CONTEXT SELF))))
   ((CL:EQ SLOTNAME SYM-SPECIALISTS-LOGIC-DOWN-FRAME)
    (CL:IF SETVALUE? (CL:SETF (%DOWN-FRAME SELF) VALUE)
     (CL:SETQ VALUE (%DOWN-FRAME SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (/PL-KERNEL-KB/IST-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/IST-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (CONTEXTVALUE
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (ADJUNCT
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT NULL)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-DOWN)
     (CL:WHEN (CL:EQ ADJUNCT NULL)
      (CL:LET*
       ((PROPOSITIONVALUE
         (ARGUMENT-BOUND-TO
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
           1))))
       (CL:WHEN
        (CL:OR (CL:EQ CONTEXTVALUE NULL) (CL:EQ PROPOSITIONVALUE NULL)
         (CL:NOT (ISA? CONTEXTVALUE SGT-SPECIALISTS-STELLA-CONTEXT)))
        (CL:RETURN-FROM |/PL-KERNEL-KB/IST-SPECIALIST|
         KWD-SPECIALISTS-TERMINAL-FAILURE))
       (CL:LET* ((SELF-000 (NEW-SAVED-CONTEXT-PROOF-ADJUNCT)))
        (CL:SETF (%SAVED-CONTEXT SELF-000) *CONTEXT*)
        (CL:SETF (%DOWN-FRAME SELF-000)
         (CREATE-DOWN-FRAME FRAME PROPOSITIONVALUE))
        (CL:SETQ ADJUNCT SELF-000))
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
        SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT ADJUNCT NULL)))
     (CL:SETF (%DOWN FRAME) (%DOWN-FRAME ADJUNCT))
     (CHANGE-CONTEXT (BEST-INFERENCE-CACHE CONTEXTVALUE))
     KWD-SPECIALISTS-MOVE-DOWN)
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-TRUE)
     (PROPAGATE-FRAME-TRUTH-VALUE (%RESULT FRAME) FRAME)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
      (PROPAGATE-FRAME-PARTIAL-TRUTH (%PARTIAL-MATCH-FRAME (%RESULT FRAME))
       FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (CL:LET* ((SELF-001 (NEW-JUSTIFICATION)))
       (CL:SETF (%INFERENCE-RULE SELF-001) KWD-SPECIALISTS-IST-INTRODUCTION)
       (CL:SETF (%ANTECEDENTS SELF-001)
        (CONS
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%RESULT FRAME))
          SYM-SPECIALISTS-LOGIC-JUSTIFICATION NULL)
         NIL))
       (RECORD-GOAL-JUSTIFICATION FRAME SELF-001)))
     (CHANGE-CONTEXT (%SAVED-CONTEXT ADJUNCT))
     (CL:COND
      ((CL:NOT (CL:EQ (%DOWN FRAME) NULL))
       (CL:SETF (%DOWN-FRAME ADJUNCT) (%DOWN FRAME))
       (CL:SETF (%DOWN FRAME) NULL) KWD-SPECIALISTS-CONTINUING-SUCCESS)
      (CL:T KWD-SPECIALISTS-FINAL-SUCCESS)))
    ((CL:EQ LASTMOVE KWD-SPECIALISTS-UP-FAIL)
     (PROPAGATE-FRAME-TRUTH-VALUE (%RESULT FRAME) FRAME)
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
       (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
      (PROPAGATE-FRAME-PARTIAL-TRUTH (%PARTIAL-MATCH-FRAME (%RESULT FRAME))
       FRAME))
     (CL:WHEN *RECORD-JUSTIFICATIONS?*
      (RECORD-PRIMITIVE-JUSTIFICATION FRAME KWD-SPECIALISTS-UP-FAIL))
     (CHANGE-CONTEXT (%SAVED-CONTEXT ADJUNCT)) KWD-SPECIALISTS-FAILURE)
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LASTMOVE
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFGLOBAL *ACCELERATE-FRAME-COMPUTATIONS?* ...)

(CL:DEFVAR *ACCELERATE-FRAME-COMPUTATIONS?* CL:T
  "Used to test how big is the effect of the frame
specialists.")

;;; (DEFUN (GET-ROLESET-OF SKOLEM) ...)

(CL:DEFUN GET-ROLESET-OF (RELATION INSTANCE)
  (%%VALUE
   (ALL-RELATION-VALUES SGT-SPECIALISTS-PL-KERNEL-KB-THE-ROLESET
    (CONS-LIST RELATION INSTANCE))))

;;; (DEFUN (COMPUTE-STORED-BOUND-ON-ROLESET INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:T) CL:FIXNUM)
  COMPUTE-STORED-BOUND-ON-ROLESET))
(CL:DEFUN COMPUTE-STORED-BOUND-ON-ROLESET (RELATION INSTANCE LOWERORUPPER)
  (CL:LET*
   ((ROLESET (GET-ROLESET-OF RELATION INSTANCE)) (CARDINALITY NULL)
    (INTERVALCACHE NULL) (BOUND NULL))
   (CL:WHEN (CL:EQ ROLESET NULL)
    (CL:RETURN-FROM COMPUTE-STORED-BOUND-ON-ROLESET NULL-INTEGER))
   (CL:SETQ CARDINALITY
    (ACCESS-BINARY-VALUE ROLESET SGT-SPECIALISTS-PL-KERNEL-KB-CARDINALITY))
   (CL:WHEN (CL:NOT (CL:EQ CARDINALITY NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE CARDINALITY)))
     (CL:COND
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
       (CL:PROGN
        (CL:RETURN-FROM COMPUTE-STORED-BOUND-ON-ROLESET
         (%WRAPPER-VALUE CARDINALITY))))
      ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-SKOLEM)
       (CL:PROGN
        (CL:LET* ()
         (CL:SETQ INTERVALCACHE
          (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| CARDINALITY))
         (CL:WHEN (CL:NOT (CL:EQ INTERVALCACHE NULL))
          (CL:COND
           ((CL:EQ LOWERORUPPER KWD-SPECIALISTS-LOWER)
            (CL:SETQ BOUND (%LOWER-BOUND INTERVALCACHE)))
           ((CL:EQ LOWERORUPPER KWD-SPECIALISTS-UPPER)
            (CL:SETQ BOUND (%UPPER-BOUND INTERVALCACHE)))
           (CL:T
            (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LOWERORUPPER
              "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ BOUND NULL))
            (ISA? BOUND SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER))
           (CL:RETURN-FROM COMPUTE-STORED-BOUND-ON-ROLESET
            (UNWRAP-INTEGER BOUND)))))))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-000
         "' is not a valid case option")
        (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
   NULL-INTEGER))

;;; (DEFUN (COMPUTE-MINIMUM-CARDINALITY INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM) COMPUTE-MINIMUM-CARDINALITY))
(CL:DEFUN COMPUTE-MINIMUM-CARDINALITY (RELATION INSTANCE)
  (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:LET* ((RELATIONREF (%SURROGATE-VALUE-INVERSE RELATION)))
    (CL:WHEN
     (CL:AND (SINGLE-VALUED-TERM? RELATION)
      (CL:NOT (CL:EQ (ACCESS-BINARY-VALUE INSTANCE RELATIONREF) NULL)))
     (CL:RETURN-FROM COMPUTE-MINIMUM-CARDINALITY 1))
    (CL:LET*
     ((MINCARDS
       (CONS-LIST (WRAP-INTEGER 0)
        (WRAP-INTEGER
         (COMPUTE-STORED-BOUND-ON-ROLESET RELATION INSTANCE
          KWD-SPECIALISTS-LOWER)))))
     (CL:SETQ MINCARDS
      (CONS (WRAP-INTEGER (LENGTH (ALL-SLOT-VALUES INSTANCE RELATIONREF)))
       MINCARDS))
     (CL:LET* ((SUBR NULL) (ITER-000 (ALL-SUBRELATIONS RELATION CL:NIL)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SUBR (%%VALUE ITER-000))
       (CL:SETQ MINCARDS
        (CONS
         (WRAP-INTEGER
          (COMPUTE-STORED-BOUND-ON-ROLESET SUBR INSTANCE
           KWD-SPECIALISTS-LOWER))
         MINCARDS))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:LET* ((MAXMIN (%WRAPPER-VALUE (%%VALUE MINCARDS))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM MAXMIN))
      (CL:LET* ((LB NULL) (ITER-001 (%%REST MINCARDS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ LB (%%VALUE ITER-001))
        (CL:WHEN (CL:NOT (CL:EQ LB NULL))
         (CL:SETQ MAXMIN (MAX MAXMIN (%WRAPPER-VALUE LB))))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      MAXMIN)))))

;;; (DEFUN (/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (RELATION
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (INSTANCE
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       1)))
    (MINCARDARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      2))
    (MINCARDVALUE (ARGUMENT-BOUND-TO MINCARDARG))
    (COMPUTEDVALUE NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COMPUTEDVALUE)) (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:NOT *ACCELERATE-FRAME-COMPUTATIONS?*)
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:WHEN (CL:OR (CL:EQ RELATION NULL) (CL:EQ INSTANCE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000
     (ISA? RELATION SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ()
      (CL:SETQ COMPUTEDVALUE (COMPUTE-MINIMUM-CARDINALITY RELATION INSTANCE))
      (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:= COMPUTEDVALUE NULL-INTEGER)))))
    (CL:IF TEST-VALUE-000
     (CL:LET* ((TV UNKNOWN-TRUTH-VALUE))
      (CL:IF
       (CL:AND (CL:NOT (CL:EQ MINCARDVALUE NULL))
        (ISA? MINCARDVALUE SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER))
       (CL:IF (CL:>= COMPUTEDVALUE (NUMBER-WRAPPER-TO-FLOAT MINCARDVALUE))
        (CL:PROGN (CL:SETQ TV TRUE-TRUTH-VALUE))
        (CL:IF (CLOSED-TERM? RELATION)
         (CL:PROGN (CL:SETQ TV FALSE-TRUTH-VALUE))
         (CL:LET* ((TEST-VALUE-001 CL:NIL))
          (CL:LET* ()
           (CL:SETQ COMPUTEDVALUE
            (COMPUTE-MAXIMUM-CARDINALITY RELATION INSTANCE))
           (CL:SETQ TEST-VALUE-001
            (CL:NOT (CL:= COMPUTEDVALUE NULL-INTEGER))))
          (CL:WHEN TEST-VALUE-001
           (CL:SETQ TEST-VALUE-001
            (< COMPUTEDVALUE (NUMBER-WRAPPER-TO-FLOAT MINCARDVALUE))))
          (CL:WHEN TEST-VALUE-001 (CL:SETQ TV FALSE-TRUTH-VALUE)))))
       (CL:IF
        (BIND-ARGUMENT-TO-VALUE? MINCARDARG (WRAP-INTEGER COMPUTEDVALUE) CL:T)
        (CL:SETQ TV TRUE-TRUTH-VALUE) (CL:SETQ TV FALSE-TRUTH-VALUE)))
      (CL:WHEN *REVERSEPOLARITY?* (CL:SETQ TV (INVERT-TRUTH-VALUE TV)))
      (SET-FRAME-TRUTH-VALUE FRAME TV)
      (CL:COND
       ((CL:OR (CL:EQ TV TRUE-TRUTH-VALUE)
         (CL:EQ TV DEFAULT-TRUE-TRUTH-VALUE))
        KWD-SPECIALISTS-FINAL-SUCCESS)
       ((CL:OR (CL:EQ TV FALSE-TRUTH-VALUE)
         (CL:EQ TV DEFAULT-FALSE-TRUTH-VALUE))
        KWD-SPECIALISTS-FAILURE)
       (CL:T KWD-SPECIALISTS-FAILURE)))
     KWD-SPECIALISTS-FAILURE))))

;;; (DEFUN (COMPUTE-MAXIMUM-CARDINALITY INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM) COMPUTE-MAXIMUM-CARDINALITY))
(CL:DEFUN COMPUTE-MAXIMUM-CARDINALITY (RELATION INSTANCE)
  (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:LET*
    ((RELATIONREF (%SURROGATE-VALUE-INVERSE RELATION))
     (SINGLEVALUED? (SINGLE-VALUED-TERM? RELATION)))
    (CL:WHEN
     (CL:AND SINGLEVALUED?
      (CL:NOT (CL:EQ (ACCESS-BINARY-VALUE INSTANCE RELATIONREF) NULL)))
     (CL:RETURN-FROM COMPUTE-MAXIMUM-CARDINALITY 1))
    (CL:LET*
     ((MAXCARDS
       (CONS-LIST
        (WRAP-INTEGER
         (COMPUTE-STORED-BOUND-ON-ROLESET RELATION INSTANCE
          KWD-SPECIALISTS-UPPER)))))
     (CL:WHEN SINGLEVALUED?
      (CL:SETQ MAXCARDS (CONS (WRAP-INTEGER 1) MAXCARDS)))
     (CL:LET* ((ROLESET (GET-ROLESET-OF RELATION INSTANCE)))
      (CL:WHEN (CL:AND (CL:NOT (CL:EQ ROLESET NULL)) (EMPTY-TERM? ROLESET))
       (CL:RETURN-FROM COMPUTE-MAXIMUM-CARDINALITY 0)))
     (CL:WHEN (CLOSED-TERM? RELATION)
      (CL:SETQ MAXCARDS
       (CONS (WRAP-INTEGER (COMPUTE-MINIMUM-CARDINALITY RELATION INSTANCE))
        MAXCARDS)))
     (CL:LET* ((SUPERR NULL) (ITER-000 (ALL-SUPERRELATIONS RELATION CL:NIL)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SUPERR (%%VALUE ITER-000))
       (CL:SETQ MAXCARDS
        (CONS
         (WRAP-INTEGER
          (COMPUTE-STORED-BOUND-ON-ROLESET SUPERR INSTANCE
           KWD-SPECIALISTS-UPPER))
         MAXCARDS))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:LET* ((MINMAX (%WRAPPER-VALUE (%%VALUE MAXCARDS))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM MINMAX))
      (CL:LET* ((UB NULL) (ITER-001 (%%REST MAXCARDS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ UB (%%VALUE ITER-001))
        (CL:WHEN (CL:NOT (CL:EQ UB NULL))
         (CL:SETQ MINMAX (MIN MINMAX (%WRAPPER-VALUE UB))))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      MINMAX)))))

;;; (DEFUN (/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (RELATION
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (INSTANCE
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       1)))
    (MAXCARDARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      2))
    (MAXCARDVALUE (ARGUMENT-BOUND-TO MAXCARDARG))
    (COMPUTEDVALUE NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COMPUTEDVALUE)) (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:NOT *ACCELERATE-FRAME-COMPUTATIONS?*)
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:WHEN (CL:OR (CL:EQ RELATION NULL) (CL:EQ INSTANCE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:LET* ((TEST-VALUE-000 CL:NIL))
    (CL:SETQ TEST-VALUE-000
     (ISA? RELATION SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ()
      (CL:SETQ COMPUTEDVALUE (COMPUTE-MAXIMUM-CARDINALITY RELATION INSTANCE))
      (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:= COMPUTEDVALUE NULL-INTEGER)))))
    (CL:IF TEST-VALUE-000
     (CL:LET*
      ((SUCCESS?
        (CL:IF
         (CL:AND (CL:NOT (CL:EQ MAXCARDVALUE NULL))
          (ISA? MAXCARDVALUE SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER))
         (<= COMPUTEDVALUE (NUMBER-WRAPPER-TO-FLOAT MAXCARDVALUE))
         (BIND-ARGUMENT-TO-VALUE? MAXCARDARG (WRAP-INTEGER COMPUTEDVALUE)
          CL:T))))
      (SELECT-TEST-RESULT SUCCESS? CL:T FRAME))
     (CL:LET* ((TEST-VALUE-001 CL:NIL))
      (CL:SETQ TEST-VALUE-001 (CL:NOT (CL:EQ MAXCARDVALUE NULL)))
      (CL:WHEN TEST-VALUE-001
       (CL:SETQ TEST-VALUE-001
        (ISA? MAXCARDVALUE SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER))
       (CL:WHEN TEST-VALUE-001
        (CL:LET* ()
         (CL:SETQ COMPUTEDVALUE
          (COMPUTE-MINIMUM-CARDINALITY RELATION INSTANCE))
         (CL:SETQ TEST-VALUE-001 (CL:NOT (CL:= COMPUTEDVALUE NULL-INTEGER))))
        (CL:WHEN TEST-VALUE-001
         (CL:SETQ TEST-VALUE-001
          (> COMPUTEDVALUE (NUMBER-WRAPPER-TO-FLOAT MAXCARDVALUE))))))
      (CL:IF TEST-VALUE-001 (SELECT-TEST-RESULT CL:NIL CL:T FRAME)
       KWD-SPECIALISTS-FAILURE))))))

;;; (DEFUN (TEST-RANGE-TYPE? BOOLEAN) ...)

(CL:DEFUN TEST-RANGE-TYPE? (RELATION INSTANCE VALUETYPE)
  (CL:LET*
   ((RELATIONREF (%SURROGATE-VALUE-INVERSE RELATION))
    (VALUESURROGATE (%SURROGATE-VALUE-INVERSE VALUETYPE)))
   (CL:WHEN (SINGLE-VALUED-TERM? RELATION)
    (CL:LET* ((FILLER (ACCESS-BINARY-VALUE INSTANCE RELATIONREF)))
     (CL:WHEN (CL:NOT (CL:EQ FILLER NULL))
      (CL:RETURN-FROM TEST-RANGE-TYPE?
       (TEST-TYPE-ON-INSTANCE? FILLER VALUESURROGATE)))))
   (CL:LET*
    ((ROLESET (GET-ROLESET-OF RELATION INSTANCE))
     (CLOSED? (CL:OR (CLOSED-TERM? RELATION) (CLOSED-TERM? ROLESET))))
    (CL:IF (CL:NOT (CL:EQ ROLESET NULL))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:IF (COLLECTION-IMPLIES-COLLECTION? ROLESET VALUETYPE)
       (CL:SETQ TEST-VALUE-000 CL:T)
       (CL:PROGN (CL:SETQ TEST-VALUE-000 CLOSED?)
        (CL:WHEN TEST-VALUE-000
         (CL:LET* ((ALWAYS?-000 CL:T))
          (CL:LET*
           ((FILLER NULL) (ITER-000 (ALL-SLOT-VALUES INSTANCE RELATIONREF)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:SETQ FILLER (%%VALUE ITER-000))
            (CL:WHEN (CL:NOT (TEST-TYPE-ON-INSTANCE? FILLER VALUESURROGATE))
             (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
            (CL:SETQ ITER-000 (%%REST ITER-000))))
          (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))))
      (CL:WHEN TEST-VALUE-000 (CL:RETURN-FROM TEST-RANGE-TYPE? CL:T)))
     (CL:LET* ((TEST-VALUE-001 CL:NIL)) (CL:SETQ TEST-VALUE-001 CLOSED?)
      (CL:WHEN TEST-VALUE-001
       (CL:LET* ((ALWAYS?-001 CL:T))
        (CL:LET*
         ((FILLER NULL) (ITER-001 (ALL-SLOT-VALUES INSTANCE RELATIONREF)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ FILLER (%%VALUE ITER-001))
          (CL:WHEN (CL:NOT (TEST-TYPE-ON-INSTANCE? FILLER VALUESURROGATE))
           (CL:SETQ ALWAYS?-001 CL:NIL) (CL:RETURN))
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:SETQ TEST-VALUE-001 ALWAYS?-001)))
      (CL:WHEN TEST-VALUE-001 (CL:RETURN-FROM TEST-RANGE-TYPE? CL:T)))))
   (CL:LET* ((SUPERR NULL) (ITER-002 (ALL-SUPERRELATIONS RELATION CL:NIL)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ SUPERR (%%VALUE ITER-002))
     (CL:LET* ((SUPERROLESET (GET-ROLESET-OF SUPERR INSTANCE)))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ SUPERROLESET NULL))
        (COLLECTION-IMPLIES-COLLECTION? SUPERROLESET VALUETYPE))
       (CL:RETURN-FROM TEST-RANGE-TYPE? CL:T)))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   CL:NIL))

;;; (DEFUN (/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (RELATION
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (INSTANCE
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       1)))
    (VALUETYPEARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      2))
    (VALUETYPEVALUE (ARGUMENT-BOUND-TO VALUETYPEARG)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:NOT *ACCELERATE-FRAME-COMPUTATIONS?*)
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:WHEN (CL:OR (CL:EQ RELATION NULL) (CL:EQ INSTANCE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:WHEN (CL:EQ VALUETYPEVALUE NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:WHEN (ISA? VALUETYPEVALUE SGT-SPECIALISTS-STELLA-SURROGATE)
    (CL:SETQ VALUETYPEVALUE (SURROGATE-TO-DESCRIPTION VALUETYPEVALUE)))
   (CL:WHEN
    (CL:OR (CL:NOT (ISA? RELATION SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
     (CL:NOT (ISA? VALUETYPEVALUE SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
     (CL:EQ VALUETYPEVALUE NULL))
    (CL:RETURN-FROM |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:IF (TEST-RANGE-TYPE? RELATION INSTANCE VALUETYPEVALUE)
    (SELECT-TEST-RESULT CL:T CL:T FRAME) KWD-SPECIALISTS-FAILURE)))

;;; (DEFUN (/PL-KERNEL-KB/REFLEXIVE-RELATION-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/REFLEXIVE-RELATION-SPECIALIST| (FRAME LASTMOVE)
  (CL:SETQ LASTMOVE LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (ARG1
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (ARG2
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       1))))
   (CL:IF
    (CL:OR (EQL? ARG1 ARG2)
     (EQL? (ARGUMENT-BOUND-TO ARG1) (ARGUMENT-BOUND-TO ARG2)))
    (SELECT-TEST-RESULT CL:T CL:T FRAME) KWD-SPECIALISTS-FAILURE)))

;;; (DEFUN (/PL-KERNEL-KB/IRREFLEXIVE-RELATION-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/IRREFLEXIVE-RELATION-SPECIALIST| (FRAME LASTMOVE)
  (CL:SETQ LASTMOVE LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (ARG1
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)))
    (ARG2
     (ARGUMENT-BOUND-TO
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       1))))
   (CL:IF
    (CL:OR (EQL? ARG1 ARG2)
     (EQL? (ARGUMENT-BOUND-TO ARG1) (ARGUMENT-BOUND-TO ARG2)))
    (SELECT-TEST-RESULT CL:NIL CL:T FRAME) KWD-SPECIALISTS-FAILURE)))

;;; (DEFUN (/PL-KERNEL-KB/OBJECT-NAME-COMPUTATION STRING-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/OBJECT-NAME-COMPUTATION| (OBJECTARG)
  (CL:LET* ((NAME-STRING (OBJECT-NAME-STRING (VALUE-OF OBJECTARG))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME-STRING))
   (CL:IF (CL:EQ NAME-STRING STELLA::NULL-STRING) NULL
    (WRAP-STRING NAME-STRING))))

;;; (DEFUN (/PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION| (NAMEARG)
  (CL:LET* ((*MODULE* (%BASE-MODULE *CONTEXT*)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CL:NOT (STRING? NAMEARG))
    (CL:LET* ((INSTANCE (GET-INSTANCE NAMEARG)))
     (CL:WHEN (CL:NOT (CL:EQ INSTANCE NULL))
      (CL:RETURN-FROM |/PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION| INSTANCE))))
   (CL:LET*
    ((NAMEARGSTRING (PLI::OBJECT-TO-STRING NAMEARG))
     (INSTANCENAME (LOOKUP-SURROGATE NAMEARGSTRING)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAMEARGSTRING))
    (CL:LET* ((TEMP-000 (GET-INSTANCE INSTANCENAME)))
     (CL:LET*
      ((VALUE-000
        (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000
         (CREATE-LOGIC-INSTANCE
          (INTERN-SURROGATE-IN-MODULE NAMEARGSTRING *MODULE* CL:T) NULL))))
      VALUE-000)))))

;;; (DEFUN (/PL-KERNEL-KB/ARITY-COMPUTATION INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/ARITY-COMPUTATION| (DESCRIPTIONARG)
  (CL:LET* ((DESCRIPTION (VALUE-OF DESCRIPTIONARG)))
   (CL:IF (CL:NOT (CL:EQ DESCRIPTION NULL))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE DESCRIPTION)
       SGT-SPECIALISTS-LOGIC-DESCRIPTION)
      (CL:PROGN (WRAP-INTEGER (ARITY DESCRIPTION))))
     (CL:T NULL))
    NULL)))

;;; (DEFUN (/PL-KERNEL-KB/ARITY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/ARITY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (RELATION-ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (RELATION-ARG-VALUE (ARGUMENT-BOUND-TO RELATION-ARG))
    (ARITY-ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (ARITY-ARG-VALUE (ARGUMENT-BOUND-TO ARITY-ARG))
    (COMPUTED-ARITY (|/PL-KERNEL-KB/ARITY-COMPUTATION| RELATION-ARG-VALUE))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:COND
     ((CL:EQ RELATION-ARG-VALUE NULL)
      (CL:SETQ ITERATOR (ALL-NAMED-DESCRIPTIONS *MODULE* CL:NIL))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
       SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
     ((CL:EQ ARITY-ARG-VALUE NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/ARITY-SPECIALIST|
       (SELECT-PROOF-RESULT
        (BIND-ARGUMENT-TO-VALUE? ARITY-ARG COMPUTED-ARITY CL:T) CL:NIL CL:T)))
     (CL:T
      (CL:IF (CL:EQ COMPUTED-ARITY NULL)
       (CL:RETURN-FROM |/PL-KERNEL-KB/ARITY-SPECIALIST|
        KWD-SPECIALISTS-FAILURE)
       (CL:COND
        ((SUBTYPE-OF-INTEGER? (SAFE-PRIMARY-TYPE ARITY-ARG-VALUE))
         (CL:PROGN
          (CL:RETURN-FROM |/PL-KERNEL-KB/ARITY-SPECIALIST|
           (SELECT-TEST-RESULT (EQL? ARITY-ARG-VALUE COMPUTED-ARITY) CL:T
            FRAME))))
        (CL:T
         (CL:RETURN-FROM |/PL-KERNEL-KB/ARITY-SPECIALIST|
          (SELECT-TEST-RESULT
           (BIND-ARGUMENT-TO-VALUE? ARITY-ARG COMPUTED-ARITY CL:T) CL:T
           FRAME))))))))
   (CL:LET* ((DESCRIPTION NULL))
    (CL:LOOP WHILE (NEXT? ITERATOR) DO (CL:SETQ DESCRIPTION (%VALUE ITERATOR))
     (CL:SETQ COMPUTED-ARITY (|/PL-KERNEL-KB/ARITY-COMPUTATION| DESCRIPTION))
     (CL:WHEN
      (CL:AND (BIND-ARGUMENT-TO-VALUE? ARITY-ARG COMPUTED-ARITY CL:T)
       (BIND-ARGUMENT-TO-VALUE? RELATION-ARG DESCRIPTION CL:T))
      (CL:RETURN-FROM |/PL-KERNEL-KB/ARITY-SPECIALIST|
       KWD-SPECIALISTS-CONTINUING-SUCCESS)))
    KWD-SPECIALISTS-FAILURE)))

;;; (DEFUN (/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME)) (RELATION (%OPERATOR PROPOSITION))
    (BOUNDARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (BOUNDARGVALUE (ARGUMENT-BOUND-TO BOUNDARG))
    (OTHERARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (OTHERARGVALUE (ARGUMENT-BOUND-TO OTHERARG)) (REFLEXIVE? CL:NIL)
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL))
    (COLLECTION NIL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN (CL:EQ BOUNDARGVALUE NULL)
    (CL:COND
     ((CL:EQ OTHERARGVALUE NULL)
      (CL:RETURN-FROM |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|
       KWD-SPECIALISTS-TERMINAL-FAILURE))
     (CL:T (CL:SETQ BOUNDARG OTHERARG) (CL:SETQ BOUNDARGVALUE OTHERARGVALUE)
      (CL:SETQ OTHERARG
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION))) 0))
      (CL:SETQ OTHERARGVALUE NULL)
      (CL:COND
       ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUBRELATION)
        (CL:SETQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUPERRELATION))
       ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUPERRELATION)
        (CL:SETQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUBRELATION))
       ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUBRELATION)
        (CL:SETQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUPERRELATION))
       ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUPERRELATION)
        (CL:SETQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUBRELATION))
       ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUBRELATION)
        (CL:SETQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUPERRELATION))
       ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUPERRELATION)
        (CL:SETQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUBRELATION))
       (CL:T)))))
   (CL:WHEN
    (CL:NOT (ISA? BOUNDARGVALUE SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION))
    (CL:RETURN-FROM |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:COND
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUBRELATION)
      (CL:SETQ COLLECTION (ALL-DIRECT-SUBRELATIONS BOUNDARGVALUE CL:T)))
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUBRELATION)
      (CL:SETQ REFLEXIVE? CL:T)
      (CL:SETQ COLLECTION (ALL-SUBRELATIONS BOUNDARGVALUE CL:NIL)))
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUBRELATION)
      (CL:SETQ COLLECTION (ALL-SUBRELATIONS BOUNDARGVALUE CL:T)))
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUPERRELATION)
      (CL:SETQ COLLECTION (ALL-DIRECT-SUPERRELATIONS BOUNDARGVALUE CL:T)))
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-SUPERRELATION)
      (CL:SETQ REFLEXIVE? CL:T)
      (CL:SETQ COLLECTION (ALL-SUPERRELATIONS BOUNDARGVALUE CL:NIL)))
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUPERRELATION)
      (CL:SETQ COLLECTION (ALL-SUPERRELATIONS BOUNDARGVALUE CL:T)))
     ((CL:EQ RELATION SGT-SPECIALISTS-PL-KERNEL-KB-EQUIVALENT-RELATION)
      (CL:SETQ COLLECTION (ALL-EQUIVALENT-RELATIONS BOUNDARGVALUE CL:T)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" RELATION
        "' is not a valid case option")
       (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
    (CL:WHEN (CL:AND REFLEXIVE? (CL:NOT (MEMB? COLLECTION BOUNDARGVALUE)))
     (CL:SETQ COLLECTION (CONS BOUNDARGVALUE COLLECTION))))
   (CL:WHEN (CL:NOT (CL:EQ OTHERARGVALUE NULL))
    (CL:IF (MEMB? COLLECTION OTHERARGVALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|
      KWD-SPECIALISTS-FINAL-SUCCESS)
     (CL:RETURN-FROM |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE)))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:WHEN (CL:EQ COLLECTION NIL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (CL:SETQ ITERATOR (ALLOCATE-ITERATOR COLLECTION))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
     SYM-SPECIALISTS-STELLA-ITERATOR ITERATOR NULL))
   (CL:IF
    (CL:AND (NEXT? ITERATOR)
     (BIND-ARGUMENT-TO-VALUE? OTHERARG (%VALUE ITERATOR) CL:T))
    KWD-SPECIALISTS-CONTINUING-SUCCESS KWD-SPECIALISTS-TERMINAL-FAILURE)))

;;; (DEFUN (HELP-PROJECT-NTH-COLUMN LIST) ...)

(CL:DEFUN HELP-PROJECT-NTH-COLUMN (N TUPLELIST)
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:WHEN (CL:EQ TUPLELIST NULL)
   (CL:RETURN-FROM HELP-PROJECT-NTH-COLUMN NULL))
  (CL:LET* ((PROJECTEDLIST (NEW-LIST)) (ITEM NULL))
   (CL:LET*
    ((TUPLE NULL) (ITER-000 (%THE-CONS-LIST TUPLELIST)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TUPLE (%%VALUE ITER-000))
     (CL:TAGBODY
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TUPLE)))
       (CL:COND
        ((CL:EQ TEST-VALUE-000 SGT-SPECIALISTS-STELLA-CONS)
         (CL:PROGN (CL:SETQ ITEM (NTH TUPLE N))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-LIST)
         (CL:PROGN (CL:SETQ ITEM (NTH TUPLE N))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-STELLA-COLLECTION)
         (CL:PROGN
          (CL:LET* ((MEMBERS (ASSERTED-COLLECTION-MEMBERS TUPLE CL:NIL)))
           (CL:IF (CL:NOT (CL:EQ MEMBERS NULL)) (CL:SETQ ITEM (NTH MEMBERS N))
            (CL:GO :CONTINUE)))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-SPECIALISTS-LOGIC-SKOLEM)
         (CL:PROGN
          (CL:LET* ((MEMBERS (ASSERTED-COLLECTION-MEMBERS TUPLE CL:NIL)))
           (CL:IF (CL:NOT (CL:EQ MEMBERS NULL)) (CL:SETQ ITEM (NTH MEMBERS N))
            (CL:GO :CONTINUE)))))
        (CL:T
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
          "Can't handle tuple object `" TUPLE "'" EOL EOL)
         (CL:GO :CONTINUE))))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ITEM NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST PROJECTEDLIST) NIL)
         (CL:SETF (%THE-CONS-LIST PROJECTEDLIST) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST PROJECTEDLIST)
          COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ITEM NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      :CONTINUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:IF (EMPTY? PROJECTEDLIST) NULL PROJECTEDLIST)))

;;; (DEFUN (/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (PROJECTIONARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      0))
    (PROJECTIONVALUE (ARGUMENT-BOUND-TO PROJECTIONARG))
    (COLLECTIONARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      1))
    (COLLECTIONVALUE (ARGUMENT-BOUND-TO COLLECTIONARG))
    (SELECTOR NULL-INTEGER)
    (LISTARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
      2)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SELECTOR)) (CL:SETQ LASTMOVE LASTMOVE)
   (CL:WHEN
    (CL:OR (CL:EQ COLLECTIONVALUE NULL) (CL:EQ PROJECTIONVALUE NULL)
     (CL:NOT (ISA? PROJECTIONVALUE SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER)))
    (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
     KWD-SPECIALISTS-TERMINAL-FAILURE))
   (CL:SETQ SELECTOR (%WRAPPER-VALUE PROJECTIONVALUE))
   (CL:WHEN
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-SPECIALISTS-STELLA-ITERATOR NULL)
     NULL)
    (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE COLLECTIONVALUE)))
     (CL:COND
      ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-STELLA-COLLECTION)
       (CL:PROGN
        (CL:LET*
         ((MEMBERS
           (HELP-PROJECT-NTH-COLUMN SELECTOR
            (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))))
         (CL:WHEN (CL:EQ MEMBERS NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
           KWD-SPECIALISTS-TERMINAL-FAILURE))
         (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
          (SELECT-PROOF-RESULT
           (BIND-ARGUMENT-TO-VALUE? LISTARG (CREATE-LOGICAL-LIST MEMBERS)
            CL:T)
           CL:NIL CL:T)))))
      ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-LOGIC-SKOLEM)
       (CL:PROGN
        (CL:LET*
         ((MEMBERS
           (HELP-PROJECT-NTH-COLUMN SELECTOR
            (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))))
         (CL:WHEN (CL:EQ MEMBERS NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
           KWD-SPECIALISTS-TERMINAL-FAILURE))
         (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
          (SELECT-PROOF-RESULT
           (BIND-ARGUMENT-TO-VALUE? LISTARG (CREATE-LOGICAL-LIST MEMBERS)
            CL:T)
           CL:NIL CL:T)))))
      ((SUBTYPE-OF? TEST-VALUE-001 SGT-SPECIALISTS-LOGIC-DESCRIPTION)
       (CL:PROGN
        (CL:LET* ((TEST-VALUE-000 CL:NIL))
         (CL:SETQ TEST-VALUE-000
          (CL:NOT
           (CL:EQ
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS COLLECTIONVALUE)
             SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL)
            NULL)))
         (CL:WHEN TEST-VALUE-000
          (CL:LET* ((FOUND?-000 CL:NIL))
           (CL:LET*
            ((V NULL)
             (VECTOR-000
              (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS COLLECTIONVALUE)
               SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES NULL))
             (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
            (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
             (CL:SETQ V
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
               INDEX-000))
             (CL:WHEN (CL:EQ (ARGUMENT-BOUND-TO V) NULL)
              (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
             (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
           (CL:SETQ TEST-VALUE-000 FOUND?-000)))
         (CL:WHEN TEST-VALUE-000
          (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
           KWD-SPECIALISTS-TERMINAL-FAILURE)))
        (CL:IF (INFERABLE? COLLECTIONVALUE)
         (CL:PROGN
          (CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME FRAME COLLECTIONVALUE)
          (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
           SYM-SPECIALISTS-STELLA-ITERATOR EMPTY-PROPOSITIONS-ITERATOR NULL)
          (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
           KWD-SPECIALISTS-MOVE-DOWN))
         (CL:LET*
          ((MEMBERS
            (HELP-PROJECT-NTH-COLUMN SELECTOR
             (ASSERTED-COLLECTION-MEMBERS COLLECTIONVALUE CL:NIL))))
          (CL:WHEN (CL:EQ MEMBERS NULL)
           (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
            KWD-SPECIALISTS-TERMINAL-FAILURE))
          (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
           (SELECT-PROOF-RESULT
            (BIND-ARGUMENT-TO-VALUE? LISTARG (CREATE-LOGICAL-LIST MEMBERS)
             CL:T)
            CL:NIL CL:T))))))
      (CL:T
       (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
        KWD-SPECIALISTS-FAILURE)))))
   (CL:WHEN (CL:EQ (%DOWN FRAME) NULL)
    (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
     KWD-SPECIALISTS-FAILURE))
   (CL:LET*
    ((LIST
      (HELP-PROJECT-NTH-COLUMN SELECTOR
       (%COLLECTION-LIST (%PATTERN-RECORD (%DOWN FRAME))))))
    (POP-FRAMES-UP-TO (%DOWN FRAME))
    (CL:WHEN (CL:EQ LIST NULL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|
      KWD-SPECIALISTS-TERMINAL-FAILURE))
    (SELECT-PROOF-RESULT
     (BIND-ARGUMENT-TO-VALUE? LISTARG (CREATE-LOGICAL-LIST LIST) CL:T) CL:NIL
     CL:T))))

;;; (DEFUN /PL-KERNEL-KB/ASSERT-SYNONYM-DEMON ...)

(CL:DEFUN |/PL-KERNEL-KB/ASSERT-SYNONYM-DEMON| (SELF)
  (CL:LET*
   ((TERM
     (VALUE-OF
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0)))
    (SYNONYM
     (VALUE-OF
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 1)))
    (SYNONYMNAME NULL))
   (CL:WHEN
    (CL:AND (CL:NOT (EQL? TERM SYNONYM))
     (ISA? SYNONYM SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT))
    (CL:SETQ SYNONYMNAME (%SURROGATE-VALUE-INVERSE SYNONYM))
    (CL:SETF (%SURROGATE-VALUE SYNONYMNAME) TERM)
    (ASSERT-TUPLE SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM (CONS-LIST TERM TERM)))))

;;; (DEFUN /PL-KERNEL-KB/RETRACT-SYNONYM-DEMON ...)

(CL:DEFUN |/PL-KERNEL-KB/RETRACT-SYNONYM-DEMON| (SELF)
  (CL:LET*
   ((TERM
     (VALUE-OF
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF))) 0)))
    (SYNONYM NULL) (SYNONYMNAME NULL))
   (CL:LET*
    ((PROP NULL)
     (ITER-000
      (ALL-TRUE-DEPENDENT-PROPOSITIONS TERM
       SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
     (CL:SETQ SYNONYM
      (VALUE-OF
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP))) 1)))
     (CL:WHEN (ISA? SYNONYM SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT)
      (CL:SETQ SYNONYMNAME (%SURROGATE-VALUE-INVERSE SYNONYM))
      (CL:SETF (%SURROGATE-VALUE SYNONYMNAME) SYNONYM))
     (CL:LET*
      ((OBJECT-000 PROP) (VALUE-000 NULL)
       (OLD-VALUE-000 (%TRUTH-VALUE OBJECT-000))
       (NEW-VALUE-000
        (UPDATE-IN-CONTEXT OLD-VALUE-000 VALUE-000 (%HOME-CONTEXT OBJECT-000)
         CL:NIL)))
      (CL:WHEN
       (CL:NOT
        (CL:AND (CL:NOT (CL:EQ OLD-VALUE-000 NULL))
         (CL:EQ (PRIMARY-TYPE OLD-VALUE-000)
          SGT-SPECIALISTS-STELLA-CS-VALUE)))
       (CL:SETF (%TRUTH-VALUE OBJECT-000) NEW-VALUE-000)))))))

;;; (DEFUN (GET-SYNONYMS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN GET-SYNONYMS (TERM)
  (CL:LET*
   ((TERMVALUE (VALUE-OF TERM)) (FIRSTARG NULL) (SECONDARG NULL)
    (SYNONYMS NIL))
   (CL:LET*
    ((PROP NULL)
     (ITER-000
      (ALL-TRUE-DEPENDENT-PROPOSITIONS TERM
       SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
     (CL:SETQ FIRSTARG
      (VALUE-OF
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP))) 0)))
     (CL:SETQ SECONDARG
      (VALUE-OF
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP))) 1)))
     (CL:WHEN
      (CL:AND (EQL? FIRSTARG TERMVALUE) (CL:NOT (EQL? FIRSTARG SECONDARG))
       (CL:NOT (MEMB? SYNONYMS SECONDARG)))
      (CL:SETQ SYNONYMS (CONS SECONDARG SYNONYMS)))))
   SYNONYMS))

;;; (DEFUN (SYNONYM-SURROGATE? BOOLEAN) ...)

(CL:DEFUN SYNONYM-SURROGATE? (NAME)
  (CL:LET* ((*MODULE* (HOME-MODULE NAME)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:LET*
    ((VALUE (%SURROGATE-VALUE NAME)) (VALUENAME (OBJECT-SURROGATE VALUE)))
    (CL:LET* ((TEST-VALUE-000 CL:NIL))
     (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ VALUENAME NULL)))
     (CL:WHEN TEST-VALUE-000
      (CL:SETQ TEST-VALUE-000 (CL:NOT (CL:EQ NAME VALUENAME)))
      (CL:WHEN TEST-VALUE-000
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET* ((SYNONYM NULL) (ITER-000 (GET-SYNONYMS VALUE)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
          (CL:SETQ SYNONYM (%%VALUE ITER-000))
          (CL:WHEN (CL:EQ (%SURROGATE-VALUE-INVERSE SYNONYM) NAME)
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ ITER-000 (%%REST ITER-000))))
        (CL:SETQ TEST-VALUE-000 FOUND?-000))))
     (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))))

;;; (DEFUN TRANSFER-SYNONYMS ...)

(CL:DEFUN TRANSFER-SYNONYMS (OLDOBJECT NEWOBJECT)
  (CL:LET* ((ORIGINATEDPROPS (ORIGINATED-PROPOSITIONS OLDOBJECT)))
   (CL:LET* ((SYNONYM NULL) (ITER-000 (GET-SYNONYMS OLDOBJECT)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SYNONYM (%%VALUE ITER-000))
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((PROP NULL)
        (ITER-001
         (ALL-TRUE-DEPENDENT-PROPOSITIONS SYNONYM
          SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM CL:NIL)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ PROP (%VALUE ITER-001))
        (CL:WHEN
         (CL:AND
          (EQL?
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP)))
            0)
           OLDOBJECT)
          (CL:EQ
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP)))
            1)
           SYNONYM)
          (CL:NOT (MEMB? ORIGINATEDPROPS PROP)))
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))))
      (CL:IF FOUND?-000
       (CL:SETF (%SURROGATE-VALUE (OBJECT-SURROGATE SYNONYM)) NEWOBJECT)
       (CL:SETF (%SURROGATE-VALUE (OBJECT-SURROGATE SYNONYM)) NULL)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN (/PL-KERNEL-KB/DIFFERENT-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/DIFFERENT-SPECIALIST| (FRAME LASTMOVE)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS (%PROPOSITION FRAME))) (ARGUMENTVALUES NIL)
    (UNBOUNDARGS? CL:NIL) (VALUE NULL))
   (CL:SETQ LASTMOVE LASTMOVE)
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000 (CONS (VALUE-OF (ARGUMENT-BOUND-TO ARG)) NIL))
       (CL:IF (CL:EQ ARGUMENTVALUES NIL) (CL:SETQ ARGUMENTVALUES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ARGUMENTVALUES COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS (VALUE-OF (ARGUMENT-BOUND-TO ARG)) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ARGUMENTVALUES NIL)) DO
    (CL:SETQ VALUE (%%VALUE ARGUMENTVALUES))
    (CL:IF (CL:EQ VALUE NULL) (CL:SETQ UNBOUNDARGS? CL:T)
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET* ((VALUE2 NULL) (ITER-000 (%%REST ARGUMENTVALUES)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ VALUE2 (%%VALUE ITER-000))
        (CL:WHEN (EQL? VALUE VALUE2) (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:WHEN FOUND?-000
       (CL:RETURN-FROM |/PL-KERNEL-KB/DIFFERENT-SPECIALIST|
        (SELECT-TEST-RESULT CL:NIL CL:T FRAME)))))
    (CL:SETQ ARGUMENTVALUES (%%REST ARGUMENTVALUES)))
   (CL:IF UNBOUNDARGS? KWD-SPECIALISTS-FAILURE
    (SELECT-TEST-RESULT CL:T CL:T FRAME))))

;;; (DEFUN (LOOKUP-NATIVE-SPECIALIST FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-NATIVE-SPECIALIST (NATIVE-NAME)
  "Returns the native funtion code for `native-name' if it exists
and the underlying programming languages supports such lookups.  Uses the signature
of a specialist function."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NATIVE-NAME))
  #+MCL
  (CL:CHECK-TYPE NATIVE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((CODE NULL))
   (cl:setq code (cl:symbol-function (cl:read-from-string native-name)))
   (CL:WHEN (CL:EQ CODE NULL)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "Couldn't locate native function for `" NATIVE-NAME "'")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
   CODE))

;;; (DEFUN REGISTER-SPECIALIST-FUNCTION ...)

(CL:DEFUN REGISTER-SPECIALIST-FUNCTION (NAME CODE)
  "Creates a registration entry for `name' as a specialist which
executes `code'.  Essentially just builds the Stella meta-information
tructure needed to funcall `name' as a specialist.  The function definition
in `code' needs to accept a CONTROL-FRAME and KEYWORD as arguments and
return a KEYWORD.  Side effects on elements of the proposition in the
control frame can be used to bind and thus return values."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (DEFINE-FUNCTION-OBJECT (CONCATENATE " " NAME)
   (CONCATENATE "(DEFUN (" NAME
    " KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))")
   CODE NULL))

;;; (DEFUN REGISTER-SPECIALIST-FUNCTION-NAME ...)

(CL:DEFUN %REGISTER-SPECIALIST-FUNCTION-NAME (STELLA-NAME NATIVE-NAME)
  "registers a specialist function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STELLA-NAME NATIVE-NAME))
  #+MCL
  (CL:CHECK-TYPE STELLA-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NATIVE-NAME CL:SIMPLE-STRING)
  (REGISTER-SPECIALIST-FUNCTION STELLA-NAME
   (LOOKUP-NATIVE-SPECIALIST NATIVE-NAME)))

(CL:DEFUN REGISTER-SPECIALIST-FUNCTION-NAME-EVALUATOR-WRAPPER (ARGUMENTS)
  (%REGISTER-SPECIALIST-FUNCTION-NAME (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO REGISTER-SPECIALIST-FUNCTION-NAME (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "registers a specialist function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/REGISTER-SPECIALIST-FUNCTION-NAME|)) (CL:MACRO-FUNCTION (CL:QUOTE REGISTER-SPECIALIST-FUNCTION-NAME)))

;;; (DEFUN (LOOKUP-NATIVE-COMPUTATION FUNCTION-CODE) ...)

(CL:DEFUN LOOKUP-NATIVE-COMPUTATION (NATIVE-NAME ARITY)
  "Returns the native funtion code for `native-name' if it exists
and the underlying programming languages supports such lookups.  It is looked up
using the signature of a computation function supported by the computation specialist."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NATIVE-NAME) (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NATIVE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:LET* ((CODE NULL))
   (cl:setq code (cl:symbol-function (cl:read-from-string native-name)))
   (CL:WHEN (CL:EQ CODE NULL)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
      "Couldn't locate native function for `" NATIVE-NAME "'")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
   CODE))

;;; (DEFUN REGISTER-COMPUTATION-FUNCTION ...)

(CL:DEFUN REGISTER-COMPUTATION-FUNCTION (NAME CODE ARITY)
  "Creates a registration entry for `name' as a computation which
executes `code'.  Essentially just builds the Stella meta-information
tructure needed to funcall `name' as a computation function by the
computation specialist.  The function definition in `code' needs to
accept ARITY Stella OBJECTs as arguments and return a Stella OBJECT 
suitable for PowerLoom use.  (These are generally LOGIC-OBJECTs and the
literal wrappers FLOAT-WRAPPER, INTEGER-WRAPPER and STRING-WRAPPER.)"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME) (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:LET* ((DEFINITION-STRING "(DEFUN ("))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DEFINITION-STRING))
   (CL:SETQ DEFINITION-STRING
    (CONCATENATE DEFINITION-STRING NAME " OBJECT) ("))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 ARITY)
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:SETQ DEFINITION-STRING
      (CONCATENATE DEFINITION-STRING "(X" (INTEGER-TO-STRING (CL:TRUNCATE I))
       " OBJECT) "))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETQ DEFINITION-STRING (CONCATENATE DEFINITION-STRING "))"))
   (DEFINE-FUNCTION-OBJECT (CONCATENATE " " NAME) DEFINITION-STRING CODE NULL)))

;;; (DEFUN REGISTER-COMPUTATION-FUNCTION-NAME ...)

(CL:DEFUN %REGISTER-COMPUTATION-FUNCTION-NAME (STELLA-NAME NATIVE-NAME ARITY)
  "registers a computation function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STELLA-NAME NATIVE-NAME)
   (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE STELLA-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE NATIVE-NAME CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (REGISTER-COMPUTATION-FUNCTION STELLA-NAME
   (LOOKUP-NATIVE-COMPUTATION NATIVE-NAME ARITY) ARITY))

(CL:DEFUN REGISTER-COMPUTATION-FUNCTION-NAME-EVALUATOR-WRAPPER (ARGUMENTS)
  (%REGISTER-COMPUTATION-FUNCTION-NAME (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))
   (%WRAPPER-VALUE (%%VALUE (%%REST (%%REST ARGUMENTS))))))

(CL:DEFMACRO REGISTER-COMPUTATION-FUNCTION-NAME (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "registers a computation function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/REGISTER-COMPUTATION-FUNCTION-NAME|)) (CL:MACRO-FUNCTION (CL:QUOTE REGISTER-COMPUTATION-FUNCTION-NAME)))

(CL:DEFUN HELP-STARTUP-SPECIALISTS1 ()
  (CL:PROGN
   (CL:SETQ SGT-SPECIALISTS-LOGIC-COMPUTED-PROCEDURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPUTED-PROCEDURE" NULL 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-PROCEDURE-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROCEDURE-NAME" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-PROCEDURE-CODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROCEDURE-CODE" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-SPECIALIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-SPECIALIST"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-HANDLES-REVERSE-POLARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HANDLES-REVERSE-POLARITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-CONSTRAINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-CONSTRAINT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-COMPUTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-COMPUTATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-RELATION-EVALUATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATION-EVALUATOR"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-TERMINAL-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TERMINAL-FAILURE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-FINAL-SUCCESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINAL-SUCCESS" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-CONTINUING-SUCCESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUING-SUCCESS" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-FUNCTION-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION-CODE-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-METHOD-CODE-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-CODE-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-SUBSTRING-POSITION-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSTRING-POSITION-ITERATOR" NULL 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-SUPER-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPER-STRING" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-SUB-STRING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUB-STRING" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-STELLA-START
    (INTERN-RIGID-SYMBOL-WRT-MODULE "START" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-SUB-LENGTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUB-LENGTH" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-TOTAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TOTAL"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ KWD-SPECIALISTS-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-STELLA-ITERATOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-SPECIALISTS-STELLA-NUMBER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-COLLECTIONOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTIONOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-UP-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-UP-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FAIL" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-STELLA-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ KWD-SPECIALISTS-MOVE-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MOVE-DOWN" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-EXTERNAL-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTERNAL-VARIABLES" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ KWD-SPECIALISTS-SCAN-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-COLLECTION" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-DOWN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-STELLA-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-SPECIALISTS-STELLA-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-SPECIALISTS-STELLA-DUMMY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DUMMY" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ KWD-SPECIALISTS-FULL-SUBQUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FULL-SUBQUERY" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ KWD-SPECIALISTS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-ISA (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-AND (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-STELLA-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-FORK-PROOF-ADJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORK-PROOF-ADJUNCT" NULL 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-CONDITION-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONDITION-JUSTIFICATION" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-DOWN-FRAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWN-FRAME" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-PROOF-ADJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROOF-ADJUNCT" NULL 0))
   (CL:SETQ KWD-SPECIALISTS-FAIL-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-FORK-ELSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORK-ELSE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-FORK-THEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORK-THEN" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 0))
   (CL:SETQ KWD-SPECIALISTS-TECHNICAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TECHNICAL" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-LAY (INTERN-RIGID-SYMBOL-WRT-MODULE "LAY" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))))

(CL:DEFUN HELP-STARTUP-SPECIALISTS2 ()
  (CL:PROGN
   (CL:SETQ KWD-SPECIALISTS-HOW-MANY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOW-MANY" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-INHERIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INHERIT" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-ALL (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-CURRENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CURRENT" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-QUERY-SPECIALIST-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-SPECIALIST-IO-VARIABLES" NULL 0))
   (CL:SETQ KWD-SPECIALISTS-MATCH-MODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-MODE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-SORT-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SORT-BY" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-GOAL-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT" NULL
     1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-SAVED-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVED-INFERENCE-LEVEL" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-LEVEL" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-ASSERTION-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERTION-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SHALLOW-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHALLOW-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SUBSUMPTION-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-BACKTRACKING-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKTRACKING-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-NORMAL-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NORMAL-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-REFUTATION-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REFUTATION-QUERY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-LEVELED-QUERY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LEVELED-QUERY" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-CONCEPT-PROTOTYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONCEPT-PROTOTYPE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-HYPOTHESIZED-INSTANCE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HYPOTHESIZED-INSTANCE?" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-CLOSED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-MONOTONIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MONOTONIC?" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-F-CLOSED-TERM?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-CLOSED-TERM?-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-EQUIVALENT-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT-VALUE" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-F-CLOSED-PROPOSITION?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-CLOSED-PROPOSITION?-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ KWD-SPECIALISTS-OR (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-NOT (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SINGLE-VALUED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLE-VALUED"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-F-SINGLE-VALUED-TERM?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE "F-SINGLE-VALUED-TERM?-MEMO-TABLE-000"
     NULL 1))
   (CL:SETQ KWD-SPECIALISTS-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO-LIST"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-COLLECT-INTO-ORDERED-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-INTO-ORDERED-SET"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-INFERENCE-CUTOFF-REASON
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-CUTOFF-REASON" NULL 0))
   (CL:SETQ KWD-SPECIALISTS-COLLECT-MEMBERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COLLECT-MEMBERS" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-?SUPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?SUPER" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-?MDC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?MDC" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-MUTUALLY-DISJOINT-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTUALLY-DISJOINT-COLLECTION" NULL 0))
   (CL:SETQ
    SYM-SPECIALISTS-LOGIC-F-HELP-DERIVE-PARTITION-MEMBERSHIPS-QUERY-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-HELP-DERIVE-PARTITION-MEMBERSHIPS-QUERY-000" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-MUTUALLY-DISJOINT-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTUALLY-DISJOINT-COLLECTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-PARTITION-MEMBERSHIP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTITION-MEMBERSHIP"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-DISJOINT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISJOINT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-HAS-PARTITION-MEMBERSHIP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HAS-PARTITION-MEMBERSHIP"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-ASSERT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-ASSERT-FALSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-FALSE" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-EMPTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EMPTY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-LOGIC-SAVED-CONTEXT-PROOF-ADJUNCT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVED-CONTEXT-PROOF-ADJUNCT" NULL 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-SAVED-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVED-CONTEXT" NULL 0))
   (CL:SETQ SGT-SPECIALISTS-STELLA-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTEXT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-IST-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IST-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-SPECIALISTS-PARTIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-THE-ROLESET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ROLESET"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-CARDINALITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CARDINALITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-SPECIALISTS-LOWER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOWER" NULL 2))))

(CL:DEFUN HELP-STARTUP-SPECIALISTS3 ()
  (CL:PROGN
   (CL:SETQ KWD-SPECIALISTS-UPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPPER" NULL 2))
   (CL:SETQ SGT-SPECIALISTS-STELLA-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUBRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECT-SUBRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-DIRECT-SUPERRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIRECT-SUPERRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SUBRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SUPERRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPERRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUBRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPER-SUBRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-PROPER-SUPERRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPER-SUPERRELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-EQUIVALENT-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT-RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ SGT-SPECIALISTS-PL-KERNEL-KB-SYNONYM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYNONYM"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-SPECIALISTS-STELLA-CS-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CS-VALUE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-REGISTER-SPECIALIST-FUNCTION-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REGISTER-SPECIALIST-FUNCTION-NAME" NULL
     0))
   (CL:SETQ KWD-SPECIALISTS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-REGISTER-COMPUTATION-FUNCTION-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REGISTER-COMPUTATION-FUNCTION-NAME" NULL
     0))
   (CL:SETQ SYM-SPECIALISTS-LOGIC-STARTUP-SPECIALISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-SPECIALISTS" NULL 0))
   (CL:SETQ SYM-SPECIALISTS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-SPECIALISTS4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "FUNCTION-CODE-FROM-PROCEDURE"
    "(DEFUN (FUNCTION-CODE-FROM-PROCEDURE FUNCTION-CODE) ((P OBJECT)))"
    (CL:FUNCTION FUNCTION-CODE-FROM-PROCEDURE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-SPECIALIST"
    "(DEFUN (LOOKUP-SPECIALIST FUNCTION-CODE) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LOOKUP-SPECIALIST) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-CONSTRAINT"
    "(DEFUN (LOOKUP-CONSTRAINT FUNCTION-CODE) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LOOKUP-CONSTRAINT) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-COMPUTATION"
    "(DEFUN (LOOKUP-COMPUTATION FUNCTION-CODE) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LOOKUP-COMPUTATION) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-EVALUATOR"
    "(DEFUN (LOOKUP-EVALUATOR FUNCTION-CODE) ((DESCRIPTION NAMED-DESCRIPTION)))"
    (CL:FUNCTION LOOKUP-EVALUATOR) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-TEST-RESULT"
    "(DEFUN (SELECT-TEST-RESULT KEYWORD) ((SUCCESS? BOOLEAN) (TERMINAL? BOOLEAN) (FRAME CONTROL-FRAME)) :PUBLIC? TRUE :DOCUMENTATION \"Helping function for specialists testing the validity of a
fully bound inference frame.  Based on the test result `success?'
and `reversePolarity?*', set the truth value of `frame' and return
an appropriate keyword.  The keyword will be either `:final-success'
`:terminal-failure' if `terminal?' is true.  Otherwise it will be
`:final-success' or `:failure'.\")" (CL:FUNCTION SELECT-TEST-RESULT) NULL)
   (DEFINE-FUNCTION-OBJECT "SELECT-PROOF-RESULT"
    "(DEFUN (SELECT-PROOF-RESULT KEYWORD) ((SUCCESS? BOOLEAN) (CONTINUING? BOOLEAN) (TERMINAL? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Helping function for specialists.   Return the appropriate
keyword indicating success or failure of a proof.\")"
    (CL:FUNCTION SELECT-PROOF-RESULT) NULL)
   (DEFINE-FUNCTION-OBJECT "NULL-WRAPPER?"
    "(DEFUN (NULL-WRAPPER? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION NULL-WRAPPER?) NULL)
   (DEFINE-FUNCTION-OBJECT "NATIVE-SLOT-READER-SPECIALIST"
    "(DEFUN (NATIVE-SLOT-READER-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION NATIVE-SLOT-READER-SPECIALIST) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NEXT? BOOLEAN) ((IT SUBSTRING-POSITION-ITERATOR)))"
    (CL:FUNCTION NEXT?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((IT SUBSTRING-POSITION-ITERATOR)))"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTATION-INPUT-BOUND?"
    "(DEFUN (COMPUTATION-INPUT-BOUND? BOOLEAN) ((VALUE OBJECT)))"
    (CL:FUNCTION COMPUTATION-INPUT-BOUND?) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-RELATION-VALUE"
    "(DEFUN (COMPUTE-RELATION-VALUE OBJECT) ((PROPOSITION PROPOSITION) (CODE FUNCTION-CODE) (ERROR? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-RELATION-VALUE) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/COMPUTATION-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/COMPUTATION-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/COMPUTATION-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-SIMPLE-RELATION-CONSTRAINT"
    "(DEFUN (COMPUTE-SIMPLE-RELATION-CONSTRAINT OBJECT INTEGER) ((PROPOSITION PROPOSITION) (CODE FUNCTION-CODE) (ERROR? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-SIMPLE-RELATION-CONSTRAINT) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/CONSTRAINT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/CONSTRAINT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/CONSTRAINT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SQUARE-ROOT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/ABSOLUTE-VALUE-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "ENUMERATIONS-CONTAINING-MEMBER"
    "(DEFUN (ENUMERATIONS-CONTAINING-MEMBER LIST) ((SELF OBJECT)))"
    (CL:FUNCTION ENUMERATIONS-CONTAINING-MEMBER) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/MEMBER-OF-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/MEMBER-OF-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MEMBER-OF-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/MEMBER-OF-EVALUATOR"
    "(DEFUN /PL-KERNEL-KB/MEMBER-OF-EVALUATOR ((SELF PROPOSITION)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MEMBER-OF-EVALUATOR|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/INSTANCE-OF-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/INSTANCE-OF-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-DISJOINT-TERMS?"
    "(DEFUN (TEST-DISJOINT-TERMS? BOOLEAN) ((TERM1 OBJECT) (TERM2 OBJECT)))"
    (CL:FUNCTION TEST-DISJOINT-TERMS?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/SUBSET-OF-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/SUBSET-OF-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SUBSET-OF-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/HOLDS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/HOLDS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/HOLDS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/PROPOSITION-RELATION-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/PROPOSITION-RELATION-COMPUTATION OBJECT) ((P PROPOSITION)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PROPOSITION-RELATION-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION OBJECT) ((P PROPOSITION) (I INTEGER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PROPOSITION-ARGUMENT-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION SKOLEM) ((P PROPOSITION)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PROPOSITION-ARGUMENTS-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION INTEGER-WRAPPER) ((P PROPOSITION)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PROPOSITION-ARITY-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/CUT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/CUT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/CUT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/BOUND-VARIABLES-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/BOUND-VARIABLES-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/BOUND-VARIABLES-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/FORK-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/FORK-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/FORK-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-SUBQUERY-OPTIONS"
    "(DEFUN (COMPUTE-SUBQUERY-OPTIONS PROPOSITION PROPERTY-LIST) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COMPUTE-SUBQUERY-OPTIONS) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTROL-FRAME QUERY-SPECIALIST-IO-VARIABLES :TYPE LIST :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "CREATE-QUERY-SPECIALIST-ITERATOR"
    "(DEFUN (CREATE-QUERY-SPECIALIST-ITERATOR QUERY-ITERATOR BOOLEAN BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION CREATE-QUERY-SPECIALIST-ITERATOR) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/QUERY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/QUERY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/QUERY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL"
    "(DEFUN (LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL INFERENCE-LEVEL) ((RELATION SURROGATE)))"
    (CL:FUNCTION LEVELED-QUERY-RELATION-TO-INFERENCE-LEVEL) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/LEVELED-QUERY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/CONCEPT-PROTOTYPE-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEPT-PROTOTYPE-OF"
    "(DEFUN (CONCEPT-PROTOTYPE-OF NAMED-DESCRIPTION) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION CONCEPT-PROTOTYPE-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "CONCEPT-PROTOTYPE?"
    "(DEFUN (CONCEPT-PROTOTYPE? BOOLEAN) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION CONCEPT-PROTOTYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/CLOSED-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/CLOSED-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/CLOSED-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "CLOSED-BY-ASSERTION?"
    "(DEFUN (CLOSED-BY-ASSERTION? BOOLEAN) ((SELF OBJECT)) :GLOBALLY-INLINE? TRUE (RETURN (AND (TEST-PROPERTY? SELF /PL-KERNEL-KB/@CLOSED) (NOT (MONOTONIC? *CONTEXT*)))))"
    (CL:FUNCTION CLOSED-BY-ASSERTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLOSED-TERM?"
    "(DEFUN (CLOSED-TERM? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (MEMOIZE (SELF *CONTEXT*) :TIMESTAMPS :KB-UPDATE :MAX-VALUES 500 (HELP-CLOSED-TERM? SELF NIL))))"
    (CL:FUNCTION CLOSED-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-CLOSED-TERM?"
    "(DEFUN (HELP-CLOSED-TERM? BOOLEAN) ((SELF OBJECT) (ACTIVETERMS CONS)))"
    (CL:FUNCTION HELP-CLOSED-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "CLOSED-PROPOSITION?"
    "(DEFUN (CLOSED-PROPOSITION? BOOLEAN) ((SELF PROPOSITION)) :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (MEMOIZE (SELF *CONTEXT*) :TIMESTAMPS :META-KB-UPDATE :MAX-VALUES 500 (HELP-CLOSED-PROPOSITION? SELF NIL))))"
    (CL:FUNCTION CLOSED-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-CLOSED-PROPOSITION?"
    "(DEFUN (HELP-CLOSED-PROPOSITION? BOOLEAN) ((SELF PROPOSITION) (ACTIVETERMS CONS)))"
    (CL:FUNCTION HELP-CLOSED-PROPOSITION?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SINGLE-VALUED-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "SINGLE-VALUED-TERM?"
    "(DEFUN (SINGLE-VALUED-TERM? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION SINGLE-VALUED-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "NON-RECURSIVE-SINGLE-VALUED-TERM?"
    "(DEFUN (NON-RECURSIVE-SINGLE-VALUED-TERM? BOOLEAN) ((SELF OBJECT)))"
    (CL:FUNCTION NON-RECURSIVE-SINGLE-VALUED-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "SINGLE-VALUED-GOAL?"
    "(DEFUN (SINGLE-VALUED-GOAL? BOOLEAN) ((PROPOSITION PROPOSITION) (IOVARIABLES (CONS OF PATTERN-VARIABLE)) (BOUNDVARIABLES (CONS OF PATTERN-VARIABLE))) :PUBLIC? TRUE)"
    (CL:FUNCTION SINGLE-VALUED-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-SINGLE-VALUED-GOAL?"
    "(DEFUN (HELP-SINGLE-VALUED-GOAL? BOOLEAN) ((PROPOSITION PROPOSITION) (IOVARIABLES (CONS OF PATTERN-VARIABLE)) (BOUNDVARIABLES (CONS OF PATTERN-VARIABLE)) (RECURSIVE? BOOLEAN)) :PUBLIC? TRUE)"
    (CL:FUNCTION HELP-SINGLE-VALUED-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-SINGLY-BOUND-VARIABLES"
    "(DEFUN HELP-COLLECT-SINGLY-BOUND-VARIABLES ((PROPOSITION PROPOSITION) (BOUNDVARIABLES (LIST OF PATTERN-VARIABLE)) (RECURSIVE? BOOLEAN)))"
    (CL:FUNCTION HELP-COLLECT-SINGLY-BOUND-VARIABLES) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME"
    "(DEFUN CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME ((FRAME CONTROL-FRAME) (DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION CREATE-COLLECT-DESCRIPTION-EXTENSION-FRAME) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-DESCRIPTION-EXTENSION-FRAME?"
    "(DEFUN (COLLECT-DESCRIPTION-EXTENSION-FRAME? BOOLEAN) ((FRAME CONTROL-FRAME)))"
    (CL:FUNCTION COLLECT-DESCRIPTION-EXTENSION-FRAME?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/COLLECT-MEMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/LENGTH-OF-LIST-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/LENGTH-OF-LIST-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/LENGTH-OF-LIST-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/NTH-ELEMENT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/NTH-HEAD-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/NTH-HEAD-COMPUTATION SKOLEM) ((LIST SKOLEM) (NARG INTEGER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/NTH-HEAD-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/NTH-REST-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/NTH-REST-COMPUTATION SKOLEM) ((LIST SKOLEM) (NARG INTEGER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/NTH-REST-COMPUTATION|) NULL)))

(CL:DEFUN HELP-STARTUP-SPECIALISTS5 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION SKOLEM) ((LIST SKOLEM) (NARG INTEGER-WRAPPER) (ELEMENT OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/INSERT-ELEMENT-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MINIMUM-OF-NUMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MAXIMUM-OF-NUMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SUM-OF-NUMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MEAN-OF-NUMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MEDIAN-OF-NUMBERS-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-VARIANCE-OR-STANDARD-DEVIATION"
    "(DEFUN (COMPUTE-VARIANCE-OR-STANDARD-DEVIATION KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD) (STANDARD-DEVIATION? BOOLEAN)))"
    (CL:FUNCTION COMPUTE-VARIANCE-OR-STANDARD-DEVIATION) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/STANDARD-DEVIATION-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/STANDARD-DEVIATION-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STANDARD-DEVIATION-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/VARIANCE-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/VARIANCE-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/VARIANCE-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-DERIVE-PARTITION-MEMBERSHIPS"
    "(DEFUN HELP-DERIVE-PARTITION-MEMBERSHIPS ((SELF LOGIC-OBJECT) (SUPER LOGIC-OBJECT) (TUPLES (LIST OF PROPOSITION))))"
    (CL:FUNCTION HELP-DERIVE-PARTITION-MEMBERSHIPS) NULL)
   (DEFINE-FUNCTION-OBJECT "DERIVE-PARTITION-MEMBERSHIPS?"
    "(DEFUN (DERIVE-PARTITION-MEMBERSHIPS? BOOLEAN) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION DERIVE-PARTITION-MEMBERSHIPS?) NULL)
   (DEFINE-FUNCTION-OBJECT
    " /PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/HAS-PARTITION-MEMBERSHIP-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/REFUTATION-DISJOINT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/EMPTY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/EMPTY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/EMPTY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "EMPTY-TERM?"
    "(DEFUN (EMPTY-TERM? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION EMPTY-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "CHEAP-EMPTY-TERM?"
    "(DEFUN (CHEAP-EMPTY-TERM? BOOLEAN) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION CHEAP-EMPTY-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPENSIVE-EMPTY-TERM?"
    "(DEFUN (EXPENSIVE-EMPTY-TERM? BOOLEAN) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION EXPENSIVE-EMPTY-TERM?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/CONTEXT-OF-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/CONTEXT-OF-COMPUTATION CONTEXT) ((INSTANCE OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/CONTEXT-OF-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/IST-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/IST-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/IST-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-ROLESET-OF"
    "(DEFUN (GET-ROLESET-OF SKOLEM) ((RELATION NAMED-DESCRIPTION) (INSTANCE OBJECT)))"
    (CL:FUNCTION GET-ROLESET-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-STORED-BOUND-ON-ROLESET"
    "(DEFUN (COMPUTE-STORED-BOUND-ON-ROLESET INTEGER) ((RELATION NAMED-DESCRIPTION) (INSTANCE OBJECT) (LOWERORUPPER KEYWORD)))"
    (CL:FUNCTION COMPUTE-STORED-BOUND-ON-ROLESET) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-MINIMUM-CARDINALITY"
    "(DEFUN (COMPUTE-MINIMUM-CARDINALITY INTEGER) ((RELATION NAMED-DESCRIPTION) (INSTANCE OBJECT)))"
    (CL:FUNCTION COMPUTE-MINIMUM-CARDINALITY) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/RANGE-MIN-CARDINALITY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-MAXIMUM-CARDINALITY"
    "(DEFUN (COMPUTE-MAXIMUM-CARDINALITY INTEGER) ((RELATION NAMED-DESCRIPTION) (INSTANCE OBJECT)))"
    (CL:FUNCTION COMPUTE-MAXIMUM-CARDINALITY) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/RANGE-MAX-CARDINALITY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-RANGE-TYPE?"
    "(DEFUN (TEST-RANGE-TYPE? BOOLEAN) ((RELATION NAMED-DESCRIPTION) (INSTANCE OBJECT) (VALUETYPE NAMED-DESCRIPTION)))"
    (CL:FUNCTION TEST-RANGE-TYPE?) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/RANGE-TYPE-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/RANGE-TYPE-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/REFLEXIVE-RELATION-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/REFLEXIVE-RELATION-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/REFLEXIVE-RELATION-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/IRREFLEXIVE-RELATION-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/IRREFLEXIVE-RELATION-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/IRREFLEXIVE-RELATION-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/OBJECT-NAME-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/OBJECT-NAME-COMPUTATION STRING-WRAPPER) ((OBJECTARG OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/OBJECT-NAME-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION OBJECT) ((NAMEARG OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/NAME-TO-OBJECT-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/ARITY-COMPUTATION"
    "(DEFUN (/PL-KERNEL-KB/ARITY-COMPUTATION INTEGER-WRAPPER) ((DESCRIPTIONARG OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/ARITY-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/ARITY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/ARITY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/ARITY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/RELATION-HIERARCHY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-PROJECT-NTH-COLUMN"
    "(DEFUN (HELP-PROJECT-NTH-COLUMN LIST) ((N INTEGER) (TUPLELIST LIST)))"
    (CL:FUNCTION HELP-PROJECT-NTH-COLUMN) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PROJECT-COLUMN-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/ASSERT-SYNONYM-DEMON"
    "(DEFUN /PL-KERNEL-KB/ASSERT-SYNONYM-DEMON ((SELF PROPOSITION)))"
    (CL:FUNCTION |/PL-KERNEL-KB/ASSERT-SYNONYM-DEMON|) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/RETRACT-SYNONYM-DEMON"
    "(DEFUN /PL-KERNEL-KB/RETRACT-SYNONYM-DEMON ((SELF PROPOSITION)))"
    (CL:FUNCTION |/PL-KERNEL-KB/RETRACT-SYNONYM-DEMON|) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-SYNONYMS"
    "(DEFUN (GET-SYNONYMS (CONS OF LOGIC-OBJECT)) ((TERM OBJECT)))"
    (CL:FUNCTION GET-SYNONYMS) NULL)
   (DEFINE-FUNCTION-OBJECT "SYNONYM-SURROGATE?"
    "(DEFUN (SYNONYM-SURROGATE? BOOLEAN) ((NAME SURROGATE)))"
    (CL:FUNCTION SYNONYM-SURROGATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "TRANSFER-SYNONYMS"
    "(DEFUN TRANSFER-SYNONYMS ((OLDOBJECT OBJECT) (NEWOBJECT OBJECT)))"
    (CL:FUNCTION TRANSFER-SYNONYMS) NULL)
   (DEFINE-FUNCTION-OBJECT " /PL-KERNEL-KB/DIFFERENT-SPECIALIST"
    "(DEFUN (/PL-KERNEL-KB/DIFFERENT-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/DIFFERENT-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-NATIVE-SPECIALIST"
    "(DEFUN (LOOKUP-NATIVE-SPECIALIST FUNCTION-CODE) ((NATIVE-NAME STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the native funtion code for `native-name' if it exists
and the underlying programming languages supports such lookups.  Uses the signature
of a specialist function.\")" (CL:FUNCTION LOOKUP-NATIVE-SPECIALIST) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-SPECIALIST-FUNCTION"
    "(DEFUN REGISTER-SPECIALIST-FUNCTION ((NAME STRING) (CODE FUNCTION-CODE)) :DOCUMENTATION \"Creates a registration entry for `name' as a specialist which
executes `code'.  Essentially just builds the Stella meta-information
tructure needed to funcall `name' as a specialist.  The function definition
in `code' needs to accept a CONTROL-FRAME and KEYWORD as arguments and
return a KEYWORD.  Side effects on elements of the proposition in the
control frame can be used to bind and thus return values.\" :PUBLIC? TRUE)"
    (CL:FUNCTION REGISTER-SPECIALIST-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-SPECIALIST-FUNCTION-NAME"
    "(DEFUN REGISTER-SPECIALIST-FUNCTION-NAME ((STELLA-NAME STRING) (NATIVE-NAME STRING)) :PUBLIC? TRUE :COMMAND? TRUE :DOCUMENTATION \"registers a specialist function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages.\")"
    (CL:FUNCTION %REGISTER-SPECIALIST-FUNCTION-NAME)
    (CL:FUNCTION REGISTER-SPECIALIST-FUNCTION-NAME-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "LOOKUP-NATIVE-COMPUTATION"
    "(DEFUN (LOOKUP-NATIVE-COMPUTATION FUNCTION-CODE) ((NATIVE-NAME STRING) (ARITY INTEGER)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the native funtion code for `native-name' if it exists
and the underlying programming languages supports such lookups.  It is looked up
using the signature of a computation function supported by the computation specialist.\")"
    (CL:FUNCTION LOOKUP-NATIVE-COMPUTATION) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-COMPUTATION-FUNCTION"
    "(DEFUN REGISTER-COMPUTATION-FUNCTION ((NAME STRING) (CODE FUNCTION-CODE) (ARITY INTEGER)) :DOCUMENTATION \"Creates a registration entry for `name' as a computation which
executes `code'.  Essentially just builds the Stella meta-information
tructure needed to funcall `name' as a computation function by the
computation specialist.  The function definition in `code' needs to
accept ARITY Stella OBJECTs as arguments and return a Stella OBJECT 
suitable for PowerLoom use.  (These are generally LOGIC-OBJECTs and the
literal wrappers FLOAT-WRAPPER, INTEGER-WRAPPER and STRING-WRAPPER.)\" :PUBLIC? TRUE)"
    (CL:FUNCTION REGISTER-COMPUTATION-FUNCTION) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-COMPUTATION-FUNCTION-NAME"
    "(DEFUN REGISTER-COMPUTATION-FUNCTION-NAME ((STELLA-NAME STRING) (NATIVE-NAME STRING) (ARITY INTEGER)) :PUBLIC? TRUE :COMMAND? TRUE :DOCUMENTATION \"registers a computation function `stella-name' based on the `native-name'
for the particular programming language in question.  Use of this command makes
the resulting code or knowledge bases non-portable to other target languages.\")"
    (CL:FUNCTION %REGISTER-COMPUTATION-FUNCTION-NAME)
    (CL:FUNCTION REGISTER-COMPUTATION-FUNCTION-NAME-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "STARTUP-SPECIALISTS"
    "(DEFUN STARTUP-SPECIALISTS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-SPECIALISTS) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-SPECIALISTS-LOGIC-STARTUP-SPECIALISTS)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
     SYM-SPECIALISTS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupSpecialists") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-SPECIALISTS ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-SPECIALISTS1)
    (HELP-STARTUP-SPECIALISTS2) (HELP-STARTUP-SPECIALISTS3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "COMPUTED-PROCEDURE"
        "(DEFCLASS COMPUTED-PROCEDURE (THING) :PUBLIC? TRUE :DOCUMENTATION \"Each instance denotes a programming language 
function that computes some procedure.  The slot 'procedure-name'
provides the name of the procedure.  The slot 'procedure-code'
points directly to the procedure itself.  Both slots are optional;
if neither is supplied, the procedure will be invoked by extracting
its name from the name of the instance.\" :PUBLIC-SLOTS ((PROCEDURE-NAME :TYPE SYMBOL) (PROCEDURE-CODE :TYPE FUNCTION-CODE)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-COMPUTED-PROCEDURE))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-COMPUTED-PROCEDURE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SUBSTRING-POSITION-ITERATOR"
        "(DEFCLASS SUBSTRING-POSITION-ITERATOR (ITERATOR) :SLOTS ((SUPER-STRING :TYPE STRING :REQUIRED? TRUE) (SUB-STRING :TYPE STRING :REQUIRED? TRUE) (START :TYPE INTEGER :INITIALLY 0) (SUB-LENGTH :TYPE INTEGER :INITIALLY (LENGTH (SUB-STRING SELF)))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SUBSTRING-POSITION-ITERATOR))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SUBSTRING-POSITION-ITERATOR-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORK-PROOF-ADJUNCT"
        "(DEFCLASS FORK-PROOF-ADJUNCT (PROOF-ADJUNCT) :SLOTS ((CONDITION-JUSTIFICATION :TYPE JUSTIFICATION) (DOWN-FRAME :TYPE CONTROL-FRAME)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-FORK-PROOF-ADJUNCT))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-FORK-PROOF-ADJUNCT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
        "SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT"
        "(DEFCLASS SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT (PROOF-ADJUNCT) :SLOTS ((SAVED-INFERENCE-LEVEL :TYPE INFERENCE-LEVEL) (INFERENCE-LEVEL :TYPE INFERENCE-LEVEL) (DOWN-FRAME :TYPE CONTROL-FRAME)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SAVED-INFERENCE-LEVEL-PROOF-ADJUNCT-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "SAVED-CONTEXT-PROOF-ADJUNCT"
        "(DEFCLASS SAVED-CONTEXT-PROOF-ADJUNCT (PROOF-ADJUNCT) :SLOTS ((SAVED-CONTEXT :TYPE CONTEXT) (DOWN-FRAME :TYPE CONTROL-FRAME)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-SAVED-CONTEXT-PROOF-ADJUNCT))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-SAVED-CONTEXT-PROOF-ADJUNCT-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-SPECIALISTS4)
    (HELP-STARTUP-SPECIALISTS5))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-FORK-THEN
     KWD-SPECIALISTS-TECHNICAL "by FORK-introduction of its THEN argument")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-FORK-THEN KWD-SPECIALISTS-LAY
     "since the condition and THEN-clause of a FORK-proposition succeeded")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-FORK-ELSE
     KWD-SPECIALISTS-TECHNICAL "by FORK-introduction of its ELSE argument")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-FORK-ELSE KWD-SPECIALISTS-LAY
     "since the condition and ELSE-clause of a FORK-proposition succeeded")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PROTOTYPE-ID-COUNTER* INTEGER 0)")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-COLLECT-MEMBERS
     KWD-SPECIALISTS-TECHNICAL
     "since it was proven by the COLLECT-MEMBERS specialist")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-COLLECT-MEMBERS
     KWD-SPECIALISTS-LAY
     "because of a specialized COLLECT-MEMBERS reasoning procedure")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-IST-INTRODUCTION
     KWD-SPECIALISTS-TECHNICAL "by IST-Introduction")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-IST-INTRODUCTION
     KWD-SPECIALISTS-LAY "because its argument is true")
    (DEFINE-EXPLANATION-PHRASE KWD-SPECIALISTS-IST-INTRODUCTION
     KWD-SPECIALISTS-LAY "because its argument is partly true"
     KWD-SPECIALISTS-PARTIAL)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ACCELERATE-FRAME-COMPUTATIONS?* BOOLEAN TRUE :DOCUMENTATION \"Used to test how big is the effect of the frame
specialists.\")")
    (REGISTER-NATIVE-NAME
     SYM-SPECIALISTS-LOGIC-REGISTER-SPECIALIST-FUNCTION-NAME
     KWD-SPECIALISTS-COMMON-LISP KWD-SPECIALISTS-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-SPECIALISTS-LOGIC-REGISTER-COMPUTATION-FUNCTION-NAME
     KWD-SPECIALISTS-COMMON-LISP KWD-SPECIALISTS-FUNCTION))))
