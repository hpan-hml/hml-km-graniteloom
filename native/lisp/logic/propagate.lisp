;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; propagate.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2014      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-PROPAGATE-LOGIC-PROPAGATION-ENVIRONMENT NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-EVALUATION-QUEUE NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-EVALUATION-STATES NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-QUEUE NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-SET NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-DEFERRED-DEFAULT-PROPOSITIONS NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-ELABORATED-OBJECTS NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-PROPAGATION-ENVIRONMENT NULL)
(CL:DEFVAR KWD-PROPAGATE-POSTED NULL)
(CL:DEFVAR KWD-PROPAGATE-FORWARD NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-BACKWARD-ONLY? NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-FORWARD-ONLY? NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000 NULL)
(CL:DEFVAR KWD-PROPAGATE-FUNCTION NULL)
(CL:DEFVAR KWD-PROPAGATE-ISA NULL)
(CL:DEFVAR KWD-PROPAGATE-PREDICATE NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-SKOLEM-GENERATION-COUNT NULL)
(CL:DEFVAR KWD-PROPAGATE-PROPAGATE NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-HYPOTHESIZED-INSTANCE? NULL)
(CL:DEFVAR SGT-PROPAGATE-PL-KERNEL-KB-AND NULL)
(CL:DEFVAR KWD-PROPAGATE-GOAL-TREE NULL)
(CL:DEFVAR KWD-PROPAGATE-SINGLETONS? NULL)
(CL:DEFVAR KWD-PROPAGATE-INFERENCE-LEVEL NULL)
(CL:DEFVAR KWD-PROPAGATE-SHALLOW NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-PROPOSITION NULL)
(CL:DEFVAR KWD-PROPAGATE-KB-UPDATE NULL)
(CL:DEFVAR KWD-PROPAGATE-META-KB-UPDATE NULL)
(CL:DEFVAR KWD-PROPAGATE-META NULL)
(CL:DEFVAR SGT-PROPAGATE-STELLA-MODULE NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-DESCRIPTIVE? NULL)
(CL:DEFVAR SGT-PROPAGATE-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-PROPAGATE-STELLA-SYMBOL NULL)
(CL:DEFVAR KWD-PROPAGATE-EVALUATED NULL)
(CL:DEFVAR KWD-PROPAGATE-AND NULL)
(CL:DEFVAR KWD-PROPAGATE-OR NULL)
(CL:DEFVAR KWD-PROPAGATE-NOT NULL)
(CL:DEFVAR KWD-PROPAGATE-EQUIVALENT NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-CULL-CLASH-EXCEPTIONS NULL)
(CL:DEFVAR KWD-PROPAGATE-ELABORATE NULL)
(CL:DEFVAR KWD-PROPAGATE-EXTENSIONAL-ASSERTION NULL)
(CL:DEFVAR SGT-PROPAGATE-PL-KERNEL-KB-INEQUALITY NULL)
(CL:DEFVAR SGT-PROPAGATE-STELLA-SURROGATE NULL)
(CL:DEFVAR KWD-PROPAGATE-EXISTS NULL)
(CL:DEFVAR KWD-PROPAGATE-FORALL NULL)
(CL:DEFVAR SGT-PROPAGATE-PL-KERNEL-KB-EQUIVALENT NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-PROPAGATE-STELLA-SLOT NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-ALL-FACTS-OF NULL)
(CL:DEFVAR KWD-PROPAGATE-COMMON-LISP NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-PRINT-FACTS NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-CALL-ALL-FACTS-OF NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-RETRACT-FACTS-OF NULL)
(CL:DEFVAR SGT-PROPAGATE-PL-KERNEL-KB-PHRASE NULL)
(CL:DEFVAR KWD-PROPAGATE-IMPLIES NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-ALL-SENTENCES-OF NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-ALL-FACTS-OF-N NULL)
(CL:DEFVAR SYM-PROPAGATE-LOGIC-STARTUP-PROPAGATE NULL)
(CL:DEFVAR SYM-PROPAGATE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *PL-KERNEL-MODULE* STANDARD-ERROR
  DEFAULT-FALSE-TRUTH-VALUE *INVISIBLEASSERTION?* *MODULE*
  DEFAULT-TRUE-TRUTH-VALUE *TRACED-KEYWORDS* NULL-INTEGER-WRAPPER
  NULL-INTEGER *MEMOIZATION-ENABLED?* MEMOIZED-NULL-VALUE NIL
  TRUE-WRAPPER FALSE-WRAPPER *CONTEXT* STANDARD-OUTPUT EOL))

;;; (DEFCLASS PROPAGATION-ENVIRONMENT ...)

(CL:DEFCLASS PROPAGATION-ENVIRONMENT (STANDARD-OBJECT)
  ((EVALUATION-QUEUE :ALLOCATION :INSTANCE :ACCESSOR %EVALUATION-QUEUE)
   (EVALUATION-STATES :ALLOCATION :INSTANCE :ACCESSOR
    %EVALUATION-STATES)
   (FORWARD-CHAINING-QUEUE :ALLOCATION :INSTANCE :ACCESSOR
    %FORWARD-CHAINING-QUEUE)
   (FORWARD-CHAINING-SET :ALLOCATION :INSTANCE :ACCESSOR
    %FORWARD-CHAINING-SET)
   (DEFERRED-DEFAULT-PROPOSITIONS :ALLOCATION :INSTANCE :ACCESSOR
    %DEFERRED-DEFAULT-PROPOSITIONS)
   (ELABORATED-OBJECTS :ALLOCATION :INSTANCE :ACCESSOR
    %ELABORATED-OBJECTS)))

(CL:DEFUN NEW-PROPAGATION-ENVIRONMENT ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PROPAGATION-ENVIRONMENT)))
   (CL:SETF (%ELABORATED-OBJECTS SELF) (NEW-HASH-SET))
   (CL:SETF (%DEFERRED-DEFAULT-PROPOSITIONS SELF) (LIST))
   (CL:SETF (%FORWARD-CHAINING-SET SELF) (NEW-HASH-SET))
   (CL:SETF (%FORWARD-CHAINING-QUEUE SELF) (LIST))
   (CL:SETF (%EVALUATION-STATES SELF) (NEW-KEY-VALUE-MAP))
   (CL:SETF (%EVALUATION-QUEUE SELF) (LIST)) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROPAGATION-ENVIRONMENT))
  SGT-PROPAGATE-LOGIC-PROPAGATION-ENVIRONMENT)

(CL:DEFUN ACCESS-PROPAGATION-ENVIRONMENT-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-PROPAGATE-LOGIC-EVALUATION-QUEUE)
    (CL:IF SETVALUE? (CL:SETF (%EVALUATION-QUEUE SELF) VALUE)
     (CL:SETQ VALUE (%EVALUATION-QUEUE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPAGATE-LOGIC-EVALUATION-STATES)
    (CL:IF SETVALUE? (CL:SETF (%EVALUATION-STATES SELF) VALUE)
     (CL:SETQ VALUE (%EVALUATION-STATES SELF))))
   ((CL:EQ SLOTNAME SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-QUEUE)
    (CL:IF SETVALUE? (CL:SETF (%FORWARD-CHAINING-QUEUE SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-CHAINING-QUEUE SELF))))
   ((CL:EQ SLOTNAME SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-SET)
    (CL:IF SETVALUE? (CL:SETF (%FORWARD-CHAINING-SET SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-CHAINING-SET SELF))))
   ((CL:EQ SLOTNAME SYM-PROPAGATE-LOGIC-DEFERRED-DEFAULT-PROPOSITIONS)
    (CL:IF SETVALUE?
     (CL:SETF (%DEFERRED-DEFAULT-PROPOSITIONS SELF) VALUE)
     (CL:SETQ VALUE (%DEFERRED-DEFAULT-PROPOSITIONS SELF))))
   ((CL:EQ SLOTNAME SYM-PROPAGATE-LOGIC-ELABORATED-OBJECTS)
    (CL:IF SETVALUE? (CL:SETF (%ELABORATED-OBJECTS SELF) VALUE)
     (CL:SETQ VALUE (%ELABORATED-OBJECTS SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN PRINT-PROPAGATION-ENVIRONMENT-STATS ...)

(CL:DEFUN PRINT-PROPAGATION-ENVIRONMENT-STATS (SELF)
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:SETQ SELF (GET-PROPAGATION-ENVIRONMENT *CONTEXT*)))
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
   "Propagation environment stats:" EOL)
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "  "
   (LENGTH (%EVALUATION-QUEUE SELF))
   " propositions in evaluation-queue" EOL)
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "  "
   (LENGTH (%FORWARD-CHAINING-SET SELF))
   " propositions in forward-chaining-queue" EOL)
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "  "
   (LENGTH (%ELABORATED-OBJECTS SELF)) " objects elaborated" EOL))

;;; (DEFUN (GET-PROPAGATION-ENVIRONMENT PROPAGATION-ENVIRONMENT) ...)

(CL:DEFUN GET-PROPAGATION-ENVIRONMENT (SELF)
  (CL:LET*
   ((ENVIRONMENT
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPAGATE-LOGIC-PROPAGATION-ENVIRONMENT NULL)))
   (CL:WHEN (CL:EQ ENVIRONMENT NULL)
    (CL:SETQ ENVIRONMENT (NEW-PROPAGATION-ENVIRONMENT))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-PROPAGATE-LOGIC-PROPAGATION-ENVIRONMENT ENVIRONMENT NULL))
   ENVIRONMENT))

;;; (DEFUN UNLINK-PROPAGATION-ENVIRONMENT ...)

(CL:DEFUN UNLINK-PROPAGATION-ENVIRONMENT (SELF)
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
   SYM-PROPAGATE-LOGIC-PROPAGATION-ENVIRONMENT NULL NULL))

;;; (DEFMETHOD DEFER-DEFAULT-PROPOSITION ...)

(CL:DEFMETHOD DEFER-DEFAULT-PROPOSITION ((SELF PROPAGATION-ENVIRONMENT) PROPOSITION)
  (INSERT (%DEFERRED-DEFAULT-PROPOSITIONS SELF) PROPOSITION))

;;; (DEFMETHOD CLEAR-PROPAGATION-QUEUES ...)

(CL:DEFMETHOD CLEAR-PROPAGATION-QUEUES ((SELF PROPAGATION-ENVIRONMENT))
  (CLEAR (%EVALUATION-QUEUE SELF))
  (CLEAR (%FORWARD-CHAINING-QUEUE SELF)))

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF PROPAGATION-ENVIRONMENT))
  (CL:LET* ((COPY (NEW-PROPAGATION-ENVIRONMENT)))
   (CL:SETF (%EVALUATION-QUEUE COPY) (COPY (%EVALUATION-QUEUE SELF)))
   (CL:LET*
    ((PROP NULL) (STATE NULL)
     (ITER-000 (ALLOCATE-ITERATOR (%EVALUATION-STATES SELF))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%KEY ITER-000))
     (CL:SETQ STATE (%VALUE ITER-000))
     (INSERT-AT (%EVALUATION-STATES COPY) PROP STATE)))
   (CL:SETF (%FORWARD-CHAINING-QUEUE COPY)
    (COPY (%FORWARD-CHAINING-QUEUE SELF)))
   (CL:LET*
    ((PROP NULL)
     (ITER-001 (ALLOCATE-ITERATOR (%FORWARD-CHAINING-SET SELF))))
    (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ PROP (%VALUE ITER-001))
     (INSERT (%FORWARD-CHAINING-SET COPY) PROP)))
   (CL:SETF (%DEFERRED-DEFAULT-PROPOSITIONS COPY)
    (COPY (%DEFERRED-DEFAULT-PROPOSITIONS SELF)))
   (CL:LET*
    ((OBJ NULL)
     (ITER-002 (ALLOCATE-ITERATOR (%ELABORATED-OBJECTS SELF))))
    (CL:LOOP WHILE (NEXT? ITER-002) DO (CL:SETQ OBJ (%VALUE ITER-002))
     (INSERT (%ELABORATED-OBJECTS COPY) OBJ)))
   COPY))

;;; (DEFSPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?* ...)

(CL:DEFVAR *FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:NIL
  "True if we are inside of 'react-to-kb-update'.")

;;; (DEFSPECIAL *DEFERINGDEFAULTFORWARDINFERENCES?* ...)

(CL:DEFVAR *DEFERINGDEFAULTFORWARDINFERENCES?* CL:NIL
  "True if we are propagating strict inferences, and
posting derived default propositions to temporary queues.")

;;; (DEFUN (EVALUATION-STATE KEYWORD) ...)

(CL:DEFUN EVALUATION-STATE (PROPOSITION)
  "Return :POSTED if `proposition' is on the evaluation queue
for *context*, :EVALUATED if has been evaluated, or NULL if it has never been evaluated."
  (CL:IF (DESCRIPTION-MODE?) NULL
   (LOOKUP (%EVALUATION-STATES (GET-PROPAGATION-ENVIRONMENT *CONTEXT*))
    PROPOSITION)))

;;; (DEFUN EVALUATION-STATE-SETTER ...)

(CL:DEFUN EVALUATION-STATE-SETTER (PROPOSITION STATE)
  "Record the evaluation `state' of 'proposition'."
  (CL:WHEN (CL:NOT (DESCRIPTION-MODE?))
   (INSERT-AT
    (%EVALUATION-STATES (GET-PROPAGATION-ENVIRONMENT *CONTEXT*))
    PROPOSITION STATE)))

;;; (DEFUN POST-FOR-EVALUATION ...)

(CL:DEFUN POST-FOR-EVALUATION (SELF WORLD)
  "Push 'self' onto the evaluation queue (unless it's already there)."
  (CL:WHEN (CL:EQ WORLD NULL) (CL:SETQ WORLD *CONTEXT*))
  (CL:WHEN (CL:NOT *FILLINGCONSTRAINTPROPAGATIONQUEUES?*)
   (CL:LET* ((*CONTEXT* WORLD) (*MODULE* (%BASE-MODULE *CONTEXT*)))
    (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
    (EVALUATE-PROPOSITION SELF) (CL:RETURN-FROM POST-FOR-EVALUATION)))
  (CL:LET* ((ENVIRONMENT (GET-PROPAGATION-ENVIRONMENT WORLD)))
   (CL:WHEN
    (CL:NOT
     (CL:EQ (LOOKUP (%EVALUATION-STATES ENVIRONMENT) SELF)
      KWD-PROPAGATE-POSTED))
    (INSERT (%EVALUATION-QUEUE ENVIRONMENT) SELF)
    (INSERT-AT (%EVALUATION-STATES ENVIRONMENT) SELF
     KWD-PROPAGATE-POSTED))))

;;; (DEFUN (HELP-COLLECT-FORWARD-RULES (CONS OF KEY-VALUE-LIST)) ...)

(CL:DEFUN HELP-COLLECT-FORWARD-RULES (DESCRIPTION RULES INDICES TOUCHEDDEFAULT? BEENTHERE)
  (CL:WHEN (CL:EQ RULES NULL) (CL:SETQ RULES (NEW-KEY-VALUE-LIST)))
  (CL:WHEN (CL:EQ INDICES NULL) (CL:SETQ INDICES (NEW-KEY-VALUE-LIST)))
  (CL:WHEN (CL:EQ BEENTHERE NULL) (CL:SETQ BEENTHERE (NEW-LIST)))
  (INSERT BEENTHERE DESCRIPTION)
  (CL:LET*
   ((INDEX NULL)
    (ITER-000 (%THE-CONS-LIST (FORWARD-CHAINING-INDICES DESCRIPTION))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ INDEX (%%VALUE ITER-000))
    (CL:WHEN
     (CL:AND (CL:NOT (DELETED? (%MASTER-RULE INDEX)))
      (TRUE? (%MASTER-RULE INDEX)))
     (INSERT-AT INDICES INDEX
      (CL:IF TOUCHEDDEFAULT? TRUE-WRAPPER FALSE-WRAPPER)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET*
   ((P NULL)
    (ITER-001
     (APPLICABLE-RULES-OF-DESCRIPTION DESCRIPTION KWD-PROPAGATE-FORWARD
      CL:T)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
    (CL:SETQ P (%%VALUE ITER-001))
    (CL:WHEN
     (CL:NOT
      (%WRAPPER-VALUE
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS P)
        SYM-PROPAGATE-LOGIC-BACKWARD-ONLY? FALSE-WRAPPER)))
     (CL:LET*
      ((CONSEQUENT
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P)))
         1)))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE CONSEQUENT)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000
          SGT-PROPAGATE-LOGIC-NAMED-DESCRIPTION)
         (CL:PROGN
          (CL:LET* ((SUPER (VALUE-OF CONSEQUENT)))
           (CL:WHEN (DEFAULT-TRUE? P) (CL:SETQ TOUCHEDDEFAULT? CL:T))
           (CL:WHEN
            (CL:OR
             (%WRAPPER-VALUE
              (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS P)
               SYM-PROPAGATE-LOGIC-FORWARD-ONLY? FALSE-WRAPPER))
             (CL:NOT (CL:EQ (CLASS? DESCRIPTION) (CLASS? SUPER))))
            (INSERT-AT RULES P
             (CL:IF TOUCHEDDEFAULT? TRUE-WRAPPER FALSE-WRAPPER)))
           (CL:WHEN (CL:NOT (MEMBER? BEENTHERE SUPER))
            (HELP-COLLECT-FORWARD-RULES SUPER RULES INDICES
             TOUCHEDDEFAULT? BEENTHERE)))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-DESCRIPTION)
         (CL:PROGN
          (INSERT-AT RULES P
           (CL:IF TOUCHEDDEFAULT? TRUE-WRAPPER FALSE-WRAPPER))))
        (CL:T)))))
    (CL:SETQ ITER-001 (%%REST ITER-001))))
  (CONS RULES (CONS INDICES NIL)))

;;; (DEFUN (COLLECT-FORWARD-CHAINING-RULES (KEY-VALUE-LIST OF PROPOSITION BOOLEAN-WRAPPER) (KEY-VALUE-LIST OF FORWARD-CHAINING-INDEX BOOLEAN-WRAPPER)) ...)

(CL:DEFUN COLLECT-FORWARD-CHAINING-RULES (DESCRIPTION)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE-VALUE
      SGT-PROPAGATE-LOGIC-F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-PROPAGATE-LOGIC-F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000
      "(:MAX-VALUES 500 :TIMESTAMPS (:META-KB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE-VALUE
       SGT-PROPAGATE-LOGIC-F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 DESCRIPTION *CONTEXT*
      MEMOIZED-NULL-VALUE NULL -1))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (HELP-COLLECT-FORWARD-RULES DESCRIPTION NULL NULL CL:NIL NULL))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((RULES MEMOIZED-VALUE-000))
    (CL:VALUES (%%VALUE RULES) (%%VALUE (%%REST RULES))))))

;;; (DEFUN (HAS-FORWARD-CHAINING-RULES? BOOLEAN) ...)

(CL:DEFUN HAS-FORWARD-CHAINING-RULES? (DESCRIPTION PROPOSITION)
  (CL:WHEN (FALSE? PROPOSITION)
   (CL:SETQ DESCRIPTION
    (GET-INFERABLE-COMPLEMENT-DESCRIPTION DESCRIPTION))
   (CL:WHEN (CL:EQ DESCRIPTION NULL)
    (CL:RETURN-FROM HAS-FORWARD-CHAINING-RULES? CL:NIL)))
  (CL:LET* ((RULES NULL) (INDICES NULL))
   (CL:MULTIPLE-VALUE-SETQ (RULES INDICES)
    (COLLECT-FORWARD-CHAINING-RULES DESCRIPTION))
   (CL:OR (NON-EMPTY? RULES) (NON-EMPTY? INDICES))))

;;; (DEFUN POST-TO-FORWARD-CHAINING-QUEUE ...)

(CL:DEFUN POST-TO-FORWARD-CHAINING-QUEUE (SELF WORLD)
  (CL:WHEN
   (CL:AND (UNKNOWN? SELF)
    (CL:NOT (CL:EQ (%KIND SELF) KWD-PROPAGATE-FUNCTION)))
   (CL:RETURN-FROM POST-TO-FORWARD-CHAINING-QUEUE))
  (CL:WHEN (CL:EQ WORLD NULL) (CL:SETQ WORLD *CONTEXT*))
  (CL:LET*
   ((ENVIRONMENT (GET-PROPAGATION-ENVIRONMENT WORLD))
    (DESCRIPTION NULL))
   (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-ISA)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-FUNCTION))
      (CL:WHEN (MEMBER? (%FORWARD-CHAINING-SET ENVIRONMENT) SELF)
       (CL:RETURN-FROM POST-TO-FORWARD-CHAINING-QUEUE))
      (CL:SETQ DESCRIPTION (GET-DESCRIPTION (%OPERATOR SELF)))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ DESCRIPTION NULL))
        (HAS-FORWARD-CHAINING-RULES? DESCRIPTION SELF))
       (INSERT (%FORWARD-CHAINING-SET ENVIRONMENT) SELF)
       (INSERT (%FORWARD-CHAINING-QUEUE ENVIRONMENT) SELF)))
     (CL:T)))))

;;; (DEFSPECIAL *COLLECTFORWARDPROPOSITIONS* ...)

(CL:DEFVAR *COLLECTFORWARDPROPOSITIONS* NULL
  "Collect goes-true propositions produced by forward
chaining.")

(CL:DEFMETHOD SKOLEM-GENERATION-COUNT ((SELF SKOLEM))
  (CL:LET*
   ((ANSWER
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-PROPAGATE-LOGIC-SKOLEM-GENERATION-COUNT
       NULL-INTEGER-WRAPPER))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ANSWER))
   (CL:IF (CL:= ANSWER NULL-INTEGER) 0 ANSWER)))

;;; (DEFGLOBAL *MAX-SKOLEM-GENERATION-COUNT* ...)

(CL:DEFVAR *MAX-SKOLEM-GENERATION-COUNT* 3)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *MAX-SKOLEM-GENERATION-COUNT*))

;;; (DEFUN APPLY-RULE-CONSEQUENT-TO-VECTOR ...)

(CL:DEFUN APPLY-RULE-CONSEQUENT-TO-VECTOR (CONSEQUENT ARGUMENTS RULE TRIGGERDESCRIPTION TRIGGERPROPOSITION TOUCHEDDEFAULT? BC-JUSTIFICATION)
  (CL:SETQ TRIGGERDESCRIPTION TRIGGERDESCRIPTION)
  (CL:LET* ((*COLLECTFORWARDPROPOSITIONS* NIL))
   (CL:DECLARE (CL:SPECIAL *COLLECTFORWARDPROPOSITIONS*))
   (CL:LET*
    ((TOUCHEDDEFAULTKNOWLEDGE?
      (CL:OR (DEFAULT-TRUE? TRIGGERPROPOSITION) (DEFAULT-TRUE? RULE)
       TOUCHEDDEFAULT?))
     (SKOLEM NULL) (SKOLEMGENERATIONCOUNT 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM SKOLEMGENERATIONCOUNT))
    (CL:LET*
     ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:WHEN
       (CL:AND (SKOLEM? ARG)
        (CL:> (SKOLEM-GENERATION-COUNT ARG) SKOLEMGENERATIONCOUNT))
       (CL:SETQ SKOLEMGENERATIONCOUNT (SKOLEM-GENERATION-COUNT ARG))
       (CL:WHEN
        (CL:>= SKOLEMGENERATIONCOUNT *MAX-SKOLEM-GENERATION-COUNT*)
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
          (MEMB? *TRACED-KEYWORDS* KWD-PROPAGATE-PROPAGATE))
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
          "*** cutting off forward skolemization on: "
          TRIGGERPROPOSITION EOL))
        (CL:RETURN-FROM APPLY-RULE-CONSEQUENT-TO-VECTOR)))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
    (CL:LET*
     ((*QUERYITERATOR* NULL)
      (*DONT-CHECK-FOR-DUPLICATE-PROPOSITIONS?* CL:NIL))
     (CL:DECLARE
      (CL:SPECIAL *QUERYITERATOR*
       *DONT-CHECK-FOR-DUPLICATE-PROPOSITIONS?*))
     (INHERIT-DESCRIPTION ARGUMENTS CONSEQUENT
      TOUCHEDDEFAULTKNOWLEDGE?))
    (CL:WHEN (TRACE-KEYWORD? KWD-PROPAGATE-PROPAGATE)
     (TRACE-FORWARD-RULE RULE TRIGGERPROPOSITION
      *COLLECTFORWARDPROPOSITIONS*))
    (CL:LET* ((P NULL) (ITER-000 *COLLECTFORWARDPROPOSITIONS*))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ P (%%VALUE ITER-000))
      (CL:LET* ((VALUE-000 NULL))
       (CL:LET*
        ((ARG NULL) (VECTOR-001 (%ARGUMENTS P)) (INDEX-001 0)
         (LENGTH-001 (LENGTH VECTOR-001)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
        (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
           INDEX-001))
         (CL:WHEN (SKOLEM? ARG) (CL:SETQ VALUE-000 ARG) (CL:RETURN))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
       (CL:SETQ SKOLEM VALUE-000))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ SKOLEM NULL))
        (CL:EQ (%DEFINING-PROPOSITION SKOLEM) NULL)
        (CL:NOT
         (%WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SKOLEM)
           SYM-PROPAGATE-LOGIC-HYPOTHESIZED-INSTANCE? FALSE-WRAPPER))))
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SKOLEM)
        SYM-PROPAGATE-LOGIC-SKOLEM-GENERATION-COUNT
        (WRAP-INTEGER
         (MAX (CL:1+ SKOLEMGENERATIONCOUNT)
          (SKOLEM-GENERATION-COUNT SKOLEM)))
        NULL-INTEGER-WRAPPER))
      (RECORD-FORWARD-GOAL RULE ARGUMENTS P)
      (RECORD-FORWARD-JUSTIFICATION (CONS-LIST TRIGGERPROPOSITION) RULE
       ARGUMENTS P BC-JUSTIFICATION)
      (CL:SETQ ITER-000 (%%REST ITER-000)))))))

;;; (DEFUN TRACE-FORWARD-RULE ...)

(CL:DEFUN TRACE-FORWARD-RULE (RULE TRIGGER CONSEQUENTS)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ CONSEQUENTS NULL))
    (CL:NOT (CL:EQ CONSEQUENTS NIL)))
   (CL:LET* ((INDENT 11)) (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "RUNNING FORWARD RULE:" EOL "  TRIGGER: ")
    (PRINT-FORMULA TRIGGER INDENT)
    (CL:WHEN (FALSE? TRIGGER)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) ")"))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL "  RULE:    ")
    (PRINT-FORMULA RULE INDENT)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL "  RESULT:  ")
    (CL:WHEN (CL:NOT (CL:EQ (%%REST CONSEQUENTS) NIL))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "("
      (STRINGIFIED-SURROGATE SGT-PROPAGATE-PL-KERNEL-KB-AND) " ")
     (CL:SETQ INDENT (CL:+ INDENT 5)))
    (CL:LET*
     ((C NULL) (ITER-000 CONSEQUENTS) (I NULL-INTEGER) (ITER-001 1))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ C (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
      (CL:WHEN (CL:> I 1)
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL)
       (CL:LET*
        ((I NULL-INTEGER) (ITER-002 1) (UPPER-BOUND-000 INDENT)
         (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
        (CL:LOOP WHILE
         (CL:OR UNBOUNDED?-000 (CL:<= ITER-002 UPPER-BOUND-000)) DO
         (CL:SETQ I ITER-002) (CL:SETQ I I)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) " ")
         (CL:SETQ ITER-002 (CL:1+ ITER-002)))))
      (PRINT-FORMULA C INDENT) (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (CL:WHEN (CL:NOT (CL:EQ (%%REST CONSEQUENTS) NIL))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) ")")
     (CL:SETQ INDENT (CL:- INDENT 5)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL))))

;;; (DEFUN APPLY-FORWARD-RULES-TO-VECTOR ...)

(CL:DEFUN APPLY-FORWARD-RULES-TO-VECTOR (TRIGGERDESCRIPTION ARGUMENTS TRIGGERPROPOSITION)
  (CL:LET* ((EVALUATEDARGS ARGUMENTS))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:COND
      ((DELETED? ARG) (CL:RETURN-FROM APPLY-FORWARD-RULES-TO-VECTOR))
      ((CL:NOT (EQL? ARG (VALUE-OF ARG)))
       (CL:WHEN (CL:EQ ARGUMENTS EVALUATEDARGS)
        (CL:SETQ EVALUATEDARGS (COPY ARGUMENTS)))
       (CL:LET
        ((SELF (%THE-ARRAY EVALUATEDARGS)) (VALUE (VALUE-OF ARG))
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETQ ARGUMENTS EVALUATEDARGS))
  (CL:LET* ((RULES NULL) (INDICES NULL))
   (CL:MULTIPLE-VALUE-SETQ (RULES INDICES)
    (COLLECT-FORWARD-CHAINING-RULES TRIGGERDESCRIPTION))
   (CL:LET*
    ((R NULL) (TOUCHEDDEFAULT? NULL) (ITER-001 (%THE-KV-LIST RULES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NULL)) DO
     (CL:SETQ R (%KEY ITER-001))
     (CL:SETQ TOUCHEDDEFAULT? (%VALUE ITER-001))
     (CL:WHEN (APPLICABLE-FORWARD-RULE? R ARGUMENTS)
      (APPLY-RULE-CONSEQUENT-TO-VECTOR
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS R)))
        1)
       ARGUMENTS R TRIGGERDESCRIPTION TRIGGERPROPOSITION
       (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN TOUCHEDDEFAULT?) NULL))
     (CL:SETQ ITER-001 (%REST ITER-001))))
   (CL:LET*
    ((FWDINDEX NULL) (TOUCHEDDEFAULT? NULL)
     (ITER-002 (%THE-KV-LIST INDICES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NULL)) DO
     (CL:SETQ FWDINDEX (%KEY ITER-002))
     (CL:SETQ TOUCHEDDEFAULT? (%VALUE ITER-002))
     (CL:TAGBODY
      (CL:LET* ((INPUTARGS NIL))
       (CL:WHEN
        (CL:NOT
         (CL:= (LENGTH ARGUMENTS)
          (LENGTH (%ARGUMENTS (%FORWARD-GOAL FWDINDEX)))))
        (CL:GO :CONTINUE))
       (CL:LET*
        ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
         (LENGTH-001 (LENGTH VECTOR-001)) (GOALARG NULL)
         (VECTOR-002 (%ARGUMENTS (%FORWARD-GOAL FWDINDEX)))
         (INDEX-002 0) (LENGTH-002 (LENGTH VECTOR-002)))
        (CL:DECLARE
         (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 INDEX-002 LENGTH-002))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-001 LENGTH-001)
          (CL:< INDEX-002 LENGTH-002))
         DO
         (CL:SETQ ARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
           INDEX-001))
         (CL:SETQ GOALARG
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
           INDEX-002))
         (CL:COND
          ((VARIABLE? GOALARG)
           (CL:SETQ INPUTARGS (CONS ARG INPUTARGS)))
          ((CL:NOT (EQL? ARG (VALUE-OF GOALARG)))
           (CL:SETQ INPUTARGS NULL) (CL:RETURN)))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
         (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
       (CL:WHEN (CL:EQ INPUTARGS NULL) (CL:GO :CONTINUE))
       (CL:LET*
        ((IT (ALLOCATE-ITERATOR (%INPUT-BINDINGS FWDINDEX))) (ARG NULL)
         (ITER-003 (REVERSE INPUTARGS)))
        (CL:LOOP WHILE
         (CL:AND (NEXT? IT) (CL:NOT (CL:EQ ITER-003 NIL))) DO
         (CL:SETQ ARG (%%VALUE ITER-003)) (CL:PROGN)
         (VALUE-SETTER IT ARG) (CL:SETQ ITER-003 (%%REST ITER-003)))))
      (CL:LET*
       ((OUTPUTBINDINGS NULL) (TRUTHVALUES NULL) (JUSTIFICATIONS NULL)
        (TRACEFORWARDINFERENCE?
         (TRACE-KEYWORD? KWD-PROPAGATE-PROPAGATE))
        (TRACEGOALTREE?
         (CL:AND TRACEFORWARDINFERENCE?
          (TRACE-KEYWORD? KWD-PROPAGATE-GOAL-TREE)))
        (OLDTRACEKEYWORDS *TRACED-KEYWORDS*))
       (CL:COND
        (TRACEFORWARDINFERENCE?
         (CL:WHEN TRACEGOALTREE?
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
           "Proving forward goal: " (%QUERY-BODY FWDINDEX) EOL)))
        ((TRACE-KEYWORD? KWD-PROPAGATE-GOAL-TREE)
         (CL:SETQ *TRACED-KEYWORDS*
          (REMOVE (COPY *TRACED-KEYWORDS*) KWD-PROPAGATE-GOAL-TREE))))
       (CL:LET* ((*FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:T))
        (CL:DECLARE (CL:SPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
        (CL:MULTIPLE-VALUE-SETQ
         (OUTPUTBINDINGS TRUTHVALUES JUSTIFICATIONS)
         (APPLY-CACHED-RETRIEVE (%IO-VARIABLES FWDINDEX)
          (%QUERY-BODY FWDINDEX) (%INPUT-BINDINGS FWDINDEX)
          (CONS-LIST KWD-PROPAGATE-SINGLETONS? FALSE-WRAPPER
           KWD-PROPAGATE-INFERENCE-LEVEL KWD-PROPAGATE-SHALLOW)
          (%CACHE-ID FWDINDEX))))
       (CL:WHEN TRACEGOALTREE?
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
         "Done proving forward goal: " (%QUERY-BODY FWDINDEX) EOL EOL))
       (CL:SETQ *TRACED-KEYWORDS* OLDTRACEKEYWORDS)
       (CL:LET*
        ((OB NULL) (ITER-004 OUTPUTBINDINGS) (TV NULL)
         (ITER-005 TRUTHVALUES))
        (CL:LOOP WHILE
         (CL:AND (CL:NOT (CL:EQ ITER-004 NIL))
          (CL:NOT (CL:EQ ITER-005 NIL)))
         DO (CL:SETQ OB (%%VALUE ITER-004))
         (CL:SETQ TV (%%VALUE ITER-005))
         (CL:LET* ((HEAD-000 (%%VALUE JUSTIFICATIONS)))
          (CL:SETQ JUSTIFICATIONS (%%REST JUSTIFICATIONS))
          (CL:LET* ((JUSTIFICATION HEAD-000))
           (APPLY-RULE-CONSEQUENT-TO-VECTOR (%CONSEQUENT FWDINDEX)
            (COPY-LIST-TO-ARGUMENTS-VECTOR (LISTIFY OB))
            (%MASTER-RULE FWDINDEX) TRIGGERDESCRIPTION
            TRIGGERPROPOSITION
            (CL:OR (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN TOUCHEDDEFAULT?)
             (CL:EQ TV DEFAULT-TRUE-TRUTH-VALUE))
            JUSTIFICATION)))
         (CL:SETQ ITER-004 (%%REST ITER-004))
         (CL:SETQ ITER-005 (%%REST ITER-005)))))
      :CONTINUE)
     (CL:SETQ ITER-002 (%REST ITER-002))))))

;;; (DEFUN (APPLICABLE-FORWARD-RULE? BOOLEAN) ...)

(CL:DEFUN APPLICABLE-FORWARD-RULE? (RULE ARGUMENTS)
  (CL:LET*
   ((ANTECEDENTDESCRIPTION
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS RULE)))
      0)))
   (CL:AND (TRUE? RULE)
    (CL:= (LENGTH ARGUMENTS)
     (LENGTH (%IO-VARIABLES ANTECEDENTDESCRIPTION))))))

;;; (DEFMETHOD REACT-TO-INFERENCE-UPDATE ...)

(CL:DEFMETHOD REACT-TO-INFERENCE-UPDATE ((SELF SKOLEM))
  (CL:LET* ((DERIVEDVALUE (VALUE-OF SELF)) (ASSERTEDVALUE NULL))
   (CL:LET* ((*MODULE* (%BASE-MODULE *CONTEXT*)) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:SETQ ASSERTEDVALUE (VALUE-OF SELF)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ ASSERTEDVALUE NULL))
     (CL:NOT (EQL? ASSERTEDVALUE DERIVEDVALUE)))
    (EQUATE-VALUES NULL (VALUE-OF ASSERTEDVALUE) DERIVEDVALUE))
   (CL:LET*
    ((PROP NULL)
     (ITER-000
      (ALLOCATE-ITERATOR
       (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
     (POST-FOR-EVALUATION PROP *CONTEXT*)))
   (CL:WHEN *FILLINGCONSTRAINTPROPAGATIONQUEUES?*
    (CL:LET* ((DEFININGPROPOSITION (%DEFINING-PROPOSITION SELF)))
     (CL:WHEN (CL:NOT (CL:EQ DEFININGPROPOSITION NULL))
      (POST-TO-FORWARD-CHAINING-QUEUE DEFININGPROPOSITION *CONTEXT*))))))

;;; (DEFMETHOD REACT-TO-INFERENCE-UPDATE ...)

(CL:DEFMETHOD REACT-TO-INFERENCE-UPDATE ((SELF PROPOSITION))
  (POST-FOR-EVALUATION SELF *CONTEXT*)
  (CL:LET*
   ((PROP NULL)
    (ITER-000 (ALLOCATE-ITERATOR (%DEPENDENT-PROPOSITIONS SELF))))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PROP (%VALUE ITER-000))
    (POST-FOR-EVALUATION PROP *CONTEXT*)))
  (CL:WHEN *FILLINGCONSTRAINTPROPAGATIONQUEUES?*
   (POST-TO-FORWARD-CHAINING-QUEUE SELF *CONTEXT*)))

;;; (DEFUN REACT-TO-KB-UPDATE ...)

(CL:DEFUN REACT-TO-KB-UPDATE (CONTEXT OBJECT)
  (CL:LET*
   ((SKOLEM? CL:NIL) (PROPOSITION? CL:NIL) (METAPROPOSITION? CL:NIL))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OBJECT)))
    (CL:COND
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-SKOLEM)
      (CL:PROGN (CL:SETQ SKOLEM? CL:T)))
     ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-PROPOSITION)
      (CL:PROGN (CL:SETQ PROPOSITION? CL:T)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (CL:WHEN (CL:AND PROPOSITION? (META-PROPOSITION? OBJECT))
    (CL:SETQ METAPROPOSITION? CL:T))
   (BUMP-MEMOIZATION-TIMESTAMP KWD-PROPAGATE-KB-UPDATE)
   (CL:WHEN METAPROPOSITION?
    (BUMP-MEMOIZATION-TIMESTAMP KWD-PROPAGATE-META-KB-UPDATE))
   (CL:COND (*INVISIBLEASSERTION?* (CL:RETURN-FROM REACT-TO-KB-UPDATE))
    ((DESCRIPTION-MODE?)
     (CL:LET* ((*FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:NIL))
      (CL:DECLARE (CL:SPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
      (CL:COND (PROPOSITION? (REACT-TO-INFERENCE-UPDATE OBJECT))
       (SKOLEM? (REACT-TO-INFERENCE-UPDATE OBJECT))))
     (CL:RETURN-FROM REACT-TO-KB-UPDATE))
    (*FILLINGCONSTRAINTPROPAGATIONQUEUES?*
     (CL:COND (PROPOSITION? (REACT-TO-INFERENCE-UPDATE OBJECT))
      (SKOLEM? (REACT-TO-INFERENCE-UPDATE OBJECT)))
     (CL:RETURN-FROM REACT-TO-KB-UPDATE)))
   (CL:LET*
    ((WORLD
      (CL:IF METAPROPOSITION?
       (LOOKUP-INFERENCE-CACHE CONTEXT KWD-PROPAGATE-META)
       (LOOKUP-CONSTRAINT-PROPAGATION-WORLD CONTEXT))))
    (CL:WHEN (CL:NOT (CL:EQ WORLD NULL))
     (CL:LET* ((*CONTEXT* WORLD) (*MODULE* (%BASE-MODULE *CONTEXT*)))
      (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
      (CL:LET* ((*FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:T))
       (CL:DECLARE (CL:SPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
       (CL:COND (PROPOSITION? (REACT-TO-INFERENCE-UPDATE OBJECT))
        (SKOLEM? (REACT-TO-INFERENCE-UPDATE OBJECT)))
       (EXECUTE-CONSTRAINT-PROPAGATION-QUEUES)))))
   (CL:WHEN (ISA? CONTEXT SGT-PROPAGATE-STELLA-MODULE)
    (CL:LET*
     ((CHILD NULL)
      (ITER-000 (%THE-CONS-LIST (%CHILD-CONTEXTS CONTEXT))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ CHILD (%%VALUE ITER-000))
      (CL:WHEN (ISA? CHILD SGT-PROPAGATE-STELLA-MODULE)
       (REACT-TO-KB-UPDATE CHILD OBJECT))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))))

;;; (DEFMETHOD EXECUTE-PROPAGATION-QUEUES ...)

(CL:DEFMETHOD EXECUTE-PROPAGATION-QUEUES ((SELF PROPAGATION-ENVIRONMENT))
  (CL:LET* ((*INHIBITOBJECTFINALIZATION?* CL:T))
   (CL:DECLARE (CL:SPECIAL *INHIBITOBJECTFINALIZATION?*))
   (CL:LOOP
    (CL:LET* ((QUEUE (%EVALUATION-QUEUE SELF)))
     (CL:WHEN (NON-EMPTY? QUEUE)
      (CL:SETF (%EVALUATION-QUEUE SELF) (NEW-LIST))
      (CL:LET* ((P NULL) (ITER-000 (%THE-CONS-LIST QUEUE)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ P (%%VALUE ITER-000)) (EVALUATE-PROPOSITION P)
        (CL:SETQ ITER-000 (%%REST ITER-000))))))
    (CL:LET*
     ((QUEUE (%FORWARD-CHAINING-QUEUE SELF)) (DESCRIPTION NULL))
     (CL:WHEN (NON-EMPTY? QUEUE)
      (CL:SETF (%FORWARD-CHAINING-QUEUE SELF) (NEW-LIST))
      (CL:LET* ((PROPOSITION NULL) (ITER-001 (%THE-CONS-LIST QUEUE)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ PROPOSITION (%%VALUE ITER-001)) (CL:PROGN)
        (CL:SETQ DESCRIPTION (GET-DESCRIPTION (%OPERATOR PROPOSITION)))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ DESCRIPTION NULL))
          (FALSE? PROPOSITION))
         (CL:SETQ DESCRIPTION
          (GET-INFERABLE-COMPLEMENT-DESCRIPTION DESCRIPTION)))
        (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
         (APPLY-FORWARD-RULES-TO-VECTOR DESCRIPTION
          (%ARGUMENTS PROPOSITION) PROPOSITION))
        (CL:SETQ ITER-001 (%%REST ITER-001))))))
    (CL:WHEN
     (CL:AND (EMPTY? (%EVALUATION-QUEUE SELF))
      (EMPTY? (%FORWARD-CHAINING-QUEUE SELF)))
     (CL:RETURN-FROM EXECUTE-PROPAGATION-QUEUES)))))

;;; (DEFUN EXECUTE-CONSTRAINT-PROPAGATION-QUEUES ...)

(CL:DEFUN EXECUTE-CONSTRAINT-PROPAGATION-QUEUES ()
  (EXECUTE-PROPAGATION-QUEUES (GET-PROPAGATION-ENVIRONMENT *CONTEXT*)))

;;; (DEFUN EVALUATE-NEW-PROPOSITION ...)

(CL:DEFUN EVALUATE-NEW-PROPOSITION (SELF)
  (CL:WHEN
   (CL:OR (DESCRIPTION-MODE?)
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-PROPAGATE-LOGIC-DESCRIPTIVE? FALSE-WRAPPER)))
   (CL:RETURN-FROM EVALUATE-NEW-PROPOSITION))
  (CL:LET* ((WORLD (LOOKUP-CONSTRAINT-PROPAGATION-WORLD *CONTEXT*)))
   (CL:WHEN (CL:NOT (CL:EQ WORLD NULL))
    (CL:LET* ((*CONTEXT* WORLD)) (CL:DECLARE (CL:SPECIAL *CONTEXT*))
     (EVALUATE-PROPOSITION SELF)
     (CL:WHEN (CL:NOT (UNKNOWN? SELF))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
        (MEMB? *TRACED-KEYWORDS* KWD-PROPAGATE-PROPAGATE))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "evaluate-new-proposition:  " SELF EOL))
      (CL:LET*
       ((PROP NULL)
        (ITER-000 (ALLOCATE-ITERATOR (%DEPENDENT-PROPOSITIONS SELF))))
       (CL:LOOP WHILE (NEXT? ITER-000) DO
        (CL:SETQ PROP (%VALUE ITER-000))
        (EVALUATE-PROPOSITION PROP))))))))

;;; (DEFUN EVALUATE-AND-PROPOSITION ...)

(CL:DEFUN EVALUATE-AND-PROPOSITION (SELF)
  (CL:LET* ((ARGUMENTS (%ARGUMENTS SELF)))
   (CL:COND
    ((TRUE? SELF)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (ASSIGN-TRUTH-VALUE ARG
        (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF)
         CL:NIL))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    ((FALSE? SELF)
     (CL:LET*
      ((ONLYUNBOUNDARG NULL) (TOUCHEDDEFAULT? (DEFAULT-FALSE? SELF)))
      (CL:LET*
       ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:COND
         ((FALSE? ARG) (CL:RETURN-FROM EVALUATE-AND-PROPOSITION))
         ((UNKNOWN? ARG)
          (CL:WHEN (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
           (CL:RETURN-FROM EVALUATE-AND-PROPOSITION))
          (CL:SETQ ONLYUNBOUNDARG ARG))
         ((DEFAULT-TRUE? ARG) (CL:SETQ TOUCHEDDEFAULT? CL:T)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:IF (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
       (ASSIGN-TRUTH-VALUE ONLYUNBOUNDARG
        (DEFAULTIFY-TRUTH-VALUE CL:NIL TOUCHEDDEFAULT?))
       (ASSIGN-TRUTH-VALUE SELF
        (DEFAULTIFY-TRUTH-VALUE CL:T TOUCHEDDEFAULT?)))))
    (CL:T
     (CL:LET* ((UNBOUNDARG? CL:NIL) (TOUCHEDDEFAULT? CL:NIL))
      (CL:LET*
       ((ARG NULL) (VECTOR-002 ARGUMENTS) (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
       (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
          INDEX-002))
        (CL:COND
         ((FALSE? ARG)
          (CL:IF (DEFAULT-FALSE? ARG)
           (ASSIGN-TRUTH-VALUE SELF DEFAULT-FALSE-TRUTH-VALUE)
           (CL:PROGN (ASSIGN-TRUTH-VALUE SELF FALSE-WRAPPER)
            (CL:RETURN-FROM EVALUATE-AND-PROPOSITION))))
         ((UNKNOWN? ARG) (CL:SETQ UNBOUNDARG? CL:T))
         ((DEFAULT-TRUE? ARG) (CL:SETQ TOUCHEDDEFAULT? CL:T)))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
      (CL:WHEN
       (CL:AND (CL:NOT UNBOUNDARG?) (CL:NOT (DEFAULT-FALSE? SELF)))
       (ASSIGN-TRUTH-VALUE SELF
        (DEFAULTIFY-TRUTH-VALUE CL:T TOUCHEDDEFAULT?))))))))

;;; (DEFUN EVALUATE-OR-PROPOSITION ...)

(CL:DEFUN EVALUATE-OR-PROPOSITION (SELF)
  (CL:LET* ((ARGUMENTS (%ARGUMENTS SELF)))
   (CL:COND
    ((FALSE? SELF)
     (CL:LET*
      ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (ASSIGN-TRUTH-VALUE ARG
        (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF)
         CL:NIL))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
    ((TRUE? SELF)
     (CL:LET*
      ((ONLYUNBOUNDARG NULL) (TOUCHEDDEFAULT? (DEFAULT-TRUE? SELF)))
      (CL:LET*
       ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:COND ((TRUE? ARG) (CL:RETURN-FROM EVALUATE-OR-PROPOSITION))
         ((UNKNOWN? ARG)
          (CL:WHEN (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
           (CL:RETURN-FROM EVALUATE-OR-PROPOSITION))
          (CL:SETQ ONLYUNBOUNDARG ARG))
         ((DEFAULT-FALSE? ARG) (CL:SETQ TOUCHEDDEFAULT? CL:T)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
      (CL:IF (CL:NOT (CL:EQ ONLYUNBOUNDARG NULL))
       (ASSIGN-TRUTH-VALUE ONLYUNBOUNDARG
        (DEFAULTIFY-TRUTH-VALUE CL:T TOUCHEDDEFAULT?))
       (ASSIGN-TRUTH-VALUE SELF
        (DEFAULTIFY-TRUTH-VALUE CL:NIL TOUCHEDDEFAULT?)))))
    (CL:T
     (CL:LET* ((UNBOUNDARG? CL:NIL) (TOUCHEDDEFAULT? CL:NIL))
      (CL:LET*
       ((ARG NULL) (VECTOR-002 ARGUMENTS) (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
       (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
          INDEX-002))
        (CL:COND
         ((TRUE? ARG)
          (CL:IF (DEFAULT-TRUE? ARG)
           (ASSIGN-TRUTH-VALUE SELF DEFAULT-TRUE-TRUTH-VALUE)
           (CL:PROGN (ASSIGN-TRUTH-VALUE SELF TRUE-WRAPPER)
            (CL:RETURN-FROM EVALUATE-OR-PROPOSITION))))
         ((UNKNOWN? ARG) (CL:SETQ UNBOUNDARG? CL:T))
         ((DEFAULT-FALSE? ARG) (CL:SETQ TOUCHEDDEFAULT? CL:T)))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002))))
      (CL:WHEN
       (CL:AND (CL:NOT UNBOUNDARG?) (CL:NOT (DEFAULT-TRUE? SELF)))
       (ASSIGN-TRUTH-VALUE SELF
        (DEFAULTIFY-TRUTH-VALUE CL:NIL TOUCHEDDEFAULT?))))))))

;;; (DEFUN EVALUATE-NOT-PROPOSITION ...)

(CL:DEFUN EVALUATE-NOT-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENT
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
      0)))
   (CL:WHEN (CL:OR (TRUE? ARGUMENT) (FALSE? ARGUMENT))
    (ASSIGN-TRUTH-VALUE SELF
     (INVERT-TRUTH-VALUE
      (ACCESS-IN-CONTEXT (%TRUTH-VALUE ARGUMENT)
       (%HOME-CONTEXT ARGUMENT) CL:NIL))))
   (CL:WHEN (CL:OR (TRUE? SELF) (FALSE? SELF))
    (ASSIGN-TRUTH-VALUE ARGUMENT
     (INVERT-TRUTH-VALUE
      (ACCESS-IN-CONTEXT (%TRUTH-VALUE SELF) (%HOME-CONTEXT SELF)
       CL:NIL))))))

;;; (DEFUN EVALUATE-EQUIVALENT-PROPOSITION ...)

(CL:DEFUN EVALUATE-EQUIVALENT-PROPOSITION (SELF)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS SELF))
    (FIRSTARG
     (INNERMOST-OF
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0)))
    (SECONDARG
     (INNERMOST-OF
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1))))
   (CL:COND
    ((TRUE? SELF)
     (CL:WHEN (DEFAULT-TRUE? SELF)
      (CL:WARN
       "INTERNAL ERROR: DON'T KNOW YET HOW TO EQUATE THINGS BY DEFAULT."))
     (CL:LET*
      ((FIRSTARGTYPES (ALL-ASSERTED-TYPES FIRSTARG))
       (SECONDARGTYPES (ALL-ASSERTED-TYPES SECONDARG)))
      (CL:LET* ((TYPE1 NULL) (ITER-000 FIRSTARGTYPES))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ TYPE1 (%%VALUE ITER-000))
        (CL:LET* ((FOUND?-000 CL:NIL))
         (CL:LET* ((TYPE2 NULL) (ITER-001 SECONDARGTYPES))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ TYPE2 (%%VALUE ITER-001))
           (CL:WHEN (DISJOINT-TERMS? TYPE1 TYPE2)
            (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (CL:WHEN FOUND?-000
          (SIGNAL-UNIFICATION-CLASH SELF FIRSTARG SECONDARG)))
        (CL:SETQ ITER-000 (%%REST ITER-000)))))
     (EQUATE-VALUES SELF FIRSTARG SECONDARG))
    ((EQL? FIRSTARG SECONDARG) (ASSIGN-TRUTH-VALUE SELF TRUE-WRAPPER))
    ((CL:AND (CL:NOT (SKOLEM? FIRSTARG)) (CL:NOT (SKOLEM? SECONDARG)))
     (ASSIGN-TRUTH-VALUE SELF FALSE-WRAPPER)))))

;;; (DEFUN EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS ...)

(CL:DEFUN EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS (SELF)
  (CL:LET*
   ((RELATIONREF (%OPERATOR SELF)) (NOFARGS (LENGTH (%ARGUMENTS SELF)))
    (CANDIDATEPROPOSITIONS (NEW-LIST)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFARGS))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-000 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:SETQ I ITER-000)
     (CL:WHEN (CL:NOT (CL:= I NOFARGS))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-SKOLEM)
         (CL:PROGN
          (CL:WHEN
           (CL:AND
            (CL:NOT
             (CL:EQ
              (ACCESS-IN-CONTEXT (%VARIABLE-VALUE ARG)
               (%HOME-CONTEXT ARG) CL:NIL)
              NULL))
            (ISA?
             (ACCESS-IN-CONTEXT (%VARIABLE-VALUE ARG)
              (%HOME-CONTEXT ARG) CL:NIL)
             SGT-PROPAGATE-LOGIC-LOGIC-OBJECT))
           (CL:LET*
            ((PROP NULL)
             (ITER-001
              (ALLOCATE-ITERATOR
               (UNFILTERED-DEPENDENT-PROPOSITIONS
                (ACCESS-IN-CONTEXT (%VARIABLE-VALUE ARG)
                 (%HOME-CONTEXT ARG) CL:NIL)
                RELATIONREF))))
            (CL:LOOP WHILE (NEXT? ITER-001) DO
             (CL:SETQ PROP (%VALUE ITER-001))
             (CL:WHEN
              (CL:AND (CL:EQ (%OPERATOR PROP) RELATIONREF)
               (CL:NOT (CL:EQ PROP SELF)))
              (INSERT-NEW CANDIDATEPROPOSITIONS PROP)))))
          (CL:LET*
           ((INVARG NULL) (ITER-002 (VARIABLE-VALUE-INVERSE ARG)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
            (CL:SETQ INVARG (%%VALUE ITER-002))
            (CL:LET*
             ((PROP NULL)
              (ITER-003
               (ALLOCATE-ITERATOR
                (UNFILTERED-DEPENDENT-PROPOSITIONS INVARG
                 RELATIONREF))))
             (CL:LOOP WHILE (NEXT? ITER-003) DO
              (CL:SETQ PROP (%VALUE ITER-003))
              (CL:WHEN
               (CL:AND (CL:EQ (%OPERATOR PROP) RELATIONREF)
                (CL:NOT (CL:EQ PROP SELF)))
               (INSERT-NEW CANDIDATEPROPOSITIONS PROP))))
            (CL:SETQ ITER-002 (%%REST ITER-002))))))
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-LOGIC-OBJECT)
         (CL:PROGN
          (CL:LET*
           ((INVARG NULL) (ITER-004 (VARIABLE-VALUE-INVERSE ARG)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
            (CL:SETQ INVARG (%%VALUE ITER-004))
            (CL:LET*
             ((PROP NULL)
              (ITER-005
               (ALLOCATE-ITERATOR
                (UNFILTERED-DEPENDENT-PROPOSITIONS INVARG
                 RELATIONREF))))
             (CL:LOOP WHILE (NEXT? ITER-005) DO
              (CL:SETQ PROP (%VALUE ITER-005))
              (CL:WHEN
               (CL:AND (CL:EQ (%OPERATOR PROP) RELATIONREF)
                (CL:NOT (CL:EQ PROP SELF)))
               (INSERT-NEW CANDIDATEPROPOSITIONS PROP))))
            (CL:SETQ ITER-004 (%%REST ITER-004))))))
        (CL:T))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((PROP NULL) (ITER-006 (%THE-CONS-LIST CANDIDATEPROPOSITIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
     (CL:SETQ PROP (%%VALUE ITER-006))
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((ARG1 NULL) (VECTOR-001 (%ARGUMENTS SELF)) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)) (ARG2 NULL)
        (VECTOR-002 (%ARGUMENTS PROP)) (INDEX-002 0)
        (LENGTH-002 (LENGTH VECTOR-002)) (I NULL-INTEGER) (ITER-007 1))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 INDEX-002 LENGTH-002 I
         ITER-007))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-001 LENGTH-001)
         (CL:< INDEX-002 LENGTH-002))
        DO
        (CL:SETQ ARG1
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
          INDEX-001))
        (CL:SETQ ARG2
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002))
          INDEX-002))
        (CL:SETQ I ITER-007)
        (CL:WHEN (CL:NOT (CL:= I NOFARGS))
         (CL:WHEN
          (CL:NOT (EQL? (INNERMOST-OF ARG1) (INNERMOST-OF ARG2)))
          (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN)))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
        (CL:SETQ INDEX-002 (CL:1+ INDEX-002))
        (CL:SETQ ITER-007 (CL:1+ ITER-007))))
      (CL:WHEN ALWAYS?-000
       (EQUATE-VALUES SELF (INNERMOST-OF (LAST (%ARGUMENTS SELF)))
        (INNERMOST-OF (LAST (%ARGUMENTS PROP))))))
     (CL:SETQ ITER-006 (%%REST ITER-006))))
   (FREE CANDIDATEPROPOSITIONS)))

;;; (DEFUN EVALUATE-FUNCTION-PROPOSITION ...)

(CL:DEFUN EVALUATE-FUNCTION-PROPOSITION (SELF)
  (CL:WHEN (ISA? (%OPERATOR SELF) SGT-PROPAGATE-STELLA-SYMBOL)
   (CL:RETURN-FROM EVALUATE-FUNCTION-PROPOSITION))
  (EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS SELF)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR SELF)))
    (COMPUTATION (LOOKUP-CONSTRAINT-FUNCTION DESCRIPTION))
    (STOREDVALUE NULL) (COMPUTEDVALUE NULL) (MISSINGVALUEINDEX -1))
   (CL:DECLARE (CL:TYPE CL:FIXNUM MISSINGVALUEINDEX))
   (CL:WHEN (CL:NOT (CL:EQ COMPUTATION NULL))
    (CL:MULTIPLE-VALUE-SETQ (COMPUTEDVALUE MISSINGVALUEINDEX)
     (COMPUTE-SIMPLE-RELATION-CONSTRAINT SELF COMPUTATION CL:NIL))
    (CL:WHEN (CL:NOT (CL:EQ COMPUTEDVALUE NULL))
     (CL:WHEN (CL:= MISSINGVALUEINDEX -1)
      (ASSIGN-TRUTH-VALUE SELF COMPUTEDVALUE)
      (CL:RETURN-FROM EVALUATE-FUNCTION-PROPOSITION))
     (CL:SETQ STOREDVALUE
      (VALUE-OF
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
        MISSINGVALUEINDEX)))
     (CL:WHEN (CL:NOT (EQL? COMPUTEDVALUE STOREDVALUE))
      (EQUATE-VALUES SELF COMPUTEDVALUE STOREDVALUE)))
    (CL:RETURN-FROM EVALUATE-FUNCTION-PROPOSITION))
   (CL:SETQ COMPUTATION (LOOKUP-COMPUTATION-FUNCTION DESCRIPTION))
   (CL:WHEN (CL:NOT (CL:EQ COMPUTATION NULL))
    (CL:SETQ COMPUTEDVALUE
     (COMPUTE-RELATION-VALUE SELF COMPUTATION CL:NIL))
    (CL:WHEN (CL:NOT (CL:EQ COMPUTEDVALUE NULL))
     (CL:SETQ COMPUTEDVALUE (EVALUATE-TERM COMPUTEDVALUE)))
    (CL:SETQ STOREDVALUE
     (VALUE-OF
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
       (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS SELF)))))))
    (CL:WHEN
     (CL:AND (CL:NOT (EQL? COMPUTEDVALUE STOREDVALUE))
      (CL:NOT (CL:EQ COMPUTEDVALUE NULL)))
     (EQUATE-VALUES SELF COMPUTEDVALUE STOREDVALUE)))))

;;; (DEFUN EVALUATE-PREDICATE-PROPOSITION ...)

(CL:DEFUN EVALUATE-PREDICATE-PROPOSITION (SELF)
  (CL:LET*
   ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR SELF)))
    (COMPUTATION (LOOKUP-CONSTRAINT-FUNCTION DESCRIPTION))
    (SUCCESS? CL:NIL))
   (CL:WHEN (CL:NOT (CL:EQ COMPUTATION NULL))
    (CL:SETQ SUCCESS?
     (EQL? (COMPUTE-SIMPLE-RELATION-CONSTRAINT SELF COMPUTATION CL:NIL)
      TRUE-WRAPPER))
    (ASSIGN-TRUTH-VALUE SELF
     (CL:IF SUCCESS? TRUE-WRAPPER FALSE-WRAPPER))
    (CL:RETURN-FROM EVALUATE-PREDICATE-PROPOSITION))
   (CL:SETQ COMPUTATION (LOOKUP-COMPUTATION-FUNCTION DESCRIPTION))
   (CL:WHEN (CL:NOT (CL:EQ COMPUTATION NULL))
    (CL:SETQ SUCCESS?
     (EQL? (COMPUTE-RELATION-VALUE SELF COMPUTATION CL:NIL)
      TRUE-WRAPPER))
    (ASSIGN-TRUTH-VALUE SELF
     (CL:IF SUCCESS? TRUE-WRAPPER FALSE-WRAPPER)))))

;;; (DEFUN EVALUATE-PROPOSITION ...)

(CL:DEFUN EVALUATE-PROPOSITION (SELF)
  "Evaluate 'self' against its arguments, possibly resulting in
the setting or changing of its truth value."
  (EVALUATION-STATE-SETTER SELF KWD-PROPAGATE-EVALUATED)
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-AND)
     (EVALUATE-AND-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-OR)
     (EVALUATE-OR-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-NOT)
     (EVALUATE-NOT-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-EQUIVALENT)
     (EVALUATE-EQUIVALENT-PROPOSITION SELF))
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-ISA))
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-PREDICATE))
     (CL:LET*
      ((DESCRIPTION (GET-DESCRIPTION (%OPERATOR SELF)))
       (EVALUATOR (LOOKUP-EVALUATOR DESCRIPTION)))
      (CL:COND
       ((CL:NOT (CL:EQ EVALUATOR NULL)) (CL:FUNCALL EVALUATOR SELF))
       ((CL:EQ (%KIND SELF) KWD-PROPAGATE-PREDICATE)
        (EVALUATE-PREDICATE-PROPOSITION SELF))
       (CL:T (EVALUATE-FUNCTION-PROPOSITION SELF)))))
    (CL:T))))

;;; (DEFMETHOD MARK-AS-INCOHERENT ...)

(CL:DEFMETHOD MARK-AS-INCOHERENT ((SELF LOGIC-OBJECT)))

;;; (DEFMETHOD MARK-AS-INCOHERENT ...)

(CL:DEFMETHOD MARK-AS-INCOHERENT ((SELF SKOLEM))
  (CL:WHEN (CL:NOT (CL:EQ (%DEFINING-PROPOSITION SELF) NULL))
   (CL:LET*
    ((FIRSTARG
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR
        (%THE-ARRAY (%ARGUMENTS (%DEFINING-PROPOSITION SELF))))
       0)))
    (CL:COND
     ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE FIRSTARG)
       SGT-PROPAGATE-LOGIC-LOGIC-OBJECT)
      (CL:PROGN (MARK-AS-INCOHERENT FIRSTARG) NULL))
     (CL:T)))))

;;; (DEFGLOBAL *JUST-IN-TIME-FORWARD-INFERENCE?* ...)

(CL:DEFVAR *JUST-IN-TIME-FORWARD-INFERENCE?* CL:T
  "If TRUE, ensures that forward propagation has
been applied to each instance 'touched' during a query.")

;;; (DEFGLOBAL *CLASH-EXCEPTIONS* ...)

(CL:DEFVAR *CLASH-EXCEPTIONS* NULL
  "Collects clash exceptions that occur during inference.")

;;; (DEFUN RESET-CLASH-EXCEPTIONS ...)

(CL:DEFUN RESET-CLASH-EXCEPTIONS ()
  "Resets the collection of clash exceptions"
  (CL:SETQ *CLASH-EXCEPTIONS* (NEW-LIST)))

;;; (DEFUN (EXCEPTION-RECORD-MATCHES-CONTEXT? BOOLEAN) ...)

(CL:DEFUN EXCEPTION-RECORD-MATCHES-CONTEXT? (RECORD)
  (CL:EQ (%CONTEXT RECORD) *CONTEXT*))

;;; (DEFUN CULL-CLASH-EXCEPTIONS ...)

(CL:DEFUN CULL-CLASH-EXCEPTIONS (SELF)
  (CL:LET* ((*CONTEXT* SELF) (*MODULE* (%BASE-MODULE *CONTEXT*)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
   (REMOVE-IF *CLASH-EXCEPTIONS*
    (CL:FUNCTION EXCEPTION-RECORD-MATCHES-CONTEXT?))))

;;; (DEFUN RECURSIVELY-REACT-TO-INFERENCE-UPDATE ...)

(CL:DEFUN RECURSIVELY-REACT-TO-INFERENCE-UPDATE (SELF)
  (REACT-TO-INFERENCE-UPDATE SELF)
  (CL:LET*
   ((ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
      INDEX-000))
    (CL:WHEN (ISA? ARG SGT-PROPAGATE-LOGIC-PROPOSITION)
     (RECURSIVELY-REACT-TO-INFERENCE-UPDATE ARG))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))

;;; (DEFUN ELABORATE-META-INSTANCE ...)

(CL:DEFUN ELABORATE-META-INSTANCE (SELF)
  (CL:LET*
   ((WORLDSTATE (GET-WORLD-STATE *CONTEXT*))
    (METAWORLD (GET-INFERENCE-CACHE WORLDSTATE KWD-PROPAGATE-META)))
   (CL:LET* ((*CONTEXT* METAWORLD)) (CL:DECLARE (CL:SPECIAL *CONTEXT*))
    (ELABORATE-INSTANCE SELF))))

;;; (DEFUN ELABORATE-INSTANCE ...)

(CL:DEFUN ELABORATE-INSTANCE (SELF)
  (CL:WHEN *FILLINGCONSTRAINTPROPAGATIONQUEUES?*
   (CL:RETURN-FROM ELABORATE-INSTANCE))
  (CL:WHEN *JUST-IN-TIME-FORWARD-INFERENCE?*
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
      SGT-PROPAGATE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:LET* ((ENVIRONMENT (GET-PROPAGATION-ENVIRONMENT *CONTEXT*)))
       (CL:WHEN (MEMBER? (%ELABORATED-OBJECTS ENVIRONMENT) SELF)
        (CL:RETURN-FROM ELABORATE-INSTANCE))
       (CL:WHEN
        (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
         (MEMB? *TRACED-KEYWORDS* KWD-PROPAGATE-ELABORATE))
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
         " ELABORATING:  " SELF " in world " *CONTEXT* EOL))
       (CL:LET*
        ((*EVALUATIONMODE* KWD-PROPAGATE-EXTENSIONAL-ASSERTION)
         (*INHIBITOBJECTFINALIZATION?* CL:T) (*QUERYITERATOR* NULL))
        (CL:DECLARE
         (CL:SPECIAL *EVALUATIONMODE* *INHIBITOBJECTFINALIZATION?*
          *QUERYITERATOR*))
        (CL:HANDLER-CASE
         (CL:PROGN
          (CL:LET* ((*FILLINGCONSTRAINTPROPAGATIONQUEUES?* CL:T))
           (CL:DECLARE
            (CL:SPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?*))
           (POST-RELATED-FACTS SELF ENVIRONMENT)
           (EVALUATE-REACHABLE-INEQUALITIES SELF (LIST))
           (CL:LET* ((*DEFERINGDEFAULTFORWARDINFERENCES?* CL:T))
            (CL:DECLARE
             (CL:SPECIAL *DEFERINGDEFAULTFORWARDINFERENCES?*))
            (EXECUTE-CONSTRAINT-PROPAGATION-QUEUES))
           (CL:LET*
            ((P NULL)
             (ITER-000
              (%THE-CONS-LIST
               (%DEFERRED-DEFAULT-PROPOSITIONS ENVIRONMENT))))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
             (CL:SETQ P (%%VALUE ITER-000))
             (ASSIGN-TRUTH-VALUE P DEFAULT-TRUE-TRUTH-VALUE)
             (CL:SETQ ITER-000 (%%REST ITER-000))))
           (CLEAR (%DEFERRED-DEFAULT-PROPOSITIONS ENVIRONMENT))
           (EXECUTE-CONSTRAINT-PROPAGATION-QUEUES)))
         (CLASH (E)
          (CL:LET* ((SELF-000 (NEW-EXCEPTION-RECORD)))
           (CL:SETF (%EXCEPTION SELF-000) E)
           (CL:SETF (%CONTEXT SELF-000) *CONTEXT*)
           (CL:SETF (%MODULE SELF-000) *MODULE*)
           (PUSH *CLASH-EXCEPTIONS* SELF-000))
          (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
           (EXCEPTION-MESSAGE E) EOL)))))))
    (CL:T))))

;;; (DEFUN EVALUATE-REACHABLE-INEQUALITIES ...)

(CL:DEFUN EVALUATE-REACHABLE-INEQUALITIES (SELF VISITEDLIST)
  (CL:LET*
   ((P NULL)
    (ITER-000
     (ALL-TRUE-DEPENDENT-PROPOSITIONS SELF
      SGT-PROPAGATE-PL-KERNEL-KB-INEQUALITY CL:T)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
    (POST-FOR-EVALUATION P *CONTEXT*) (PUSH VISITEDLIST SELF)
    (CL:LET*
     ((ARG NULL) (VECTOR-000 (%ARGUMENTS P)) (INDEX-000 0)
      (LENGTH-000 (LENGTH VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ ARG
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
        INDEX-000))
      (CL:WHEN
       (CL:AND (CL:NOT (MEMBER? VISITEDLIST ARG))
        (ISA? ARG SGT-PROPAGATE-LOGIC-LOGIC-OBJECT))
       (EVALUATE-REACHABLE-INEQUALITIES ARG VISITEDLIST))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))))

;;; (DEFUN ELABORATE-SURROGATES-IN-PROPOSITION ...)

(CL:DEFUN ELABORATE-SURROGATES-IN-PROPOSITION (PROPOSITION)
  (CL:WHEN *JUST-IN-TIME-FORWARD-INFERENCE?*
   (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-PREDICATE)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-FUNCTION)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-ISA))
      (ELABORATE-META-INSTANCE
       (GET-DESCRIPTION (%OPERATOR PROPOSITION)))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:WHEN (ISA? ARG SGT-PROPAGATE-STELLA-SURROGATE)
         (CL:LET* ((VALUE (VALUE-OF ARG)))
          (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
           (ELABORATE-INSTANCE VALUE))))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000)))))
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-AND)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-OR)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-NOT)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-EXISTS)
       (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-FORALL))
      (CL:LET*
       ((P NULL) (VECTOR-001 (%ARGUMENTS PROPOSITION)) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
       (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
        (CL:SETQ P
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
          INDEX-001))
        (ELABORATE-SURROGATES-IN-PROPOSITION P)
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
     (CL:T)))))

;;; (DEFUN (FOLLOW-DEPENDENT-PROPOSITION-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN FOLLOW-DEPENDENT-PROPOSITION-ARGUMENT? (PROPOSITION ARGUMENT)
  (CL:WHEN (CL:EQ (%KIND PROPOSITION) KWD-PROPAGATE-EQUIVALENT)
   (CL:RETURN-FROM FOLLOW-DEPENDENT-PROPOSITION-ARGUMENT? CL:T))
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARGUMENT)
     SGT-PROPAGATE-LOGIC-SKOLEM)
    (CL:PROGN
     (CL:WHEN (FUNCTION-OUTPUT-SKOLEM? ARGUMENT)
      (CL:RETURN-FROM FOLLOW-DEPENDENT-PROPOSITION-ARGUMENT? CL:T))
     (CL:LET* ((RELATION (GET-DESCRIPTION (%OPERATOR PROPOSITION))))
      (CL:WHEN (CL:NOT (CL:EQ RELATION NULL))
       (CL:WHEN (COMPUTED-TERM? RELATION)
        (CL:RETURN-FROM FOLLOW-DEPENDENT-PROPOSITION-ARGUMENT? CL:T))))
     (CL:RETURN-FROM FOLLOW-DEPENDENT-PROPOSITION-ARGUMENT?
      (CL:NOT
       (EMPTY?
        (UNFILTERED-DEPENDENT-PROPOSITIONS ARGUMENT
         SGT-PROPAGATE-PL-KERNEL-KB-EQUIVALENT))))))
   (CL:T))
  CL:NIL)

;;; (DEFUN (DO-NOT-ELABORATE? BOOLEAN) ...)

(CL:DEFUN DO-NOT-ELABORATE? (SELF ENVIRONMENT)
  (CL:SETQ ENVIRONMENT ENVIRONMENT)
  (CL:LET*
   ((DONOTELABORATESURROGATE
     (LOOKUP-SURROGATE-IN-MODULE "DO-NOT-ELABORATE" *PL-KERNEL-MODULE*
      CL:NIL)))
   (CL:AND (CL:NOT (CL:EQ DONOTELABORATESURROGATE NULL))
    (TEST-ISA? SELF DONOTELABORATESURROGATE))))

;;; (DEFUN POST-RELATED-FACTS ...)

(CL:DEFUN POST-RELATED-FACTS (SELF ENVIRONMENT)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:WHEN (MEMBER? (%ELABORATED-OBJECTS ENVIRONMENT) SELF)
       (CL:RETURN-FROM POST-RELATED-FACTS))
      (INSERT (%ELABORATED-OBJECTS ENVIRONMENT) SELF)
      (CL:WHEN (DO-NOT-ELABORATE? SELF ENVIRONMENT)
       (CL:RETURN-FROM POST-RELATED-FACTS))
      (CL:LET*
       ((P NULL)
        (ITER-000
         (ALLOCATE-ITERATOR
          (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))))
       (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
        (POST-RELATED-FACTS P ENVIRONMENT)
        (CL:LET*
         ((ARG NULL) (VECTOR-000 (%ARGUMENTS P)) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ ARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:WHEN
           (CL:AND (CL:NOT (CL:EQ ARG SELF))
            (FOLLOW-DEPENDENT-PROPOSITION-ARGUMENT? P ARG))
           (POST-RELATED-FACTS ARG ENVIRONMENT))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))))
      (CL:LET*
       ((EQUIVALENT NULL) (ITER-001 (VARIABLE-VALUE-INVERSE SELF)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ EQUIVALENT (%%VALUE ITER-001))
        (POST-RELATED-FACTS EQUIVALENT ENVIRONMENT)
        (CL:SETQ ITER-001 (%%REST ITER-001))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:WHEN
       (CL:NOT
        (CL:EQ (LOOKUP (%EVALUATION-STATES ENVIRONMENT) SELF) NULL))
       (CL:RETURN-FROM POST-RELATED-FACTS))
      (CL:LET*
       ((ASSERTED? (CL:NOT (UNKNOWN? SELF))) (OUTPUTSKOLEM NULL))
       (CL:WHEN
        (CL:AND (CL:NOT ASSERTED?)
         (CL:EQ (%KIND SELF) KWD-PROPAGATE-FUNCTION))
        (CL:SETQ ASSERTED? (FUNCTION-WITH-DEFINED-VALUE? SELF)))
       (CL:WHEN ASSERTED? (RECURSIVELY-REACT-TO-INFERENCE-UPDATE SELF))
       (CL:LET*
        ((P NULL)
         (ITER-002 (ALLOCATE-ITERATOR (%DEPENDENT-PROPOSITIONS SELF))))
        (CL:LOOP WHILE (NEXT? ITER-002) DO
         (CL:SETQ P (%VALUE ITER-002))
         (POST-RELATED-FACTS P ENVIRONMENT))))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE-VALUE SELF) NULL))
       (POST-RELATED-FACTS (%SURROGATE-VALUE SELF) ENVIRONMENT))))
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
          SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
         NULL))
       (POST-RELATED-FACTS
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
        ENVIRONMENT))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-STELLA-SLOT)
     (CL:PROGN
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
          SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
         NULL))
       (POST-RELATED-FACTS
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
        ENVIRONMENT))))
    (CL:T))))

;;; (DEFUN HELP-COLLECT-FACTS ...)

(CL:DEFUN HELP-COLLECT-FACTS (SELF FACTS BEENTHERE INCLUDEUNKNOWN?)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (CL:IF (MEMBER? BEENTHERE SELF)
       (CL:RETURN-FROM HELP-COLLECT-FACTS) (INSERT BEENTHERE SELF))
      (CL:LET*
       ((P NULL)
        (ITER-000
         (ALLOCATE-ITERATOR
          (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))))
       (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
        (HELP-COLLECT-FACTS P FACTS BEENTHERE INCLUDEUNKNOWN?)))
      (CL:LET*
       ((EQUIVALENT NULL) (ITER-001 (VARIABLE-VALUE-INVERSE SELF)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ EQUIVALENT (%%VALUE ITER-001))
        (HELP-COLLECT-FACTS EQUIVALENT FACTS BEENTHERE INCLUDEUNKNOWN?)
        (CL:SETQ ITER-001 (%%REST ITER-001))))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-LOGIC-PROPOSITION)
     (CL:PROGN
      (CL:IF (MEMBER? BEENTHERE SELF)
       (CL:RETURN-FROM HELP-COLLECT-FACTS) (INSERT BEENTHERE SELF))
      (CL:LET*
       ((ASSERTED? (CL:OR INCLUDEUNKNOWN? (CL:NOT (UNKNOWN? SELF))))
        (OUTPUTSKOLEM NULL))
       (CL:WHEN
        (CL:AND (CL:NOT ASSERTED?)
         (CL:EQ (%KIND SELF) KWD-PROPAGATE-FUNCTION))
        (CL:SETQ OUTPUTSKOLEM
         (CL:AREF
          (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
          (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS SELF))))))
        (CL:SETQ ASSERTED?
         (CL:NOT (CL:EQ OUTPUTSKOLEM (VALUE-OF OUTPUTSKOLEM)))))
       (CL:WHEN ASSERTED? (INSERT FACTS SELF))
       (CL:LET*
        ((P NULL)
         (ITER-002 (ALLOCATE-ITERATOR (%DEPENDENT-PROPOSITIONS SELF))))
        (CL:LOOP WHILE (NEXT? ITER-002) DO
         (CL:SETQ P (%VALUE ITER-002))
         (HELP-COLLECT-FACTS P FACTS BEENTHERE INCLUDEUNKNOWN?))))))
    ((SUBTYPE-OF-SURROGATE? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN (CL:NOT (CL:EQ (%SURROGATE-VALUE SELF) NULL))
       (HELP-COLLECT-FACTS (%SURROGATE-VALUE SELF) FACTS BEENTHERE
        INCLUDEUNKNOWN?))))
    ((SUBTYPE-OF-CLASS? TEST-VALUE-000)
     (CL:PROGN
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
          SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
         NULL))
       (HELP-COLLECT-FACTS
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
        FACTS BEENTHERE INCLUDEUNKNOWN?))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-PROPAGATE-STELLA-SLOT)
     (CL:PROGN
      (CL:WHEN
       (CL:NOT
        (CL:EQ
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
          SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
         NULL))
       (HELP-COLLECT-FACTS
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-PROPAGATE-LOGIC-DESCRIPTION NULL)
        FACTS BEENTHERE INCLUDEUNKNOWN?))))
    (CL:T))))

;;; (DEFUN (ALL-FACTS-OF-INSTANCE (LIST OF PROPOSITION)) ...)

(CL:DEFUN ALL-FACTS-OF-INSTANCE (SELF INCLUDEUNKNOWNFACTS? ELABORATE?)
  "Return a list of all definite (TRUE or FALSE) propositions
attached to `self'."
  (CL:LET* ((FACTS (NEW-LIST)))
   (CL:LET*
    ((*CONTEXT* (GET-QUERY-CONTEXT))
     (*MODULE* (%BASE-MODULE *CONTEXT*)))
    (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
    (CL:WHEN ELABORATE? (ELABORATE-INSTANCE SELF))
    (HELP-COLLECT-FACTS SELF FACTS (NEW-HASH-SET)
     INCLUDEUNKNOWNFACTS?))
   FACTS))

;;; (DEFUN (ALL-FACTS-OF (CONS OF PROPOSITION)) ...)

(CL:DEFUN %ALL-FACTS-OF (INSTANCEREF)
  "Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'.  This includes propositions
asserted to be true by default, but it does not include propositions
that are found to be TRUE only by running the query engine.  Facts
inferred to be TRUE by the forward chainer will be included.
Hence, the returned list of facts may be longer in a context where the
forward chainer has been run then in one where it has not (see
`run-forward-rules').  `instanceRef' can be a regular name such as
`fred' as well as a function term such as `(father fred)'."
  (CL:LET* ((INSTANCE (COERCE-TO-INSTANCE INSTANCEREF NULL)))
   (CL:IF (CL:NOT (CL:EQ INSTANCE NULL))
    (%THE-CONS-LIST (ALL-FACTS-OF-INSTANCE INSTANCE CL:NIL CL:T)) NULL)))

(CL:DEFMACRO ALL-FACTS-OF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'.  This includes propositions
asserted to be true by default, but it does not include propositions
that are found to be TRUE only by running the query engine.  Facts
inferred to be TRUE by the forward chainer will be included.
Hence, the returned list of facts may be longer in a context where the
forward chainer has been run then in one where it has not (see
`run-forward-rules').  `instanceRef' can be a regular name such as
`fred' as well as a function term such as `(father fred)'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ALL-FACTS-OF|)) (CL:MACRO-FUNCTION (CL:QUOTE ALL-FACTS-OF)))

;;; (DEFUN PRINT-FACTS ...)

(CL:DEFUN %PRINT-FACTS (INSTANCEREF)
  "Like `all-facts-of', but sorts and prints each fact
on a separate line on the standard output stream."
  (CL:LET* ((INSTANCE (COERCE-TO-INSTANCE INSTANCEREF NULL)))
   (CL:LET*
    ((FACT NULL)
     (ITER-000
      (%THE-CONS-LIST
       (SORT (ALL-FACTS-OF-INSTANCE INSTANCE CL:NIL CL:NIL)
        (CL:FUNCTION PROPOSITION-LESS-THAN?)))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ FACT (%%VALUE ITER-000))
     (PRETTY-PRINT-LOGICAL-FORM FACT STANDARD-OUTPUT)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL)
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

(CL:DEFMACRO PRINT-FACTS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Like `all-facts-of', but sorts and prints each fact
on a separate line on the standard output stream."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/PRINT-FACTS|)) (CL:MACRO-FUNCTION (CL:QUOTE PRINT-FACTS)))

;;; (DEFUN (CALL-ALL-FACTS-OF (LIST OF PROPOSITION)) ...)

(CL:DEFUN %CALL-ALL-FACTS-OF (INSTANCEREF)
  "Return a list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'."
  (CL:LET* ((INSTANCE (COERCE-TO-INSTANCE INSTANCEREF NULL)))
   (CL:IF (CL:NOT (CL:EQ INSTANCE NULL))
    (ALL-FACTS-OF-INSTANCE INSTANCE CL:NIL CL:T) NULL)))

(CL:DEFMACRO CALL-ALL-FACTS-OF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Return a list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/CALL-ALL-FACTS-OF|)) (CL:MACRO-FUNCTION (CL:QUOTE CALL-ALL-FACTS-OF)))

;;; (DEFUN RETRACT-FACTS-OF-INSTANCE ...)

(CL:DEFUN RETRACT-FACTS-OF-INSTANCE (SELF)
  "Retract all definite (TRUE or FALSE) propositions attached to `self'."
  (CL:WHEN (CL:EQ SELF NULL) (CL:RETURN-FROM RETRACT-FACTS-OF-INSTANCE))
  (CL:LET*
   ((P NULL)
    (ITER-000
     (%THE-CONS-LIST (ALL-FACTS-OF-INSTANCE SELF CL:NIL CL:T))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ P (%%VALUE ITER-000))
    (CL:TAGBODY
     (CL:COND
      ((CL:EQ (%KIND P) KWD-PROPAGATE-FUNCTION)
       (CL:LET* ((SKOLEM (LAST (%ARGUMENTS P))))
        (CL:WHEN (CL:EQ SKOLEM SELF) (CL:GO :CONTINUE))
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ SKOLEM NULL))
          (CL:NOT
           (CL:EQ
            (ACCESS-IN-CONTEXT (%VARIABLE-VALUE SKOLEM)
             (%HOME-CONTEXT SKOLEM) CL:NIL)
            NULL)))
         (UNASSERT-PROPOSITION P))
        (RETRACT-FACTS-OF-INSTANCE SKOLEM)))
      (CL:T (UNASSERT-PROPOSITION P)))
     :CONTINUE)
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN RETRACT-FACTS-OF ...)

(CL:DEFUN %RETRACT-FACTS-OF (INSTANCEREF)
  "Retract all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'."
  (CL:LET* ((INSTANCE (COERCE-TO-INSTANCE INSTANCEREF NULL)))
   (CL:WHEN (CL:NOT (CL:EQ INSTANCE NULL))
    (RETRACT-FACTS-OF-INSTANCE INSTANCE))))

(CL:DEFMACRO RETRACT-FACTS-OF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Retract all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/RETRACT-FACTS-OF|)) (CL:MACRO-FUNCTION (CL:QUOTE RETRACT-FACTS-OF)))

;;; (DEFUN (EXPLODE-VARIABLIZED-STRING LIST) ...)

(CL:DEFUN EXPLODE-VARIABLIZED-STRING (STRING)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRING))
  #+MCL
  (CL:CHECK-TYPE STRING CL:SIMPLE-STRING)
  (CL:LET*
   ((LIST (NEW-LIST))
    (ENDOFSTRING (CL:THE CL:FIXNUM (CL:LENGTH STRING))) (BEGIN 0)
    (END NULL-INTEGER) (SUBSTRING STELLA::NULL-STRING) (SYMBOL NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ENDOFSTRING BEGIN END)
    (CL:TYPE CL:SIMPLE-STRING SUBSTRING))
   (CL:LOOP
    (CL:WHEN (CL:>= BEGIN ENDOFSTRING)
     (CL:RETURN-FROM EXPLODE-VARIABLIZED-STRING LIST))
    (CL:SETQ END (POSITION STRING #\? BEGIN))
    (CL:COND
     ((CL:= END NULL-INTEGER)
      (CL:SETQ SUBSTRING (SUBSEQUENCE STRING BEGIN ENDOFSTRING))
      (INSERT-LAST LIST (WRAP-STRING SUBSTRING))
      (CL:RETURN-FROM EXPLODE-VARIABLIZED-STRING LIST))
     ((CL:> END BEGIN)
      (CL:SETQ SUBSTRING (SUBSEQUENCE STRING BEGIN END))
      (INSERT-LAST LIST (WRAP-STRING SUBSTRING))))
    (CL:SETQ BEGIN END) (CL:SETQ END (POSITION STRING #\  BEGIN))
    (CL:WHEN (CL:= END NULL-INTEGER) (CL:SETQ END ENDOFSTRING))
    (CL:SETQ SUBSTRING (SUBSEQUENCE STRING BEGIN END))
    (CL:SETQ SYMBOL (INTERN-SYMBOL (STRING-UPCASE SUBSTRING)))
    (INSERT-LAST LIST SYMBOL) (CL:SETQ BEGIN END))))

;;; (DEFUN (FACT-TO-SENTENCE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:SIMPLE-STRING) FACT-TO-SENTENCE))
(CL:DEFUN FACT-TO-SENTENCE (SELF PERIOD?)
  (CL:LET* ((TEST-VALUE-000 (%KIND SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-PROPAGATE-ISA))
     (CL:LET*
      ((RELATION (%SURROGATE-VALUE (%OPERATOR SELF)))
       (PHRASE
        (ACCESS-BINARY-VALUE RELATION
         SGT-PROPAGATE-PL-KERNEL-KB-PHRASE))
       (EXPLODEDSTRING
        (CL:IF (CL:NOT (CL:EQ PHRASE NULL))
         (EXPLODE-VARIABLIZED-STRING (%WRAPPER-VALUE PHRASE)) NULL)))
      (CL:WHEN (CL:NOT (CL:EQ EXPLODEDSTRING NULL))
       (CL:LET* ((TABLE (NEW-KEY-VALUE-LIST)) (SENTENCE ""))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SENTENCE))
        (CL:LET*
         ((VBL NULL)
          (ITER-000 (%THE-CONS-LIST (%IO-VARIABLE-NAMES RELATION)))
          (ARG NULL) (VECTOR-000 (%ARGUMENTS SELF)) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE
          (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
           (CL:< INDEX-000 LENGTH-000))
          DO (CL:SETQ VBL (%%VALUE ITER-000))
          (CL:SETQ ARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (INSERT-AT TABLE VBL ARG)
          (CL:SETQ ITER-000 (%%REST ITER-000))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
        (CL:LET*
         ((ITEM NULL) (ITER-001 (%THE-CONS-LIST EXPLODEDSTRING)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ ITEM (%%VALUE ITER-001))
          (CL:LET* ((VALUE NULL) (STRINGVALUE STELLA::NULL-STRING))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING STRINGVALUE))
           (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE ITEM)))
            (CL:COND
             ((SUBTYPE-OF-SYMBOL? TEST-VALUE-002)
              (CL:PROGN (CL:SETQ VALUE (LOOKUP TABLE ITEM))
               (CL:WHEN (CL:NOT (CL:EQ VALUE NULL))
                (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE VALUE)))
                 (CL:COND
                  ((SUBTYPE-OF? TEST-VALUE-001
                    SGT-PROPAGATE-LOGIC-SKOLEM)
                   (CL:PROGN
                    (CL:LET*
                     ((SURROGATE (%SURROGATE-VALUE-INVERSE VALUE))
                      (DEFININGPROPOSITION
                       (%DEFINING-PROPOSITION VALUE)))
                     (CL:COND
                      ((CL:NOT (CL:EQ DEFININGPROPOSITION NULL))
                       (CL:SETQ STRINGVALUE
                        (FACT-TO-SENTENCE DEFININGPROPOSITION CL:NIL)))
                      ((CL:NOT (CL:EQ SURROGATE NULL))
                       (CL:SETQ STRINGVALUE (%SYMBOL-NAME SURROGATE)))
                      (CL:T
                       (CL:SETQ STRINGVALUE
                        (%SYMBOL-NAME (%SKOLEM-NAME VALUE))))))))
                  ((SUBTYPE-OF? TEST-VALUE-001
                    SGT-PROPAGATE-LOGIC-LOGIC-OBJECT)
                   (CL:PROGN
                    (CL:LET*
                     ((SURROGATE (%SURROGATE-VALUE-INVERSE VALUE)))
                     (CL:WHEN (CL:NOT (CL:EQ SURROGATE NULL))
                      (CL:SETQ STRINGVALUE
                       (%SYMBOL-NAME SURROGATE))))))
                  ((SUBTYPE-OF-STRING? TEST-VALUE-001)
                   (CL:PROGN
                    (CL:SETQ STRINGVALUE
                     (CONCATENATE "'" (%WRAPPER-VALUE VALUE) "'"))))
                  ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
                   (CL:PROGN
                    (CL:SETQ STRINGVALUE
                     (INTEGER-TO-STRING
                      (CL:TRUNCATE (%WRAPPER-VALUE VALUE))))))
                  ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
                   (CL:PROGN
                    (CL:SETQ STRINGVALUE
                     (FLOAT-TO-STRING (%WRAPPER-VALUE VALUE)))))
                  (CL:T))))
               (CL:IF (CL:NOT (CL:EQ STRINGVALUE STELLA::NULL-STRING))
                (CL:SETQ SENTENCE (CONCATENATE SENTENCE STRINGVALUE))
                (CL:SETQ SENTENCE
                 (CONCATENATE SENTENCE (%SYMBOL-NAME ITEM))))))
             ((SUBTYPE-OF-STRING? TEST-VALUE-002)
              (CL:PROGN
               (CL:SETQ SENTENCE
                (CONCATENATE SENTENCE (%WRAPPER-VALUE ITEM)))))
             (CL:T
              (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
               (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
                TEST-VALUE-002 "' is not a valid case option")
               (CL:ERROR
                (NEW-STELLA-EXCEPTION
                 (THE-STRING-READER STREAM-000))))))))
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:WHEN PERIOD? (CL:SETQ SENTENCE (CONCATENATE SENTENCE ".")))
        (CL:RETURN-FROM FACT-TO-SENTENCE SENTENCE)))
      STELLA::NULL-STRING))
    ((CL:EQ TEST-VALUE-000 KWD-PROPAGATE-IMPLIES)
     "rules not yet implemented")
    (CL:T "???"))))

;;; (DEFUN (ALL-SENTENCES-OF (CONS OF STRING-WRAPPER)) ...)

(CL:DEFUN %ALL-SENTENCES-OF (INSTANCEREF)
  "Return a list of sentences describing facts about 'instanceRef'."
  (CL:LET*
   ((INSTANCE (COERCE-TO-INSTANCE INSTANCEREF NULL))
    (SENTENCE STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SENTENCE))
   (CL:IF (CL:NOT (CL:EQ INSTANCE NULL))
    (CL:LET* ((LIST NIL))
     (CL:LET*
      ((FACT NULL)
       (ITER-000
        (%THE-CONS-LIST (ALL-FACTS-OF-INSTANCE INSTANCE CL:NIL CL:T)))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ FACT (%%VALUE ITER-000))
       (CL:TAGBODY
        (CL:PROGN (CL:SETQ SENTENCE (FACT-TO-SENTENCE FACT CL:T))
         (CL:WHEN (CL:EQ SENTENCE STELLA::NULL-STRING)
          (CL:GO :CONTINUE)))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000 (CONS (WRAP-STRING SENTENCE) NIL))
          (CL:IF (CL:EQ LIST NIL) (CL:SETQ LIST COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST LIST COLLECT-000)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-000)
           (CONS (WRAP-STRING SENTENCE) NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
        :CONTINUE)
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     LIST)
    NULL)))

(CL:DEFMACRO ALL-SENTENCES-OF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Return a list of sentences describing facts about 'instanceRef'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ALL-SENTENCES-OF|)) (CL:MACRO-FUNCTION (CL:QUOTE ALL-SENTENCES-OF)))

;;; (DEFUN (CALL-ALL-FACTS-OF-N (LIST OF PROPOSITION)) ...)

(CL:DEFUN CALL-ALL-FACTS-OF-N (N SEEDREFS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:LET*
   ((VISITED (NEW-HASH-TABLE)) (FACTS (NEW-HASH-TABLE))
    (FACTLIST (NEW-LIST)) (SEEDS (NEW-LIST)) (NEWSEEDS (NEW-LIST))
    (INSTANCE NULL))
   (CL:LET* ((SEEDREF NULL) (ITER-000 SEEDREFS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SEEDREF (%%VALUE ITER-000))
     (CL:SETQ INSTANCE (COERCE-TO-INSTANCE SEEDREF NULL))
     (CL:WHEN (CL:NOT (CL:EQ INSTANCE NULL))
      (INSERT-NEW SEEDS INSTANCE))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 0)
     (UPPER-BOUND-000 (CL:IF (CL:NOT (CL:= N NULL-INTEGER)) N 0))
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-001) (CL:SETQ I I)
     (CL:LET* ((SEED NULL) (ITER-002 (%THE-CONS-LIST SEEDS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ SEED (%%VALUE ITER-002)) (INSERT-AT VISITED SEED SEED)
       (CL:SETQ ITER-002 (%%REST ITER-002))))
     (CL:LET* ((SEED NULL) (ITER-003 (%THE-CONS-LIST SEEDS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
       (CL:SETQ SEED (%%VALUE ITER-003))
       (CL:LET*
        ((PROP NULL)
         (ITER-004
          (%THE-CONS-LIST (ALL-FACTS-OF-INSTANCE SEED CL:NIL CL:T))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
         (CL:SETQ PROP (%%VALUE ITER-004))
         (CL:TAGBODY
          (CL:WHEN (CL:NOT (CL:EQ (LOOKUP FACTS PROP) NULL))
           (CL:GO :CONTINUE))
          (INSERT-AT FACTS PROP PROP) (INSERT FACTLIST PROP)
          (CL:LET*
           ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROP)) (INDEX-000 0)
            (LENGTH-000 (LENGTH VECTOR-000)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
           (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
            (CL:SETQ ARG
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
              INDEX-000))
            (CL:WHEN (CL:EQ (LOOKUP VISITED ARG) NULL)
             (INSERT-NEW NEWSEEDS ARG))
            (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
          :CONTINUE)
         (CL:SETQ ITER-004 (%%REST ITER-004))))
       (CL:SETQ ITER-003 (%%REST ITER-003))))
     (CL:SETQ SEEDS NEWSEEDS) (CL:SETQ NEWSEEDS (NEW-LIST))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (REVERSE FACTLIST)))

;;; (DEFUN (FILTERED-ALL-FACTS-OF-N (LIST OF PROPOSITION)) ...)

(CL:DEFUN FILTERED-ALL-FACTS-OF-N (N SEEDREFS FILTER)
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (CL:LET*
   ((VISITED (NEW-HASH-TABLE)) (FACTS (NEW-HASH-TABLE))
    (FACTLIST (NEW-LIST)) (SEEDS (NEW-LIST)) (NEWSEEDS (NEW-LIST))
    (INSTANCE NULL))
   (CL:LET* ((SEEDREF NULL) (ITER-000 SEEDREFS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SEEDREF (%%VALUE ITER-000))
     (CL:SETQ INSTANCE (COERCE-TO-INSTANCE SEEDREF NULL))
     (CL:WHEN (CL:NOT (CL:EQ INSTANCE NULL))
      (INSERT-NEW SEEDS INSTANCE))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 0)
     (UPPER-BOUND-000 (CL:IF (CL:NOT (CL:= N NULL-INTEGER)) N 0))
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-001) (CL:SETQ I I)
     (CL:LET* ((SEED NULL) (ITER-002 (%THE-CONS-LIST SEEDS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ SEED (%%VALUE ITER-002)) (INSERT-AT VISITED SEED SEED)
       (CL:SETQ ITER-002 (%%REST ITER-002))))
     (CL:LET* ((SEED NULL) (ITER-003 (%THE-CONS-LIST SEEDS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-003 NIL)) DO
       (CL:SETQ SEED (%%VALUE ITER-003))
       (CL:LET*
        ((PROP NULL)
         (ITER-004
          (%THE-CONS-LIST (ALL-FACTS-OF-INSTANCE SEED CL:NIL CL:T))))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
         (CL:SETQ PROP (%%VALUE ITER-004))
         (CL:TAGBODY
          (CL:WHEN (CL:NOT (CL:EQ (LOOKUP FACTS PROP) NULL))
           (CL:GO :CONTINUE))
          (CL:LET*
           ((FILTEROUTPUT (CL:FUNCALL FILTER PROP))
            (FACTPROPS (%%VALUE FILTEROUTPUT))
            (PROPSEEDS (%%VALUE (%%REST FILTEROUTPUT))))
           (CL:LET* ((FACTPROP NULL) (ITER-005 FACTPROPS))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
             (CL:SETQ FACTPROP (%%VALUE ITER-005))
             (INSERT-AT FACTS FACTPROP FACTPROP)
             (INSERT FACTLIST FACTPROP)
             (CL:SETQ ITER-005 (%%REST ITER-005))))
           (CL:LET* ((ARG NULL) (ITER-006 PROPSEEDS))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-006 NIL)) DO
             (CL:SETQ ARG (%%VALUE ITER-006))
             (CL:WHEN (CL:EQ (LOOKUP VISITED ARG) NULL)
              (INSERT-NEW NEWSEEDS ARG))
             (CL:SETQ ITER-006 (%%REST ITER-006)))))
          :CONTINUE)
         (CL:SETQ ITER-004 (%%REST ITER-004))))
       (CL:SETQ ITER-003 (%%REST ITER-003))))
     (CL:SETQ SEEDS NEWSEEDS) (CL:SETQ NEWSEEDS (NEW-LIST))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (REVERSE FACTLIST)))

;;; (DEFUN (ALL-FACTS-OF-N (CONS OF PROPOSITION)) ...)

(CL:DEFUN %ALL-FACTS-OF-N (N INSTANCEREFS)
  "This is a generalization of `all-facts-of' (which see).  With `n' = 0
and only one instance this command behaves just like `all-facts-of'.
Otherwise, returns a cons list of all definite (TRUE or FALSE) propositions
that reference any of the instances listed in `instanceRefs', plus if `n' >= 1
all propositions that reference any instances that are arguments of
propositions collected in the previous step, plus if `n' >= 2... and so on.
That is, if we only consider binary propositions, this can be viewed as
growing a graph with instances as its nodes and predicates as its arcs
starting from the set of seed `instanceRefs' to depth `n'-1.
Caution: with a fully connected KB and large enough `n' this could return
the whole knowledge base.

The returned propositions include those asserted to be true or false by
default, but it does not include propositions that are found to be
true only by running the query engine.  Facts inferred to be true by
the forward chainer will be included.  Hence, the returned list of
facts may be longer in a context where the forward chainer has been
run then in one where it has not (see `run-forward-rules')."
  (CL:DECLARE (CL:TYPE CL:FIXNUM N))
  #+MCL
  (CL:CHECK-TYPE N CL:FIXNUM)
  (%THE-CONS-LIST (CALL-ALL-FACTS-OF-N N INSTANCEREFS)))

(CL:DEFUN ALL-FACTS-OF-N-EVALUATOR-WRAPPER (ARGUMENTS)
  (%ALL-FACTS-OF-N (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%%REST ARGUMENTS)))

(CL:DEFMACRO ALL-FACTS-OF-N (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "This is a generalization of `all-facts-of' (which see).  With `n' = 0
and only one instance this command behaves just like `all-facts-of'.
Otherwise, returns a cons list of all definite (TRUE or FALSE) propositions
that reference any of the instances listed in `instanceRefs', plus if `n' >= 1
all propositions that reference any instances that are arguments of
propositions collected in the previous step, plus if `n' >= 2... and so on.
That is, if we only consider binary propositions, this can be viewed as
growing a graph with instances as its nodes and predicates as its arcs
starting from the set of seed `instanceRefs' to depth `n'-1.
Caution: with a fully connected KB and large enough `n' this could return
the whole knowledge base.

The returned propositions include those asserted to be true or false by
default, but it does not include propositions that are found to be
true only by running the query engine.  Facts inferred to be true by
the forward chainer will be included.  Hence, the returned list of
facts may be longer in a context where the forward chainer has been
run then in one where it has not (see `run-forward-rules')."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ALL-FACTS-OF-N|)) (CL:MACRO-FUNCTION (CL:QUOTE ALL-FACTS-OF-N)))

(CL:DEFUN HELP-STARTUP-PROPAGATE1 ()
  (CL:PROGN
   (CL:SETQ SGT-PROPAGATE-LOGIC-PROPAGATION-ENVIRONMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPAGATION-ENVIRONMENT" NULL 1))
   (CL:SETQ SYM-PROPAGATE-LOGIC-EVALUATION-QUEUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATION-QUEUE" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-EVALUATION-STATES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATION-STATES" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-QUEUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-QUEUE" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-FORWARD-CHAINING-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-SET" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-DEFERRED-DEFAULT-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFERRED-DEFAULT-PROPOSITIONS"
     NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-ELABORATED-OBJECTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ELABORATED-OBJECTS" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-PROPAGATION-ENVIRONMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPAGATION-ENVIRONMENT" NULL 0))
   (CL:SETQ KWD-PROPAGATE-POSTED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSTED" NULL 2))
   (CL:SETQ KWD-PROPAGATE-FORWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-BACKWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-ONLY?" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-FORWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
   (CL:SETQ SGT-PROPAGATE-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-PROPAGATE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ
    SGT-PROPAGATE-LOGIC-F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-COLLECT-FORWARD-CHAINING-RULES-MEMO-TABLE-000" NULL 1))
   (CL:SETQ KWD-PROPAGATE-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-PROPAGATE-ISA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-PROPAGATE-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-SKOLEM-GENERATION-COUNT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM-GENERATION-COUNT" NULL 0))
   (CL:SETQ KWD-PROPAGATE-PROPAGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPAGATE" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-HYPOTHESIZED-INSTANCE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HYPOTHESIZED-INSTANCE?" NULL 0))
   (CL:SETQ SGT-PROPAGATE-PL-KERNEL-KB-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPAGATE-GOAL-TREE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-TREE" NULL 2))
   (CL:SETQ KWD-PROPAGATE-SINGLETONS?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLETONS?" NULL 2))
   (CL:SETQ KWD-PROPAGATE-INFERENCE-LEVEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-LEVEL" NULL 2))
   (CL:SETQ KWD-PROPAGATE-SHALLOW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SHALLOW" NULL 2))
   (CL:SETQ SGT-PROPAGATE-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-PROPAGATE-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ KWD-PROPAGATE-KB-UPDATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KB-UPDATE" NULL 2))
   (CL:SETQ KWD-PROPAGATE-META-KB-UPDATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-KB-UPDATE" NULL 2))
   (CL:SETQ KWD-PROPAGATE-META
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META" NULL 2))
   (CL:SETQ SGT-PROPAGATE-STELLA-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODULE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPAGATE-LOGIC-DESCRIPTIVE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTIVE?" NULL 0))
   (CL:SETQ SGT-PROPAGATE-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SGT-PROPAGATE-STELLA-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMBOL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-PROPAGATE-EVALUATED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVALUATED" NULL 2))
   (CL:SETQ KWD-PROPAGATE-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-PROPAGATE-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ KWD-PROPAGATE-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-PROPAGATE-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-CULL-CLASH-EXCEPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CULL-CLASH-EXCEPTIONS" NULL 0))
   (CL:SETQ KWD-PROPAGATE-ELABORATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ELABORATE" NULL 2))
   (CL:SETQ KWD-PROPAGATE-EXTENSIONAL-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXTENSIONAL-ASSERTION" NULL 2))
   (CL:SETQ SGT-PROPAGATE-PL-KERNEL-KB-INEQUALITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INEQUALITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SGT-PROPAGATE-STELLA-SURROGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SURROGATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-PROPAGATE-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-PROPAGATE-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL" NULL 2))
   (CL:SETQ SGT-PROPAGATE-PL-KERNEL-KB-EQUIVALENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENT"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-PROPAGATE-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 0))
   (CL:SETQ SGT-PROPAGATE-STELLA-SLOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SLOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-PROPAGATE-LOGIC-ALL-FACTS-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-FACTS-OF" NULL 0))
   (CL:SETQ KWD-PROPAGATE-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-PRINT-FACTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRINT-FACTS" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-CALL-ALL-FACTS-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CALL-ALL-FACTS-OF" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-RETRACT-FACTS-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-FACTS-OF" NULL 0))
   (CL:SETQ SGT-PROPAGATE-PL-KERNEL-KB-PHRASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PHRASE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-PROPAGATE-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ SYM-PROPAGATE-LOGIC-ALL-SENTENCES-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-SENTENCES-OF" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-ALL-FACTS-OF-N
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL-FACTS-OF-N" NULL 0))
   (CL:SETQ SYM-PROPAGATE-LOGIC-STARTUP-PROPAGATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-PROPAGATE" NULL 0))))

(CL:DEFUN HELP-STARTUP-PROPAGATE2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "PRINT-PROPAGATION-ENVIRONMENT-STATS"
    "(DEFUN PRINT-PROPAGATION-ENVIRONMENT-STATS ((SELF PROPAGATION-ENVIRONMENT)))"
    (CL:FUNCTION PRINT-PROPAGATION-ENVIRONMENT-STATS) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT CONTEXT PROPAGATION-ENVIRONMENT :TYPE PROPAGATION-ENVIRONMENT :PUBLIC? TRUE :DOCUMENTATION \"Holds propositions posted for evaluation and
forward chaining as well as various other propagation control information.\" :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "GET-PROPAGATION-ENVIRONMENT"
    "(DEFUN (GET-PROPAGATION-ENVIRONMENT PROPAGATION-ENVIRONMENT) ((SELF CONTEXT)))"
    (CL:FUNCTION GET-PROPAGATION-ENVIRONMENT) NULL)
   (DEFINE-FUNCTION-OBJECT "UNLINK-PROPAGATION-ENVIRONMENT"
    "(DEFUN UNLINK-PROPAGATION-ENVIRONMENT ((SELF CONTEXT)))"
    (CL:FUNCTION UNLINK-PROPAGATION-ENVIRONMENT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD DEFER-DEFAULT-PROPOSITION ((SELF PROPAGATION-ENVIRONMENT) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION DEFER-DEFAULT-PROPOSITION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD CLEAR-PROPAGATION-QUEUES ((SELF PROPAGATION-ENVIRONMENT)))"
    (CL:FUNCTION CLEAR-PROPAGATION-QUEUES) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (COPY (LIKE SELF)) ((SELF PROPAGATION-ENVIRONMENT)))"
    (CL:FUNCTION COPY) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATION-STATE"
    "(DEFUN (EVALUATION-STATE KEYWORD) ((PROPOSITION PROPOSITION)) :DOCUMENTATION \"Return :POSTED if `proposition' is on the evaluation queue
for *context*, :EVALUATED if has been evaluated, or NULL if it has never been evaluated.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (IF (DESCRIPTION-MODE?) (RETURN NULL) (RETURN (LOOKUP (EVALUATION-STATES (GET-PROPAGATION-ENVIRONMENT *CONTEXT*)) PROPOSITION))))"
    (CL:FUNCTION EVALUATION-STATE) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATION-STATE-SETTER"
    "(DEFUN EVALUATION-STATE-SETTER ((PROPOSITION PROPOSITION) (STATE KEYWORD)) :DOCUMENTATION \"Record the evaluation `state' of 'proposition'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION EVALUATION-STATE-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "POST-FOR-EVALUATION"
    "(DEFUN POST-FOR-EVALUATION ((SELF PROPOSITION) (WORLD CONTEXT)) :DOCUMENTATION \"Push 'self' onto the evaluation queue (unless it's already there).\" :PUBLIC? TRUE)"
    (CL:FUNCTION POST-FOR-EVALUATION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-FORWARD-RULES"
    "(DEFUN (HELP-COLLECT-FORWARD-RULES (CONS OF KEY-VALUE-LIST)) ((DESCRIPTION DESCRIPTION) (RULES KEY-VALUE-LIST) (INDICES KEY-VALUE-LIST) (TOUCHEDDEFAULT? BOOLEAN) (BEENTHERE LIST)))"
    (CL:FUNCTION HELP-COLLECT-FORWARD-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-FORWARD-CHAINING-RULES"
    "(DEFUN (COLLECT-FORWARD-CHAINING-RULES (KEY-VALUE-LIST OF PROPOSITION BOOLEAN-WRAPPER) (KEY-VALUE-LIST OF FORWARD-CHAINING-INDEX BOOLEAN-WRAPPER)) ((DESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION COLLECT-FORWARD-CHAINING-RULES) NULL)
   (DEFINE-FUNCTION-OBJECT "HAS-FORWARD-CHAINING-RULES?"
    "(DEFUN (HAS-FORWARD-CHAINING-RULES? BOOLEAN) ((DESCRIPTION DESCRIPTION) (PROPOSITION PROPOSITION)))"
    (CL:FUNCTION HAS-FORWARD-CHAINING-RULES?) NULL)
   (DEFINE-FUNCTION-OBJECT "POST-TO-FORWARD-CHAINING-QUEUE"
    "(DEFUN POST-TO-FORWARD-CHAINING-QUEUE ((SELF PROPOSITION) (WORLD WORLD)))"
    (CL:FUNCTION POST-TO-FORWARD-CHAINING-QUEUE) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT SKOLEM SKOLEM-GENERATION-COUNT :TYPE INTEGER :DEFAULT 0 :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "APPLY-RULE-CONSEQUENT-TO-VECTOR"
    "(DEFUN APPLY-RULE-CONSEQUENT-TO-VECTOR ((CONSEQUENT DESCRIPTION) (ARGUMENTS ARGUMENTS-VECTOR) (RULE PROPOSITION) (TRIGGERDESCRIPTION DESCRIPTION) (TRIGGERPROPOSITION PROPOSITION) (TOUCHEDDEFAULT? BOOLEAN) (BC-JUSTIFICATION JUSTIFICATION)))"
    (CL:FUNCTION APPLY-RULE-CONSEQUENT-TO-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "TRACE-FORWARD-RULE"
    "(DEFUN TRACE-FORWARD-RULE ((RULE PROPOSITION) (TRIGGER PROPOSITION) (CONSEQUENTS (CONS OF PROPOSITION))))"
    (CL:FUNCTION TRACE-FORWARD-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-FORWARD-RULES-TO-VECTOR"
    "(DEFUN APPLY-FORWARD-RULES-TO-VECTOR ((TRIGGERDESCRIPTION DESCRIPTION) (ARGUMENTS ARGUMENTS-VECTOR) (TRIGGERPROPOSITION PROPOSITION)))"
    (CL:FUNCTION APPLY-FORWARD-RULES-TO-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLICABLE-FORWARD-RULE?"
    "(DEFUN (APPLICABLE-FORWARD-RULE? BOOLEAN) ((RULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR)))"
    (CL:FUNCTION APPLICABLE-FORWARD-RULE?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REACT-TO-INFERENCE-UPDATE ((SELF SKOLEM)))"
    (CL:FUNCTION REACT-TO-INFERENCE-UPDATE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD REACT-TO-INFERENCE-UPDATE ((SELF PROPOSITION)))"
    (CL:FUNCTION REACT-TO-INFERENCE-UPDATE) NULL)
   (DEFINE-FUNCTION-OBJECT "REACT-TO-KB-UPDATE"
    "(DEFUN REACT-TO-KB-UPDATE ((CONTEXT CONTEXT) (OBJECT OBJECT)))"
    (CL:FUNCTION REACT-TO-KB-UPDATE) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD EXECUTE-PROPAGATION-QUEUES ((SELF PROPAGATION-ENVIRONMENT)))"
    (CL:FUNCTION EXECUTE-PROPAGATION-QUEUES) NULL)
   (DEFINE-FUNCTION-OBJECT "EXECUTE-CONSTRAINT-PROPAGATION-QUEUES"
    "(DEFUN EXECUTE-CONSTRAINT-PROPAGATION-QUEUES ())"
    (CL:FUNCTION EXECUTE-CONSTRAINT-PROPAGATION-QUEUES) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-NEW-PROPOSITION"
    "(DEFUN EVALUATE-NEW-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION EVALUATE-NEW-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-AND-PROPOSITION"
    "(DEFUN EVALUATE-AND-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION EVALUATE-AND-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-OR-PROPOSITION"
    "(DEFUN EVALUATE-OR-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION EVALUATE-OR-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-NOT-PROPOSITION"
    "(DEFUN EVALUATE-NOT-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION EVALUATE-NOT-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-EQUIVALENT-PROPOSITION"
    "(DEFUN EVALUATE-EQUIVALENT-PROPOSITION ((SELF PROPOSITION)))"
    (CL:FUNCTION EVALUATE-EQUIVALENT-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS"
    "(DEFUN EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS ((SELF PROPOSITION)))"
    (CL:FUNCTION EQUATE-EQUIVALENT-FUNCTION-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-FUNCTION-PROPOSITION"
    "(DEFUN EVALUATE-FUNCTION-PROPOSITION ((SELF PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION EVALUATE-FUNCTION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-PREDICATE-PROPOSITION"
    "(DEFUN EVALUATE-PREDICATE-PROPOSITION ((SELF PROPOSITION)) :PUBLIC? TRUE)"
    (CL:FUNCTION EVALUATE-PREDICATE-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-PROPOSITION"
    "(DEFUN EVALUATE-PROPOSITION ((SELF PROPOSITION)) :DOCUMENTATION \"Evaluate 'self' against its arguments, possibly resulting in
the setting or changing of its truth value.\" :PUBLIC? TRUE)"
    (CL:FUNCTION EVALUATE-PROPOSITION) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD MARK-AS-INCOHERENT ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION MARK-AS-INCOHERENT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD MARK-AS-INCOHERENT ((SELF SKOLEM)))"
    (CL:FUNCTION MARK-AS-INCOHERENT) NULL)
   (DEFINE-FUNCTION-OBJECT "RESET-CLASH-EXCEPTIONS"
    "(DEFUN RESET-CLASH-EXCEPTIONS () :PUBLIC? TRUE :DOCUMENTATION \"Resets the collection of clash exceptions\")"
    (CL:FUNCTION RESET-CLASH-EXCEPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "EXCEPTION-RECORD-MATCHES-CONTEXT?"
    "(DEFUN (EXCEPTION-RECORD-MATCHES-CONTEXT? BOOLEAN) ((RECORD EXCEPTION-RECORD)))"
    (CL:FUNCTION EXCEPTION-RECORD-MATCHES-CONTEXT?) NULL)
   (DEFINE-FUNCTION-OBJECT "CULL-CLASH-EXCEPTIONS"
    "(DEFUN CULL-CLASH-EXCEPTIONS ((SELF CONTEXT)))"
    (CL:FUNCTION CULL-CLASH-EXCEPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "RECURSIVELY-REACT-TO-INFERENCE-UPDATE"
    "(DEFUN RECURSIVELY-REACT-TO-INFERENCE-UPDATE ((SELF PROPOSITION)))"
    (CL:FUNCTION RECURSIVELY-REACT-TO-INFERENCE-UPDATE) NULL)
   (DEFINE-FUNCTION-OBJECT "ELABORATE-META-INSTANCE"
    "(DEFUN ELABORATE-META-INSTANCE ((SELF OBJECT)))"
    (CL:FUNCTION ELABORATE-META-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "ELABORATE-INSTANCE"
    "(DEFUN ELABORATE-INSTANCE ((SELF OBJECT)))"
    (CL:FUNCTION ELABORATE-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-REACHABLE-INEQUALITIES"
    "(DEFUN EVALUATE-REACHABLE-INEQUALITIES ((SELF LOGIC-OBJECT) (VISITEDLIST LIST)))"
    (CL:FUNCTION EVALUATE-REACHABLE-INEQUALITIES) NULL)
   (DEFINE-FUNCTION-OBJECT "ELABORATE-SURROGATES-IN-PROPOSITION"
    "(DEFUN ELABORATE-SURROGATES-IN-PROPOSITION ((PROPOSITION PROPOSITION)))"
    (CL:FUNCTION ELABORATE-SURROGATES-IN-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "FOLLOW-DEPENDENT-PROPOSITION-ARGUMENT?"
    "(DEFUN (FOLLOW-DEPENDENT-PROPOSITION-ARGUMENT? BOOLEAN) ((PROPOSITION PROPOSITION) (ARGUMENT OBJECT)))"
    (CL:FUNCTION FOLLOW-DEPENDENT-PROPOSITION-ARGUMENT?) NULL)
   (DEFINE-FUNCTION-OBJECT "DO-NOT-ELABORATE?"
    "(DEFUN (DO-NOT-ELABORATE? BOOLEAN) ((SELF OBJECT) (ENVIRONMENT PROPAGATION-ENVIRONMENT)))"
    (CL:FUNCTION DO-NOT-ELABORATE?) NULL)
   (DEFINE-FUNCTION-OBJECT "POST-RELATED-FACTS"
    "(DEFUN POST-RELATED-FACTS ((SELF OBJECT) (ENVIRONMENT PROPAGATION-ENVIRONMENT)))"
    (CL:FUNCTION POST-RELATED-FACTS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-FACTS"
    "(DEFUN HELP-COLLECT-FACTS ((SELF OBJECT) (FACTS (LIST OF PROPOSITION)) (BEENTHERE HASH-SET) (INCLUDEUNKNOWN? BOOLEAN)))"
    (CL:FUNCTION HELP-COLLECT-FACTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-FACTS-OF-INSTANCE"
    "(DEFUN (ALL-FACTS-OF-INSTANCE (LIST OF PROPOSITION)) ((SELF OBJECT) (INCLUDEUNKNOWNFACTS? BOOLEAN) (ELABORATE? BOOLEAN)) :DOCUMENTATION \"Return a list of all definite (TRUE or FALSE) propositions
attached to `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION ALL-FACTS-OF-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-FACTS-OF"
    "(DEFUN (ALL-FACTS-OF (CONS OF PROPOSITION)) ((INSTANCEREF OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Return a cons list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'.  This includes propositions
asserted to be true by default, but it does not include propositions
that are found to be TRUE only by running the query engine.  Facts
inferred to be TRUE by the forward chainer will be included.
Hence, the returned list of facts may be longer in a context where the
forward chainer has been run then in one where it has not (see
`run-forward-rules').  `instanceRef' can be a regular name such as
`fred' as well as a function term such as `(father fred)'.\")"
    (CL:FUNCTION %ALL-FACTS-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-FACTS"
    "(DEFUN PRINT-FACTS ((INSTANCEREF OBJECT)) :DOCUMENTATION \"Like `all-facts-of', but sorts and prints each fact
on a separate line on the standard output stream.\" :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %PRINT-FACTS) NULL)
   (DEFINE-FUNCTION-OBJECT "CALL-ALL-FACTS-OF"
    "(DEFUN (CALL-ALL-FACTS-OF (LIST OF PROPOSITION)) ((INSTANCEREF OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? TRUE :DOCUMENTATION \"Return a list of all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'.\")"
    (CL:FUNCTION %CALL-ALL-FACTS-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT-FACTS-OF-INSTANCE"
    "(DEFUN RETRACT-FACTS-OF-INSTANCE ((SELF LOGIC-OBJECT)) :DOCUMENTATION \"Retract all definite (TRUE or FALSE) propositions attached to `self'.\" :PUBLIC? TRUE)"
    (CL:FUNCTION RETRACT-FACTS-OF-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "RETRACT-FACTS-OF"
    "(DEFUN RETRACT-FACTS-OF ((INSTANCEREF OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Retract all definite (TRUE or FALSE) propositions
that reference the instance `instanceRef'.\")"
    (CL:FUNCTION %RETRACT-FACTS-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPLODE-VARIABLIZED-STRING"
    "(DEFUN (EXPLODE-VARIABLIZED-STRING LIST) ((STRING STRING)))"
    (CL:FUNCTION EXPLODE-VARIABLIZED-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "FACT-TO-SENTENCE"
    "(DEFUN (FACT-TO-SENTENCE STRING) ((SELF PROPOSITION) (PERIOD? BOOLEAN)))"
    (CL:FUNCTION FACT-TO-SENTENCE) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-SENTENCES-OF"
    "(DEFUN (ALL-SENTENCES-OF (CONS OF STRING-WRAPPER)) ((INSTANCEREF OBJECT)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? TRUE :DOCUMENTATION \"Return a list of sentences describing facts about 'instanceRef'.\")"
    (CL:FUNCTION %ALL-SENTENCES-OF) NULL)
   (DEFINE-FUNCTION-OBJECT "CALL-ALL-FACTS-OF-N"
    "(DEFUN (CALL-ALL-FACTS-OF-N (LIST OF PROPOSITION)) ((N INTEGER) (SEEDREFS CONS)))"
    (CL:FUNCTION CALL-ALL-FACTS-OF-N) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTERED-ALL-FACTS-OF-N"
    "(DEFUN (FILTERED-ALL-FACTS-OF-N (LIST OF PROPOSITION)) ((N INTEGER) (SEEDREFS CONS) (FILTER FUNCTION-CODE)))"
    (CL:FUNCTION FILTERED-ALL-FACTS-OF-N) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-FACTS-OF-N"
    "(DEFUN (ALL-FACTS-OF-N (CONS OF PROPOSITION)) ((N INTEGER) |&REST| (INSTANCEREFS NAME)) :COMMAND? TRUE :PUBLIC? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"This is a generalization of `all-facts-of' (which see).  With `n' = 0
and only one instance this command behaves just like `all-facts-of'.
Otherwise, returns a cons list of all definite (TRUE or FALSE) propositions
that reference any of the instances listed in `instanceRefs', plus if `n' >= 1
all propositions that reference any instances that are arguments of
propositions collected in the previous step, plus if `n' >= 2... and so on.
That is, if we only consider binary propositions, this can be viewed as
growing a graph with instances as its nodes and predicates as its arcs
starting from the set of seed `instanceRefs' to depth `n'-1.
Caution: with a fully connected KB and large enough `n' this could return
the whole knowledge base.

The returned propositions include those asserted to be true or false by
default, but it does not include propositions that are found to be
true only by running the query engine.  Facts inferred to be true by
the forward chainer will be included.  Hence, the returned list of
facts may be longer in a context where the forward chainer has been
run then in one where it has not (see `run-forward-rules').\")"
    (CL:FUNCTION %ALL-FACTS-OF-N)
    (CL:FUNCTION ALL-FACTS-OF-N-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "STARTUP-PROPAGATE"
    "(DEFUN STARTUP-PROPAGATE () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-PROPAGATE) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-PROPAGATE-LOGIC-STARTUP-PROPAGATE)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
     SYM-PROPAGATE-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupPropagate") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-PROPAGATE ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-PROPAGATE1)
    (CL:SETQ SYM-PROPAGATE-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *CLASH-EXCEPTIONS* (NEW-LIST)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PROPAGATION-ENVIRONMENT"
        "(DEFCLASS PROPAGATION-ENVIRONMENT (STANDARD-OBJECT) :SLOTS ((EVALUATION-QUEUE :TYPE (LIST OF PROPOSITION) :INITIALLY (LIST)) (EVALUATION-STATES :TYPE (KEY-VALUE-MAP OF PROPOSITION KEYWORD) :INITIALLY (NEW KEY-VALUE-MAP)) (FORWARD-CHAINING-QUEUE :TYPE (LIST OF PROPOSITION) :INITIALLY (LIST)) (FORWARD-CHAINING-SET :TYPE (HASH-SET OF PROPOSITION PROPOSITION) :INITIALLY (NEW HASH-SET)) (DEFERRED-DEFAULT-PROPOSITIONS :TYPE (LIST OF PROPOSITION) :INITIALLY (LIST)) (ELABORATED-OBJECTS :TYPE HASH-SET :INITIALLY (NEW HASH-SET))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PROPAGATION-ENVIRONMENT))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PROPAGATION-ENVIRONMENT-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-PROPAGATE2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *FILLINGCONSTRAINTPROPAGATIONQUEUES?* BOOLEAN FALSE :DOCUMENTATION \"True if we are inside of 'react-to-kb-update'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *DEFERINGDEFAULTFORWARDINFERENCES?* BOOLEAN FALSE :DOCUMENTATION \"True if we are propagating strict inferences, and
posting derived default propositions to temporary queues.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *COLLECTFORWARDPROPOSITIONS* (CONS OF PROPOSITION) NULL :DOCUMENTATION \"Collect goes-true propositions produced by forward
chaining.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAX-SKOLEM-GENERATION-COUNT* INTEGER 3)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *JUST-IN-TIME-FORWARD-INFERENCE?* BOOLEAN TRUE :PUBLIC? TRUE :DOCUMENTATION \"If TRUE, ensures that forward propagation has
been applied to each instance 'touched' during a query.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CLASH-EXCEPTIONS* (LIST OF EXCEPTION-RECORD) (NEW LIST) :PUBLIC? TRUE :DOCUMENTATION \"Collects clash exceptions that occur during inference.\")")
    (ADD-HOOK *DESTROY-CONTEXT-HOOKS*
     SYM-PROPAGATE-LOGIC-CULL-CLASH-EXCEPTIONS)
    (REGISTER-NATIVE-NAME SYM-PROPAGATE-LOGIC-ALL-FACTS-OF
     KWD-PROPAGATE-COMMON-LISP KWD-PROPAGATE-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPAGATE-LOGIC-PRINT-FACTS
     KWD-PROPAGATE-COMMON-LISP KWD-PROPAGATE-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPAGATE-LOGIC-CALL-ALL-FACTS-OF
     KWD-PROPAGATE-COMMON-LISP KWD-PROPAGATE-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPAGATE-LOGIC-RETRACT-FACTS-OF
     KWD-PROPAGATE-COMMON-LISP KWD-PROPAGATE-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPAGATE-LOGIC-ALL-SENTENCES-OF
     KWD-PROPAGATE-COMMON-LISP KWD-PROPAGATE-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-PROPAGATE-LOGIC-ALL-FACTS-OF-N
     KWD-PROPAGATE-COMMON-LISP KWD-PROPAGATE-FUNCTION))))
