;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; classify.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2010      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-CLASSIFY-IMPLIES-PROPOSITION-UPDATE NULL)
(CL:DEFVAR KWD-CLASSIFY-PREDICATE NULL)
(CL:DEFVAR KWD-CLASSIFY-FUNCTION NULL)
(CL:DEFVAR KWD-CLASSIFY-ISA NULL)
(CL:DEFVAR KWD-CLASSIFY-AND NULL)
(CL:DEFVAR KWD-CLASSIFY-EXISTS NULL)
(CL:DEFVAR KWD-CLASSIFY-BACKWARD NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-FORWARD-ONLY? NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-CLASSIFY-STELLA-THING NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-F-INFERABLE-WITH-CYCLE-CHECK?-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-MARKER-TABLE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-TEST-TABLE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-RECALL-TABLE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-SUPPORTS-RECALL? NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-SUBSUMPTION-LINK? NULL)
(CL:DEFVAR KWD-CLASSIFY-CLASSIFIER-INFERENCES NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-CLASSIFICATION-CACHE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-INFERABLE-DIRECT-SUBDESCRIPTIONS NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CACHE-UPCLASSIFICATION-TIMESTAMP NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CACHE-DOWNCLASSIFICATION-TIMESTAMP NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP NULL)
(CL:DEFVAR SGT-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFICATION-WORLD NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFICATION-CACHE-TABLE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFICATION-TIMECLOCK NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP-STACK NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-EVERYTHING-CLASSIFIED? NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-KEY NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-VALUE NULL)
(CL:DEFVAR KWD-CLASSIFY-DESCRIPTION NULL)
(CL:DEFVAR KWD-CLASSIFY-META NULL)
(CL:DEFVAR KWD-CLASSIFY-INSTANCE NULL)
(CL:DEFVAR KWD-CLASSIFY-TMS NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-META-INFERENCE-CACHE NULL)
(CL:DEFVAR KWD-CLASSIFY-JUST-IN-TIME NULL)
(CL:DEFVAR KWD-CLASSIFY-CLASSIFIER NULL)
(CL:DEFVAR KWD-CLASSIFY-CLASSIFIER-PROFILE NULL)
(CL:DEFVAR KWD-CLASSIFY-UPCLASSIFY NULL)
(CL:DEFVAR KWD-CLASSIFY-DOWNCLASSIFY NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-SUBRELATION-LINK? NULL)
(CL:DEFVAR KWD-CLASSIFY-ASSERT-TRUE NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFY-RELATIONS NULL)
(CL:DEFVAR KWD-CLASSIFY-COMMON-LISP NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-LIST-UNCLASSIFIED-RELATIONS NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-CLASSIFY-INSTANCES NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-LIST-UNCLASSIFIED-INSTANCES NULL)
(CL:DEFVAR SYM-CLASSIFY-LOGIC-STARTUP-CLASSIFY NULL)
(CL:DEFVAR SYM-CLASSIFY-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *TRACED-KEYWORDS* TRUE-TRUTH-VALUE
  DEFAULT-TRUE-TRUTH-VALUE *MODULE* NULL-INTEGER *EMIT-THINKING-DOTS?*
  STANDARD-OUTPUT EOL *CONTEXT* *MEMOIZATION-ENABLED?* MEMOIZED-NULL-VALUE
  TRUE-WRAPPER NIL FALSE-WRAPPER))

;;; (DEFUN BUMP-INFERABLE-TIMESTAMP ...)

(CL:DEFUN BUMP-INFERABLE-TIMESTAMP ()
  (BUMP-MEMOIZATION-TIMESTAMP KWD-CLASSIFY-IMPLIES-PROPOSITION-UPDATE))

;;; (DEFUN HELP-COLLECT-INTENSIONAL-PARENTS ...)

(CL:DEFUN HELP-COLLECT-INTENSIONAL-PARENTS (DESCRIPTION PROPOSITION COLLECTION)
  (CL:LET* ((TEST-VALUE-000 (%KIND PROPOSITION)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-CLASSIFY-PREDICATE)
      (CL:EQ TEST-VALUE-000 KWD-CLASSIFY-FUNCTION)
      (CL:EQ TEST-VALUE-000 KWD-CLASSIFY-ISA))
     (CL:LET* ((TEST-VALUE-001 CL:NIL))
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET*
        ((ARG1 NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
         (LENGTH-000 (LENGTH VECTOR-000)) (ARG2 NULL)
         (VECTOR-001 (%IO-VARIABLES DESCRIPTION)) (INDEX-001 0)
         (LENGTH-001 (LENGTH VECTOR-001)))
        (CL:DECLARE
         (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
        (CL:LOOP WHILE
         (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
         (CL:SETQ ARG1
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
           INDEX-000))
         (CL:SETQ ARG2
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
           INDEX-001))
         (CL:WHEN (CL:NOT (CL:EQ ARG1 ARG2)) (CL:SETQ ALWAYS?-000 CL:NIL)
          (CL:RETURN))
         (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
         (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
       (CL:SETQ TEST-VALUE-001 ALWAYS?-000))
      (CL:WHEN TEST-VALUE-001
       (CL:SETQ TEST-VALUE-001
        (CL:= (LENGTH (%ARGUMENTS PROPOSITION))
         (LENGTH (%IO-VARIABLES DESCRIPTION)))))
      (CL:WHEN TEST-VALUE-001
       (PUSH COLLECTION (GET-DESCRIPTION (%OPERATOR PROPOSITION))))))
    ((CL:EQ TEST-VALUE-000 KWD-CLASSIFY-AND)
     (CL:LET*
      ((ARG NULL) (VECTOR-002 (%ARGUMENTS PROPOSITION)) (INDEX-002 0)
       (LENGTH-002 (LENGTH VECTOR-002)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
      (CL:LOOP WHILE (CL:< INDEX-002 LENGTH-002) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-002)) INDEX-002))
       (HELP-COLLECT-INTENSIONAL-PARENTS DESCRIPTION ARG COLLECTION)
       (CL:SETQ INDEX-002 (CL:1+ INDEX-002)))))
    ((CL:EQ TEST-VALUE-000 KWD-CLASSIFY-EXISTS)
     (HELP-COLLECT-INTENSIONAL-PARENTS DESCRIPTION
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       0)
      COLLECTION))
    (CL:T))))

;;; (DEFUN (ALL-INTENSIONAL-PARENTS (LIST OF DESCRIPTION)) ...)

(CL:DEFUN ALL-INTENSIONAL-PARENTS (SELF)
  (CL:LET* ((COLLECTION (NEW-LIST)))
   (HELP-COLLECT-INTENSIONAL-PARENTS SELF (%PROPOSITION SELF) COLLECTION)
   COLLECTION))

;;; (DEFUN (INFERABLE-THROUGH-BY-SOME-DESCENDANT? BOOLEAN) ...)

(CL:DEFUN INFERABLE-THROUGH-BY-SOME-DESCENDANT? (SELF THROUGHCHILD ALREADYVISITEDLIST)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE THROUGHCHILD)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:COND
       ((CL:OR (CL:NOT (CL:EQ (LOOKUP-SPECIALIST THROUGHCHILD) NULL))
         (CL:NOT (CL:EQ (LOOKUP-COMPUTATION THROUGHCHILD) NULL)))
        (CL:RETURN-FROM INFERABLE-THROUGH-BY-SOME-DESCENDANT? CL:T))
       ((CL:NOT
         (CL:EQ (%KIND (%PROPOSITION SELF))
          (%KIND (%PROPOSITION THROUGHCHILD))))
        (CL:RETURN-FROM INFERABLE-THROUGH-BY-SOME-DESCENDANT? CL:T))
       ((CL:NOT (INFERABLE-WITH-CYCLE-CHECK? THROUGHCHILD ALREADYVISITEDLIST))
        (CL:RETURN-FROM INFERABLE-THROUGH-BY-SOME-DESCENDANT? CL:NIL)))
      (CL:SETQ ALREADYVISITEDLIST (CONS THROUGHCHILD ALREADYVISITEDLIST))
      (CL:LET*
       ((P NULL)
        (ITER-000
         (APPLICABLE-RULES-OF-DESCRIPTION THROUGHCHILD KWD-CLASSIFY-BACKWARD
          CL:NIL)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ P (%%VALUE ITER-000))
        (CL:WHEN
         (CL:AND
          (CL:NOT
           (%WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS P)
             SYM-CLASSIFY-LOGIC-FORWARD-ONLY? FALSE-WRAPPER)))
          (TRUE? P))
         (CL:WHEN
          (INFERABLE-THROUGH-BY-SOME-DESCENDANT? SELF
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 0)
           ALREADYVISITEDLIST)
          (CL:RETURN-FROM INFERABLE-THROUGH-BY-SOME-DESCENDANT? CL:T)))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      CL:NIL))
    ((SUBTYPE-OF? TEST-VALUE-001 SGT-CLASSIFY-LOGIC-DESCRIPTION)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 CL:NIL))
       (CL:LET* ((FOUND?-000 CL:NIL))
        (CL:LET*
         ((PARENT NULL)
          (ITER-001 (%THE-CONS-LIST (ALL-INTENSIONAL-PARENTS THROUGHCHILD))))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ PARENT (%%VALUE ITER-001))
          (CL:WHEN (COLLECTION-IMPLIES-COLLECTION? PARENT SELF)
           (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:SETQ TEST-VALUE-000 FOUND?-000))
       (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000))
       (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000))))
    (CL:T CL:NIL))))

;;; (DEFUN (INFERABLE-WITH-CYCLE-CHECK? BOOLEAN) ...)

(CL:DEFUN INFERABLE-WITH-CYCLE-CHECK? (SELF ALREADYVISITEDLIST)
  (CL:WHEN (MEMB? ALREADYVISITEDLIST SELF)
   (CL:RETURN-FROM INFERABLE-WITH-CYCLE-CHECK? CL:NIL))
  (CL:LET* ((INFERABLE? CL:NIL))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
      SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION)
     (CL:PROGN
      (CL:LET*
       ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
        (MEMOIZED-VALUE-000 NULL))
       (CL:WHEN *MEMOIZATION-ENABLED?*
        (CL:SETQ MEMO-TABLE-000
         (%SURROGATE-VALUE
          SGT-CLASSIFY-LOGIC-F-INFERABLE-WITH-CYCLE-CHECK?-MEMO-TABLE-000))
        (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
         (INITIALIZE-MEMOIZATION-TABLE
          SGT-CLASSIFY-LOGIC-F-INFERABLE-WITH-CYCLE-CHECK?-MEMO-TABLE-000
          "(:MAX-VALUES 500 :TIMESTAMPS (:IMPLIES-PROPOSITION-UPDATE))")
         (CL:SETQ MEMO-TABLE-000
          (%SURROGATE-VALUE
           SGT-CLASSIFY-LOGIC-F-INFERABLE-WITH-CYCLE-CHECK?-MEMO-TABLE-000)))
        (CL:SETQ MEMOIZED-ENTRY-000
         (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000 SELF *CONTEXT*
          MEMOIZED-NULL-VALUE NULL -1))
        (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
       (CL:COND
        ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
         (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
          (CL:SETQ MEMOIZED-VALUE-000 NULL)))
        (CL:T
         (CL:LET* ((TEST-VALUE-001 CL:NIL))
          (CL:SETQ TEST-VALUE-001
           (CL:NOT
            (CL:EQ (%SURROGATE-VALUE-INVERSE SELF)
             SGT-CLASSIFY-STELLA-THING)))
          (CL:WHEN TEST-VALUE-001
           (CL:SETQ TEST-VALUE-001
            (CL:NOT
             (CL:EQ
              (CL:SETQ ALREADYVISITEDLIST (CONS SELF ALREADYVISITEDLIST))
              NULL)))
           (CL:WHEN TEST-VALUE-001
            (CL:LET* ((FOUND?-001 CL:NIL))
             (CL:LET*
              ((P NULL)
               (ITER-001
                (APPLICABLE-RULES-OF-DESCRIPTION SELF KWD-CLASSIFY-BACKWARD
                 CL:NIL)))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
               (CL:SETQ P (%%VALUE ITER-001))
               (CL:WHEN
                (CL:AND
                 (CL:NOT
                  (%WRAPPER-VALUE
                   (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS P)
                    SYM-CLASSIFY-LOGIC-FORWARD-ONLY? FALSE-WRAPPER)))
                 (TRUE? P)
                 (INFERABLE-THROUGH-BY-SOME-DESCENDANT? SELF
                  (CL:AREF
                   (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 0)
                  ALREADYVISITEDLIST))
                (CL:SETQ FOUND?-001 CL:T) (CL:RETURN))
               (CL:SETQ ITER-001 (%%REST ITER-001))))
             (CL:SETQ TEST-VALUE-001 FOUND?-001))))
          (CL:SETQ MEMOIZED-VALUE-000
           (CL:IF TEST-VALUE-001 TRUE-WRAPPER FALSE-WRAPPER)))
         (CL:WHEN *MEMOIZATION-ENABLED?*
          (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
           (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
            MEMOIZED-VALUE-000)))))
       (CL:SETQ INFERABLE?
        (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN MEMOIZED-VALUE-000)))))
    (CL:T (CL:SETQ INFERABLE? CL:T)))
   INFERABLE?))

;;; (DEFUN (INFERABLE? BOOLEAN) ...)

(CL:DEFUN INFERABLE? (SELF)
  (CL:LET*
   ((*CONTEXT* (GET-INFERABLE-TEST-CONTEXT))
    (*MODULE* (%BASE-MODULE *CONTEXT*)))
   (CL:DECLARE (CL:SPECIAL *CONTEXT* *MODULE*))
   (INFERABLE-WITH-CYCLE-CHECK? SELF NIL)))

;;; (DEFUN (NON-INFERABLE? BOOLEAN) ...)

(CL:DEFUN NON-INFERABLE? (SELF)
  (CL:NOT (INFERABLE? SELF)))

;;; (DEFCLASS MARKER-TABLE ...)

(CL:DEFCLASS MARKER-TABLE (STANDARD-OBJECT)
  ((TEST-TABLE :ALLOCATION :INSTANCE :ACCESSOR %TEST-TABLE)
   (RECALL-TABLE :ALLOCATION :INSTANCE :ACCESSOR %RECALL-TABLE)
   (SUPPORTS-RECALL? :ALLOCATION :INSTANCE :ACCESSOR %SUPPORTS-RECALL?))
  (:DOCUMENTATION "Used to record (mark) a set of objects.
Can be optimized for testing only, or also for recall."))

(CL:DEFUN NEW-MARKER-TABLE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE MARKER-TABLE)))
   (CL:SETF (%SUPPORTS-RECALL? SELF) CL:NIL)
   (CL:SETF (%RECALL-TABLE SELF) NULL) (CL:SETF (%TEST-TABLE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF MARKER-TABLE))
  SGT-CLASSIFY-LOGIC-MARKER-TABLE)

(CL:DEFUN ACCESS-MARKER-TABLE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-TEST-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%TEST-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%TEST-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-RECALL-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%RECALL-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%RECALL-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-SUPPORTS-RECALL?)
    (CL:IF SETVALUE?
     (CL:SETF (%SUPPORTS-RECALL? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%SUPPORTS-RECALL? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (CREATE-MARKER-STORAGE MARKER-TABLE) ...)

(CL:DEFUN CREATE-MARKER-STORAGE (SUPPORTRECALL?)
  "Return a new marker storage object, used to
remember with objects have been 'marked'.  If 'supportRecall?'
is set, then the iterator 'recall-marked-objects' can be invoked
on the new marker storage object."
  (CL:LET* ((TABLE (NEW-MARKER-TABLE)))
   (CL:SETF (%TEST-TABLE TABLE) (NEW-HASH-TABLE))
   (CL:WHEN SUPPORTRECALL? (CL:SETF (%SUPPORTS-RECALL? TABLE) CL:T)
    (CL:SETF (%RECALL-TABLE TABLE) (NEW-LIST)))
   TABLE))

;;; (DEFMETHOD SET-MARKER ...)

(CL:DEFMETHOD SET-MARKER ((SELF MARKER-TABLE) OBJECT)
  "Record membership of 'object' in the marker
storage object 'self'."
  (CL:IF (%SUPPORTS-RECALL? SELF)
   (CL:WHEN (CL:EQ (LOOKUP (%TEST-TABLE SELF) OBJECT) NULL)
    (INSERT-AT (%TEST-TABLE SELF) OBJECT TRUE-WRAPPER)
    (PUSH (%RECALL-TABLE SELF) OBJECT))
   (INSERT-AT (%TEST-TABLE SELF) OBJECT TRUE-WRAPPER)))

;;; (DEFMETHOD (TEST-MARKER? BOOLEAN) ...)

(CL:DEFMETHOD TEST-MARKER? ((SELF MARKER-TABLE) OBJECT)
  "Return TRUE if 'object' is stored (marked) in 'self'."
  (CL:NOT (CL:EQ (LOOKUP (%TEST-TABLE SELF) OBJECT) NULL)))

;;; (DEFSPECIAL *SPECIALMARKERTABLE* ...)

(CL:DEFVAR *SPECIALMARKERTABLE*)

;;; (DEFUN (TEST-SPECIAL-MARKER-TABLE? BOOLEAN) ...)

(CL:DEFUN TEST-SPECIAL-MARKER-TABLE? (SELF)
  "Return TRUE if the object 'self' is stored (marked)
in the table pointed at by the special variable *specialMarkerTable*.
Designed for use by 'remove-if'."
  (TEST-MARKER? *SPECIALMARKERTABLE* SELF))

;;; (DEFMETHOD (RECALL-MARKED-OBJECTS LIST-ITERATOR) ...)

(CL:DEFMETHOD RECALL-MARKED-OBJECTS ((SELF MARKER-TABLE))
  "Return an iterator that generates all marked objects
recorded in 'self'."
  (ALLOCATE-ITERATOR (%RECALL-TABLE SELF)))

;;; (DEFUN (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-NAMED-DIRECT-SUPERDESCRIPTIONS (SELF REMOVEEQUIVALENTS?)
  (CL:LET* ((RESULT NIL))
   (CL:LET*
    ((D NULL)
     (ITER-000 (ALL-DIRECT-SUPERCOLLECTIONS SELF REMOVEEQUIVALENTS?)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ D (%VALUE ITER-000))
     (CL:WHEN (ISA? D SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION)
      (CL:SETQ RESULT (CONS D RESULT)))))
   RESULT))

;;; (DEFUN (ALL-NAMED-DIRECT-SUBDESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN ALL-NAMED-DIRECT-SUBDESCRIPTIONS (SELF)
  (CL:LET* ((RESULT NIL))
   (CL:LET* ((D NULL) (ITER-000 (ALL-DIRECT-SUBCOLLECTIONS SELF CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ D (%VALUE ITER-000))
     (CL:WHEN (ISA? D SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION)
      (CL:SETQ RESULT (CONS D RESULT)))))
   RESULT))

;;; (DEFUN ADD-ISA-LINK ...)

(CL:DEFUN ADD-ISA-LINK (INSTANCE SUPERDESCRIPTION)
  (CL:LET*
   ((ISAPROP
     (ASSERT-ISA-PROPOSITION INSTANCE
      (%SURROGATE-VALUE-INVERSE SUPERDESCRIPTION))))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ISAPROP)
    SYM-CLASSIFY-LOGIC-SUBSUMPTION-LINK? TRUE-WRAPPER FALSE-WRAPPER)
   (CL:WHEN (TRACE-KEYWORD? KWD-CLASSIFY-CLASSIFIER-INFERENCES)
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (CL:WHEN *EMIT-THINKING-DOTS?*
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Recognized type: "
      ISAPROP EOL)))))

;;; (DEFUN ADD-SUBSUMPTION-LINK ...)

(CL:DEFUN ADD-SUBSUMPTION-LINK (SUBDESCRIPTION SUPERDESCRIPTION)
  (CL:LET*
   ((IMPLIESPROP
     (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION SUBDESCRIPTION SUPERDESCRIPTION
      CL:NIL)))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS IMPLIESPROP)
    SYM-CLASSIFY-LOGIC-SUBSUMPTION-LINK? TRUE-WRAPPER FALSE-WRAPPER)
   (CL:WHEN (TRACE-KEYWORD? KWD-CLASSIFY-CLASSIFIER-INFERENCES)
    (CL:LET* ((*INDENTCOUNTER* 4) (*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *INDENTCOUNTER* *PRINTREADABLY?*))
     (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
     (CL:WHEN *EMIT-THINKING-DOTS?*
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "Recognized subsumption link:" EOL "    " IMPLIESPROP EOL))))
  (PUSH (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS SUPERDESCRIPTION) SUBDESCRIPTION)
  (CL:LET*
   ((P NULL)
    (ITER-000 (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS SUPERDESCRIPTION CL:NIL)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ P (%%VALUE ITER-000))
    (CL:LET* ((SUBCOLLECTIONS (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS P)))
     (CL:SETF (%THE-CONS-LIST SUBCOLLECTIONS)
      (MOST-GENERAL-COLLECTIONS (%THE-CONS-LIST SUBCOLLECTIONS))))
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN (MOST-SPECIFIC-COLLECTIONS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN MOST-SPECIFIC-COLLECTIONS (DESCRIPTIONS)
  (CL:WHEN (CL:EQ (%%REST DESCRIPTIONS) NULL)
   (CL:RETURN-FROM MOST-SPECIFIC-COLLECTIONS DESCRIPTIONS))
  (CL:LET* ((CURSOR1 DESCRIPTIONS) (CURSOR2 NULL) (VALUE1 NULL) (VALUE2 NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR1 NIL)) DO
    (CL:SETQ VALUE1 (%%VALUE CURSOR1))
    (CL:WHEN (CL:NOT (CL:EQ VALUE1 NULL)) (CL:SETQ CURSOR2 (%%REST CURSOR1))
     (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR2 NIL)) DO
      (CL:SETQ VALUE2 (%%VALUE CURSOR2))
      (CL:WHEN (CL:NOT (CL:EQ VALUE2 NULL))
       (CL:IF (COLLECTION-IMPLIES-COLLECTION? VALUE1 VALUE2)
        (CL:SETF (%%VALUE CURSOR2) NULL)
        (CL:WHEN (COLLECTION-IMPLIES-COLLECTION? VALUE2 VALUE1)
         (CL:SETF (%%VALUE CURSOR1) NULL) (CL:RETURN))))
      (CL:SETQ CURSOR2 (%%REST CURSOR2))))
    (CL:SETQ CURSOR1 (%%REST CURSOR1))))
  (CL:SETQ DESCRIPTIONS (REMOVE DESCRIPTIONS NULL))
  DESCRIPTIONS)

;;; (DEFUN (MOST-GENERAL-COLLECTIONS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN MOST-GENERAL-COLLECTIONS (DESCRIPTIONS)
  (CL:WHEN (CL:EQ (%%REST DESCRIPTIONS) NULL)
   (CL:RETURN-FROM MOST-GENERAL-COLLECTIONS DESCRIPTIONS))
  (CL:LET* ((CURSOR1 DESCRIPTIONS) (CURSOR2 NULL) (VALUE1 NULL) (VALUE2 NULL))
   (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR1 NIL)) DO
    (CL:SETQ VALUE1 (%%VALUE CURSOR1))
    (CL:WHEN (CL:NOT (CL:EQ VALUE1 NULL)) (CL:SETQ CURSOR2 (%%REST CURSOR1))
     (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR2 NIL)) DO
      (CL:SETQ VALUE2 (%%VALUE CURSOR2))
      (CL:WHEN (CL:NOT (CL:EQ VALUE2 NULL))
       (CL:IF (COLLECTION-IMPLIES-COLLECTION? VALUE2 VALUE1)
        (CL:SETF (%%VALUE CURSOR2) NULL)
        (CL:WHEN (COLLECTION-IMPLIES-COLLECTION? VALUE1 VALUE2)
         (CL:SETF (%%VALUE CURSOR1) NULL) (CL:RETURN))))
      (CL:SETQ CURSOR2 (%%REST CURSOR2))))
    (CL:SETQ CURSOR1 (%%REST CURSOR1))))
  (CL:SETQ DESCRIPTIONS (REMOVE DESCRIPTIONS NULL))
  DESCRIPTIONS)

;;; (DEFSPECIAL *FINDSUPERSANDSUBSDESCRIPTION* ...)

(CL:DEFVAR *FINDSUPERSANDSUBSDESCRIPTION* NULL
  "Points to a possibly unnamed description being
temporarily classified.")

;;; (DEFUN (NAMED-COLLECTION? BOOLEAN) ...)

(CL:DEFUN NAMED-COLLECTION? (SELF)
  (CL:OR (CL:NOT (CL:EQ (%SURROGATE-VALUE-INVERSE SELF) NULL))
   (CL:EQ SELF *FINDSUPERSANDSUBSDESCRIPTION*)))

;;; (DEFUN (MOST-SPECIFIC-NAMED-COLLECTIONS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN MOST-SPECIFIC-NAMED-COLLECTIONS (DESCRIPTIONS)
  (CL:SETQ DESCRIPTIONS (MOST-SPECIFIC-COLLECTIONS DESCRIPTIONS))
  (CL:LET* ((RECOMPUTE? CL:NIL))
   (CL:LET* ((D NULL) (ITER-000 (COPY-CONS-LIST DESCRIPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ D (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (NAMED-COLLECTION? D))
      (CL:SETQ DESCRIPTIONS (REMOVE DESCRIPTIONS D))
      (CL:LET*
       ((SUPER NULL) (ITER-001 (ALL-DIRECT-SUPERCOLLECTIONS D CL:NIL)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ SUPER (%VALUE ITER-001))
        (CL:SETQ DESCRIPTIONS (CONS SUPER DESCRIPTIONS))))
      (CL:SETQ RECOMPUTE? CL:T))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN RECOMPUTE? (MOST-SPECIFIC-NAMED-COLLECTIONS DESCRIPTIONS))
   DESCRIPTIONS))

;;; (DEFUN (MOST-SPECIFIC-NAMED-DESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN MOST-SPECIFIC-NAMED-DESCRIPTIONS (DESCRIPTIONS)
  (CL:SETQ DESCRIPTIONS (MOST-SPECIFIC-COLLECTIONS DESCRIPTIONS))
  (CL:LET* ((RECOMPUTE? CL:NIL))
   (CL:LET* ((D NULL) (ITER-000 (COPY-CONS-LIST DESCRIPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ D (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (NAMED-DESCRIPTION? D))
      (CL:SETQ DESCRIPTIONS (REMOVE DESCRIPTIONS D))
      (CL:LET*
       ((SUPER NULL) (ITER-001 (ALL-DIRECT-SUPERCOLLECTIONS D CL:NIL)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ SUPER (%VALUE ITER-001))
        (CL:SETQ DESCRIPTIONS (CONS SUPER DESCRIPTIONS))))
      (CL:SETQ RECOMPUTE? CL:T))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:WHEN RECOMPUTE? (MOST-SPECIFIC-NAMED-COLLECTIONS DESCRIPTIONS))
   DESCRIPTIONS))

;;; (DEFCLASS CLASSIFICATION-CACHE ...)

(CL:DEFCLASS CLASSIFICATION-CACHE (STANDARD-OBJECT)
  ((INFERABLE-DIRECT-SUBDESCRIPTIONS :ALLOCATION :INSTANCE :ACCESSOR
    %INFERABLE-DIRECT-SUBDESCRIPTIONS)
   (CACHE-UPCLASSIFICATION-TIMESTAMP :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %CACHE-UPCLASSIFICATION-TIMESTAMP)
   (CACHE-DOWNCLASSIFICATION-TIMESTAMP :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %CACHE-DOWNCLASSIFICATION-TIMESTAMP)
   (INTRODUCTION-TIMESTAMP :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION
    :INSTANCE :ACCESSOR %INTRODUCTION-TIMESTAMP))
  (:DOCUMENTATION "Records various kinds of data about a description
during a classification session."))

(CL:DEFUN NEW-CLASSIFICATION-CACHE ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CLASSIFICATION-CACHE)))
   (CL:SETF (%INTRODUCTION-TIMESTAMP SELF) 0)
   (CL:SETF (%CACHE-DOWNCLASSIFICATION-TIMESTAMP SELF) -1)
   (CL:SETF (%CACHE-UPCLASSIFICATION-TIMESTAMP SELF) -1)
   (CL:SETF (%INFERABLE-DIRECT-SUBDESCRIPTIONS SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CLASSIFICATION-CACHE))
  SGT-CLASSIFY-LOGIC-CLASSIFICATION-CACHE)

(CL:DEFUN ACCESS-CLASSIFICATION-CACHE-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-INFERABLE-DIRECT-SUBDESCRIPTIONS)
    (CL:IF SETVALUE? (CL:SETF (%INFERABLE-DIRECT-SUBDESCRIPTIONS SELF) VALUE)
     (CL:SETQ VALUE (%INFERABLE-DIRECT-SUBDESCRIPTIONS SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-CACHE-UPCLASSIFICATION-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF (%CACHE-UPCLASSIFICATION-TIMESTAMP SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%CACHE-UPCLASSIFICATION-TIMESTAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-CACHE-DOWNCLASSIFICATION-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF (%CACHE-DOWNCLASSIFICATION-TIMESTAMP SELF)
      (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (%CACHE-DOWNCLASSIFICATION-TIMESTAMP SELF)))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP)
    (CL:IF SETVALUE?
     (CL:SETF (%INTRODUCTION-TIMESTAMP SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%INTRODUCTION-TIMESTAMP SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS CLASSIFICATION-SESSION ...)

(CL:DEFCLASS CLASSIFICATION-SESSION (STANDARD-OBJECT)
  ((CLASSIFICATION-WORLD :ALLOCATION :INSTANCE :ACCESSOR
    %CLASSIFICATION-WORLD)
   (CLASSIFICATION-CACHE-TABLE :ALLOCATION :INSTANCE :ACCESSOR
    %CLASSIFICATION-CACHE-TABLE)
   (CLASSIFICATION-TIMECLOCK :TYPE CL:FIXNUM :INITFORM NULL-INTEGER
    :ALLOCATION :INSTANCE :ACCESSOR %CLASSIFICATION-TIMECLOCK)
   (INTRODUCTION-TIMESTAMP-STACK :ALLOCATION :INSTANCE :ACCESSOR
    %INTRODUCTION-TIMESTAMP-STACK)
   (EVERYTHING-CLASSIFIED? :ALLOCATION :INSTANCE :ACCESSOR
    %EVERYTHING-CLASSIFIED?)
   (LAST-CACHE-TABLE-KEY :ALLOCATION :INSTANCE :ACCESSOR
    %LAST-CACHE-TABLE-KEY)
   (LAST-CACHE-TABLE-VALUE :ALLOCATION :INSTANCE :ACCESSOR
    %LAST-CACHE-TABLE-VALUE)))

(CL:DEFUN NEW-CLASSIFICATION-SESSION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE CLASSIFICATION-SESSION)))
   (CL:SETF (%LAST-CACHE-TABLE-VALUE SELF) NULL)
   (CL:SETF (%LAST-CACHE-TABLE-KEY SELF) NULL)
   (CL:SETF (%EVERYTHING-CLASSIFIED? SELF) CL:NIL)
   (CL:SETF (%INTRODUCTION-TIMESTAMP-STACK SELF) (LIST (WRAP-INTEGER 0)))
   (CL:SETF (%CLASSIFICATION-TIMECLOCK SELF) 0)
   (CL:SETF (%CLASSIFICATION-CACHE-TABLE SELF) (NEW-HASH-TABLE))
   (CL:SETF (%CLASSIFICATION-WORLD SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF CLASSIFICATION-SESSION))
  SGT-CLASSIFY-LOGIC-CLASSIFICATION-SESSION)

(CL:DEFUN ACCESS-CLASSIFICATION-SESSION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-CLASSIFICATION-WORLD)
    (CL:IF SETVALUE? (CL:SETF (%CLASSIFICATION-WORLD SELF) VALUE)
     (CL:SETQ VALUE (%CLASSIFICATION-WORLD SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-CLASSIFICATION-CACHE-TABLE)
    (CL:IF SETVALUE? (CL:SETF (%CLASSIFICATION-CACHE-TABLE SELF) VALUE)
     (CL:SETQ VALUE (%CLASSIFICATION-CACHE-TABLE SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-CLASSIFICATION-TIMECLOCK)
    (CL:IF SETVALUE?
     (CL:SETF (%CLASSIFICATION-TIMECLOCK SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%CLASSIFICATION-TIMECLOCK SELF)))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP-STACK)
    (CL:IF SETVALUE? (CL:SETF (%INTRODUCTION-TIMESTAMP-STACK SELF) VALUE)
     (CL:SETQ VALUE (%INTRODUCTION-TIMESTAMP-STACK SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-EVERYTHING-CLASSIFIED?)
    (CL:IF SETVALUE?
     (CL:SETF (%EVERYTHING-CLASSIFIED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%EVERYTHING-CLASSIFIED? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-KEY)
    (CL:IF SETVALUE? (CL:SETF (%LAST-CACHE-TABLE-KEY SELF) VALUE)
     (CL:SETQ VALUE (%LAST-CACHE-TABLE-KEY SELF))))
   ((CL:EQ SLOTNAME SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%LAST-CACHE-TABLE-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%LAST-CACHE-TABLE-VALUE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFSPECIAL *CLASSIFICATIONSESSION* ...)

(CL:DEFVAR *CLASSIFICATIONSESSION* NULL
  "Points to state of on-going classification session.")

;;; (DEFUN (GET-CLASSIFICATION-WORLD WORLD) ...)

(CL:DEFUN GET-CLASSIFICATION-WORLD ()
  (%CLASSIFICATION-WORLD *CLASSIFICATIONSESSION*))

;;; (DEFUN (GET-CLASSIFICATION-SESSION CLASSIFICATION-SESSION) ...)

(CL:DEFUN GET-CLASSIFICATION-SESSION (INSTANCEORDESCRIPTION)
  (CL:WHEN (CL:NOT (CL:EQ *CLASSIFICATIONSESSION* NULL))
   (CL:RETURN-FROM GET-CLASSIFICATION-SESSION *CLASSIFICATIONSESSION*))
  (CL:LET* ((WORLD NULL) (SESSION NULL))
   (CL:COND
    ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-DESCRIPTION)
     (CL:SETQ WORLD (GET-INFERENCE-CACHE *MODULE* KWD-CLASSIFY-META)))
    ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-INSTANCE)
     (CL:SETQ WORLD (GET-INFERENCE-CACHE *MODULE* KWD-CLASSIFY-TMS)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" INSTANCEORDESCRIPTION
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:SETQ SESSION
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
     SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL))
   (CL:WHEN (CL:EQ SESSION NULL)
    (CL:SETQ SESSION (NEW-CLASSIFICATION-SESSION))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
     SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION SESSION NULL)
    (CL:SETF (%CLASSIFICATION-WORLD SESSION) WORLD))
   SESSION))

;;; (DEFUN (GET-CLASSIFICATION-CACHE CLASSIFICATION-CACHE) ...)

(CL:DEFUN GET-CLASSIFICATION-CACHE (SELF)
  (CL:LET* ((SESSION *CLASSIFICATIONSESSION*) (CACHE NULL))
   (CL:WHEN (CL:EQ (%LAST-CACHE-TABLE-KEY SESSION) SELF)
    (CL:RETURN-FROM GET-CLASSIFICATION-CACHE
     (%LAST-CACHE-TABLE-VALUE SESSION)))
   (CL:SETQ CACHE (LOOKUP (%CLASSIFICATION-CACHE-TABLE SESSION) SELF))
   (CL:WHEN (CL:EQ CACHE NULL) (CL:SETQ CACHE (NEW-CLASSIFICATION-CACHE))
    (INSERT-AT (%CLASSIFICATION-CACHE-TABLE SESSION) SELF CACHE))
   (CL:SETF (%LAST-CACHE-TABLE-KEY SESSION) SELF)
   (CL:SETF (%LAST-CACHE-TABLE-VALUE SESSION) CACHE) CACHE))

;;; (DEFGLOBAL *CACHE-INFERABLE-SUBCOLLECTIONS?* ...)

(CL:DEFVAR *CACHE-INFERABLE-SUBCOLLECTIONS?* CL:T
  "If TRUE, prevents caching of computations of
all inferable subcollections of a collection.")

;;; (DEFUN (TOGGLE-INFERABLE-DIRECT-SUBCOLLECTIONS-CACHING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:SIMPLE-STRING)
  TOGGLE-INFERABLE-DIRECT-SUBCOLLECTIONS-CACHING))
(CL:DEFUN TOGGLE-INFERABLE-DIRECT-SUBCOLLECTIONS-CACHING ()
  (CL:SETQ *CACHE-INFERABLE-SUBCOLLECTIONS?*
   (CL:NOT *CACHE-INFERABLE-SUBCOLLECTIONS?*))
  (CL:IF *CACHE-INFERABLE-SUBCOLLECTIONS?*
   "Inferable subcollections caching enabled"
   "Inferable subcollections caching disabled"))

;;; (DEFUN (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS (LIST OF DESCRIPTION)) ...)

(CL:DEFUN ALL-INFERABLE-DIRECT-SUBCOLLECTIONS (SELF)
  (CL:LET*
   ((CACHE (GET-CLASSIFICATION-CACHE SELF))
    (LIST (%INFERABLE-DIRECT-SUBDESCRIPTIONS CACHE)))
   (CL:WHEN
    (CL:OR (CL:EQ LIST NULL) (CL:NOT *CACHE-INFERABLE-SUBCOLLECTIONS?*))
    (CL:SETQ LIST (NEW-LIST))
    (CL:LET* ((SUB NULL) (ITER-000 (ALL-NAMED-DIRECT-SUBDESCRIPTIONS SELF)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ SUB (%%VALUE ITER-000))
      (CL:WHEN (INFERABLE? SUB) (INSERT LIST SUB))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETF (%INFERABLE-DIRECT-SUBDESCRIPTIONS CACHE) LIST))
   LIST))

;;; (DEFUN FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE ...)

(CL:DEFUN FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE (IMPLIESPROPOSITION)
  (CL:WHEN (CL:EQ *CLASSIFICATIONSESSION* NULL)
   (CL:RETURN-FROM FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE))
  (CL:LET*
   ((CACHE
     (GET-CLASSIFICATION-CACHE
      (CL:AREF
       (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS IMPLIESPROPOSITION)))
       1))))
   (CL:WHEN (CL:NOT (CL:EQ CACHE NULL))
    (CL:SETF (%INFERABLE-DIRECT-SUBDESCRIPTIONS CACHE) NULL))))

;;; (DEFUN (CURRENT-CLASSIFICATION-TIME TIMESTAMP) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION () CL:FIXNUM) CURRENT-CLASSIFICATION-TIME))
(CL:DEFUN CURRENT-CLASSIFICATION-TIME ()
  (%CLASSIFICATION-TIMECLOCK *CLASSIFICATIONSESSION*))

;;; (DEFUN (BUMP-CLASSIFICATION-TIMECLOCK TIMESTAMP) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:FIXNUM) BUMP-CLASSIFICATION-TIMECLOCK))
(CL:DEFUN BUMP-CLASSIFICATION-TIMECLOCK ()
  (CL:SETF (%CLASSIFICATION-TIMECLOCK *CLASSIFICATIONSESSION*)
   (CL:1+ (%CLASSIFICATION-TIMECLOCK *CLASSIFICATIONSESSION*))))

;;; (DEFMETHOD (INTRODUCTION-TIMESTAMP TIMESTAMP) ...)

(CL:DEFMETHOD INTRODUCTION-TIMESTAMP ((SELF LOGIC-OBJECT))
  (%INTRODUCTION-TIMESTAMP (GET-CLASSIFICATION-CACHE SELF)))

;;; (DEFUN INTRODUCE-INTO-CLASSIFICATION-SESSION ...)

(CL:DEFUN INTRODUCE-INTO-CLASSIFICATION-SESSION (SELF)
  (CL:LET*
   ((WORLD
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *MODULE*)
      SYM-CLASSIFY-LOGIC-META-INFERENCE-CACHE NULL)))
   (CL:WHEN
    (CL:OR (CL:EQ WORLD NULL)
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
       SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL)
      NULL))
    (CL:RETURN-FROM INTRODUCE-INTO-CLASSIFICATION-SESSION))
   (CL:LET* ((NEWTIMESTAMP (BUMP-CLASSIFICATION-TIMECLOCK)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM NEWTIMESTAMP))
    (CL:SETF (%INTRODUCTION-TIMESTAMP (GET-CLASSIFICATION-CACHE SELF))
     NEWTIMESTAMP)
    (PUSH (%INTRODUCTION-TIMESTAMP-STACK *CLASSIFICATIONSESSION*)
     (WRAP-INTEGER NEWTIMESTAMP)))))

;;; (DEFUN (YOUNGEST-INTRODUCTION-TIMESTAMP INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:FIXNUM) YOUNGEST-INTRODUCTION-TIMESTAMP))
(CL:DEFUN YOUNGEST-INTRODUCTION-TIMESTAMP ()
  (%WRAPPER-VALUE
   (FIRST (%INTRODUCTION-TIMESTAMP-STACK *CLASSIFICATIONSESSION*))))

;;; (DEFUN (UPCLASSIFICATION-TIMESTAMP INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) UPCLASSIFICATION-TIMESTAMP))
(CL:DEFUN UPCLASSIFICATION-TIMESTAMP (SELF)
  (%CACHE-UPCLASSIFICATION-TIMESTAMP (GET-CLASSIFICATION-CACHE SELF)))

;;; (DEFUN (DOWNCLASSIFICATION-TIMESTAMP INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) DOWNCLASSIFICATION-TIMESTAMP))
(CL:DEFUN DOWNCLASSIFICATION-TIMESTAMP (SELF)
  (%CACHE-DOWNCLASSIFICATION-TIMESTAMP (GET-CLASSIFICATION-CACHE SELF)))

;;; (DEFUN REFRESH-UPCLASSIFICATION-TIMESTAMP ...)

(CL:DEFUN REFRESH-UPCLASSIFICATION-TIMESTAMP (SELF)
  (CL:SETF (%CACHE-UPCLASSIFICATION-TIMESTAMP (GET-CLASSIFICATION-CACHE SELF))
   (BUMP-CLASSIFICATION-TIMECLOCK)))

;;; (DEFUN REFRESH-DOWNCLASSIFICATION-TIMESTAMP ...)

(CL:DEFUN REFRESH-DOWNCLASSIFICATION-TIMESTAMP (SELF)
  (CL:SETF
   (%CACHE-DOWNCLASSIFICATION-TIMESTAMP (GET-CLASSIFICATION-CACHE SELF))
   (BUMP-CLASSIFICATION-TIMECLOCK)))

;;; (DEFUN FLUSH-CLASSIFICATION-SESSIONS ...)

(CL:DEFUN FLUSH-CLASSIFICATION-SESSIONS ()
  (CL:LET*
   ((JITWORLD (LOOKUP-INFERENCE-CACHE *MODULE* KWD-CLASSIFY-JUST-IN-TIME))
    (METAWORLD (LOOKUP-INFERENCE-CACHE *MODULE* KWD-CLASSIFY-META))
    (TMSWORLD (LOOKUP-INFERENCE-CACHE *MODULE* KWD-CLASSIFY-TMS)))
   (CL:WHEN (CL:NOT (CL:EQ JITWORLD NULL))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS JITWORLD)
     SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL NULL))
   (CL:WHEN (CL:NOT (CL:EQ METAWORLD NULL))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS METAWORLD)
     SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL NULL))
   (CL:WHEN (CL:NOT (CL:EQ TMSWORLD NULL))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS TMSWORLD)
     SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION NULL NULL))))

;;; (DEFUN (UPCLASSIFIED? BOOLEAN) ...)

(CL:DEFUN UPCLASSIFIED? (SELF)
  (> (UPCLASSIFICATION-TIMESTAMP SELF) (YOUNGEST-INTRODUCTION-TIMESTAMP)))

;;; (DEFUN (UPCLASSIFIED-LATER-THAN? BOOLEAN) ...)

(CL:DEFUN UPCLASSIFIED-LATER-THAN? (SELF OTHER)
  (> (UPCLASSIFICATION-TIMESTAMP SELF) (INTRODUCTION-TIMESTAMP OTHER)))

;;; (DEFUN (DOWNCLASSIFIED? BOOLEAN) ...)

(CL:DEFUN DOWNCLASSIFIED? (SELF)
  (CL:OR (NON-INFERABLE? SELF)
   (CL:> (DOWNCLASSIFICATION-TIMESTAMP SELF)
    (YOUNGEST-INTRODUCTION-TIMESTAMP))))

;;; (DEFUN MARK-UNMARKED-SUPERRELATIONS ...)

(CL:DEFUN MARK-UNMARKED-SUPERRELATIONS (DESCRIPTION SELFISBELOWTABLE)
  (SET-MARKER SELFISBELOWTABLE DESCRIPTION)
  (CL:LET*
   ((SUPER NULL)
    (ITER-000 (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS DESCRIPTION CL:T)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ SUPER (%%VALUE ITER-000))
    (CL:WHEN (CL:NOT (TEST-MARKER? SELFISBELOWTABLE DESCRIPTION))
     (MARK-UNMARKED-SUPERRELATIONS SUPER SELFISBELOWTABLE))
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN (APPLY-SUBSUMPTION-TEST? BOOLEAN) ...)

(CL:DEFUN APPLY-SUBSUMPTION-TEST? (SUBSUMPTIONTEST SELF SUPER)
  (CL:LET* ((RESULT (CL:FUNCALL SUBSUMPTIONTEST SELF SUPER)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (CL:OR (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER)
      (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER-PROFILE)))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   SPECIALIZES?:  "
     RESULT "  self=" SELF " super=" SUPER EOL))
   (CL:OR (CL:EQ RESULT TRUE-TRUTH-VALUE)
    (CL:EQ RESULT DEFAULT-TRUE-TRUTH-VALUE))))

;;; (DEFUN (HELP-COLLECT-PARENTS-BELOW? BOOLEAN) ...)

(CL:DEFUN HELP-COLLECT-PARENTS-BELOW? (SELF SUPER NEWPARENTDESCRIPTIONS ALREADYVISITEDTABLE SELFISBELOWTABLE SUBSUMPTIONTEST)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "HELP-COLLECT-PARENTS-BELOW  self= " SELF "    super= " SUPER EOL))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "   TEST-MARKER of 'super': " (TEST-MARKER? SELFISBELOWTABLE SUPER) EOL))
  (CL:LET* ((FOUNDSUBSUMINGSUB? CL:NIL))
   (SET-MARKER ALREADYVISITEDTABLE SUPER)
   (CL:COND
    ((TEST-MARKER? SELFISBELOWTABLE SUPER) (CL:SETQ FOUNDSUBSUMINGSUB? CL:T)
     (CL:LET*
      ((SUB NULL)
       (ITER-000
        (%THE-CONS-LIST (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS SUPER))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SUB (%%VALUE ITER-000))
       (CL:WHEN (CL:NOT (TEST-MARKER? ALREADYVISITEDTABLE SUB))
        (HELP-COLLECT-PARENTS-BELOW? SELF SUB NEWPARENTDESCRIPTIONS
         ALREADYVISITEDTABLE SELFISBELOWTABLE SUBSUMPTIONTEST))
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    ((CL:AND (CL:NOT (UPCLASSIFIED-LATER-THAN? SELF SUPER))
      (APPLY-SUBSUMPTION-TEST? SUBSUMPTIONTEST SELF SUPER))
     (CL:SETQ FOUNDSUBSUMINGSUB? CL:T)
     (MARK-UNMARKED-SUPERRELATIONS SUPER SELFISBELOWTABLE)
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET*
       ((SUB NULL)
        (ITER-001
         (%THE-CONS-LIST (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS SUPER))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ SUB (%%VALUE ITER-001))
        (CL:WHEN
         (CL:AND (CL:NOT (TEST-MARKER? ALREADYVISITEDTABLE SUB))
          (HELP-COLLECT-PARENTS-BELOW? SELF SUB NEWPARENTDESCRIPTIONS
           ALREADYVISITEDTABLE SELFISBELOWTABLE SUBSUMPTIONTEST))
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CL:LET* ((EXISTSMORESPECIFICSUB? FOUND?-000))
       (CL:WHEN (CL:NOT EXISTSMORESPECIFICSUB?)
        (CL:WHEN
         (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
          (CL:OR (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER)
           (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER-PROFILE)))
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL
          "XXXXXXX PUSHING NEW PARENT: " SUPER "  of " SELF EOL EOL))
        (PUSH NEWPARENTDESCRIPTIONS SUPER)))))
    (CL:T))
   FOUNDSUBSUMINGSUB?))

;;; (DEFUN COLLECT-SUBSUMING-PARENTS-BELOW ...)

(CL:DEFUN COLLECT-SUBSUMING-PARENTS-BELOW (SELF SUPER NEWPARENTDESCRIPTIONS ALREADYVISITEDTABLE SELFISBELOWTABLE SUBSUMPTIONTEST)
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
    "COLLECT-SUBSUMING  self= " SELF "    super= " SUPER EOL))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   ALL-INFERABLE-SUBS:  "
    (CONS-LIST (LISTIFY (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS SUPER))) EOL))
  (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
   (CL:LET*
    ((SUB NULL)
     (ITER-000 (%THE-CONS-LIST (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS SUPER))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ SUB (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (TEST-MARKER? ALREADYVISITEDTABLE SUB))
      (HELP-COLLECT-PARENTS-BELOW? SELF SUB NEWPARENTDESCRIPTIONS
       ALREADYVISITEDTABLE SELFISBELOWTABLE SUBSUMPTIONTEST))
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN (ALL-ANCESTORS-OF-PARENTS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-ANCESTORS-OF-PARENTS (SUPERS)
  (CL:LET* ((COLLECTION (COPY-CONS-LIST SUPERS)))
   (CL:LET* ((S NULL) (ITER-000 SUPERS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ S (%%VALUE ITER-000))
     (CL:LET* ((A NULL) (ITER-001 (ALL-SUPERCOLLECTIONS S)))
      (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ A (%VALUE ITER-001))
       (CL:WHEN (CL:NOT (MEMBER? SUPERS A))
        (CL:SETQ COLLECTION (CONS A COLLECTION)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (ALLOCATE-ITERATOR COLLECTION)))

;;; (DEFUN (ALL-ANCESTOR-COLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-ANCESTOR-COLLECTIONS (SELF INSTANCEORDESCRIPTION)
  (CL:COND
   ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-INSTANCE)
    (ALL-ANCESTORS-OF-PARENTS (ALL-ISA-COLLECTIONS SELF)))
   ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-DESCRIPTION)
    (ALL-SUPERCOLLECTIONS SELF))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" INSTANCEORDESCRIPTION
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFSPECIAL *CLASSIFY-FROM-NON-INFERABLE-PARENTS-ONLY?* ...)

(CL:DEFVAR *CLASSIFY-FROM-NON-INFERABLE-PARENTS-ONLY?* CL:T
  "If true (the default) only consider those relations (or instances) for
classification that have at least one non-inferable parent (or type).  This
can greatly reduce the classification effort.  To find entities that were
left unclassified due to this optimization use `list-unclassified-relations'
or `list-unclassified-instances'.")

;;; (DEFUN HELP-UPCLASSIFY-ONE-ENTITY ...)

(CL:DEFUN HELP-UPCLASSIFY-ONE-ENTITY (SELF INSTANCEORDESCRIPTION)
  (CL:WHEN (UPCLASSIFIED? SELF) (CL:RETURN-FROM HELP-UPCLASSIFY-ONE-ENTITY))
  (CL:LET*
   ((ALREADYVISITEDTABLE (CREATE-MARKER-STORAGE CL:NIL))
    (INSTANCEISBELOWTABLE (CREATE-MARKER-STORAGE CL:NIL))
    (NEWPARENTDESCRIPTIONS (NEW-LIST)))
   (SET-MARKER INSTANCEISBELOWTABLE SELF)
   (CL:LET*
    ((SUPER NULL)
     (ITER-000 (ALL-ANCESTOR-COLLECTIONS SELF INSTANCEORDESCRIPTION)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ SUPER (%VALUE ITER-000))
     (SET-MARKER INSTANCEISBELOWTABLE SUPER)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   WORLD: " *CONTEXT*
     "  self: " SELF EOL "   ANCESTORS: "
     (CONSIFY (ALL-ANCESTOR-COLLECTIONS SELF INSTANCEORDESCRIPTION)) EOL))
   (CL:LET*
    ((SUPER NULL)
     (ITER-001 (ALL-ANCESTOR-COLLECTIONS SELF INSTANCEORDESCRIPTION)))
    (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ SUPER (%VALUE ITER-001))
     (CL:WHEN
      (CL:AND (ISA? SUPER SGT-CLASSIFY-LOGIC-DESCRIPTION)
       (CL:OR (CL:NOT *CLASSIFY-FROM-NON-INFERABLE-PARENTS-ONLY?*)
        (NON-INFERABLE? SUPER))
       (CL:NOT (TEST-MARKER? ALREADYVISITEDTABLE SUPER)))
      (SET-MARKER ALREADYVISITEDTABLE SUPER)
      (COLLECT-SUBSUMING-PARENTS-BELOW SELF SUPER NEWPARENTDESCRIPTIONS
       ALREADYVISITEDTABLE INSTANCEISBELOWTABLE
       (CL:IF (CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-INSTANCE)
        (CL:FUNCTION INSTANCE-SATISFIES-DESCRIPTION?)
        (CL:FUNCTION DESCRIPTION-SPECIALIZES-DESCRIPTION?))))))
   (CL:LET*
    ((PD NULL)
     (ITER-002
      (MOST-SPECIFIC-NAMED-COLLECTIONS
       (%THE-CONS-LIST NEWPARENTDESCRIPTIONS))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ PD (%%VALUE ITER-002))
     (CL:COND
      ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-INSTANCE)
       (ADD-ISA-LINK SELF PD))
      ((CL:EQ INSTANCEORDESCRIPTION KWD-CLASSIFY-DESCRIPTION)
       (ADD-SUBSUMPTION-LINK SELF PD))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" INSTANCEORDESCRIPTION
         "' is not a valid case option")
        (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (REFRESH-UPCLASSIFICATION-TIMESTAMP SELF)))

;;; (DEFUN UPCLASSIFY-ONE-INSTANCE ...)

(CL:DEFUN UPCLASSIFY-ONE-INSTANCE (SELF)
  (CL:WHEN (UPCLASSIFIED? SELF) (CL:RETURN-FROM UPCLASSIFY-ONE-INSTANCE))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:OR (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER)
     (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER-PROFILE)))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "UPCLASSIFY:  " SELF EOL))
  (EMIT-THINKING-DOT KWD-CLASSIFY-UPCLASSIFY)
  (HELP-UPCLASSIFY-ONE-ENTITY SELF KWD-CLASSIFY-INSTANCE))

;;; (DEFUN UPCLASSIFY-ONE-DESCRIPTION ...)

(CL:DEFUN UPCLASSIFY-ONE-DESCRIPTION (SELF)
  (CL:WHEN
   (CL:OR (UPCLASSIFIED? SELF)
    (CL:NOT (ISA? SELF SGT-CLASSIFY-LOGIC-DESCRIPTION)))
   (CL:RETURN-FROM UPCLASSIFY-ONE-DESCRIPTION))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
    (CL:OR (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER)
     (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER-PROFILE)))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "UPCLASSIFY: " SELF EOL))
  (EMIT-THINKING-DOT KWD-CLASSIFY-UPCLASSIFY)
  (CL:LET* ((EQUIVALENTS (ALL-EQUIVALENT-COLLECTIONS SELF CL:T)))
   (CL:LET* ((E NULL) (ITER-000 EQUIVALENTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ E (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (NAMED-DESCRIPTION? E))
      (CL:LET*
       ((PD NULL) (ITER-001 (%THE-CONS-LIST (ALL-INTENSIONAL-PARENTS E))))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ PD (%%VALUE ITER-001)) (ADD-SUBSUMPTION-LINK SELF PD)
        (CL:SETQ ITER-001 (%%REST ITER-001)))))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  (CL:LET*
   ((SUPER NULL) (ITER-002 (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS SELF CL:T)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
    (CL:SETQ SUPER (%%VALUE ITER-002)) (UPCLASSIFY-ONE-DESCRIPTION SUPER)
    (CL:SETQ ITER-002 (%%REST ITER-002))))
  (HELP-UPCLASSIFY-ONE-ENTITY SELF KWD-CLASSIFY-DESCRIPTION))

;;; (DEFUN HELP-DOWNCLASSIFY-ONE-DESCRIPTION ...)

(CL:DEFUN HELP-DOWNCLASSIFY-ONE-DESCRIPTION (NODE SELF NECESSARYANCESTORS ALREADYVISITEDTABLE)
  (CL:WHEN
   (CL:OR (TEST-MARKER? ALREADYVISITEDTABLE NODE)
    (COLLECTION-IMPLIES-COLLECTION? NODE SELF))
   (CL:RETURN-FROM HELP-DOWNCLASSIFY-ONE-DESCRIPTION))
  (SET-MARKER ALREADYVISITEDTABLE NODE)
  (CL:LET* ((NODECOULDBETHEONE? CL:T))
   (CL:COND
    ((CL:= (UPCLASSIFICATION-TIMESTAMP NODE) -1)
     (UPCLASSIFY-ONE-DESCRIPTION NODE))
    ((CL:NOT (UPCLASSIFIED-LATER-THAN? NODE SELF))
     (CL:LET* ((FOUND?-000 CL:NIL))
      (CL:LET* ((ANCESTOR NULL) (ITER-000 NECESSARYANCESTORS))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ ANCESTOR (%%VALUE ITER-000))
        (CL:WHEN
         (CL:AND (UPCLASSIFIED-LATER-THAN? NODE ANCESTOR)
          (CL:NOT (COLLECTION-IMPLIES-COLLECTION? NODE ANCESTOR)))
         (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:IF FOUND?-000 (CL:SETQ NODECOULDBETHEONE? CL:NIL)
       (UPCLASSIFY-ONE-DESCRIPTION NODE)))))
   (CL:WHEN
    (CL:AND NODECOULDBETHEONE? (COLLECTION-IMPLIES-COLLECTION? NODE SELF))
    (CL:RETURN-FROM HELP-DOWNCLASSIFY-ONE-DESCRIPTION))
   (CL:LET*
    ((SUBNODE NULL) (ITER-001 (ALL-NAMED-DIRECT-SUBDESCRIPTIONS NODE)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ SUBNODE (%%VALUE ITER-001))
     (HELP-DOWNCLASSIFY-ONE-DESCRIPTION SUBNODE SELF NECESSARYANCESTORS
      ALREADYVISITEDTABLE)
     (CL:SETQ ITER-001 (%%REST ITER-001))))))

;;; (DEFUN (COLLECTION-WITH-FEWEST-CHILDREN LOGIC-OBJECT) ...)

(CL:DEFUN COLLECTION-WITH-FEWEST-CHILDREN (COLLECTIONS)
  (CL:WHEN (CL:EQ (%%REST COLLECTIONS) NULL)
   (CL:RETURN-FROM COLLECTION-WITH-FEWEST-CHILDREN (%%VALUE COLLECTIONS)))
  (CL:LET* ((BESTCOLLECTION (%%VALUE COLLECTIONS)) (LOWESTCHILDCOUNT 100))
   (CL:DECLARE (CL:TYPE CL:FIXNUM LOWESTCHILDCOUNT))
   (CL:LET* ((C NULL) (ITER-000 COLLECTIONS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ C (%%VALUE ITER-000))
     (CL:LET* ((CHILDCOUNT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM CHILDCOUNT))
      (CL:LET*
       ((P
         (ALLOCATE-ITERATOR
          (APPLICABLE-RULES-OF-DESCRIPTION C KWD-CLASSIFY-BACKWARD CL:T))))
       (CL:LOOP WHILE (NEXT? P) DO (CL:SETQ CHILDCOUNT (CL:1+ CHILDCOUNT))))
      (CL:WHEN (CL:< CHILDCOUNT LOWESTCHILDCOUNT) (CL:SETQ BESTCOLLECTION C)
       (CL:SETQ LOWESTCHILDCOUNT CHILDCOUNT)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   BESTCOLLECTION))

;;; (DEFUN (CHOOSE-BEST-DOWNCLASSIFIED-PARENT LOGIC-OBJECT) ...)

(CL:DEFUN CHOOSE-BEST-DOWNCLASSIFIED-PARENT (PARENTS)
  (CL:WHEN (CL:EQ PARENTS NIL)
   (CL:RETURN-FROM CHOOSE-BEST-DOWNCLASSIFIED-PARENT NULL))
  (CL:LET* ((DOWNCLASSIFIEDPARENTS NIL) (BESTPARENT NULL))
   (CL:LET* ((P NULL) (ITER-000 PARENTS) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ P (%%VALUE ITER-000))
     (CL:WHEN (DOWNCLASSIFIED? P) (CL:PROGN)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS P NIL))
        (CL:IF (CL:EQ DOWNCLASSIFIEDPARENTS NIL)
         (CL:SETQ DOWNCLASSIFIEDPARENTS COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST DOWNCLASSIFIEDPARENTS COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS P NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:CASE (LENGTH DOWNCLASSIFIEDPARENTS)
    (0
     (CL:LET* ((NAMEDPARENTS NIL))
      (CL:LET* ((P NULL) (ITER-001 PARENTS) (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ P (%%VALUE ITER-001))
        (CL:WHEN (NAMED-DESCRIPTION? P)
         (CL:IF (CL:EQ COLLECT-001 NULL)
          (CL:PROGN (CL:SETQ COLLECT-001 (CONS P NIL))
           (CL:IF (CL:EQ NAMEDPARENTS NIL) (CL:SETQ NAMEDPARENTS COLLECT-001)
            (ADD-CONS-TO-END-OF-CONS-LIST NAMEDPARENTS COLLECT-001)))
          (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS P NIL))
           (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CL:WHEN (CL:NOT (CL:EQ NAMEDPARENTS NIL))
       (CL:SETQ BESTPARENT (COLLECTION-WITH-FEWEST-CHILDREN NAMEDPARENTS)))
      (CL:WHEN (CL:EQ BESTPARENT NULL)
       (CL:SETQ BESTPARENT (COLLECTION-WITH-FEWEST-CHILDREN PARENTS)))
      (DOWNCLASSIFY-ONE-DESCRIPTION BESTPARENT)))
    (1 (CL:SETQ BESTPARENT (%%VALUE DOWNCLASSIFIEDPARENTS)))
    (CL:OTHERWISE
     (CL:SETQ BESTPARENT
      (COLLECTION-WITH-FEWEST-CHILDREN DOWNCLASSIFIEDPARENTS))))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
     (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   BEST PARENT:   "
     BESTPARENT "   ALL-PARENTS: " PARENTS EOL))
   BESTPARENT))

;;; (DEFUN DOWNCLASSIFY-ONE-DESCRIPTION ...)

(CL:DEFUN DOWNCLASSIFY-ONE-DESCRIPTION (SELF)
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-DESCRIPTION)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION*))
   (CL:WHEN (CL:NOT (DOWNCLASSIFIED? SELF))
    (CL:WHEN (NON-INFERABLE? SELF) (REFRESH-DOWNCLASSIFICATION-TIMESTAMP SELF)
     (CL:RETURN-FROM DOWNCLASSIFY-ONE-DESCRIPTION))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
      (CL:OR (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER)
       (MEMB? *TRACED-KEYWORDS* KWD-CLASSIFY-CLASSIFIER-PROFILE)))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "DOWNCLASSIFY-ONE-DESCRIPTION:  " SELF EOL))
    (EMIT-THINKING-DOT KWD-CLASSIFY-DOWNCLASSIFY)
    (CL:LET*
     ((ALREADYVISITEDTABLE (CREATE-MARKER-STORAGE CL:NIL))
      (PARENTS (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS SELF CL:NIL))
      (BESTPARENT (CHOOSE-BEST-DOWNCLASSIFIED-PARENT PARENTS))
      (OTHERPARENTS (REMOVE PARENTS BESTPARENT)))
     (SET-MARKER ALREADYVISITEDTABLE SELF)
     (CL:WHEN (CL:NOT (CL:EQ BESTPARENT NULL))
      (CL:LET*
       ((CHILD NULL) (ITER-000 (ALL-NAMED-DIRECT-SUBDESCRIPTIONS BESTPARENT)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ CHILD (%%VALUE ITER-000))
        (HELP-DOWNCLASSIFY-ONE-DESCRIPTION CHILD SELF OTHERPARENTS
         ALREADYVISITEDTABLE)
        (CL:SETQ ITER-000 (%%REST ITER-000))))))
    (REFRESH-DOWNCLASSIFICATION-TIMESTAMP SELF))))

;;; (DEFMETHOD (VIRGIN? BOOLEAN) ...)

(CL:DEFMETHOD VIRGIN? ((SELF DESCRIPTION))
  (CL:AND (EMPTY? (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))
   (CL:NOT (NAMED-COLLECTION? SELF))))

;;; (DEFUN EVAPORATE-VIRGIN ...)

(CL:DEFUN EVAPORATE-VIRGIN (SELF)
  (CL:LET*
   ((PARENTIMPLIES (NEW-LIST)) (CHILDIMPLIES (NEW-LIST)) (PARENT NULL)
    (CHILD NULL) (BRIDGEPROP NULL))
   (CL:LET*
    ((P NULL)
     (ITER-000
      (ALLOCATE-ITERATOR (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (CL:IF
      (CL:EQ (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS P))) 0)
       SELF)
      (PUSH PARENTIMPLIES P) (PUSH CHILDIMPLIES P))))
   (CL:LET* ((CP NULL) (ITER-001 (%THE-CONS-LIST CHILDIMPLIES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ CP (%%VALUE ITER-001))
     (CL:SETQ CHILD
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS CP))) 0))
     (CL:LET* ((PP NULL) (ITER-002 (%THE-CONS-LIST PARENTIMPLIES)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
       (CL:SETQ PP (%%VALUE ITER-002))
       (CL:SETQ PARENT
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PP))) 1))
       (CL:SETQ BRIDGEPROP
        (ASSERT-DESCRIPTION-IMPLIES-DESCRIPTION CHILD PARENT CL:T))
       (CL:WHEN
        (CL:AND
         (%WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CP)
           SYM-CLASSIFY-LOGIC-SUBRELATION-LINK? FALSE-WRAPPER))
         (%WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PP)
           SYM-CLASSIFY-LOGIC-SUBRELATION-LINK? FALSE-WRAPPER)))
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS BRIDGEPROP)
         SYM-CLASSIFY-LOGIC-SUBRELATION-LINK? TRUE-WRAPPER FALSE-WRAPPER))
       (UPDATE-PROPOSITION-TRUTH-VALUE BRIDGEPROP KWD-CLASSIFY-ASSERT-TRUE)
       (CL:SETQ ITER-002 (%%REST ITER-002))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET*
    ((P NULL)
     (ITER-003
      (ALLOCATE-ITERATOR (UNFILTERED-DEPENDENT-PROPOSITIONS SELF NULL))))
    (CL:LOOP WHILE (NEXT? ITER-003) DO (CL:SETQ P (%VALUE ITER-003))
     (DESTROY-PROPOSITION P)))))

;;; (DEFUN (FIND-DIRECT-SUPERS-AND-SUBS (CONS OF DESCRIPTION) (CONS OF DESCRIPTION) (CONS OF DESCRIPTION)) ...)

(CL:DEFUN FIND-DIRECT-SUPERS-AND-SUBS (SELF ONLYSUPERS?)
  "Classify 'self' and return three values, its direct
supers, direct subs, and a list of equivalent descriptions.
Setting 'supersOnly?' may speed up the computation (perhaps by a lot).
If 'description' is nameless and has no dependent propositions, then
it is automatically removed from the hierarchy after classification."
  (FINALIZE-OBJECTS)
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM FIND-DIRECT-SUPERS-AND-SUBS (CL:VALUES NIL NIL NIL)))
  (CL:LET* ((*FINDSUPERSANDSUBSDESCRIPTION* SELF))
   (CL:DECLARE (CL:SPECIAL *FINDSUPERSANDSUBSDESCRIPTION*))
   (CL:LET*
    ((*CLASSIFICATIONSESSION*
      (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-DESCRIPTION))
     (*CONTEXT* (%CLASSIFICATION-WORLD *CLASSIFICATIONSESSION*)))
    (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
    (CL:LET*
     ((VIRGIN? (VIRGIN? SELF)) (OLDCURRENTTIME (CURRENT-CLASSIFICATION-TIME))
      (SUPERS NIL) (SUBS NIL) (EQUIVALENTS NIL))
     (CL:DECLARE (CL:TYPE CL:FIXNUM OLDCURRENTTIME))
     (CL:WHEN VIRGIN? (INTRODUCE-INTO-CLASSIFICATION-SESSION SELF))
     (UPCLASSIFY-ONE-DESCRIPTION SELF)
     (CL:LET*
      ((SUPER NULL)
       (ITER-000 (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS SELF CL:NIL)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ SUPER (%%VALUE ITER-000)) (UPCLASSIFY-ONE-DESCRIPTION SUPER)
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:SETQ SUPERS (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS SELF CL:T))
     (CL:WHEN (CL:NOT ONLYSUPERS?) (DOWNCLASSIFY-ONE-DESCRIPTION SELF)
      (CL:SETQ SUBS (CONSIFY (ALL-DIRECT-SUBCOLLECTIONS SELF CL:T))))
     (CL:LET*
      ((E NULL) (ITER-001 (ALL-EQUIVALENT-COLLECTIONS SELF CL:NIL))
       (COLLECT-000 NULL))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ E (%%VALUE ITER-001))
       (CL:WHEN (NAMED-DESCRIPTION? E)
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS E NIL))
          (CL:IF (CL:EQ EQUIVALENTS NIL) (CL:SETQ EQUIVALENTS COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST EQUIVALENTS COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS E NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:WHEN VIRGIN? (EVAPORATE-VIRGIN SELF)
      (POP (%INTRODUCTION-TIMESTAMP-STACK *CLASSIFICATIONSESSION*)))
     (CL:VALUES SUPERS SUBS EQUIVALENTS)))))

;;; (DEFUN (FIND-DIRECT-SUPERS-OF-INSTANCE (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN FIND-DIRECT-SUPERS-OF-INSTANCE (SELF)
  "Classify 'self' and return a list of most specific 
named descriptions among all descriptions that it satisfies."
  (FINALIZE-OBJECTS)
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM FIND-DIRECT-SUPERS-OF-INSTANCE NIL))
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-INSTANCE))
    (*CONTEXT* (%CLASSIFICATION-WORLD *CLASSIFICATIONSESSION*)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
   (UPCLASSIFY-ONE-INSTANCE SELF)
   (MOST-SPECIFIC-NAMED-COLLECTIONS (ALL-ISA-COLLECTIONS SELF))))

;;; (DEFUN UPCLASSIFY-NAMED-DESCRIPTIONS ...)

(CL:DEFUN UPCLASSIFY-NAMED-DESCRIPTIONS (MODULE LOCAL?)
  "Classify named descriptions local to 'module' and inherited
by 'module'.  If 'local?', don't classify inherited descriptions.  If
'module' is NULL, classify descriptions in all modules."
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-DESCRIPTION))
    (*CONTEXT* (%CLASSIFICATION-WORLD *CLASSIFICATIONSESSION*)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
   (CL:LET*
    ((*MODULE* (CL:IF (CL:EQ MODULE NULL) *MODULE* MODULE))
     (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:COND ((CL:EQ MODULE NULL) (UPCLASSIFY-ALL-DESCRIPTIONS))
     (LOCAL?
      (CL:LET* ((D NULL) (ITER-000 (ALL-NAMED-DESCRIPTIONS MODULE CL:T)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ D (%VALUE ITER-000))
        (UPCLASSIFY-ONE-DESCRIPTION D))))
     (CL:T
      (CL:LET* ((SESSION *CLASSIFICATIONSESSION*))
       (CL:WHEN (CL:NOT (%EVERYTHING-CLASSIFIED? SESSION))
        (CL:LET* ((M NULL) (ITER-001 (ALL-INCLUDED-MODULES MODULE)))
         (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ M (%VALUE ITER-001))
          (CL:LET* ((D NULL) (ITER-002 (ALL-NAMED-DESCRIPTIONS M CL:T)))
           (CL:LOOP WHILE (NEXT? ITER-002) DO (CL:SETQ D (%VALUE ITER-002))
            (UPCLASSIFY-ONE-DESCRIPTION D)))))
        (CL:SETF (%EVERYTHING-CLASSIFIED? SESSION) CL:T))))))))

;;; (DEFUN CLASSIFY-RELATIONS ...)

(CL:DEFUN %CLASSIFY-RELATIONS (MODULE LOCAL?)
  "Classify named relations visible in `module'.
If `local?', only classify descriptions defined within `module', i.e.,
don't classify descriptions inherited from ancestor modules.
If `module' is NULL, classify relations in all modules.

Conceptually, the classifier operates by comparing each concept or relation
with all other concepts/relations, searching for a proof that a
subsumption relation exists between each pair. Whenever a new subsumption
relation is discovered, the classifier adds an `implication' link between
members of the pair, thereby augmenting the structure of the
concept or relation hierarchy. The implemented classification algorithm is
relatively efficient -- it works hard at limiting the number of concepts
or relations that need to be checked for possible subsumption
relationships.
"
  (FINALIZE-OBJECTS)
  (CL:LET* ((THEMODULE (COERCE-TO-MODULE MODULE CL:T)))
   (CL:WHEN (CL:NOT (CL:EQ THEMODULE NULL))
    (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ THEMODULE NULL))
    (UPCLASSIFY-NAMED-DESCRIPTIONS THEMODULE LOCAL?))))

(CL:DEFUN CLASSIFY-RELATIONS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%CLASSIFY-RELATIONS (%%VALUE ARGUMENTS)
   (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO CLASSIFY-RELATIONS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Classify named relations visible in `module'.
If `local?', only classify descriptions defined within `module', i.e.,
don't classify descriptions inherited from ancestor modules.
If `module' is NULL, classify relations in all modules.

Conceptually, the classifier operates by comparing each concept or relation
with all other concepts/relations, searching for a proof that a
subsumption relation exists between each pair. Whenever a new subsumption
relation is discovered, the classifier adds an `implication' link between
members of the pair, thereby augmenting the structure of the
concept or relation hierarchy. The implemented classification algorithm is
relatively efficient -- it works hard at limiting the number of concepts
or relations that need to be checked for possible subsumption
relationships.
"
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/CLASSIFY-RELATIONS|)) (CL:MACRO-FUNCTION (CL:QUOTE CLASSIFY-RELATIONS)))

;;; (DEFUN (LIST-UNCLASSIFIED-RELATIONS (CONS OF NAMED-DESCRIPTION)) ...)

(CL:DEFUN %LIST-UNCLASSIFIED-RELATIONS (MODULE LOCAL?)
  "Collect all named description in `module' (or in any module if `module'
is NULL) that were not (or will not be) classified due to their lack of
non-inferable/primitive ancestor relations."
  (CL:WHEN (CL:NOT *CLASSIFY-FROM-NON-INFERABLE-PARENTS-ONLY?*)
   (CL:RETURN-FROM %LIST-UNCLASSIFIED-RELATIONS NIL))
  (FINALIZE-OBJECTS)
  (CL:LET* ((THEMODULE (COERCE-TO-MODULE MODULE CL:T)) (UNCLASSIFIED NIL))
   (CL:WHEN (CL:NOT (CL:EQ THEMODULE NULL))
    (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ THEMODULE NULL))
    (CL:LET*
     ((*CLASSIFICATIONSESSION*
       (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-DESCRIPTION))
      (*CONTEXT* (%CLASSIFICATION-WORLD *CLASSIFICATIONSESSION*)))
     (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
     (CL:LET*
      ((*MODULE* (CL:IF (CL:EQ THEMODULE NULL) *MODULE* THEMODULE))
       (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:LET*
       ((D NULL) (ITER-000 (ALL-NAMED-DESCRIPTIONS THEMODULE LOCAL?))
        (COLLECT-000 NULL))
       (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ D (%VALUE ITER-000))
        (CL:LET* ((TEST-VALUE-000 CL:NIL))
         (CL:SETQ TEST-VALUE-000 (INFERABLE? D))
         (CL:WHEN TEST-VALUE-000
          (CL:LET* ((FOUND?-000 CL:NIL))
           (CL:LET*
            ((SUPER NULL)
             (ITER-001 (ALL-ANCESTOR-COLLECTIONS D KWD-CLASSIFY-DESCRIPTION)))
            (CL:LOOP WHILE (NEXT? ITER-001) DO
             (CL:SETQ SUPER (%VALUE ITER-001))
             (CL:WHEN (NON-INFERABLE? SUPER) (CL:SETQ FOUND?-000 CL:T)
              (CL:RETURN))))
           (CL:SETQ TEST-VALUE-000 FOUND?-000))
          (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000)))
         (CL:WHEN TEST-VALUE-000
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS D NIL))
            (CL:IF (CL:EQ UNCLASSIFIED NIL) (CL:SETQ UNCLASSIFIED COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST UNCLASSIFIED COLLECT-000)))
           (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS D NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))))))
   UNCLASSIFIED))

(CL:DEFUN LIST-UNCLASSIFIED-RELATIONS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%LIST-UNCLASSIFIED-RELATIONS (%%VALUE ARGUMENTS)
   (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO LIST-UNCLASSIFIED-RELATIONS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Collect all named description in `module' (or in any module if `module'
is NULL) that were not (or will not be) classified due to their lack of
non-inferable/primitive ancestor relations."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/LIST-UNCLASSIFIED-RELATIONS|)) (CL:MACRO-FUNCTION (CL:QUOTE LIST-UNCLASSIFIED-RELATIONS)))

;;; (DEFUN UPCLASSIFY-INSTANCES ...)

(CL:DEFUN UPCLASSIFY-INSTANCES (MODULE LOCAL?)
  "Classify instances local to 'module' and inherited
by 'module'.  If 'local?', don't classify inherited descriptions.  If
'module' is NULL, classify descriptions in all modules."
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-INSTANCE))
    (*CONTEXT* (%CLASSIFICATION-WORLD *CLASSIFICATIONSESSION*)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
   (CL:LET*
    ((*MODULE* (CL:IF (CL:EQ MODULE NULL) *MODULE* MODULE))
     (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:COND ((CL:EQ MODULE NULL) (UPCLASSIFY-ALL-INSTANCES))
     (LOCAL?
      (CL:LET* ((I NULL) (ITER-000 (ALL-INSTANCES MODULE CL:T)))
       (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ I (%VALUE ITER-000))
        (UPCLASSIFY-ONE-INSTANCE I))))
     (CL:T
      (CL:LET* ((M NULL) (ITER-001 (ALL-INCLUDED-MODULES MODULE)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ M (%VALUE ITER-001))
        (CL:LET* ((I NULL) (ITER-002 (ALL-INSTANCES M CL:T)))
         (CL:LOOP WHILE (NEXT? ITER-002) DO (CL:SETQ I (%VALUE ITER-002))
          (UPCLASSIFY-ONE-INSTANCE I))))))))))

;;; (DEFUN CLASSIFY-INSTANCES ...)

(CL:DEFUN %CLASSIFY-INSTANCES (MODULE LOCAL?)
  "Classify instances visible in `module'.
If `local?', only classify instances that belong to `module',
i.e., don't classify instances inherited from ancestor modules.
If `module' is NULL, classify instances in all modules.

Conceptually, the classifier operates by comparing each instance
with all concepts in the hierarchy, searching for a
proof for each pairing indicating that the instance belongs to the concept.
Whenever a new `is-a' relation is discovered, the classifier
adds an `is-a' link between the instance and the concept, thereby
recording an additional fact about the instance.  The implemented
classification algorithm is relatively efficient -- it works hard
at limiting the number of concepts or relations that need to
be checked for possible is-a relationships.
"
  (FINALIZE-OBJECTS)
  (CL:LET* ((THEMODULE (COERCE-TO-MODULE MODULE CL:T)))
   (CL:WHEN (CL:NOT (CL:EQ THEMODULE NULL))
    (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ THEMODULE NULL))
    (UPCLASSIFY-INSTANCES THEMODULE LOCAL?))))

(CL:DEFUN CLASSIFY-INSTANCES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%CLASSIFY-INSTANCES (%%VALUE ARGUMENTS)
   (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO CLASSIFY-INSTANCES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Classify instances visible in `module'.
If `local?', only classify instances that belong to `module',
i.e., don't classify instances inherited from ancestor modules.
If `module' is NULL, classify instances in all modules.

Conceptually, the classifier operates by comparing each instance
with all concepts in the hierarchy, searching for a
proof for each pairing indicating that the instance belongs to the concept.
Whenever a new `is-a' relation is discovered, the classifier
adds an `is-a' link between the instance and the concept, thereby
recording an additional fact about the instance.  The implemented
classification algorithm is relatively efficient -- it works hard
at limiting the number of concepts or relations that need to
be checked for possible is-a relationships.
"
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/CLASSIFY-INSTANCES|)) (CL:MACRO-FUNCTION (CL:QUOTE CLASSIFY-INSTANCES)))

;;; (DEFUN (LIST-UNCLASSIFIED-INSTANCES (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN %LIST-UNCLASSIFIED-INSTANCES (MODULE LOCAL?)
  "Collect all instances in `module' (or in any module if `module'
is NULL) that were not (or will not be) classified due to their lack of
non-inferable/primitive type assertions."
  (CL:WHEN (CL:NOT *CLASSIFY-FROM-NON-INFERABLE-PARENTS-ONLY?*)
   (CL:RETURN-FROM %LIST-UNCLASSIFIED-INSTANCES NIL))
  (FINALIZE-OBJECTS)
  (CL:LET* ((THEMODULE (COERCE-TO-MODULE MODULE CL:T)) (UNCLASSIFIED NIL))
   (CL:WHEN (CL:NOT (CL:EQ THEMODULE NULL))
    (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ THEMODULE NULL))
    (CL:LET*
     ((*CLASSIFICATIONSESSION*
       (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-INSTANCE))
      (*CONTEXT* (%CLASSIFICATION-WORLD *CLASSIFICATIONSESSION*)))
     (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
     (CL:LET*
      ((*MODULE* (CL:IF (CL:EQ THEMODULE NULL) *MODULE* THEMODULE))
       (*CONTEXT* *MODULE*))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (CL:LET*
       ((I NULL) (ITER-000 (ALL-INSTANCES THEMODULE LOCAL?))
        (COLLECT-000 NULL))
       (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ I (%VALUE ITER-000))
        (CL:LET* ((TEST-VALUE-000 CL:NIL))
         (CL:SETQ TEST-VALUE-000 (CL:NOT (FUNCTION-OUTPUT-SKOLEM? I)))
         (CL:WHEN TEST-VALUE-000
          (CL:LET* ((FOUND?-000 CL:NIL))
           (CL:LET*
            ((TYPE NULL)
             (ITER-001 (ALL-ANCESTOR-COLLECTIONS I KWD-CLASSIFY-INSTANCE)))
            (CL:LOOP WHILE (NEXT? ITER-001) DO
             (CL:SETQ TYPE (%VALUE ITER-001))
             (CL:WHEN (NON-INFERABLE? TYPE) (CL:SETQ FOUND?-000 CL:T)
              (CL:RETURN))))
           (CL:SETQ TEST-VALUE-000 FOUND?-000))
          (CL:SETQ TEST-VALUE-000 (CL:NOT TEST-VALUE-000)))
         (CL:WHEN TEST-VALUE-000
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS I NIL))
            (CL:IF (CL:EQ UNCLASSIFIED NIL) (CL:SETQ UNCLASSIFIED COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST UNCLASSIFIED COLLECT-000)))
           (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS I NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))))))))
   UNCLASSIFIED))

(CL:DEFUN LIST-UNCLASSIFIED-INSTANCES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%LIST-UNCLASSIFIED-INSTANCES (%%VALUE ARGUMENTS)
   (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO LIST-UNCLASSIFIED-INSTANCES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Collect all instances in `module' (or in any module if `module'
is NULL) that were not (or will not be) classified due to their lack of
non-inferable/primitive type assertions."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/LIST-UNCLASSIFIED-INSTANCES|)) (CL:MACRO-FUNCTION (CL:QUOTE LIST-UNCLASSIFIED-INSTANCES)))

;;; (DEFUN UPCLASSIFY-ALL-DESCRIPTIONS ...)

(CL:DEFUN UPCLASSIFY-ALL-DESCRIPTIONS ()
  "Classify all named descriptions."
  (FINALIZE-OBJECTS)
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-DESCRIPTION))
    (*CONTEXT* (%CLASSIFICATION-WORLD *CLASSIFICATIONSESSION*)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
   (CL:LET* ((D NULL) (ITER-000 (ALL-NAMED-DESCRIPTIONS NULL CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ D (%VALUE ITER-000))
     (UPCLASSIFY-ONE-DESCRIPTION D)))))

;;; (DEFUN UPCLASSIFY-ALL-INSTANCES ...)

(CL:DEFUN UPCLASSIFY-ALL-INSTANCES ()
  "Classify all named instances."
  (FINALIZE-OBJECTS)
  (CL:LET*
   ((*CLASSIFICATIONSESSION*
     (GET-CLASSIFICATION-SESSION KWD-CLASSIFY-INSTANCE))
    (*CONTEXT* (%CLASSIFICATION-WORLD *CLASSIFICATIONSESSION*)))
   (CL:DECLARE (CL:SPECIAL *CLASSIFICATIONSESSION* *CONTEXT*))
   (CL:LET* ((I NULL) (ITER-000 (ALL-INSTANCES NULL CL:NIL)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ I (%VALUE ITER-000))
     (UPCLASSIFY-ONE-INSTANCE I)))))

;;; (DEFUN (ALL-EQUIVALENT-COLLECTIONS (CONS OF LOGIC-OBJECT)) ...)

(CL:DEFUN ALL-EQUIVALENT-COLLECTIONS (SELF REFLEXIVE?)
  (CL:LET*
   ((EQUIVALENTS (CONS-LIST SELF)) (UNSCANNEDEQUIVALENTS (LIST SELF))
    (U NULL))
   (CL:WHEN (MEMBER? (ALL-SUPERCOLLECTIONS SELF) SELF)
    (CL:LOOP (CL:SETQ U (POP UNSCANNEDEQUIVALENTS))
     (CL:LET*
      ((PARENT NULL) (ITER-000 (ALL-DIRECT-SUPERCOLLECTIONS U CL:NIL)))
      (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ PARENT (%VALUE ITER-000))
       (CL:WHEN
        (CL:AND (CL:NOT (MEMBER? EQUIVALENTS PARENT))
         (MEMBER? (ALL-SUPERCOLLECTIONS PARENT) U))
        (CL:SETQ EQUIVALENTS (CONS PARENT EQUIVALENTS))
        (PUSH UNSCANNEDEQUIVALENTS PARENT))))
     (CL:WHEN (EMPTY? UNSCANNEDEQUIVALENTS) (CL:RETURN))))
   (CL:IF REFLEXIVE? EQUIVALENTS (REMOVE EQUIVALENTS SELF))))

;;; (DEFUN (ALL-CYCLES (CONS OF CONS)) ...)

(CL:DEFUN ALL-CYCLES (MODULE LOCAL?)
  "Return a list of lists of descriptions that are
provably co-extensional."
  NULL)

(CL:DEFUN HELP-STARTUP-CLASSIFY1 ()
  (CL:PROGN
   (CL:SETQ KWD-CLASSIFY-IMPLIES-PROPOSITION-UPDATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES-PROPOSITION-UPDATE" NULL 2))
   (CL:SETQ KWD-CLASSIFY-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE" NULL 2))
   (CL:SETQ KWD-CLASSIFY-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ KWD-CLASSIFY-ISA (INTERN-RIGID-SYMBOL-WRT-MODULE "ISA" NULL 2))
   (CL:SETQ KWD-CLASSIFY-AND (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-CLASSIFY-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS" NULL 2))
   (CL:SETQ KWD-CLASSIFY-BACKWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD" NULL 2))
   (CL:SETQ SYM-CLASSIFY-LOGIC-FORWARD-ONLY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-ONLY?" NULL 0))
   (CL:SETQ SGT-CLASSIFY-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-CLASSIFY-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-CLASSIFY-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ SGT-CLASSIFY-LOGIC-F-INFERABLE-WITH-CYCLE-CHECK?-MEMO-TABLE-000
    (INTERN-RIGID-SYMBOL-WRT-MODULE
     "F-INFERABLE-WITH-CYCLE-CHECK?-MEMO-TABLE-000" NULL 1))
   (CL:SETQ SGT-CLASSIFY-LOGIC-MARKER-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MARKER-TABLE" NULL 1))
   (CL:SETQ SYM-CLASSIFY-LOGIC-TEST-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TEST-TABLE" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-RECALL-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RECALL-TABLE" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-SUPPORTS-RECALL?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPPORTS-RECALL?" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-SUBSUMPTION-LINK?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-LINK?" NULL 0))
   (CL:SETQ KWD-CLASSIFY-CLASSIFIER-INFERENCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFIER-INFERENCES" NULL 2))
   (CL:SETQ SGT-CLASSIFY-LOGIC-CLASSIFICATION-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-CACHE" NULL 1))
   (CL:SETQ SYM-CLASSIFY-LOGIC-INFERABLE-DIRECT-SUBDESCRIPTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERABLE-DIRECT-SUBDESCRIPTIONS" NULL
     0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CACHE-UPCLASSIFICATION-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHE-UPCLASSIFICATION-TIMESTAMP" NULL
     0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CACHE-DOWNCLASSIFICATION-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CACHE-DOWNCLASSIFICATION-TIMESTAMP" NULL
     0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTRODUCTION-TIMESTAMP" NULL 0))
   (CL:SETQ SGT-CLASSIFY-LOGIC-CLASSIFICATION-SESSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-SESSION" NULL 1))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFICATION-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-WORLD" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFICATION-CACHE-TABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-CACHE-TABLE" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFICATION-TIMECLOCK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-TIMECLOCK" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-INTRODUCTION-TIMESTAMP-STACK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTRODUCTION-TIMESTAMP-STACK" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-EVERYTHING-CLASSIFIED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVERYTHING-CLASSIFIED?" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-KEY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAST-CACHE-TABLE-KEY" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-LAST-CACHE-TABLE-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAST-CACHE-TABLE-VALUE" NULL 0))
   (CL:SETQ KWD-CLASSIFY-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ KWD-CLASSIFY-META (INTERN-RIGID-SYMBOL-WRT-MODULE "META" NULL 2))
   (CL:SETQ KWD-CLASSIFY-INSTANCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INSTANCE" NULL 2))
   (CL:SETQ KWD-CLASSIFY-TMS (INTERN-RIGID-SYMBOL-WRT-MODULE "TMS" NULL 2))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFICATION-SESSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFICATION-SESSION" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-META-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-INFERENCE-CACHE" NULL 0))
   (CL:SETQ KWD-CLASSIFY-JUST-IN-TIME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUST-IN-TIME" NULL 2))
   (CL:SETQ KWD-CLASSIFY-CLASSIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFIER" NULL 2))
   (CL:SETQ KWD-CLASSIFY-CLASSIFIER-PROFILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFIER-PROFILE" NULL 2))
   (CL:SETQ KWD-CLASSIFY-UPCLASSIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPCLASSIFY" NULL 2))
   (CL:SETQ KWD-CLASSIFY-DOWNCLASSIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOWNCLASSIFY" NULL 2))
   (CL:SETQ SYM-CLASSIFY-LOGIC-SUBRELATION-LINK?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBRELATION-LINK?" NULL 0))
   (CL:SETQ KWD-CLASSIFY-ASSERT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFY-RELATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFY-RELATIONS" NULL 0))
   (CL:SETQ KWD-CLASSIFY-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ SYM-CLASSIFY-LOGIC-LIST-UNCLASSIFIED-RELATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-UNCLASSIFIED-RELATIONS" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-CLASSIFY-INSTANCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASSIFY-INSTANCES" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-LIST-UNCLASSIFIED-INSTANCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LIST-UNCLASSIFIED-INSTANCES" NULL 0))
   (CL:SETQ SYM-CLASSIFY-LOGIC-STARTUP-CLASSIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-CLASSIFY" NULL 0))
   (CL:SETQ SYM-CLASSIFY-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-CLASSIFY2 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "BUMP-INFERABLE-TIMESTAMP"
    "(DEFUN BUMP-INFERABLE-TIMESTAMP () :GLOBALLY-INLINE? TRUE (BUMP-MEMOIZATION-TIMESTAMP :IMPLIES-PROPOSITION-UPDATE))"
    (CL:FUNCTION BUMP-INFERABLE-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-INTENSIONAL-PARENTS"
    "(DEFUN HELP-COLLECT-INTENSIONAL-PARENTS ((DESCRIPTION DESCRIPTION) (PROPOSITION PROPOSITION) (COLLECTION LIST)))"
    (CL:FUNCTION HELP-COLLECT-INTENSIONAL-PARENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-INTENSIONAL-PARENTS"
    "(DEFUN (ALL-INTENSIONAL-PARENTS (LIST OF DESCRIPTION)) ((SELF DESCRIPTION)))"
    (CL:FUNCTION ALL-INTENSIONAL-PARENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "INFERABLE-THROUGH-BY-SOME-DESCENDANT?"
    "(DEFUN (INFERABLE-THROUGH-BY-SOME-DESCENDANT? BOOLEAN) ((SELF NAMED-DESCRIPTION) (THROUGHCHILD LOGIC-OBJECT) (ALREADYVISITEDLIST CONS)))"
    (CL:FUNCTION INFERABLE-THROUGH-BY-SOME-DESCENDANT?) NULL)
   (DEFINE-FUNCTION-OBJECT "INFERABLE-WITH-CYCLE-CHECK?"
    "(DEFUN (INFERABLE-WITH-CYCLE-CHECK? BOOLEAN) ((SELF DESCRIPTION) (ALREADYVISITEDLIST CONS)))"
    (CL:FUNCTION INFERABLE-WITH-CYCLE-CHECK?) NULL)
   (DEFINE-FUNCTION-OBJECT "INFERABLE?"
    "(DEFUN (INFERABLE? BOOLEAN) ((SELF DESCRIPTION)) :INLINE INFERABLE-WITH-CYCLE-CHECK?)"
    (CL:FUNCTION INFERABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "NON-INFERABLE?"
    "(DEFUN (NON-INFERABLE? BOOLEAN) ((SELF DESCRIPTION)) :INLINE INFERABLE?)"
    (CL:FUNCTION NON-INFERABLE?) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-MARKER-STORAGE"
    "(DEFUN (CREATE-MARKER-STORAGE MARKER-TABLE) ((SUPPORTRECALL? BOOLEAN)) :DOCUMENTATION \"Return a new marker storage object, used to
remember with objects have been 'marked'.  If 'supportRecall?'
is set, then the iterator 'recall-marked-objects' can be invoked
on the new marker storage object.\")" (CL:FUNCTION CREATE-MARKER-STORAGE)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD SET-MARKER ((SELF MARKER-TABLE) (OBJECT OBJECT)) :DOCUMENTATION \"Record membership of 'object' in the marker
storage object 'self'.\")" (CL:FUNCTION SET-MARKER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (TEST-MARKER? BOOLEAN) ((SELF MARKER-TABLE) (OBJECT OBJECT)) :DOCUMENTATION \"Return TRUE if 'object' is stored (marked) in 'self'.\")"
    (CL:FUNCTION TEST-MARKER?) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-SPECIAL-MARKER-TABLE?"
    "(DEFUN (TEST-SPECIAL-MARKER-TABLE? BOOLEAN) ((SELF OBJECT)) :DOCUMENTATION \"Return TRUE if the object 'self' is stored (marked)
in the table pointed at by the special variable *specialMarkerTable*.
Designed for use by 'remove-if'.\")" (CL:FUNCTION TEST-SPECIAL-MARKER-TABLE?)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (RECALL-MARKED-OBJECTS LIST-ITERATOR) ((SELF MARKER-TABLE)) :DOCUMENTATION \"Return an iterator that generates all marked objects
recorded in 'self'.\")" (CL:FUNCTION RECALL-MARKED-OBJECTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-NAMED-DIRECT-SUPERDESCRIPTIONS"
    "(DEFUN (ALL-NAMED-DIRECT-SUPERDESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ((SELF DESCRIPTION) (REMOVEEQUIVALENTS? BOOLEAN)))"
    (CL:FUNCTION ALL-NAMED-DIRECT-SUPERDESCRIPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-NAMED-DIRECT-SUBDESCRIPTIONS"
    "(DEFUN (ALL-NAMED-DIRECT-SUBDESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ((SELF DESCRIPTION)))"
    (CL:FUNCTION ALL-NAMED-DIRECT-SUBDESCRIPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-ISA-LINK"
    "(DEFUN ADD-ISA-LINK ((INSTANCE LOGIC-OBJECT) (SUPERDESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION ADD-ISA-LINK) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-SUBSUMPTION-LINK"
    "(DEFUN ADD-SUBSUMPTION-LINK ((SUBDESCRIPTION DESCRIPTION) (SUPERDESCRIPTION DESCRIPTION)))"
    (CL:FUNCTION ADD-SUBSUMPTION-LINK) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-SPECIFIC-COLLECTIONS"
    "(DEFUN (MOST-SPECIFIC-COLLECTIONS (CONS OF LOGIC-OBJECT)) ((DESCRIPTIONS (CONS OF LOGIC-OBJECT))))"
    (CL:FUNCTION MOST-SPECIFIC-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-GENERAL-COLLECTIONS"
    "(DEFUN (MOST-GENERAL-COLLECTIONS (CONS OF LOGIC-OBJECT)) ((DESCRIPTIONS (CONS OF LOGIC-OBJECT))))"
    (CL:FUNCTION MOST-GENERAL-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "NAMED-COLLECTION?"
    "(DEFUN (NAMED-COLLECTION? BOOLEAN) ((SELF LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION NAMED-COLLECTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-SPECIFIC-NAMED-COLLECTIONS"
    "(DEFUN (MOST-SPECIFIC-NAMED-COLLECTIONS (CONS OF LOGIC-OBJECT)) ((DESCRIPTIONS (CONS OF LOGIC-OBJECT))) :PUBLIC? TRUE)"
    (CL:FUNCTION MOST-SPECIFIC-NAMED-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "MOST-SPECIFIC-NAMED-DESCRIPTIONS"
    "(DEFUN (MOST-SPECIFIC-NAMED-DESCRIPTIONS (CONS OF NAMED-DESCRIPTION)) ((DESCRIPTIONS (CONS OF LOGIC-OBJECT))))"
    (CL:FUNCTION MOST-SPECIFIC-NAMED-DESCRIPTIONS) NULL)
   (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
    "(DEFSLOT WORLD CLASSIFICATION-SESSION :PUBLIC? TRUE :DOCUMENTATION \"Points to a record that caches the distributed
state of descriptions participating in a classification session.\" :TYPE CLASSIFICATION-SESSION :ALLOCATION :DYNAMIC)")
   (DEFINE-FUNCTION-OBJECT "GET-CLASSIFICATION-WORLD"
    "(DEFUN (GET-CLASSIFICATION-WORLD WORLD) () :PUBLIC? TRUE)"
    (CL:FUNCTION GET-CLASSIFICATION-WORLD) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-CLASSIFICATION-SESSION"
    "(DEFUN (GET-CLASSIFICATION-SESSION CLASSIFICATION-SESSION) ((INSTANCEORDESCRIPTION KEYWORD)) :PUBLIC? TRUE)"
    (CL:FUNCTION GET-CLASSIFICATION-SESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-CLASSIFICATION-CACHE"
    "(DEFUN (GET-CLASSIFICATION-CACHE CLASSIFICATION-CACHE) ((SELF OBJECT)))"
    (CL:FUNCTION GET-CLASSIFICATION-CACHE) NULL)
   (DEFINE-FUNCTION-OBJECT "TOGGLE-INFERABLE-DIRECT-SUBCOLLECTIONS-CACHING"
    "(DEFUN (TOGGLE-INFERABLE-DIRECT-SUBCOLLECTIONS-CACHING STRING) ())"
    (CL:FUNCTION TOGGLE-INFERABLE-DIRECT-SUBCOLLECTIONS-CACHING) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-INFERABLE-DIRECT-SUBCOLLECTIONS"
    "(DEFUN (ALL-INFERABLE-DIRECT-SUBCOLLECTIONS (LIST OF DESCRIPTION)) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION ALL-INFERABLE-DIRECT-SUBCOLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE"
    "(DEFUN FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE ((IMPLIESPROPOSITION PROPOSITION)))"
    (CL:FUNCTION FLUSH-INFERABLE-DIRECT-SUBDESCRIPTIONS-CACHE) NULL)
   (DEFINE-FUNCTION-OBJECT "CURRENT-CLASSIFICATION-TIME"
    "(DEFUN (CURRENT-CLASSIFICATION-TIME TIMESTAMP) ())"
    (CL:FUNCTION CURRENT-CLASSIFICATION-TIME) NULL)
   (DEFINE-FUNCTION-OBJECT "BUMP-CLASSIFICATION-TIMECLOCK"
    "(DEFUN (BUMP-CLASSIFICATION-TIMECLOCK TIMESTAMP) ())"
    (CL:FUNCTION BUMP-CLASSIFICATION-TIMECLOCK) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (INTRODUCTION-TIMESTAMP TIMESTAMP) ((SELF LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION INTRODUCTION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "INTRODUCE-INTO-CLASSIFICATION-SESSION"
    "(DEFUN INTRODUCE-INTO-CLASSIFICATION-SESSION ((SELF DESCRIPTION)))"
    (CL:FUNCTION INTRODUCE-INTO-CLASSIFICATION-SESSION) NULL)
   (DEFINE-FUNCTION-OBJECT "YOUNGEST-INTRODUCTION-TIMESTAMP"
    "(DEFUN (YOUNGEST-INTRODUCTION-TIMESTAMP INTEGER) ())"
    (CL:FUNCTION YOUNGEST-INTRODUCTION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCLASSIFICATION-TIMESTAMP"
    "(DEFUN (UPCLASSIFICATION-TIMESTAMP INTEGER) ((SELF OBJECT)))"
    (CL:FUNCTION UPCLASSIFICATION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "DOWNCLASSIFICATION-TIMESTAMP"
    "(DEFUN (DOWNCLASSIFICATION-TIMESTAMP INTEGER) ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION DOWNCLASSIFICATION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "REFRESH-UPCLASSIFICATION-TIMESTAMP"
    "(DEFUN REFRESH-UPCLASSIFICATION-TIMESTAMP ((SELF OBJECT)))"
    (CL:FUNCTION REFRESH-UPCLASSIFICATION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "REFRESH-DOWNCLASSIFICATION-TIMESTAMP"
    "(DEFUN REFRESH-DOWNCLASSIFICATION-TIMESTAMP ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION REFRESH-DOWNCLASSIFICATION-TIMESTAMP) NULL)
   (DEFINE-FUNCTION-OBJECT "FLUSH-CLASSIFICATION-SESSIONS"
    "(DEFUN FLUSH-CLASSIFICATION-SESSIONS ())"
    (CL:FUNCTION FLUSH-CLASSIFICATION-SESSIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCLASSIFIED?"
    "(DEFUN (UPCLASSIFIED? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPCLASSIFIED?) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCLASSIFIED-LATER-THAN?"
    "(DEFUN (UPCLASSIFIED-LATER-THAN? BOOLEAN) ((SELF LOGIC-OBJECT) (OTHER LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPCLASSIFIED-LATER-THAN?) NULL)
   (DEFINE-FUNCTION-OBJECT "DOWNCLASSIFIED?"
    "(DEFUN (DOWNCLASSIFIED? BOOLEAN) ((SELF LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION DOWNCLASSIFIED?) NULL)
   (DEFINE-FUNCTION-OBJECT "MARK-UNMARKED-SUPERRELATIONS"
    "(DEFUN MARK-UNMARKED-SUPERRELATIONS ((DESCRIPTION DESCRIPTION) (SELFISBELOWTABLE MARKER-TABLE)))"
    (CL:FUNCTION MARK-UNMARKED-SUPERRELATIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "APPLY-SUBSUMPTION-TEST?"
    "(DEFUN (APPLY-SUBSUMPTION-TEST? BOOLEAN) ((SUBSUMPTIONTEST FUNCTION-CODE) (SELF LOGIC-OBJECT) (SUPER LOGIC-OBJECT)))"
    (CL:FUNCTION APPLY-SUBSUMPTION-TEST?) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-COLLECT-PARENTS-BELOW?"
    "(DEFUN (HELP-COLLECT-PARENTS-BELOW? BOOLEAN) ((SELF LOGIC-OBJECT) (SUPER DESCRIPTION) (NEWPARENTDESCRIPTIONS (LIST OF DESCRIPTION)) (ALREADYVISITEDTABLE MARKER-TABLE) (SELFISBELOWTABLE MARKER-TABLE) (SUBSUMPTIONTEST FUNCTION-CODE)))"
    (CL:FUNCTION HELP-COLLECT-PARENTS-BELOW?) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-SUBSUMING-PARENTS-BELOW"
    "(DEFUN COLLECT-SUBSUMING-PARENTS-BELOW ((SELF LOGIC-OBJECT) (SUPER DESCRIPTION) (NEWPARENTDESCRIPTIONS (LIST OF DESCRIPTION)) (ALREADYVISITEDTABLE MARKER-TABLE) (SELFISBELOWTABLE MARKER-TABLE) (SUBSUMPTIONTEST FUNCTION-CODE)))"
    (CL:FUNCTION COLLECT-SUBSUMING-PARENTS-BELOW) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-ANCESTORS-OF-PARENTS"
    "(DEFUN (ALL-ANCESTORS-OF-PARENTS (ITERATOR OF LOGIC-OBJECT)) ((SUPERS (CONS OF LOGIC-OBJECT))))"
    (CL:FUNCTION ALL-ANCESTORS-OF-PARENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "ALL-ANCESTOR-COLLECTIONS"
    "(DEFUN (ALL-ANCESTOR-COLLECTIONS (ITERATOR OF LOGIC-OBJECT)) ((SELF OBJECT) (INSTANCEORDESCRIPTION KEYWORD)))"
    (CL:FUNCTION ALL-ANCESTOR-COLLECTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-UPCLASSIFY-ONE-ENTITY"
    "(DEFUN HELP-UPCLASSIFY-ONE-ENTITY ((SELF LOGIC-OBJECT) (INSTANCEORDESCRIPTION KEYWORD)))"
    (CL:FUNCTION HELP-UPCLASSIFY-ONE-ENTITY) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-ONE-INSTANCE"
    "(DEFUN UPCLASSIFY-ONE-INSTANCE ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION UPCLASSIFY-ONE-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-ONE-DESCRIPTION"
    "(DEFUN UPCLASSIFY-ONE-DESCRIPTION ((SELF LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION UPCLASSIFY-ONE-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "HELP-DOWNCLASSIFY-ONE-DESCRIPTION"
    "(DEFUN HELP-DOWNCLASSIFY-ONE-DESCRIPTION ((NODE LOGIC-OBJECT) (SELF LOGIC-OBJECT) (NECESSARYANCESTORS (CONS OF LOGIC-OBJECT)) (ALREADYVISITEDTABLE MARKER-TABLE)))"
    (CL:FUNCTION HELP-DOWNCLASSIFY-ONE-DESCRIPTION) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECTION-WITH-FEWEST-CHILDREN"
    "(DEFUN (COLLECTION-WITH-FEWEST-CHILDREN LOGIC-OBJECT) ((COLLECTIONS (CONS OF LOGIC-OBJECT))))"
    (CL:FUNCTION COLLECTION-WITH-FEWEST-CHILDREN) NULL)
   (DEFINE-FUNCTION-OBJECT "CHOOSE-BEST-DOWNCLASSIFIED-PARENT"
    "(DEFUN (CHOOSE-BEST-DOWNCLASSIFIED-PARENT LOGIC-OBJECT) ((PARENTS (CONS OF LOGIC-OBJECT))))"
    (CL:FUNCTION CHOOSE-BEST-DOWNCLASSIFIED-PARENT) NULL)
   (DEFINE-FUNCTION-OBJECT "DOWNCLASSIFY-ONE-DESCRIPTION"
    "(DEFUN DOWNCLASSIFY-ONE-DESCRIPTION ((SELF LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION DOWNCLASSIFY-ONE-DESCRIPTION) NULL)
   (DEFINE-METHOD-OBJECT "(DEFMETHOD (VIRGIN? BOOLEAN) ((SELF DESCRIPTION)))"
    (CL:FUNCTION VIRGIN?) NULL)
   (DEFINE-FUNCTION-OBJECT "EVAPORATE-VIRGIN"
    "(DEFUN EVAPORATE-VIRGIN ((SELF DESCRIPTION)))"
    (CL:FUNCTION EVAPORATE-VIRGIN) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DIRECT-SUPERS-AND-SUBS"
    "(DEFUN (FIND-DIRECT-SUPERS-AND-SUBS (CONS OF DESCRIPTION) (CONS OF DESCRIPTION) (CONS OF DESCRIPTION)) ((SELF DESCRIPTION) (ONLYSUPERS? BOOLEAN)) :DOCUMENTATION \"Classify 'self' and return three values, its direct
supers, direct subs, and a list of equivalent descriptions.
Setting 'supersOnly?' may speed up the computation (perhaps by a lot).
If 'description' is nameless and has no dependent propositions, then
it is automatically removed from the hierarchy after classification.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FIND-DIRECT-SUPERS-AND-SUBS) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-DIRECT-SUPERS-OF-INSTANCE"
    "(DEFUN (FIND-DIRECT-SUPERS-OF-INSTANCE (CONS OF LOGIC-OBJECT)) ((SELF OBJECT)) :DOCUMENTATION \"Classify 'self' and return a list of most specific 
named descriptions among all descriptions that it satisfies.\" :PUBLIC? TRUE)"
    (CL:FUNCTION FIND-DIRECT-SUPERS-OF-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-NAMED-DESCRIPTIONS"
    "(DEFUN UPCLASSIFY-NAMED-DESCRIPTIONS ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Classify named descriptions local to 'module' and inherited
by 'module'.  If 'local?', don't classify inherited descriptions.  If
'module' is NULL, classify descriptions in all modules.\")"
    (CL:FUNCTION UPCLASSIFY-NAMED-DESCRIPTIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLASSIFY-RELATIONS"
    "(DEFUN CLASSIFY-RELATIONS ((MODULE NAME) (LOCAL? BOOLEAN)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Classify named relations visible in `module'.
If `local?', only classify descriptions defined within `module', i.e.,
don't classify descriptions inherited from ancestor modules.
If `module' is NULL, classify relations in all modules.

Conceptually, the classifier operates by comparing each concept or relation
with all other concepts/relations, searching for a proof that a
subsumption relation exists between each pair. Whenever a new subsumption
relation is discovered, the classifier adds an `implication' link between
members of the pair, thereby augmenting the structure of the
concept or relation hierarchy. The implemented classification algorithm is
relatively efficient -- it works hard at limiting the number of concepts
or relations that need to be checked for possible subsumption
relationships.
\")" (CL:FUNCTION %CLASSIFY-RELATIONS)
    (CL:FUNCTION CLASSIFY-RELATIONS-EVALUATOR-WRAPPER))))

(CL:DEFUN STARTUP-CLASSIFY ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-CLASSIFY1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "MARKER-TABLE"
        "(DEFCLASS MARKER-TABLE (STANDARD-OBJECT) :DOCUMENTATION \"Used to record (mark) a set of objects.
Can be optimized for testing only, or also for recall.\" :SLOTS ((TEST-TABLE :TYPE HASH-TABLE) (RECALL-TABLE :TYPE LIST) (SUPPORTS-RECALL? :TYPE BOOLEAN)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-MARKER-TABLE))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-MARKER-TABLE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CLASSIFICATION-CACHE"
        "(DEFCLASS CLASSIFICATION-CACHE (STANDARD-OBJECT) :DOCUMENTATION \"Records various kinds of data about a description
during a classification session.\" :SLOTS ((INFERABLE-DIRECT-SUBDESCRIPTIONS :TYPE (LIST OF DESCRIPTION)) (CACHE-UPCLASSIFICATION-TIMESTAMP :TYPE INTEGER :INITIALLY -1) (CACHE-DOWNCLASSIFICATION-TIMESTAMP :TYPE INTEGER :INITIALLY -1) (INTRODUCTION-TIMESTAMP :TYPE INTEGER :INITIALLY 0)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CLASSIFICATION-CACHE))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CLASSIFICATION-CACHE-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "CLASSIFICATION-SESSION"
        "(DEFCLASS CLASSIFICATION-SESSION (STANDARD-OBJECT) :SLOTS ((CLASSIFICATION-WORLD :TYPE WORLD) (CLASSIFICATION-CACHE-TABLE :TYPE (HASH-TABLE OF OBJECT CLASSIFICATION-CACHE) :ALLOCATION :EMBEDDED) (CLASSIFICATION-TIMECLOCK :TYPE INTEGER :INITIALLY 0) (INTRODUCTION-TIMESTAMP-STACK :TYPE (LIST OF INTEGER-WRAPPER) :INITIALLY (LIST 0)) (EVERYTHING-CLASSIFIED? :TYPE BOOLEAN) (LAST-CACHE-TABLE-KEY :TYPE LOGIC-OBJECT) (LAST-CACHE-TABLE-VALUE :TYPE CLASSIFICATION-CACHE)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-CLASSIFICATION-SESSION))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-CLASSIFICATION-SESSION-SLOT-VALUE))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-CLASSIFY2)
    (DEFINE-FUNCTION-OBJECT "LIST-UNCLASSIFIED-RELATIONS"
     "(DEFUN (LIST-UNCLASSIFIED-RELATIONS (CONS OF NAMED-DESCRIPTION)) ((MODULE NAME) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Collect all named description in `module' (or in any module if `module'
is NULL) that were not (or will not be) classified due to their lack of
non-inferable/primitive ancestor relations.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
     (CL:FUNCTION %LIST-UNCLASSIFIED-RELATIONS)
     (CL:FUNCTION LIST-UNCLASSIFIED-RELATIONS-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-INSTANCES"
     "(DEFUN UPCLASSIFY-INSTANCES ((MODULE MODULE) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Classify instances local to 'module' and inherited
by 'module'.  If 'local?', don't classify inherited descriptions.  If
'module' is NULL, classify descriptions in all modules.\")"
     (CL:FUNCTION UPCLASSIFY-INSTANCES) NULL)
    (DEFINE-FUNCTION-OBJECT "CLASSIFY-INSTANCES"
     "(DEFUN CLASSIFY-INSTANCES ((MODULE NAME) (LOCAL? BOOLEAN)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Classify instances visible in `module'.
If `local?', only classify instances that belong to `module',
i.e., don't classify instances inherited from ancestor modules.
If `module' is NULL, classify instances in all modules.

Conceptually, the classifier operates by comparing each instance
with all concepts in the hierarchy, searching for a
proof for each pairing indicating that the instance belongs to the concept.
Whenever a new `is-a' relation is discovered, the classifier
adds an `is-a' link between the instance and the concept, thereby
recording an additional fact about the instance.  The implemented
classification algorithm is relatively efficient -- it works hard
at limiting the number of concepts or relations that need to
be checked for possible is-a relationships.
\")" (CL:FUNCTION %CLASSIFY-INSTANCES)
     (CL:FUNCTION CLASSIFY-INSTANCES-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "LIST-UNCLASSIFIED-INSTANCES"
     "(DEFUN (LIST-UNCLASSIFIED-INSTANCES (CONS OF LOGIC-OBJECT)) ((MODULE NAME) (LOCAL? BOOLEAN)) :DOCUMENTATION \"Collect all instances in `module' (or in any module if `module'
is NULL) that were not (or will not be) classified due to their lack of
non-inferable/primitive type assertions.\" :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
     (CL:FUNCTION %LIST-UNCLASSIFIED-INSTANCES)
     (CL:FUNCTION LIST-UNCLASSIFIED-INSTANCES-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-ALL-DESCRIPTIONS"
     "(DEFUN UPCLASSIFY-ALL-DESCRIPTIONS () :DOCUMENTATION \"Classify all named descriptions.\")"
     (CL:FUNCTION UPCLASSIFY-ALL-DESCRIPTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "UPCLASSIFY-ALL-INSTANCES"
     "(DEFUN UPCLASSIFY-ALL-INSTANCES () :DOCUMENTATION \"Classify all named instances.\")"
     (CL:FUNCTION UPCLASSIFY-ALL-INSTANCES) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-EQUIVALENT-COLLECTIONS"
     "(DEFUN (ALL-EQUIVALENT-COLLECTIONS (CONS OF LOGIC-OBJECT)) ((SELF LOGIC-OBJECT) (REFLEXIVE? BOOLEAN)) :PUBLIC? TRUE)"
     (CL:FUNCTION ALL-EQUIVALENT-COLLECTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "ALL-CYCLES"
     "(DEFUN (ALL-CYCLES (CONS OF CONS)) ((MODULE MODULE) (LOCAL? BOOLEAN)) :PUBLIC? TRUE :DOCUMENTATION \"Return a list of lists of descriptions that are
provably co-extensional.\")" (CL:FUNCTION ALL-CYCLES) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-CLASSIFY"
     "(DEFUN STARTUP-CLASSIFY () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-CLASSIFY) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-CLASSIFY-LOGIC-STARTUP-CLASSIFY)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-CLASSIFY-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupClassify") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *SPECIALMARKERTABLE* MARKER-TABLE :DOCUMENTATION \"Special variable that points to the marker table 
referenced by the function 'test-special-marker-table?'.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *FINDSUPERSANDSUBSDESCRIPTION* DESCRIPTION NULL :DOCUMENTATION \"Points to a possibly unnamed description being
temporarily classified.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CLASSIFICATIONSESSION* CLASSIFICATION-SESSION NULL :PUBLIC? TRUE :DOCUMENTATION \"Points to state of on-going classification session.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CACHE-INFERABLE-SUBCOLLECTIONS?* BOOLEAN TRUE :DOCUMENTATION \"If TRUE, prevents caching of computations of
all inferable subcollections of a collection.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CLASSIFY-FROM-NON-INFERABLE-PARENTS-ONLY?* BOOLEAN TRUE :DOCUMENTATION \"If true (the default) only consider those relations (or instances) for
classification that have at least one non-inferable parent (or type).  This
can greatly reduce the classification effort.  To find entities that were
left unclassified due to this optimization use `list-unclassified-relations'
or `list-unclassified-instances'.\" :PUBLIC? TRUE)")
    (REGISTER-NATIVE-NAME SYM-CLASSIFY-LOGIC-CLASSIFY-RELATIONS
     KWD-CLASSIFY-COMMON-LISP KWD-CLASSIFY-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CLASSIFY-LOGIC-LIST-UNCLASSIFIED-RELATIONS
     KWD-CLASSIFY-COMMON-LISP KWD-CLASSIFY-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CLASSIFY-LOGIC-CLASSIFY-INSTANCES
     KWD-CLASSIFY-COMMON-LISP KWD-CLASSIFY-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CLASSIFY-LOGIC-LIST-UNCLASSIFIED-INSTANCES
     KWD-CLASSIFY-COMMON-LISP KWD-CLASSIFY-FUNCTION))))
