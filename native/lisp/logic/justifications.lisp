;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; justifications.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2010      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-BACKWARD NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-PATTERN-JUSTIFICATION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-SUBSTITUTION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY? NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-POSITIVE-SCORE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-NEGATIVE-SCORE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-STRATEGY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-PATTERN NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-UP-TRUE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-UP-FAIL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAILURE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SCAN-COLLECTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-TECHNICAL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-LAY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SPECIALIST NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-COMPUTED-PREDICATE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-GOAL-COMPLEMENT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-EQUIVALENCE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SUBSUMPTION-TEST NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SUBSUMPTION-REASONING NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-STELLA-KEY-VALUE-LIST NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-AND-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-MODUS-TOLLENS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-MODUS-PONENS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-NOT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-AMPLIFICATION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-ARGUMENTS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-POPPED NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-PARTIAL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-REVERSE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-OR-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-DISPROOF NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAIL-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FAIL NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-TIMEOUT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-DEPTH-CUTOFF NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-RAW NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-INFERENCE-RULE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-STRATEGY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-TRUTH-VALUE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-POSITIVE-SCORE NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-SUBSTITUTION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-NOT NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-HOW-MANY NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-NONE NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-PREDICATE NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FORWARD NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-FORWARD-INFERENCE NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-IO-VARIABLES NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-IMPLIES NULL)
(CL:DEFVAR KWD-JUSTIFICATIONS-DESCRIPTION NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-PL-KERNEL-KB-SUBSET-OF NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS NULL)
(CL:DEFVAR SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* TRUE-TRUTH-VALUE *CONTEXT* *MODULE*
  *REVERSEPOLARITY?* NIL-LIST NULL-INTEGER UNKNOWN-TRUTH-VALUE STANDARD-OUTPUT
  EOL *QUERYITERATOR* *CURRENTJUSTIFICATION* TRUE-WRAPPER FALSE-WRAPPER NIL
  NULL-FLOAT))

;;; (DEFCLASS JUSTIFICATION ...)

(CL:DEFCLASS JUSTIFICATION (STANDARD-OBJECT)
  ((INFERENCE-RULE :DOCUMENTATION
    "Keyword describing the inference rule used to conclude the
proposition of this justification." :ALLOCATION :INSTANCE :ACCESSOR
    %INFERENCE-RULE)
   (PROPOSITION :DOCUMENTATION
    "The proposition supported by this justification." :ALLOCATION :INSTANCE
    :ACCESSOR %PROPOSITION)
   (ANTECEDENTS :DOCUMENTATION
    "Antecedents justifications of this justification." :ALLOCATION :INSTANCE
    :ACCESSOR %ANTECEDENTS)
   (PATTERN-JUSTIFICATION :DOCUMENTATION
    "Backpointer to the closest parent :PATTERN justification containing
the variable substitutions from the associated pattern control frame.  If this
is a :PATTERN justification, the slot points to the parent pattern."
    :ALLOCATION :INSTANCE :ACCESSOR %PATTERN-JUSTIFICATION)
   (SUBSTITUTION :DOCUMENTATION
    "List of variable bindings recorded for :PATTERN justifications."
    :ALLOCATION :INSTANCE :ACCESSOR %SUBSTITUTION)
   (REVERSE-POLARITY? :DOCUMENTATION
    "True if proposition was derived in reverse polarity." :ALLOCATION
    :INSTANCE :ACCESSOR %REVERSE-POLARITY?)
   (TRUTH-VALUE :DOCUMENTATION "Truth value of the derived proposition."
    :ALLOCATION :INSTANCE :ACCESSOR %TRUTH-VALUE)
   (POSITIVE-SCORE :TYPE CL:DOUBLE-FLOAT :INITFORM NULL-FLOAT :DOCUMENTATION
    "Positive partial match score of the derived proposition." :ALLOCATION
    :INSTANCE :ACCESSOR %POSITIVE-SCORE)
   (NEGATIVE-SCORE :TYPE CL:DOUBLE-FLOAT :INITFORM NULL-FLOAT :DOCUMENTATION
    "Negative partial match score of the derived proposition." :ALLOCATION
    :INSTANCE :ACCESSOR %NEGATIVE-SCORE)))

(CL:DEFUN NEW-JUSTIFICATION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE JUSTIFICATION)))
   (CL:SETF (%NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%TRUTH-VALUE SELF) NULL)
   (CL:SETF (%REVERSE-POLARITY? SELF) CL:NIL)
   (CL:SETF (%SUBSTITUTION SELF) NULL)
   (CL:SETF (%PATTERN-JUSTIFICATION SELF) NULL)
   (CL:SETF (%ANTECEDENTS SELF) NIL) (CL:SETF (%PROPOSITION SELF) NULL)
   (CL:SETF (%INFERENCE-RULE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF JUSTIFICATION))
  SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION)

(CL:DEFMETHOD INFERENCE-STRATEGY ((SELF JUSTIFICATION))
  NULL)

(CL:DEFMETHOD INFERENCE-DIRECTION ((SELF JUSTIFICATION))
  KWD-JUSTIFICATIONS-BACKWARD)

(CL:DEFUN ACCESS-JUSTIFICATION-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE)
    (CL:IF SETVALUE? (CL:SETF (%INFERENCE-RULE SELF) VALUE)
     (CL:SETQ VALUE (%INFERENCE-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS)
    (CL:IF SETVALUE? (CL:SETF (%ANTECEDENTS SELF) VALUE)
     (CL:SETQ VALUE (%ANTECEDENTS SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-PATTERN-JUSTIFICATION)
    (CL:IF SETVALUE? (CL:SETF (%PATTERN-JUSTIFICATION SELF) VALUE)
     (CL:SETQ VALUE (%PATTERN-JUSTIFICATION SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-SUBSTITUTION)
    (CL:IF SETVALUE? (CL:SETF (%SUBSTITUTION SELF) VALUE)
     (CL:SETQ VALUE (%SUBSTITUTION SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY?)
    (CL:IF SETVALUE?
     (CL:SETF (%REVERSE-POLARITY? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%REVERSE-POLARITY? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE)
    (CL:IF SETVALUE? (CL:SETF (%TRUTH-VALUE SELF) VALUE)
     (CL:SETQ VALUE (%TRUTH-VALUE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-POSITIVE-SCORE)
    (CL:IF SETVALUE? (CL:SETF (%POSITIVE-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%POSITIVE-SCORE SELF)))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-NEGATIVE-SCORE)
    (CL:IF SETVALUE? (CL:SETF (%NEGATIVE-SCORE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%NEGATIVE-SCORE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFCLASS PRIMITIVE-STRATEGY ...)

(CL:DEFCLASS PRIMITIVE-STRATEGY (JUSTIFICATION)
  ((STRATEGY :ALLOCATION :INSTANCE :ACCESSOR %STRATEGY)))

(CL:DEFUN NEW-PRIMITIVE-STRATEGY ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PRIMITIVE-STRATEGY)))
   (CL:SETF (%NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%TRUTH-VALUE SELF) NULL)
   (CL:SETF (%REVERSE-POLARITY? SELF) CL:NIL)
   (CL:SETF (%SUBSTITUTION SELF) NULL)
   (CL:SETF (%PATTERN-JUSTIFICATION SELF) NULL)
   (CL:SETF (%ANTECEDENTS SELF) NIL) (CL:SETF (%PROPOSITION SELF) NULL)
   (CL:SETF (%STRATEGY SELF) NULL)
   (CL:SETF (%INFERENCE-RULE SELF) KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PRIMITIVE-STRATEGY))
  SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)

(CL:DEFMETHOD INFERENCE-STRATEGY ((SELF PRIMITIVE-STRATEGY))
  (%STRATEGY SELF))

(CL:DEFUN ACCESS-PRIMITIVE-STRATEGY-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE)
    (CL:IF SETVALUE? (CL:SETF (%INFERENCE-RULE SELF) VALUE)
     (CL:SETQ VALUE (%INFERENCE-RULE SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-STRATEGY)
    (CL:IF SETVALUE? (CL:SETF (%STRATEGY SELF) VALUE)
     (CL:SETQ VALUE (%STRATEGY SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (JUSTIFICATION-ARGUMENT-BOUND-TO OBJECT) ...)

(CL:DEFUN JUSTIFICATION-ARGUMENT-BOUND-TO (ARGUMENT JUSTIFICATION)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARGUMENT)
     SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
    (CL:PROGN
     (CL:WHEN (CL:EQ JUSTIFICATION NULL)
      (CL:SETQ JUSTIFICATION *CURRENTJUSTIFICATION*))
     (CL:WHEN (CL:NOT (CL:EQ JUSTIFICATION NULL))
      (CL:LET*
       ((PATTERN
         (CL:IF
          (CL:EQ (%INFERENCE-RULE JUSTIFICATION) KWD-JUSTIFICATIONS-PATTERN)
          JUSTIFICATION (%PATTERN-JUSTIFICATION JUSTIFICATION)))
        (SUBSTITUTION
         (CL:IF (CL:NOT (CL:EQ PATTERN NULL)) (%SUBSTITUTION PATTERN) NULL))
        (VALUE NULL))
       (CL:WHEN (CL:NOT (CL:EQ SUBSTITUTION NULL))
        (CL:SETQ VALUE (LOOKUP SUBSTITUTION ARGUMENT)))
       (CL:WHEN (CL:AND (CL:EQ VALUE NULL) (CL:NOT (CL:EQ PATTERN NULL)))
        (CL:SETQ PATTERN (%PATTERN-JUSTIFICATION PATTERN))
        (CL:WHEN (CL:NOT (CL:EQ PATTERN NULL))
         (CL:SETQ VALUE (JUSTIFICATION-ARGUMENT-BOUND-TO ARGUMENT PATTERN))))
       (CL:RETURN-FROM JUSTIFICATION-ARGUMENT-BOUND-TO VALUE)))))
   (CL:T (CL:RETURN-FROM JUSTIFICATION-ARGUMENT-BOUND-TO ARGUMENT)))
  NULL)

;;; (DEFUN (YIELD-JUSTIFICATION-SUBSTITUTION ENTITY-MAPPING) ...)

(CL:DEFUN YIELD-JUSTIFICATION-SUBSTITUTION (JUSTIFICATION SUBSTITUTION ARGUMENT)
  (CL:LET*
   ((TOP (%PROPOSITION JUSTIFICATION))
    (PROPOSITION (CL:IF (CL:EQ ARGUMENT NULL) TOP ARGUMENT)))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
        (CL:PROGN
         (CL:WHEN (FREE-VARIABLE? ARG TOP)
          (CL:WHEN (CL:EQ SUBSTITUTION NULL)
           (CL:SETQ SUBSTITUTION (NEW-KEY-VALUE-MAP)))
          (INSERT-AT SUBSTITUTION ARG
           (JUSTIFICATION-ARGUMENT-BOUND-TO ARG JUSTIFICATION)))))
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
        (CL:PROGN
         (CL:SETQ SUBSTITUTION
          (YIELD-JUSTIFICATION-SUBSTITUTION JUSTIFICATION SUBSTITUTION ARG))))
       (CL:T)))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   SUBSTITUTION))

;;; (DEFUN (JUSTIFICATION-EQL? BOOLEAN) ...)

(CL:DEFUN JUSTIFICATION-EQL? (JUST1 JUST2)
  (CL:OR (CL:EQ JUST1 JUST2)
   (CL:AND (CL:EQ (%INFERENCE-RULE JUST1) (%INFERENCE-RULE JUST2))
    (CL:EQ (%REVERSE-POLARITY? JUST1) (%REVERSE-POLARITY? JUST2))
    (CL:OR
     (CL:AND
      (CL:NOT
       (CL:EQ (%INFERENCE-RULE JUST1) KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY))
      (CL:NOT
       (CL:EQ (%INFERENCE-RULE JUST2) KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)))
     (CL:EQ (%STRATEGY JUST1) (%STRATEGY JUST2)))
    (JUSTIFICATION-PROPOSITIONS-EQL? (%PROPOSITION JUST1) JUST1
     (%PROPOSITION JUST2) JUST2))))

;;; (DEFUN (JUSTIFICATION-PROPOSITIONS-EQL? BOOLEAN) ...)

(CL:DEFUN JUSTIFICATION-PROPOSITIONS-EQL? (PROPOSITION1 JUST1 PROPOSITION2 JUST2)
  (CL:WHEN
   (CL:AND (CL:EQ (%OPERATOR PROPOSITION1) (%OPERATOR PROPOSITION2))
    (CL:= (LENGTH (%ARGUMENTS PROPOSITION1))
     (LENGTH (%ARGUMENTS PROPOSITION2))))
   (CL:LET*
    ((ARG1 NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION1)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (ARG2 NULL)
     (VECTOR-001 (%ARGUMENTS PROPOSITION2)) (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
     (CL:SETQ ARG1
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:SETQ ARG2
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001)) INDEX-001))
     (CL:WHEN (CL:OR (CL:NOT (EQL? ARG1 ARG2)) (VARIABLE? ARG1))
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG1)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
         (CL:PROGN
          (CL:WHEN
           (CL:NOT
            (CL:AND (ISA? ARG2 SGT-JUSTIFICATIONS-LOGIC-PROPOSITION)
             (JUSTIFICATION-PROPOSITIONS-EQL? ARG1 JUST1 ARG2 JUST2)))
           (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL))))
        ((SUBTYPE-OF? TEST-VALUE-000
          SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
         (CL:PROGN
          (CL:COND
           ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG2)
             SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
            (CL:PROGN
             (CL:LET*
              ((VALUE1 (JUSTIFICATION-ARGUMENT-BOUND-TO ARG1 JUST1))
               (VALUE2 (JUSTIFICATION-ARGUMENT-BOUND-TO ARG2 JUST2)))
              (CL:WHEN
               (CL:OR (CL:EQ VALUE1 NULL) (CL:EQ VALUE2 NULL)
                (CL:NOT (EQL? VALUE1 VALUE2)))
               (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL)))))
           (CL:T
            (CL:WHEN
             (CL:NOT (EQL? (JUSTIFICATION-ARGUMENT-BOUND-TO ARG1 JUST1) ARG2))
             (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL))))))
        (CL:T
         (CL:COND
          ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE ARG2)
            SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE)
           (CL:PROGN
            (CL:WHEN
             (CL:NOT (EQL? (JUSTIFICATION-ARGUMENT-BOUND-TO ARG2 JUST2) ARG1))
             (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL))))
          (CL:T (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:NIL)))))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))
   (CL:RETURN-FROM JUSTIFICATION-PROPOSITIONS-EQL? CL:T))
  CL:NIL)

;;; (DEFMETHOD (COPY (LIKE SELF)) ...)

(CL:DEFMETHOD COPY ((SELF JUSTIFICATION))
  "Return a copy of the proof starting at `self'.  Allocates
all new justification objects, but structure-shares other information such
as propositions and substitutions."
  (CL:LET* ((COPY NULL) (ANTECEDENTS NIL))
   (CL:COND
    ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF)
      SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)
     (CL:PROGN
      (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
       (CL:SETF (%STRATEGY SELF-000) (%STRATEGY SELF))
       (CL:SETQ COPY SELF-000))))
    (CL:T (CL:SETQ COPY (NEW-JUSTIFICATION))))
   (CL:SETF (%INFERENCE-RULE COPY) (%INFERENCE-RULE SELF))
   (CL:SETF (%PROPOSITION COPY) (%PROPOSITION SELF))
   (CL:SETF (%SUBSTITUTION COPY) (%SUBSTITUTION SELF))
   (CL:SETF (%REVERSE-POLARITY? COPY) (%REVERSE-POLARITY? SELF))
   (CL:SETF (%TRUTH-VALUE COPY) (%TRUTH-VALUE SELF))
   (CL:SETF (%POSITIVE-SCORE COPY) (%POSITIVE-SCORE SELF))
   (CL:SETF (%NEGATIVE-SCORE COPY) (%NEGATIVE-SCORE SELF))
   (CL:LET*
    ((ANTECEDENT NULL) (ITER-000 (%ANTECEDENTS SELF)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (COPY ANTECEDENT) NIL))
       (CL:IF (CL:EQ ANTECEDENTS NIL) (CL:SETQ ANTECEDENTS COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ANTECEDENTS COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS (COPY ANTECEDENT) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETF (%ANTECEDENTS COPY) ANTECEDENTS)
   (CL:WHEN (CL:EQ (%INFERENCE-RULE SELF) KWD-JUSTIFICATIONS-PATTERN)
    (CL:LET* ((ANTECEDENT NULL) (ITER-001 (%ANTECEDENTS COPY)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
      (CL:SETQ ANTECEDENT (%%VALUE ITER-001))
      (BACKLINK-TO-PATTERN-JUSTIFICATION ANTECEDENT COPY)
      (CL:SETQ ITER-001 (%%REST ITER-001)))))
   COPY))

;;; (DEFSPECIAL *RECORD-JUSTIFICATIONS?* ...)

(CL:DEFVAR *RECORD-JUSTIFICATIONS?* CL:NIL
  "If TRUE every query records justifications to enable
the explanation of concluded results.")

;;; (DEFUN (RECORD-JUSTIFICATIONS? BOOLEAN) ...)

(CL:DEFUN RECORD-JUSTIFICATIONS? ()
  "Return TRUE if every query records justifications to enable
the explanation of concluded results."
  *RECORD-JUSTIFICATIONS?*)

;;; (DEFUN RECORD-GOAL-JUSTIFICATION ...)

(CL:DEFUN RECORD-GOAL-JUSTIFICATION (GOAL JUSTIFICATION)
  (CL:WHEN (CL:EQ (%PROPOSITION JUSTIFICATION) NULL)
   (CL:SETF (%PROPOSITION JUSTIFICATION) (%PROPOSITION GOAL)))
  (CL:SETF (%REVERSE-POLARITY? JUSTIFICATION) (%REVERSE-POLARITY? GOAL))
  (CL:SETF (%TRUTH-VALUE JUSTIFICATION) (%TRUTH-VALUE GOAL))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
    (CL:NOT (CL:EQ (%PARTIAL-MATCH-STRATEGY *QUERYITERATOR*) NULL)))
   (SET-JUSTIFICATION-PARTIAL-TRUTH GOAL JUSTIFICATION))
  (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS GOAL)
   SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION JUSTIFICATION NULL))

;;; (DEFUN RECORD-PRIMITIVE-JUSTIFICATION ...)

(CL:DEFUN RECORD-PRIMITIVE-JUSTIFICATION (FRAME LASTMOVE)
  (CL:COND
   ((CL:OR (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL))
    (CL:LET*
     ((STRATEGY
       (CL:IF (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL)
        KWD-JUSTIFICATIONS-FAILURE (%CURRENT-STRATEGY FRAME)))
      (JUSTIFICATION NULL))
     (CL:COND
      ((CL:AND (CL:NOT (CL:EQ (%JUSTIFICATIONS FRAME) NULL))
        (CL:NOT (EMPTY? (%JUSTIFICATIONS FRAME))))
       (CL:SETQ JUSTIFICATION (FIRST (%JUSTIFICATIONS FRAME))))
      ((CL:NOT (CL:EQ (%RESULT FRAME) NULL))
       (CL:COND
        ((CL:NOT
          (CL:EQ
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%RESULT FRAME))
            SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
           NULL))
         (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
          (CL:SETF (%STRATEGY SELF-000) STRATEGY)
          (CL:SETF (%ANTECEDENTS SELF-000)
           (CONS
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%RESULT FRAME))
             SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
            NIL))
          (CL:SETQ JUSTIFICATION SELF-000)))
        ((CL:AND (CL:NOT (CL:EQ (%PROPOSITION (%RESULT FRAME)) NULL))
          (NON-EMPTY?
           (FORWARD-JUSTIFICATIONS (%PROPOSITION (%RESULT FRAME)))))
         (CL:SETQ JUSTIFICATION
          (FIRST (FORWARD-JUSTIFICATIONS (%PROPOSITION (%RESULT FRAME))))))))
      ((CL:AND (CL:NOT (CL:EQ (%PROPOSITION FRAME) NULL))
        (NON-EMPTY? (FORWARD-JUSTIFICATIONS (%PROPOSITION FRAME))))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
        "RECORD-PRIMITIVE-JUSTIFICATION:  Test to see if clause needed." EOL)
       (CL:SETQ JUSTIFICATION
        (FIRST (FORWARD-JUSTIFICATIONS (%PROPOSITION FRAME)))))
      (CL:T))
     (CL:WHEN (CL:EQ JUSTIFICATION NULL)
      (CL:LET* ((SELF-001 (NEW-PRIMITIVE-STRATEGY)))
       (CL:SETF (%STRATEGY SELF-001) STRATEGY)
       (CL:SETQ JUSTIFICATION SELF-001)))
     (RECORD-GOAL-JUSTIFICATION FRAME JUSTIFICATION)))
   (CL:T)))

;;; (DEFUN RECORD-PATTERN-JUSTIFICATION ...)

(CL:DEFUN RECORD-PATTERN-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET*
   ((ARGUMENT (%RESULT FRAME))
    (JUSTIFICATION
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)))
   (CL:COND
    ((CL:OR (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
      (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL))
     (CL:WHEN
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARGUMENT)
        SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
       NULL)
      (CL:RETURN-FROM RECORD-PATTERN-JUSTIFICATION))
     (CL:WHEN (CL:EQ JUSTIFICATION NULL)
      (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
       (CL:SETF (%INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-PATTERN)
       (RECORD-GOAL-JUSTIFICATION FRAME SELF-000))
      (CL:SETQ JUSTIFICATION
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
        SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)))
     (CL:LET*
      ((SUBSTITUTION (NEW-KEY-VALUE-MAP))
       (PATTERNRECORD (%PATTERN-RECORD FRAME)) (DESCRIPTION NULL)
       (COLLECTIONFRAME? CL:NIL))
      (CL:WHEN (CL:NOT (CL:EQ PATTERNRECORD NULL))
       (CL:SETQ COLLECTIONFRAME?
        (CL:NOT (CL:EQ (%COLLECTION-LIST PATTERNRECORD) NULL)))
       (CL:SETQ DESCRIPTION (%OPTIMAL-PATTERN PATTERNRECORD))
       (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
        (CL:LET*
         ((VBL NULL) (VECTOR-000 (%IO-VARIABLES DESCRIPTION)) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ VBL
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (INSERT-AT SUBSTITUTION VBL
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%THE-ARRAY
              (%VARIABLE-BINDINGS (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
            (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET VBL))))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
        (CL:LET*
         ((VBL NULL) (VECTOR-001 (%INTERNAL-VARIABLES DESCRIPTION))
          (INDEX-001 0) (LENGTH-001 (LENGTH VECTOR-001)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
         (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
          (CL:SETQ VBL
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
            INDEX-001))
          (INSERT-AT SUBSTITUTION VBL
           (CL:AREF
            (CL:THE CL:SIMPLE-VECTOR
             (%THE-ARRAY
              (%VARIABLE-BINDINGS (%CURRENT-PATTERN-RECORD *QUERYITERATOR*))))
            (CL:THE CL:FIXNUM (%BOUND-TO-OFFSET VBL))))
          (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))))
      (CL:WHEN (ISA? SUBSTITUTION SGT-JUSTIFICATIONS-STELLA-KEY-VALUE-LIST)
       (CL:LET* ((OLDSUBSTITUTION SUBSTITUTION))
        (CL:SETQ SUBSTITUTION (NEW-KEY-VALUE-MAP))
        (CL:LET*
         ((KEY NULL) (VAL NULL)
          (ITER-000 (ALLOCATE-ITERATOR OLDSUBSTITUTION)))
         (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ KEY (%KEY ITER-000))
          (CL:SETQ VAL (%VALUE ITER-000)) (INSERT-AT SUBSTITUTION KEY VAL)))))
      (CL:SETF (%SUBSTITUTION JUSTIFICATION) SUBSTITUTION)
      (CL:LET*
       ((ANTECEDENT
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARGUMENT)
          SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)))
       (CL:WHEN COLLECTIONFRAME?
        (CL:SETF (%INFERENCE-RULE JUSTIFICATION)
         KWD-JUSTIFICATIONS-AND-INTRODUCTION)
        (CL:LET* ((PATTERNCOPY NULL))
         (CL:LET* ((SELF-003 (NEW-JUSTIFICATION)))
          (CL:SETF (%INFERENCE-RULE SELF-003) KWD-JUSTIFICATIONS-PATTERN)
          (CL:SETF (%ANTECEDENTS SELF-003) (CONS ANTECEDENT NIL))
          (RECORD-GOAL-JUSTIFICATION FRAME SELF-003))
         (CL:SETQ PATTERNCOPY
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
           SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
         (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
          SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION JUSTIFICATION NULL)
         (BACKLINK-TO-PATTERN-JUSTIFICATION ANTECEDENT PATTERNCOPY)
         (BACKLINK-TO-PATTERN-JUSTIFICATION PATTERNCOPY JUSTIFICATION)
         (CL:SETF (%SUBSTITUTION PATTERNCOPY) SUBSTITUTION)
         (CL:SETF (%SUBSTITUTION JUSTIFICATION) NULL)
         (CL:SETQ ANTECEDENT PATTERNCOPY)))
       (CL:SETF (%ANTECEDENTS JUSTIFICATION)
        (CONS ANTECEDENT (%ANTECEDENTS JUSTIFICATION)))
       (CL:WHEN (CL:NOT COLLECTIONFRAME?)
        (BACKLINK-TO-PATTERN-JUSTIFICATION ANTECEDENT JUSTIFICATION)))))
    (CL:T))))

;;; (DEFUN BACKLINK-TO-PATTERN-JUSTIFICATION ...)

(CL:DEFUN BACKLINK-TO-PATTERN-JUSTIFICATION (JUSTIFICATION PATTERN)
  (CL:WHEN (CL:EQ (%PATTERN-JUSTIFICATION JUSTIFICATION) NULL)
   (CL:SETF (%PATTERN-JUSTIFICATION JUSTIFICATION) PATTERN)
   (CL:LET* ((ANTECEDENT NULL) (ITER-000 (%ANTECEDENTS JUSTIFICATION)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
     (BACKLINK-TO-PATTERN-JUSTIFICATION ANTECEDENT PATTERN)
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN RECORD-MODUS-PONENS-JUSTIFICATION ...)

(CL:DEFUN RECORD-MODUS-PONENS-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((ANTECEDENT (%RESULT FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET*
      ((GOAL (EXTRACT-SUBGOAL-OF-FRAME FRAME))
       (REVERSEPOLARITY? (%REVERSE-POLARITY? FRAME))
       (INFERENCERULE
        (CL:IF REVERSEPOLARITY? KWD-JUSTIFICATIONS-MODUS-TOLLENS
         KWD-JUSTIFICATIONS-MODUS-PONENS))
       (RULE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
         SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE NULL))
       (RULECONSEQUENT
        (%PROPOSITION
         (CL:IF (CL:EQ INFERENCERULE KWD-JUSTIFICATIONS-MODUS-PONENS)
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS RULE))) 1)
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS RULE)))
           0))))
       (INVERTED? (CL:EQ (%KIND RULECONSEQUENT) KWD-JUSTIFICATIONS-NOT)))
      (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
       (CL:SETF (%INFERENCE-RULE SELF-000) INFERENCERULE)
       (CL:SETF (%PROPOSITION SELF-000) GOAL)
       (CL:LET* ((SELF-001 (NEW-PRIMITIVE-STRATEGY)))
        (CL:SETF (%STRATEGY SELF-001) KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS)
        (CL:SETF (%PROPOSITION SELF-001) RULE)
        (CL:SETF (%TRUTH-VALUE SELF-001)
         (ACCESS-IN-CONTEXT (%TRUTH-VALUE RULE) (%HOME-CONTEXT RULE) CL:NIL))
        (CL:SETF (%POSITIVE-SCORE SELF-001)
         (%POSITIVE-SCORE
          (ACCESS-IN-CONTEXT (%TRUTH-VALUE RULE) (%HOME-CONTEXT RULE)
           CL:NIL)))
        (CL:SETF (%ANTECEDENTS SELF-000)
         (CONS SELF-001
          (CONS
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ANTECEDENT)
            SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
           NIL))))
       (CL:LET* ((JUSTIFICATION SELF-000))
        (RECORD-GOAL-JUSTIFICATION FRAME JUSTIFICATION)
        (CL:SETF (%REVERSE-POLARITY? JUSTIFICATION)
         (CL:IF REVERSEPOLARITY? (CL:NOT INVERTED?) INVERTED?))))))
    (CL:T))))

;;; (DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET*
   ((CONJUNCTS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      SYM-JUSTIFICATIONS-STELLA-ARGUMENTS NULL))
    (ANTECEDENTS NIL))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET*
      ((CONJUNCT NULL) (VECTOR-000 CONJUNCTS) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ CONJUNCT
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
       (CL:PROGN)
       (CL:IF (CL:EQ COLLECT-000 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-000
          (CONS
           (CL:IF (CL:EQ (%STATE CONJUNCT) KWD-JUSTIFICATIONS-POPPED)
            (COPY
             (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONJUNCT)
              SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONJUNCT)
             SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
           NIL))
         (CL:IF (CL:EQ ANTECEDENTS NIL) (CL:SETQ ANTECEDENTS COLLECT-000)
          (ADD-CONS-TO-END-OF-CONS-LIST ANTECEDENTS COLLECT-000)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-000)
          (CONS
           (CL:IF (CL:EQ (%STATE CONJUNCT) KWD-JUSTIFICATIONS-POPPED)
            (COPY
             (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONJUNCT)
              SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONJUNCT)
             SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL))
           NIL))
         (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-AND-INTRODUCTION)
      (CL:SETF (%ANTECEDENTS SELF-000) ANTECEDENTS)
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((DISJUNCT (%RESULT FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-OR-INTRODUCTION)
      (CL:SETF (%ANTECEDENTS SELF-000)
       (CONS
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS DISJUNCT)
         SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
        NIL))
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN RECORD-DISPROOF-JUSTIFICATION ...)

(CL:DEFUN RECORD-DISPROOF-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((ARGUMENT (%RESULT FRAME)))
   (CL:COND
    ((CL:OR (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
      (CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL))
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-DISPROOF)
      (CL:SETF (%ANTECEDENTS SELF-000)
       (CONS
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARGUMENT)
         SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
        NIL))
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN RECORD-FAIL-JUSTIFICATION ...)

(CL:DEFUN RECORD-FAIL-JUSTIFICATION (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL)
    (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
     (CL:SETF (%INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-FAIL-INTRODUCTION)
     (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
   (CL:T)))

;;; (DEFUN RECORD-CLOSED-NOT-JUSTIFICATION ...)

(CL:DEFUN RECORD-CLOSED-NOT-JUSTIFICATION (FRAME LASTMOVE)
  (CL:COND
   ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-FAIL)
    (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
     (CL:SETF (%INFERENCE-RULE SELF-000)
      KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION)
     (CL:SETF (%PROPOSITION SELF-000)
      (CL:IF (CL:EQ (%KIND (%PROPOSITION FRAME)) KWD-JUSTIFICATIONS-FAIL)
       (%PROPOSITION (%UP FRAME)) (%PROPOSITION FRAME)))
     (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
   (CL:T)))

;;; (DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION ...)

(CL:DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION (FRAME LASTMOVE)
  (CL:LET* ((ARGUMENT (%RESULT FRAME)))
   (CL:COND
    ((CL:EQ LASTMOVE KWD-JUSTIFICATIONS-UP-TRUE)
     (CL:LET* ((SELF-000 (NEW-JUSTIFICATION)))
      (CL:SETF (%INFERENCE-RULE SELF-000)
       KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION)
      (CL:SETF (%ANTECEDENTS SELF-000)
       (CL:IF
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARGUMENT)
           SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
          NULL))
        (CONS
         (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARGUMENT)
          SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION NULL)
         NIL)
        NIL))
      (RECORD-GOAL-JUSTIFICATION FRAME SELF-000)))
    (CL:T))))

;;; (DEFUN (FAILED-GOAL-JUSTIFICATION? BOOLEAN) ...)

(CL:DEFUN FAILED-GOAL-JUSTIFICATION? (SELF)
  (CL:LET* ((TEST-VALUE-000 (%INFERENCE-RULE SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY)
      (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-TIMEOUT)
      (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-DEPTH-CUTOFF))
     (CL:COND
      ((CL:EQ (%STRATEGY SELF) KWD-JUSTIFICATIONS-FAILURE)
       (CL:RETURN-FROM FAILED-GOAL-JUSTIFICATION? CL:T))
      (CL:T)))
    (CL:T)))
  CL:NIL)

;;; (DEFUN (CUTOFF-GOAL-JUSTIFICATION? BOOLEAN) ...)

(CL:DEFUN CUTOFF-GOAL-JUSTIFICATION? (SELF)
  (CL:LET* ((TEST-VALUE-000 (%INFERENCE-RULE SELF)))
   (CL:COND
    ((CL:OR (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-TIMEOUT)
      (CL:EQ TEST-VALUE-000 KWD-JUSTIFICATIONS-DEPTH-CUTOFF))
     (CL:RETURN-FROM CUTOFF-GOAL-JUSTIFICATION? CL:T))
    (CL:T)))
  CL:NIL)

;;; (DEFMETHOD (CONSIFY CONS) ...)

(CL:DEFMETHOD CONSIFY ((SELF JUSTIFICATION))
  "Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.  The
consification follows the original proof structure literally, i.e., no
uninteresting nodes such as patterns or AND-introductions are suppressed."
  (CONSIFY-JUSTIFICATION SELF KWD-JUSTIFICATIONS-RAW))

;;; (DEFUN (CONSIFY-JUSTIFICATION CONS) ...)

(CL:DEFUN CONSIFY-JUSTIFICATION (SELF STYLE)
  "Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.
`style' indicates what nodes in the proof tree should be suppressed.
:RAW preserves the original structure literally, :VERBOSE keeps AND-
introductions but suppresses all auxiliary (non-logical) nodes such as
pattern nodes, and :BRIEF additionally suppresses AND-introduction nodes."
  (CL:LET* ((*EXPLANATION-STYLE* STYLE))
   (CL:DECLARE (CL:SPECIAL *EXPLANATION-STYLE*))
   (CL:WHEN (CL:NOT (CL:EQ STYLE KWD-JUSTIFICATIONS-RAW))
    (CL:SETQ SELF (VISIBLE-JUSTIFICATION SELF)))
   (CL:LET*
    ((ANTECEDENTS
      (CL:IF (CL:EQ STYLE KWD-JUSTIFICATIONS-RAW) (%ANTECEDENTS SELF)
       (%THE-CONS-LIST (VISIBLE-ANTECEDENTS SELF))))
     (PROPOSITION NULL) (KEYS (NEW-PROPERTY-LIST)) (SUBSTITUTION NIL)
     (CONSIFIEDSELF NIL))
    (CL:WHEN (CL:NOT (CL:EQ (%INFERENCE-RULE SELF) NULL))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-INFERENCE-RULE (%INFERENCE-RULE SELF))
     (CL:WHEN (ISA? SELF SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY)
      (INSERT-AT KEYS KWD-JUSTIFICATIONS-STRATEGY (%STRATEGY SELF))))
    (CL:IF (CL:NOT (CL:EQ (%TRUTH-VALUE SELF) NULL))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-TRUTH-VALUE (%TRUTH-VALUE SELF))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-TRUTH-VALUE UNKNOWN-TRUTH-VALUE))
    (CL:WHEN (CL:NOT (CL:= (%POSITIVE-SCORE SELF) NULL-FLOAT))
     (INSERT-AT KEYS KWD-JUSTIFICATIONS-POSITIVE-SCORE
      (WRAP-FLOAT (%POSITIVE-SCORE SELF))))
    (CL:LET* ((THESUBSTITUTION (%SUBSTITUTION SELF)))
     (CL:WHEN (CL:EQ THESUBSTITUTION NULL)
      (CL:LET* ((ANT NULL) (ITER-000 (%ANTECEDENTS SELF)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ ANT (%%VALUE ITER-000))
        (CL:WHEN (CL:EQ (%INFERENCE-RULE ANT) KWD-JUSTIFICATIONS-PATTERN)
         (CL:SETQ THESUBSTITUTION (%SUBSTITUTION ANT)) (CL:RETURN))
        (CL:SETQ ITER-000 (%%REST ITER-000)))))
     (CL:WHEN (CL:NOT (CL:EQ THESUBSTITUTION NULL))
      (CL:LET*
       ((VAR NULL) (BINDING NULL)
        (ITER-001 (ALLOCATE-ITERATOR THESUBSTITUTION)))
       (CL:LOOP WHILE (NEXT? ITER-001) DO (CL:SETQ VAR (%KEY ITER-001))
        (CL:SETQ BINDING (%VALUE ITER-001))
        (CL:SETQ SUBSTITUTION (CONS (GENERATE-TERM VAR) SUBSTITUTION))
        (CL:SETQ SUBSTITUTION (CONS (GENERATE-TERM BINDING) SUBSTITUTION))))
      (INSERT-AT KEYS KWD-JUSTIFICATIONS-SUBSTITUTION
       (REVERSE SUBSTITUTION))))
    (CL:LET* ((*CURRENTJUSTIFICATION* SELF))
     (CL:DECLARE (CL:SPECIAL *CURRENTJUSTIFICATION*))
     (CL:SETQ PROPOSITION (GENERATE-PROPOSITION (%PROPOSITION SELF)))
     (CL:WHEN (%REVERSE-POLARITY? SELF)
      (CL:SETQ PROPOSITION
       (LIST* SYM-JUSTIFICATIONS-STELLA-NOT PROPOSITION NIL))))
    (CL:SETQ CONSIFIEDSELF (CONS-LIST PROPOSITION (%THE-PLIST KEYS)))
    (CL:LET* ((ANTECEDENT NULL) (ITER-002 ANTECEDENTS) (COLLECT-000 NULL))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:SETQ ANTECEDENT (%%VALUE ITER-002))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000
         (CONS (CONSIFY-JUSTIFICATION ANTECEDENT STYLE) NIL))
        (CL:IF (CL:EQ CONSIFIEDSELF NIL) (CL:SETQ CONSIFIEDSELF COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST CONSIFIEDSELF COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (CONSIFY-JUSTIFICATION ANTECEDENT STYLE) NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ ITER-002 (%%REST ITER-002))))
    CONSIFIEDSELF)))

;;; (DEFUN (GET-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ...)

(CL:DEFUN GET-QUERY-JUSTIFICATIONS (QUERY SOLUTIONINDEX MAXJUSTIFICATIONS CREATE?)
  (CL:DECLARE (CL:TYPE CL:FIXNUM SOLUTIONINDEX MAXJUSTIFICATIONS))
  #+MCL
  (CL:CHECK-TYPE SOLUTIONINDEX CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MAXJUSTIFICATIONS CL:FIXNUM)
  (CL:LET*
   ((ASKQUERY? (QUERY-IS-TRUE-FALSE? QUERY)) (SOLUTIONS (%SOLUTIONS QUERY))
    (SOLUTION NULL) (NOFSOLUTIONS (LENGTH SOLUTIONS)) (JUSTIFICATIONS NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOFSOLUTIONS))
   (CL:WHEN (EMPTY? SOLUTIONS)
    (CL:RETURN-FROM GET-QUERY-JUSTIFICATIONS NIL-LIST))
   (CL:WHEN
    (CL:OR ASKQUERY? (CL:= SOLUTIONINDEX NULL-INTEGER) (CL:< SOLUTIONINDEX 0))
    (CL:SETQ SOLUTIONINDEX (CL:1- NOFSOLUTIONS)))
   (CL:WHEN (CL:>= SOLUTIONINDEX NOFSOLUTIONS)
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "There were only `"
      NOFSOLUTIONS "' solutions")
     (CL:ERROR (NEW-EXPLAIN-EXCEPTION (THE-STRING-READER STREAM-000)))))
   (CL:SETQ SOLUTION (NTH SOLUTIONS SOLUTIONINDEX))
   (CL:COND
    ((CL:EQ (%JUSTIFICATION SOLUTION) NULL)
     (CL:COND
      (CREATE?
       (CL:SETQ JUSTIFICATIONS
        (DERIVE-QUERY-JUSTIFICATIONS QUERY NULL SOLUTIONINDEX
         MAXJUSTIFICATIONS))
       (CL:SETF (%JUSTIFICATION SOLUTION) (FIRST JUSTIFICATIONS))
       (CL:SETF (%ALL-JUSTIFICATIONS SOLUTION) JUSTIFICATIONS) JUSTIFICATIONS)
      (CL:T NIL-LIST)))
    (CL:T
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ (%ALL-JUSTIFICATIONS SOLUTION) NULL))
       (NON-EMPTY? (%ALL-JUSTIFICATIONS SOLUTION)))
      (CL:SETQ JUSTIFICATIONS (LIST))
      (CL:LET*
       ((JUST NULL) (ITER-000 (%THE-CONS-LIST (%ALL-JUSTIFICATIONS SOLUTION)))
        (IGNORE NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-000 MAXJUSTIFICATIONS)
        (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER))
        (COLLECT-000 NULL))
       (CL:DECLARE (CL:TYPE CL:FIXNUM IGNORE ITER-001 UPPER-BOUND-000))
       (CL:LOOP WHILE
        (CL:AND (CL:NOT (CL:EQ ITER-000 NIL))
         (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
        DO (CL:SETQ JUST (%%VALUE ITER-000)) (CL:SETQ IGNORE ITER-001)
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN (CL:SETQ COLLECT-000 (CONS JUST NIL))
          (CL:IF (CL:EQ (%THE-CONS-LIST JUSTIFICATIONS) NIL)
           (CL:SETF (%THE-CONS-LIST JUSTIFICATIONS) COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST JUSTIFICATIONS)
            COLLECT-000)))
         (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS JUST NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
        (CL:SETQ ITER-000 (%%REST ITER-000))
        (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
     (CL:IF (CL:NOT (CL:EQ JUSTIFICATIONS NULL)) JUSTIFICATIONS
      (LIST (%JUSTIFICATION SOLUTION)))))))

;;; (DEFUN (DERIVE-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ...)

(CL:DEFUN DERIVE-QUERY-JUSTIFICATIONS (QUERY OPTIONS SOLUTIONINDEX MAXJUSTIFICATIONS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM SOLUTIONINDEX MAXJUSTIFICATIONS))
  #+MCL
  (CL:CHECK-TYPE SOLUTIONINDEX CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE MAXJUSTIFICATIONS CL:FIXNUM)
  (CL:LET*
   ((*QUERYITERATOR* QUERY) (*CONTEXT* (%QUERY-CONTEXT QUERY))
    (*INFERENCELEVEL* (CURRENT-INFERENCE-LEVEL)) (*REVERSEPOLARITY?* CL:NIL)
    (*GENERATE-ALL-PROOFS?* CL:NIL) (*RECORD-JUSTIFICATIONS?* CL:T))
   (CL:DECLARE
    (CL:SPECIAL *QUERYITERATOR* *CONTEXT* *INFERENCELEVEL* *REVERSEPOLARITY?*
     *GENERATE-ALL-PROOFS?* *RECORD-JUSTIFICATIONS?*))
   (CL:LET*
    ((ASKQUERY (ALLOCATE-QUERY-ITERATOR)) (QUERYOPTIONS (%OPTIONS QUERY)))
    (CL:WHEN (CL:EQ OPTIONS NULL) (CL:SETQ QUERYOPTIONS (COPY QUERYOPTIONS))
     (REMOVE-AT QUERYOPTIONS KWD-JUSTIFICATIONS-HOW-MANY)
     (CL:SETQ OPTIONS QUERYOPTIONS))
    (PROCESS-QUERY-OPTIONS ASKQUERY OPTIONS)
    (CL:LET* ((*TYPE-CHECK-STRATEGY* KWD-JUSTIFICATIONS-NONE))
     (CL:DECLARE (CL:SPECIAL *TYPE-CHECK-STRATEGY*))
     (INITIALIZE-QUERY-ITERATOR ASKQUERY (QUERY-DESCRIPTION QUERY)
      (%BINDINGS (NTH (%SOLUTIONS QUERY) SOLUTIONINDEX))))
    (CL:IF (QUERY-IS-PARTIAL? QUERY) (CALL-ASK-PARTIAL ASKQUERY)
     (CALL-ASK ASKQUERY))
    (GET-QUERY-JUSTIFICATIONS ASKQUERY NULL-INTEGER MAXJUSTIFICATIONS CL:NIL))))

;;; (DEFCLASS FORWARD-GOAL-RECORD ...)

(CL:DEFCLASS FORWARD-GOAL-RECORD (STANDARD-OBJECT)
  ((FORWARD-GOAL :ALLOCATION :INSTANCE :ACCESSOR %FORWARD-GOAL)
   (FORWARD-RULE :ALLOCATION :INSTANCE :ACCESSOR %FORWARD-RULE)))

(CL:DEFUN NEW-FORWARD-GOAL-RECORD ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FORWARD-GOAL-RECORD)))
   (CL:SETF (%FORWARD-RULE SELF) NULL) (CL:SETF (%FORWARD-GOAL SELF) NULL)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORWARD-GOAL-RECORD))
  SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD)

(CL:DEFUN ACCESS-FORWARD-GOAL-RECORD-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL)
    (CL:IF SETVALUE? (CL:SETF (%FORWARD-GOAL SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-GOAL SELF))))
   ((CL:EQ SLOTNAME SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE)
    (CL:IF SETVALUE? (CL:SETF (%FORWARD-RULE SELF) VALUE)
     (CL:SETQ VALUE (%FORWARD-RULE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD FORWARD-CHAINING-GOALS ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFMETHOD (DELETED? BOOLEAN) ...)

(CL:DEFMETHOD DELETED? ((SELF FORWARD-GOAL-RECORD))
  (CL:LET* ((GOAL (%FORWARD-GOAL SELF)) (RULE (%FORWARD-RULE SELF)))
   (CL:OR (CL:EQ GOAL NULL) (CL:EQ RULE NULL) (DELETED-PROPOSITION? GOAL)
    (DELETED-PROPOSITION? RULE))))

;;; (DEFMETHOD (DELETED?-SETTER BOOLEAN) ...)

(CL:DEFMETHOD DELETED?-SETTER ((SELF FORWARD-GOAL-RECORD) VALUE)
  (CL:WHEN VALUE (CL:SETF (%FORWARD-GOAL SELF) NULL)
   (CL:SETF (%FORWARD-RULE SELF) NULL))
  VALUE)

;;; (DEFUN RECORD-FORWARD-GOAL ...)

(CL:DEFUN RECORD-FORWARD-GOAL (FORWARDRULE ARGUMENTS CONSEQUENTPROPOSITION)
  (CL:LET*
   ((FWDGOALREC NULL)
    (ITER-000
     (%THE-CONS-LIST (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION))))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ FWDGOALREC (%%VALUE ITER-000))
    (CL:WHEN (CL:NOT (DELETED? FWDGOALREC))
     (CL:LET* ((FWDGOAL (%FORWARD-GOAL FWDGOALREC)))
      (CL:LET* ((TEST-VALUE-000 CL:NIL))
       (CL:SETQ TEST-VALUE-000 (CL:EQ (%FORWARD-RULE FWDGOALREC) FORWARDRULE))
       (CL:WHEN TEST-VALUE-000
        (CL:LET* ((ALWAYS?-000 CL:T))
         (CL:LET*
          ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
           (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-001 1))
          (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-001))
          (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
           (CL:SETQ ARG
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
             INDEX-000))
           (CL:SETQ I ITER-001)
           (CL:WHEN
            (CL:NOT
             (EQL?
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS FWDGOAL))) I)
              ARG))
            (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
           (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
           (CL:SETQ ITER-001 (CL:1+ ITER-001))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
       (CL:WHEN TEST-VALUE-000 (CL:RETURN-FROM RECORD-FORWARD-GOAL)))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:WHEN (ELABORATION-RULE? CONSEQUENTPROPOSITION FORWARDRULE ARGUMENTS)
   (CL:RETURN-FROM RECORD-FORWARD-GOAL))
  (CL:LET*
   ((FORWARDGOAL
     (CREATE-PROPOSITION SYM-JUSTIFICATIONS-STELLA-PREDICATE
      (CL:1+ (LENGTH ARGUMENTS)))))
   (CL:LET* ((SELF-000 (NEW-FORWARD-GOAL-RECORD)))
    (CL:SETF (%FORWARD-GOAL SELF-000) FORWARDGOAL)
    (CL:SETF (%FORWARD-RULE SELF-000) FORWARDRULE)
    (CL:LET* ((FWDGOALREC SELF-000))
     (CL:SETF (%OPERATOR FORWARDGOAL) SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS)
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS FORWARDGOAL)))
       (VALUE
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS FORWARDRULE))) 0))
       (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET*
      ((ARG NULL) (VECTOR-001 ARGUMENTS) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)) (I NULL-INTEGER) (ITER-002 1))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 I ITER-002))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001)) INDEX-001))
       (CL:SETQ I ITER-002)
       (CL:LET
        ((SELF (%THE-ARRAY (%ARGUMENTS FORWARDGOAL))) (VALUE ARG)
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
       (CL:SETQ ITER-002 (CL:1+ ITER-002))))
     (CL:IF (EMPTY? (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONSEQUENTPROPOSITION)
       SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS (LIST FWDGOALREC) NULL)
      (INSERT-NEW (FORWARD-CHAINING-GOALS CONSEQUENTPROPOSITION)
       FWDGOALREC))))))

;;; (DEFUN (PREDICATION? BOOLEAN) ...)

(CL:DEFUN PREDICATION? (PROPOSITION)
  (MEMBER?
   (GET-QUOTED-TREE "((:PREDICATE :FUNCTION :ISA :EQUIVALENT) \"/LOGIC\")"
    "/LOGIC")
   (%KIND PROPOSITION)))

;;; (DEFUN (ASSERTED-AS-TRUE? BOOLEAN) ...)

(CL:DEFUN ASSERTED-AS-TRUE? (PROPOSITION)
  (CL:LET* ((*MODULE* (%BASE-MODULE *CONTEXT*)) (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:AND (CL:NOT (DELETED? PROPOSITION))
    (CL:IF *REVERSEPOLARITY?* (FALSE? PROPOSITION)
     (CL:OR (TRUE? PROPOSITION) (FUNCTION-WITH-DEFINED-VALUE? PROPOSITION))))))

;;; (DEFUN (ELABORATION-RULE? BOOLEAN) ...)

(CL:DEFUN ELABORATION-RULE? (CONSEQUENTPROPOSITION FORWARDRULE ARGUMENTS)
  (CL:LET* ((TEST-VALUE-000 CL:NIL))
   (CL:SETQ TEST-VALUE-000 (PREDICATION? CONSEQUENTPROPOSITION))
   (CL:WHEN TEST-VALUE-000
    (CL:SETQ TEST-VALUE-000 (ASSERTED-AS-TRUE? FORWARDRULE))
    (CL:WHEN TEST-VALUE-000
     (CL:LET* ((ALWAYS?-000 CL:T))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 (%ARGUMENTS CONSEQUENTPROPOSITION))
        (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
       (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:WHEN (CL:NOT (MEMBER? ARGUMENTS ARG)) (CL:SETQ ALWAYS?-000 CL:NIL)
         (CL:RETURN))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
      (CL:SETQ TEST-VALUE-000 ALWAYS?-000))))
   (CL:LET* ((VALUE-000 TEST-VALUE-000)) VALUE-000)))

;;; (DEFUN (GET-FORWARD-GOALS (LIST OF FORWARD-GOAL-RECORD)) ...)

(CL:DEFUN GET-FORWARD-GOALS (PROPOSITION)
  (CL:LET*
   ((GOALS (REMOVE-DELETED-MEMBERS (FORWARD-CHAINING-GOALS PROPOSITION))))
   (CL:WHEN
    (CL:AND (EMPTY? GOALS)
     (CL:NOT
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
        SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)
       NULL)))
    (CL:SETQ GOALS
     (REMOVE-DELETED-MEMBERS
      (FORWARD-CHAINING-GOALS
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
        SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL)))))
   GOALS))

;;; (DEFCLASS FORWARD-JUSTIFICATION ...)

(CL:DEFCLASS FORWARD-JUSTIFICATION (JUSTIFICATION)
  ())

(CL:DEFUN NEW-FORWARD-JUSTIFICATION ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FORWARD-JUSTIFICATION)))
   (CL:SETF (%NEGATIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%POSITIVE-SCORE SELF) NULL-FLOAT)
   (CL:SETF (%TRUTH-VALUE SELF) NULL)
   (CL:SETF (%REVERSE-POLARITY? SELF) CL:NIL)
   (CL:SETF (%SUBSTITUTION SELF) NULL)
   (CL:SETF (%PATTERN-JUSTIFICATION SELF) NULL)
   (CL:SETF (%ANTECEDENTS SELF) NIL) (CL:SETF (%PROPOSITION SELF) NULL)
   (CL:SETF (%INFERENCE-RULE SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FORWARD-JUSTIFICATION))
  SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION)

(CL:DEFMETHOD INFERENCE-DIRECTION ((SELF FORWARD-JUSTIFICATION))
  KWD-JUSTIFICATIONS-FORWARD)

(CL:DEFMETHOD FORWARD-JUSTIFICATIONS ((SELF PROPOSITION))
  (CL:LET*
   ((ANSWER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS NULL)))
   (CL:IF (CL:EQ ANSWER NULL) NIL-LIST ANSWER)))

;;; (DEFUN (HAS-FORWARD-JUSTIFICATIONS? BOOLEAN) ...)

(CL:DEFUN HAS-FORWARD-JUSTIFICATIONS? (PROPOSITION)
  "Return TRUE if `proposition' has any forward justifications."
  (NON-EMPTY? (FORWARD-JUSTIFICATIONS PROPOSITION)))

;;; (DEFUN (GET-FORWARD-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ...)

(CL:DEFUN GET-FORWARD-JUSTIFICATIONS (PROPOSITION)
  "Return `proposition's forward justifications."
  (FORWARD-JUSTIFICATIONS PROPOSITION))

;;; (DEFUN ADD-FORWARD-JUSTIFICATIONS ...)

(CL:DEFUN ADD-FORWARD-JUSTIFICATIONS (PROPOSITION JUSTIFICATION)
  (CL:LET* ((JUSTIFICATIONS (FORWARD-JUSTIFICATIONS PROPOSITION)))
   (CL:LET* ((FOUND?-000 CL:NIL))
    (CL:LET* ((JUST NULL) (ITER-000 (%THE-CONS-LIST JUSTIFICATIONS)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ JUST (%%VALUE ITER-000))
      (CL:WHEN (JUSTIFICATION-EQL? JUST JUSTIFICATION)
       (CL:SETQ FOUND?-000 CL:T) (CL:RETURN))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:WHEN FOUND?-000 (CL:RETURN-FROM ADD-FORWARD-JUSTIFICATIONS)))
   (CL:WHEN (CL:EQ JUSTIFICATIONS NIL-LIST) (CL:SETQ JUSTIFICATIONS (LIST))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPOSITION)
     SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS JUSTIFICATIONS NULL))
   (PUSH JUSTIFICATIONS JUSTIFICATION)))

;;; (DEFUN (GET-RULE-IO-VARIABLES VARIABLES-VECTOR) ...)

(CL:DEFUN GET-RULE-IO-VARIABLES (RULE)
  (CL:LET*
   ((VARS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS RULE)
      SYM-JUSTIFICATIONS-LOGIC-IO-VARIABLES NULL))
    (MASTER NULL))
   (CL:WHEN (CL:NOT (CL:EQ VARS NULL))
    (CL:RETURN-FROM GET-RULE-IO-VARIABLES VARS))
   (CL:SETQ MASTER
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS RULE)
     SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION NULL))
   (CL:WHEN (CL:NOT (CL:EQ MASTER NULL))
    (CL:SETQ VARS
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS MASTER)
      SYM-JUSTIFICATIONS-LOGIC-IO-VARIABLES NULL))
    (CL:WHEN (CL:NOT (CL:EQ VARS NULL))
     (CL:RETURN-FROM GET-RULE-IO-VARIABLES VARS)))
   (CL:WHEN (CL:EQ (%KIND RULE) KWD-JUSTIFICATIONS-IMPLIES)
    (CL:LET*
     ((ARGUMENTS (%ARGUMENTS RULE))
      (ANT (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
      (CQ (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1)))
     (CL:IF (NAMED-DESCRIPTION? ANT)
      (CL:RETURN-FROM GET-RULE-IO-VARIABLES (%IO-VARIABLES CQ))
      (CL:RETURN-FROM GET-RULE-IO-VARIABLES (%IO-VARIABLES ANT)))))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
     "get-rule-io-variables: don't know how to access IO-vars of rule: `" RULE
     "'")
    (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))

;;; (DEFUN (CREATE-FORWARD-JUSTIFICATION FORWARD-JUSTIFICATION) ...)

(CL:DEFUN CREATE-FORWARD-JUSTIFICATION (ANTECEDENTS FORWARDRULE ARGUMENTS CONSEQUENTPROPOSITION BC-JUSTIFICATION)
  (CL:LET* ((SELF-000 (NEW-FORWARD-JUSTIFICATION)))
   (CL:SETF (%INFERENCE-RULE SELF-000) KWD-JUSTIFICATIONS-MODUS-PONENS)
   (CL:LET*
    ((FJ SELF-000) (RULE-VARIABLES (GET-RULE-IO-VARIABLES FORWARDRULE))
     (SUBSTITUTION NULL) (ANTECEDENT-JUSTIFICATIONS NIL))
    (CL:IF (CL:NOT (CL:EQ BC-JUSTIFICATION NULL))
     (CL:PROGN (CL:SETQ SUBSTITUTION (%SUBSTITUTION BC-JUSTIFICATION))
      (CL:SETQ ANTECEDENT-JUSTIFICATIONS
       (CONS BC-JUSTIFICATION ANTECEDENT-JUSTIFICATIONS)))
     (CL:PROGN (CL:SETQ SUBSTITUTION (NEW-KEY-VALUE-MAP))
      (CL:LET*
       ((ARG NULL) (VECTOR-000 ARGUMENTS) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)) (VAR NULL)
        (VECTOR-001 RULE-VARIABLES) (INDEX-001 0)
        (LENGTH-001 (LENGTH VECTOR-001)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 INDEX-001 LENGTH-001))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:< INDEX-001 LENGTH-001)) DO
        (CL:SETQ ARG
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ VAR
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
          INDEX-001))
        (INSERT-AT SUBSTITUTION VAR ARG) (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ INDEX-001 (CL:1+ INDEX-001))))))
    (CL:LET* ((APROP NULL) (ITER-000 ANTECEDENTS))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ APROP (%%VALUE ITER-000))
      (CL:SETQ ANTECEDENT-JUSTIFICATIONS
       (CONS (GET-FORWARD-ANTECEDENT-JUSTIFICATION APROP)
        ANTECEDENT-JUSTIFICATIONS))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (CL:SETQ ANTECEDENT-JUSTIFICATIONS
     (CONS (GET-FORWARD-ANTECEDENT-JUSTIFICATION FORWARDRULE)
      ANTECEDENT-JUSTIFICATIONS))
    (CL:SETF (%SUBSTITUTION FJ) SUBSTITUTION)
    (CL:SETF (%PROPOSITION FJ) CONSEQUENTPROPOSITION)
    (CL:SETF (%TRUTH-VALUE FJ)
     (ACCESS-IN-CONTEXT (%TRUTH-VALUE CONSEQUENTPROPOSITION)
      (%HOME-CONTEXT CONSEQUENTPROPOSITION) CL:NIL))
    (CL:SETF (%ANTECEDENTS FJ) ANTECEDENT-JUSTIFICATIONS) FJ)))

;;; (DEFUN (GET-FORWARD-ANTECEDENT-JUSTIFICATION JUSTIFICATION) ...)

(CL:DEFUN GET-FORWARD-ANTECEDENT-JUSTIFICATION (ANTECEDENT)
  (CL:IF
   (CL:AND (CL:NOT (CL:EQ (FORWARD-JUSTIFICATIONS ANTECEDENT) NULL))
    (CL:NOT (EMPTY? (FORWARD-JUSTIFICATIONS ANTECEDENT))))
   (FIRST (FORWARD-JUSTIFICATIONS ANTECEDENT))
   (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
    (CL:SETF (%PROPOSITION SELF-000) ANTECEDENT)
    (CL:SETF (%STRATEGY SELF-000) KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS)
    (CL:LET* ((VALUE-000 SELF-000)) VALUE-000))))

;;; (DEFUN RECORD-FORWARD-JUSTIFICATION ...)

(CL:DEFUN RECORD-FORWARD-JUSTIFICATION (ANTECEDENTS FORWARDRULE ARGUMENTS CONSEQUENTPROPOSITION BC-JUSTIFICATION)
  (CL:WHEN (CL:NOT *RECORD-JUSTIFICATIONS?*)
   (CL:RETURN-FROM RECORD-FORWARD-JUSTIFICATION))
  (CL:LET*
   ((JUSTIFICATIONS (FORWARD-JUSTIFICATIONS CONSEQUENTPROPOSITION))
    (NEW-FJ
     (CREATE-FORWARD-JUSTIFICATION ANTECEDENTS FORWARDRULE ARGUMENTS
      CONSEQUENTPROPOSITION BC-JUSTIFICATION)))
   (CL:LET* ((FJ NULL) (ITER-000 (%THE-CONS-LIST JUSTIFICATIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ FJ (%%VALUE ITER-000))
     (CL:WHEN (CL:EQ (%PROPOSITION (%%VALUE (%ANTECEDENTS FJ))) FORWARDRULE)
      (CL:SETF (%SUBSTITUTION FJ) (%SUBSTITUTION NEW-FJ))
      (CL:SETF (%ANTECEDENTS FJ) (%ANTECEDENTS NEW-FJ))
      (CL:RETURN-FROM RECORD-FORWARD-JUSTIFICATION))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (ADD-FORWARD-JUSTIFICATIONS CONSEQUENTPROPOSITION NEW-FJ)))

;;; (DEFUN (CREATE-SUBSET-JUSTIFICATION JUSTIFICATION) ...)

(CL:DEFUN CREATE-SUBSET-JUSTIFICATION (MAIN-PROPOSITION MATCHING-PROPOSITION)
  (CL:LET*
   ((MAIN-OPERATOR (%OPERATOR MAIN-PROPOSITION))
    (MATCHING-OPERATOR (%OPERATOR MATCHING-PROPOSITION)))
   (CL:WHEN
    (CL:NOT
     (CL:OR (CL:EQ MAIN-OPERATOR NULL) (CL:EQ MATCHING-OPERATOR NULL)
      (CL:EQ MAIN-OPERATOR MATCHING-OPERATOR)))
    (CL:WHEN
     (RELATIONREF-SPECIALIZES-RELATIONREF? MATCHING-OPERATOR MAIN-OPERATOR)
     (CL:LET* ((SUBSET-PROPOSITION NULL) (SUBSET-JUSTIFICATIONS NIL))
      (CL:LET* ((*EVALUATIONMODE* KWD-JUSTIFICATIONS-DESCRIPTION))
       (CL:DECLARE (CL:SPECIAL *EVALUATIONMODE*))
       (CL:SETQ SUBSET-PROPOSITION
        (CONCEIVE-FORMULA
         (CONS-LIST SYM-JUSTIFICATIONS-PL-KERNEL-KB-SUBSET-OF
          MATCHING-OPERATOR MAIN-OPERATOR))))
      (CL:LET* ((SELF-000 (NEW-PRIMITIVE-STRATEGY)))
       (CL:SETF (%PROPOSITION SELF-000) SUBSET-PROPOSITION)
       (CL:SETF (%TRUTH-VALUE SELF-000) TRUE-TRUTH-VALUE)
       (CL:SETF (%STRATEGY SELF-000) KWD-JUSTIFICATIONS-SPECIALIST)
       (CL:SETQ SUBSET-JUSTIFICATIONS (CONS SELF-000 SUBSET-JUSTIFICATIONS)))
      (CL:LET* ((SELF-001 (NEW-PRIMITIVE-STRATEGY)))
       (CL:SETF (%PROPOSITION SELF-001) MATCHING-PROPOSITION)
       (CL:SETF (%STRATEGY SELF-001) KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS)
       (CL:SETQ SUBSET-JUSTIFICATIONS (CONS SELF-001 SUBSET-JUSTIFICATIONS)))
      (CL:LET* ((SELF-002 (NEW-JUSTIFICATION)))
       (CL:SETF (%INFERENCE-RULE SELF-002)
        KWD-JUSTIFICATIONS-SUBSUMPTION-REASONING)
       (CL:SETF (%PROPOSITION SELF-002) MAIN-PROPOSITION)
       (CL:SETF (%ANTECEDENTS SELF-002) SUBSET-JUSTIFICATIONS)
       (CL:LET* ((VALUE-000 SELF-002))
        (CL:RETURN-FROM CREATE-SUBSET-JUSTIFICATION VALUE-000))))))
   NULL))

(CL:DEFUN HELP-STARTUP-JUSTIFICATIONS1 ()
  (CL:PROGN
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 1))
   (CL:SETQ KWD-JUSTIFICATIONS-BACKWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-INFERENCE-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-RULE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-PATTERN-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-JUSTIFICATION" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-SUBSTITUTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSTITUTION" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-REVERSE-POLARITY?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE-POLARITY?" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SCORE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-NEGATIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEGATIVE-SCORE" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-PRIMITIVE-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE-STRATEGY" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PRIMITIVE-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE-STRATEGY" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGY" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-UP-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TRUE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-UP-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-FAIL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SCAN-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-COLLECTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-TECHNICAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TECHNICAL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-PROPOSITIONS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-ASSERTIONS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-LAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAY" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SPECIALIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SPECIALIST" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-COMPUTED-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPUTED-PREDICATE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-GOAL-COMPLEMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-COMPLEMENT" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-EQUIVALENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENCE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SUBSUMPTION-TEST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-TEST" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SUBSUMPTION-REASONING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSUMPTION-REASONING" NULL 2))
   (CL:SETQ SGT-JUSTIFICATIONS-STELLA-KEY-VALUE-LIST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KEY-VALUE-LIST"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-JUSTIFICATIONS-AND-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-MODUS-TOLLENS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODUS-TOLLENS" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-MODUS-PONENS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODUS-PONENS" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-ANTECEDENTS-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANTECEDENTS-RULE" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-AMPLIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AMPLIFICATION" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-ARGUMENTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARGUMENTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-JUSTIFICATIONS-POPPED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POPPED" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-PARTIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-REVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-OR-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-DISPROOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISPROOF" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAIL-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED-NOT-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-FAIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAIL" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTENTIAL-INTRODUCTION" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-TIMEOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TIMEOUT" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-DEPTH-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPTH-CUTOFF" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-RAW
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RAW" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-INFERENCE-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-RULE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRATEGY" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-TRUTH-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-VALUE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-POSITIVE-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "POSITIVE-SCORE" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-SUBSTITUTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSTITUTION" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ KWD-JUSTIFICATIONS-HOW-MANY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOW-MANY" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-NONE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NONE" NULL 2))))

(CL:DEFUN HELP-STARTUP-JUSTIFICATIONS2 ()
  (CL:PROGN
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-FORWARD-GOAL-RECORD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-GOAL-RECORD" NULL 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-GOAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-GOAL" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-RULE" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-CHAINING-GOALS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-CHAINING-GOALS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-PREDICATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREDICATE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-JUSTIFICATIONS-PL-KERNEL-KB-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-MASTER-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ SGT-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-JUSTIFICATION" NULL 1))
   (CL:SETQ KWD-JUSTIFICATIONS-FORWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-FORWARD-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-JUSTIFICATIONS" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-FORWARD-INFERENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-INFERENCE" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-IO-VARIABLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IO-VARIABLES" NULL 0))
   (CL:SETQ KWD-JUSTIFICATIONS-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ KWD-JUSTIFICATIONS-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 2))
   (CL:SETQ SYM-JUSTIFICATIONS-PL-KERNEL-KB-SUBSET-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-JUSTIFICATIONS" NULL 0))
   (CL:SETQ SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN STARTUP-JUSTIFICATIONS ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-JUSTIFICATIONS1)
    (HELP-STARTUP-JUSTIFICATIONS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "JUSTIFICATION"
        "(DEFCLASS JUSTIFICATION (STANDARD-OBJECT) :SLOTS ((INFERENCE-RULE :TYPE KEYWORD :DOCUMENTATION \"Keyword describing the inference rule used to conclude the
proposition of this justification.\") (PROPOSITION :TYPE PROPOSITION :DOCUMENTATION \"The proposition supported by this justification.\") (ANTECEDENTS :TYPE (CONS OF JUSTIFICATION) :INITIALLY NIL :DOCUMENTATION \"Antecedents justifications of this justification.\") (PATTERN-JUSTIFICATION :TYPE JUSTIFICATION :DOCUMENTATION \"Backpointer to the closest parent :PATTERN justification containing
the variable substitutions from the associated pattern control frame.  If this
is a :PATTERN justification, the slot points to the parent pattern.\") (SUBSTITUTION :TYPE (ENTITY-MAPPING OF PATTERN-VARIABLE OBJECT) :DOCUMENTATION \"List of variable bindings recorded for :PATTERN justifications.\") (REVERSE-POLARITY? :TYPE BOOLEAN :DOCUMENTATION \"True if proposition was derived in reverse polarity.\") (TRUTH-VALUE :TYPE TRUTH-VALUE :DOCUMENTATION \"Truth value of the derived proposition.\") (POSITIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :DOCUMENTATION \"Positive partial match score of the derived proposition.\") (NEGATIVE-SCORE :TYPE PARTIAL-MATCH-SCORE :DOCUMENTATION \"Negative partial match score of the derived proposition.\")) :METHODS ((INFERENCE-STRATEGY ((SELF JUSTIFICATION)) :TYPE KEYWORD (RETURN NULL)) (INFERENCE-DIRECTION ((SELF JUSTIFICATION)) :TYPE KEYWORD (RETURN :BACKWARD))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-JUSTIFICATION))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-JUSTIFICATION-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PRIMITIVE-STRATEGY"
        "(DEFCLASS PRIMITIVE-STRATEGY (JUSTIFICATION) :SLOTS ((INFERENCE-RULE :TYPE KEYWORD :INITIALLY :PRIMITIVE-STRATEGY) (STRATEGY :TYPE KEYWORD)) :METHODS ((INFERENCE-STRATEGY ((SELF PRIMITIVE-STRATEGY)) :TYPE KEYWORD (RETURN (STRATEGY SELF)))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-PRIMITIVE-STRATEGY))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-PRIMITIVE-STRATEGY-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORWARD-GOAL-RECORD"
        "(DEFCLASS FORWARD-GOAL-RECORD (STANDARD-OBJECT) :SLOTS ((FORWARD-GOAL :TYPE PROPOSITION) (FORWARD-RULE :TYPE PROPOSITION)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-FORWARD-GOAL-RECORD))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION ACCESS-FORWARD-GOAL-RECORD-SLOT-VALUE)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FORWARD-JUSTIFICATION"
        "(DEFCLASS FORWARD-JUSTIFICATION (JUSTIFICATION) :METHODS ((INFERENCE-DIRECTION ((SELF FORWARD-JUSTIFICATION)) :TYPE KEYWORD (RETURN :FORWARD))))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION NEW-FORWARD-JUSTIFICATION))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "JUSTIFICATION-ARGUMENT-BOUND-TO"
     "(DEFUN (JUSTIFICATION-ARGUMENT-BOUND-TO OBJECT) ((ARGUMENT OBJECT) (JUSTIFICATION JUSTIFICATION)))"
     (CL:FUNCTION JUSTIFICATION-ARGUMENT-BOUND-TO) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-JUSTIFICATION-SUBSTITUTION"
     "(DEFUN (YIELD-JUSTIFICATION-SUBSTITUTION ENTITY-MAPPING) ((JUSTIFICATION JUSTIFICATION) (SUBSTITUTION ENTITY-MAPPING) (ARGUMENT PROPOSITION)))"
     (CL:FUNCTION YIELD-JUSTIFICATION-SUBSTITUTION) NULL)
    (DEFINE-FUNCTION-OBJECT "JUSTIFICATION-EQL?"
     "(DEFUN (JUSTIFICATION-EQL? BOOLEAN) ((JUST1 JUSTIFICATION) (JUST2 JUSTIFICATION)))"
     (CL:FUNCTION JUSTIFICATION-EQL?) NULL)
    (DEFINE-FUNCTION-OBJECT "JUSTIFICATION-PROPOSITIONS-EQL?"
     "(DEFUN (JUSTIFICATION-PROPOSITIONS-EQL? BOOLEAN) ((PROPOSITION1 PROPOSITION) (JUST1 JUSTIFICATION) (PROPOSITION2 PROPOSITION) (JUST2 JUSTIFICATION)))"
     (CL:FUNCTION JUSTIFICATION-PROPOSITIONS-EQL?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (COPY (LIKE SELF)) ((SELF JUSTIFICATION)) :DOCUMENTATION \"Return a copy of the proof starting at `self'.  Allocates
all new justification objects, but structure-shares other information such
as propositions and substitutions.\" :PUBLIC? TRUE)" (CL:FUNCTION COPY) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-JUSTIFICATIONS?"
     "(DEFUN (RECORD-JUSTIFICATIONS? BOOLEAN) () :DOCUMENTATION \"Return TRUE if every query records justifications to enable
the explanation of concluded results.\" :GLOBALLY-INLINE? TRUE (RETURN *RECORD-JUSTIFICATIONS?*))"
     (CL:FUNCTION RECORD-JUSTIFICATIONS?) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-GOAL-JUSTIFICATION"
     "(DEFUN RECORD-GOAL-JUSTIFICATION ((GOAL CONTROL-FRAME) (JUSTIFICATION JUSTIFICATION)))"
     (CL:FUNCTION RECORD-GOAL-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-PRIMITIVE-JUSTIFICATION"
     "(DEFUN RECORD-PRIMITIVE-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-PRIMITIVE-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-PATTERN-JUSTIFICATION"
     "(DEFUN RECORD-PATTERN-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-PATTERN-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "BACKLINK-TO-PATTERN-JUSTIFICATION"
     "(DEFUN BACKLINK-TO-PATTERN-JUSTIFICATION ((JUSTIFICATION JUSTIFICATION) (PATTERN JUSTIFICATION)))"
     (CL:FUNCTION BACKLINK-TO-PATTERN-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-MODUS-PONENS-JUSTIFICATION"
     "(DEFUN RECORD-MODUS-PONENS-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-MODUS-PONENS-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-AND-INTRODUCTION-JUSTIFICATION"
     "(DEFUN RECORD-AND-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-AND-INTRODUCTION-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-OR-INTRODUCTION-JUSTIFICATION"
     "(DEFUN RECORD-OR-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-OR-INTRODUCTION-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-DISPROOF-JUSTIFICATION"
     "(DEFUN RECORD-DISPROOF-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-DISPROOF-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-FAIL-JUSTIFICATION"
     "(DEFUN RECORD-FAIL-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-FAIL-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-CLOSED-NOT-JUSTIFICATION"
     "(DEFUN RECORD-CLOSED-NOT-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-CLOSED-NOT-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION"
     "(DEFUN RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
     (CL:FUNCTION RECORD-EXISTENTIAL-INTRODUCTION-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "FAILED-GOAL-JUSTIFICATION?"
     "(DEFUN (FAILED-GOAL-JUSTIFICATION? BOOLEAN) ((SELF JUSTIFICATION)))"
     (CL:FUNCTION FAILED-GOAL-JUSTIFICATION?) NULL)
    (DEFINE-FUNCTION-OBJECT "CUTOFF-GOAL-JUSTIFICATION?"
     "(DEFUN (CUTOFF-GOAL-JUSTIFICATION? BOOLEAN) ((SELF JUSTIFICATION)))"
     (CL:FUNCTION CUTOFF-GOAL-JUSTIFICATION?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (CONSIFY CONS) ((SELF JUSTIFICATION)) :DOCUMENTATION \"Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.  The
consification follows the original proof structure literally, i.e., no
uninteresting nodes such as patterns or AND-introductions are suppressed.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CONSIFY) NULL)
    (DEFINE-FUNCTION-OBJECT "CONSIFY-JUSTIFICATION"
     "(DEFUN (CONSIFY-JUSTIFICATION CONS) ((SELF JUSTIFICATION) (STYLE KEYWORD)) :DOCUMENTATION \"Return a CONS tree representation of the proof `self'.
Each proof step is represented as a CONS tree of the form
  (<proposition> (<key> <value>...) <antecedent>...)
where each <antecedent> is a CONS tree representing a subproof.
`style' indicates what nodes in the proof tree should be suppressed.
:RAW preserves the original structure literally, :VERBOSE keeps AND-
introductions but suppresses all auxiliary (non-logical) nodes such as
pattern nodes, and :BRIEF additionally suppresses AND-introduction nodes.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CONSIFY-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-QUERY-JUSTIFICATIONS"
     "(DEFUN (GET-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ((QUERY QUERY-ITERATOR) (SOLUTIONINDEX INTEGER) (MAXJUSTIFICATIONS INTEGER) (CREATE? BOOLEAN)))"
     (CL:FUNCTION GET-QUERY-JUSTIFICATIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "DERIVE-QUERY-JUSTIFICATIONS"
     "(DEFUN (DERIVE-QUERY-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ((QUERY QUERY-ITERATOR) (OPTIONS OBJECT) (SOLUTIONINDEX INTEGER) (MAXJUSTIFICATIONS INTEGER)))"
     (CL:FUNCTION DERIVE-QUERY-JUSTIFICATIONS) NULL)
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT PROPOSITION FORWARD-CHAINING-GOALS :TYPE (LIST OF FORWARD-GOAL-RECORD) :ALLOCATION :DYNAMIC)")
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (DELETED? BOOLEAN) ((SELF FORWARD-GOAL-RECORD)))"
     (CL:FUNCTION DELETED?) NULL)
    (DEFINE-METHOD-OBJECT
     "(DEFMETHOD (DELETED?-SETTER BOOLEAN) ((SELF FORWARD-GOAL-RECORD) (VALUE BOOLEAN)))"
     (CL:FUNCTION DELETED?-SETTER) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-FORWARD-GOAL"
     "(DEFUN RECORD-FORWARD-GOAL ((FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR) (CONSEQUENTPROPOSITION PROPOSITION)))"
     (CL:FUNCTION RECORD-FORWARD-GOAL) NULL)
    (DEFINE-FUNCTION-OBJECT "PREDICATION?"
     "(DEFUN (PREDICATION? BOOLEAN) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION PREDICATION?) NULL)
    (DEFINE-FUNCTION-OBJECT "ASSERTED-AS-TRUE?"
     "(DEFUN (ASSERTED-AS-TRUE? BOOLEAN) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION ASSERTED-AS-TRUE?) NULL)
    (DEFINE-FUNCTION-OBJECT "ELABORATION-RULE?"
     "(DEFUN (ELABORATION-RULE? BOOLEAN) ((CONSEQUENTPROPOSITION PROPOSITION) (FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR)))"
     (CL:FUNCTION ELABORATION-RULE?) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-FORWARD-GOALS"
     "(DEFUN (GET-FORWARD-GOALS (LIST OF FORWARD-GOAL-RECORD)) ((PROPOSITION PROPOSITION)))"
     (CL:FUNCTION GET-FORWARD-GOALS) NULL)
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT PROPOSITION FORWARD-JUSTIFICATIONS :TYPE (LIST OF JUSTIFICATION) :ALLOCATION :DYNAMIC)")
    (DEFINE-FUNCTION-OBJECT "HAS-FORWARD-JUSTIFICATIONS?"
     "(DEFUN (HAS-FORWARD-JUSTIFICATIONS? BOOLEAN) ((PROPOSITION PROPOSITION)) :DOCUMENTATION \"Return TRUE if `proposition' has any forward justifications.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (NON-EMPTY? (FORWARD-JUSTIFICATIONS PROPOSITION))))"
     (CL:FUNCTION HAS-FORWARD-JUSTIFICATIONS?) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-FORWARD-JUSTIFICATIONS"
     "(DEFUN (GET-FORWARD-JUSTIFICATIONS (LIST OF JUSTIFICATION)) ((PROPOSITION PROPOSITION)) :DOCUMENTATION \"Return `proposition's forward justifications.\" :PUBLIC? TRUE :GLOBALLY-INLINE? TRUE (RETURN (FORWARD-JUSTIFICATIONS PROPOSITION)))"
     (CL:FUNCTION GET-FORWARD-JUSTIFICATIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "ADD-FORWARD-JUSTIFICATIONS"
     "(DEFUN ADD-FORWARD-JUSTIFICATIONS ((PROPOSITION PROPOSITION) (JUSTIFICATION JUSTIFICATION)))"
     (CL:FUNCTION ADD-FORWARD-JUSTIFICATIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-RULE-IO-VARIABLES"
     "(DEFUN (GET-RULE-IO-VARIABLES VARIABLES-VECTOR) ((RULE PROPOSITION)))"
     (CL:FUNCTION GET-RULE-IO-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-FORWARD-JUSTIFICATION"
     "(DEFUN (CREATE-FORWARD-JUSTIFICATION FORWARD-JUSTIFICATION) ((ANTECEDENTS (CONS OF PROPOSITION)) (FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR) (CONSEQUENTPROPOSITION PROPOSITION) (BC-JUSTIFICATION JUSTIFICATION)))"
     (CL:FUNCTION CREATE-FORWARD-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-FORWARD-ANTECEDENT-JUSTIFICATION"
     "(DEFUN (GET-FORWARD-ANTECEDENT-JUSTIFICATION JUSTIFICATION) ((ANTECEDENT PROPOSITION)))"
     (CL:FUNCTION GET-FORWARD-ANTECEDENT-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "RECORD-FORWARD-JUSTIFICATION"
     "(DEFUN RECORD-FORWARD-JUSTIFICATION ((ANTECEDENTS (CONS OF PROPOSITION)) (FORWARDRULE PROPOSITION) (ARGUMENTS ARGUMENTS-VECTOR) (CONSEQUENTPROPOSITION PROPOSITION) (BC-JUSTIFICATION JUSTIFICATION)))"
     (CL:FUNCTION RECORD-FORWARD-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-SUBSET-JUSTIFICATION"
     "(DEFUN (CREATE-SUBSET-JUSTIFICATION JUSTIFICATION) ((MAIN-PROPOSITION PROPOSITION) (MATCHING-PROPOSITION PROPOSITION)))"
     (CL:FUNCTION CREATE-SUBSET-JUSTIFICATION) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-JUSTIFICATIONS"
     "(DEFUN STARTUP-JUSTIFICATIONS () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-JUSTIFICATIONS) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-JUSTIFICATIONS-LOGIC-STARTUP-JUSTIFICATIONS)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-JUSTIFICATIONS-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupJustifications") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *RECORD-JUSTIFICATIONS?* BOOLEAN FALSE :DOCUMENTATION \"If TRUE every query records justifications to enable
the explanation of concluded results.\")")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-COLLECTION
     KWD-JUSTIFICATIONS-TECHNICAL "by explicit assertion")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS
     KWD-JUSTIFICATIONS-TECHNICAL "by explicit assertion")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS
     KWD-JUSTIFICATIONS-TECHNICAL "by explicit assertion")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-COLLECTION
     KWD-JUSTIFICATIONS-LAY "because the system was told this fact")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SCAN-PROPOSITIONS
     KWD-JUSTIFICATIONS-LAY "because the system was told this fact")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-LOOKUP-ASSERTIONS
     KWD-JUSTIFICATIONS-LAY "because the system was told this fact")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SPECIALIST
     KWD-JUSTIFICATIONS-TECHNICAL
     "because it was proven by an inference specialist")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SPECIALIST
     KWD-JUSTIFICATIONS-LAY "because of a specialized reasoning procedure")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-COMPUTED-PREDICATE
     KWD-JUSTIFICATIONS-TECHNICAL "because of a computation")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-COMPUTED-PREDICATE
     KWD-JUSTIFICATIONS-LAY "because of a computation")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-GOAL-COMPLEMENT
     KWD-JUSTIFICATIONS-TECHNICAL "because its argument was proven false")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-GOAL-COMPLEMENT
     KWD-JUSTIFICATIONS-LAY "because its argument is false")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-EQUIVALENCE
     KWD-JUSTIFICATIONS-TECHNICAL "from equivalence")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-EQUIVALENCE
     KWD-JUSTIFICATIONS-LAY "because its arguments are equivalent")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SUBSUMPTION-TEST
     KWD-JUSTIFICATIONS-TECHNICAL "because of a successful subsumption test")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SUBSUMPTION-TEST
     KWD-JUSTIFICATIONS-LAY "because of a successful subsumption test")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SUBSUMPTION-REASONING
     KWD-JUSTIFICATIONS-TECHNICAL "because a subsumed relation is true")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-SUBSUMPTION-REASONING
     KWD-JUSTIFICATIONS-LAY
     "because of it is true of a relation that is a subset of the one we want")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAILURE
     KWD-JUSTIFICATIONS-TECHNICAL "could not be proven")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAILURE
     KWD-JUSTIFICATIONS-LAY "could not be proven")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-PONENS
     KWD-JUSTIFICATIONS-TECHNICAL "by Modus Ponens")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-PONENS
     KWD-JUSTIFICATIONS-LAY "because an if-then rule applies")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS
     KWD-JUSTIFICATIONS-TECHNICAL "by Modus Tollens")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS
     KWD-JUSTIFICATIONS-TECHNICAL "(p => q, ~q |= ~p)"
     KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS
     KWD-JUSTIFICATIONS-LAY "because an if-then rule was used backwards")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-MODUS-TOLLENS
     KWD-JUSTIFICATIONS-LAY
     "(if P then Q with Q false allows us to conclude P)"
     KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "by And-Introduction")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY
     "because all parts of an AND expression were true")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY "because parts of an AND expression were true"
     KWD-JUSTIFICATIONS-PARTIAL)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "by Not-Or-Introduction"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY "because all parts of an OR expression were false"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "(~p, ~q |= ~(p v q))"
     KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-AND-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY "(therefore the OR is also false)"
     KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "by Or-Introduction")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY
     "because at least one part of an OR expression was true")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "by Not-And-Introduction"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY
     "because at least one part of an AND expression was false"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "(~p |= ~(p & q))"
     KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-OR-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY "(therefore the AND is also false)"
     KWD-JUSTIFICATIONS-REVERSE KWD-JUSTIFICATIONS-AMPLIFICATION)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF
     KWD-JUSTIFICATIONS-TECHNICAL "by disproof")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF
     KWD-JUSTIFICATIONS-LAY "by proving the negation")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF
     KWD-JUSTIFICATIONS-TECHNICAL "by Double-Negation-Introduction"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-DISPROOF
     KWD-JUSTIFICATIONS-LAY "by negating a negation"
     KWD-JUSTIFICATIONS-REVERSE)
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL
     "because the argument proposition was not derivable and it uses closed-world semantics")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-CLOSED-NOT-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY
     "because the argument proposition could not be proven and it is a closed-world proposition")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAIL-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL
     "because the argument proposition was not derivable")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FAIL-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY
     "because the argument proposition could not be proven")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION
     KWD-JUSTIFICATIONS-TECHNICAL "by Existential Introduction")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-EXISTENTIAL-INTRODUCTION
     KWD-JUSTIFICATIONS-LAY "because it was true for at least one case")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FORWARD-INFERENCE
     KWD-JUSTIFICATIONS-TECHNICAL "by Forward Inference")
    (DEFINE-EXPLANATION-PHRASE KWD-JUSTIFICATIONS-FORWARD-INFERENCE
     KWD-JUSTIFICATIONS-LAY "by forward rule reasoning"))))
