;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; arithmetic.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2014      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTEGER-INTERVAL| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SYM-ARITHMETIC-PL-KERNEL-KB-INTERVAL-LOWER-BOUND| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SYM-ARITHMETIC-PL-KERNEL-KB-INTERVAL-UPPER-BOUND| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTERVAL-CACHE| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-HOME-CONTEXT| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SYM-ARITHMETIC-LOGIC-INTERVAL-MEMBER| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-LOWER-BOUND| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-UPPER-BOUND| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SYM-ARITHMETIC-LOGIC-STRICT-LOWER-BOUND?| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SYM-ARITHMETIC-LOGIC-STRICT-UPPER-BOUND?| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTERVAL-CACHE-OF| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INEQUALITY| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-LOGIC-OBJECT| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-SKOLEM| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-INTEGER| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-NUMBER-WRAPPER| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-QUANTITY-LOGIC-WRAPPER| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/KWD-ARITHMETIC-LOWER-BOUND| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/KWD-ARITHMETIC-UPPER-BOUND| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-INTEGER-WRAPPER| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/KWD-ARITHMETIC-FINAL-SUCCESS| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/KWD-ARITHMETIC-FAILURE| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/KWD-ARITHMETIC-ORIGINAL| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-ITERATOR| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/KWD-ARITHMETIC-CONTINUING-SUCCESS| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SYM-ARITHMETIC-PL-KERNEL-KB-STARTUP-ARITHMETIC| NULL)
(CL:DEFVAR |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-METHOD-STARTUP-CLASSNAME| NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* NIL *REVERSEPOLARITY?*
  UNKNOWN-TRUTH-VALUE TRUE-TRUTH-VALUE FALSE-TRUTH-VALUE *CONTEXT*
  TRUE-WRAPPER FALSE-WRAPPER NULL-INTEGER NULL-FLOAT))

;;; (DEFUN (ARITHMETIC-EQUAL-TEST BOOLEAN) ...)

(CL:DEFUN |/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| (X Y)
  (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-002)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE Y)))
       (CL:COND
        ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
         (CL:PROGN (CL:= (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y))))
        ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
         (CL:PROGN
          (CL:= (CL:FLOAT (%WRAPPER-VALUE X) 0.0d0)
           (%WRAPPER-VALUE Y))))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
           TEST-VALUE-000 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-002)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE Y)))
       (CL:COND
        ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
         (CL:PROGN
          (CL:= (%WRAPPER-VALUE X)
           (CL:FLOAT (%WRAPPER-VALUE Y) 0.0d0))))
        ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
         (CL:PROGN (CL:= (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y))))
        (CL:T
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
           TEST-VALUE-001 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))))
    (CL:T
     (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" TEST-VALUE-002
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002))))))))

;;; (DEFUN (ARITHMETIC-LESS-TEST BOOLEAN) ...)

(CL:DEFUN |/PL-KERNEL-KB/ARITHMETIC-LESS-TEST| (X Y)
  (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-002)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE Y)))
       (CL:COND
        ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
         (CL:PROGN (< (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y))))
        ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
         (CL:PROGN
          (< (CL:FLOAT (%WRAPPER-VALUE X) 0.0d0) (%WRAPPER-VALUE Y))))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
           TEST-VALUE-000 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-002)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE Y)))
       (CL:COND
        ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
         (CL:PROGN
          (< (%WRAPPER-VALUE X) (CL:FLOAT (%WRAPPER-VALUE Y) 0.0d0))))
        ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
         (CL:PROGN (< (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y))))
        (CL:T
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
           TEST-VALUE-001 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))))
    (CL:T
     (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" TEST-VALUE-002
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002))))))))

;;; (DEFUN (ARITHMETIC-GREATER-TEST BOOLEAN) ...)

(CL:DEFUN |/PL-KERNEL-KB/ARITHMETIC-GREATER-TEST| (X Y)
  (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-002)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE Y)))
       (CL:COND
        ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
         (CL:PROGN (> (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y))))
        ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
         (CL:PROGN
          (> (CL:FLOAT (%WRAPPER-VALUE X) 0.0d0) (%WRAPPER-VALUE Y))))
        (CL:T
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
           TEST-VALUE-000 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-002)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE Y)))
       (CL:COND
        ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
         (CL:PROGN
          (> (%WRAPPER-VALUE X) (CL:FLOAT (%WRAPPER-VALUE Y) 0.0d0))))
        ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
         (CL:PROGN (> (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y))))
        (CL:T
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
           TEST-VALUE-001 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))))
    (CL:T
     (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" TEST-VALUE-002
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002))))))))

;;; (DEFUN (PLUS-COMPUTATION NUMBER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/PLUS-COMPUTATION| (X Y)
  (CL:LET* ((FLOATRESULT NULL-FLOAT))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT FLOATRESULT))
   (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE X)))
    (CL:COND
     ((SUBTYPE-OF-INTEGER? TEST-VALUE-002)
      (CL:PROGN
       (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE Y)))
        (CL:COND
         ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
          (CL:PROGN
           (CL:RETURN-FROM |/PL-KERNEL-KB/PLUS-COMPUTATION|
            (WRAP-INTEGER
             (CL:TRUNCATE
              (CL:+ (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))))
         ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
          (CL:PROGN
           (CL:SETQ FLOATRESULT
            (CL:+ (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
         (CL:T
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
            TEST-VALUE-000 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION
             (THE-STRING-READER STREAM-000)))))))))
     ((SUBTYPE-OF-FLOAT? TEST-VALUE-002)
      (CL:PROGN
       (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE Y)))
        (CL:COND
         ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
          (CL:PROGN
           (CL:SETQ FLOATRESULT
            (CL:+ (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
         ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
          (CL:PROGN
           (CL:SETQ FLOATRESULT
            (CL:+ (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
         (CL:T
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
            TEST-VALUE-001 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION
             (THE-STRING-READER STREAM-001)))))))))
     (CL:T
      (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" TEST-VALUE-002
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))))
   (WRAP-FLOAT FLOATRESULT)))

;;; (DEFUN (MINUS-COMPUTATION NUMBER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/MINUS-COMPUTATION| (X Y)
  (CL:LET* ((FLOATRESULT NULL-FLOAT))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT FLOATRESULT))
   (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE X)))
    (CL:COND
     ((SUBTYPE-OF-INTEGER? TEST-VALUE-002)
      (CL:PROGN
       (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE Y)))
        (CL:COND
         ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
          (CL:PROGN
           (CL:RETURN-FROM |/PL-KERNEL-KB/MINUS-COMPUTATION|
            (WRAP-INTEGER
             (CL:TRUNCATE
              (CL:- (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))))
         ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
          (CL:PROGN
           (CL:SETQ FLOATRESULT
            (CL:- (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
         (CL:T
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
            TEST-VALUE-000 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION
             (THE-STRING-READER STREAM-000)))))))))
     ((SUBTYPE-OF-FLOAT? TEST-VALUE-002)
      (CL:PROGN
       (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE Y)))
        (CL:COND
         ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
          (CL:PROGN
           (CL:SETQ FLOATRESULT
            (CL:- (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
         ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
          (CL:PROGN
           (CL:SETQ FLOATRESULT
            (CL:- (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
         (CL:T
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
            TEST-VALUE-001 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION
             (THE-STRING-READER STREAM-001)))))))))
     (CL:T
      (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" TEST-VALUE-002
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))))
   (WRAP-FLOAT FLOATRESULT)))

;;; (DEFUN (TIMES-COMPUTATION NUMBER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/TIMES-COMPUTATION| (X Y)
  (CL:LET* ((FLOATRESULT NULL-FLOAT))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT FLOATRESULT))
   (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE X)))
    (CL:COND
     ((SUBTYPE-OF-INTEGER? TEST-VALUE-002)
      (CL:PROGN
       (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE Y)))
        (CL:COND
         ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
          (CL:PROGN
           (CL:RETURN-FROM |/PL-KERNEL-KB/TIMES-COMPUTATION|
            (WRAP-INTEGER
             (CL:TRUNCATE
              (CL:* (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))))
         ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
          (CL:PROGN
           (CL:SETQ FLOATRESULT
            (CL:* (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
         (CL:T
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
            TEST-VALUE-000 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION
             (THE-STRING-READER STREAM-000)))))))))
     ((SUBTYPE-OF-FLOAT? TEST-VALUE-002)
      (CL:PROGN
       (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE Y)))
        (CL:COND
         ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
          (CL:PROGN
           (CL:SETQ FLOATRESULT
            (CL:* (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
         ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
          (CL:PROGN
           (CL:SETQ FLOATRESULT
            (CL:* (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
         (CL:T
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
            TEST-VALUE-001 "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION
             (THE-STRING-READER STREAM-001)))))))))
     (CL:T
      (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" TEST-VALUE-002
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))))
   (WRAP-FLOAT FLOATRESULT)))

;;; (DEFUN (DIVIDE-COMPUTATION NUMBER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/DIVIDE-COMPUTATION| (X Y)
  (CL:HANDLER-CASE
   (CL:LET* ((FLOATRESULT NULL-FLOAT))
    (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT FLOATRESULT))
    (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE X)))
     (CL:COND
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-002)
       (CL:PROGN
        (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE Y)))
         (CL:COND
          ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
           (CL:PROGN
            (CL:IF
             (CL:=
              (CL:THE CL:FIXNUM
               (CL:REM (CL:THE CL:FIXNUM (%WRAPPER-VALUE X))
                (CL:THE CL:FIXNUM (%WRAPPER-VALUE Y))))
              0)
             (CL:RETURN-FROM |/PL-KERNEL-KB/DIVIDE-COMPUTATION|
              (WRAP-INTEGER
               (CL:LET ((X (%WRAPPER-VALUE X)) (Y (%WRAPPER-VALUE Y)))
                (CL:DECLARE (CL:TYPE CL:FIXNUM X Y))
                (CL:THE CL:FIXNUM (CL:VALUES (CL:TRUNCATE X Y))))))
             (CL:SETQ FLOATRESULT
              (CL:/ (CL:FLOAT (%WRAPPER-VALUE X) 0.0d0)
               (CL:FLOAT (%WRAPPER-VALUE Y) 0.0d0))))))
          ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
           (CL:PROGN
            (CL:SETQ FLOATRESULT
             (CL:/ (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
          (CL:T
           (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
             TEST-VALUE-000 "' is not a valid case option")
            (CL:ERROR
             (NEW-STELLA-EXCEPTION
              (THE-STRING-READER STREAM-000)))))))))
      ((SUBTYPE-OF-FLOAT? TEST-VALUE-002)
       (CL:PROGN
        (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE Y)))
         (CL:COND
          ((SUBTYPE-OF-INTEGER? TEST-VALUE-001)
           (CL:PROGN
            (CL:SETQ FLOATRESULT
             (CL:/ (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
          ((SUBTYPE-OF-FLOAT? TEST-VALUE-001)
           (CL:PROGN
            (CL:SETQ FLOATRESULT
             (CL:/ (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))))
          (CL:T
           (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
            (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
             TEST-VALUE-001 "' is not a valid case option")
            (CL:ERROR
             (NEW-STELLA-EXCEPTION
              (THE-STRING-READER STREAM-001)))))))))
      (CL:T
       (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" TEST-VALUE-002
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))))
    (CL:RETURN-FROM |/PL-KERNEL-KB/DIVIDE-COMPUTATION|
     (WRAP-FLOAT FLOATRESULT)))
   (CL:CONDITION () NULL)))

;;; (DEFUN (SQRT-COMPUTATION NUMBER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/SQRT-COMPUTATION| (X)
  (CL:LET* ((FLOATRESULT NULL-FLOAT) (INTEGERRESULT NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT FLOATRESULT)
    (CL:TYPE CL:FIXNUM INTEGERRESULT))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
    (CL:COND
     ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ FLOATRESULT
        (CL:THE CL:DOUBLE-FLOAT
         (CL:SQRT
          (CL:THE CL:DOUBLE-FLOAT
           (CL:FLOAT (%WRAPPER-VALUE X) 0.0d0)))))
       (CL:SETQ INTEGERRESULT (CL:TRUNCATE FLOATRESULT))
       (CL:IF (CL:= FLOATRESULT (CL:FLOAT INTEGERRESULT 0.0d0))
        (CL:RETURN-FROM |/PL-KERNEL-KB/SQRT-COMPUTATION|
         (WRAP-INTEGER INTEGERRESULT))
        (CL:RETURN-FROM |/PL-KERNEL-KB/SQRT-COMPUTATION|
         (WRAP-FLOAT FLOATRESULT)))))
     ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
      (CL:PROGN
       (CL:SETQ FLOATRESULT
        (CL:THE CL:DOUBLE-FLOAT
         (CL:SQRT (CL:THE CL:DOUBLE-FLOAT (%WRAPPER-VALUE X)))))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
   (WRAP-FLOAT FLOATRESULT)))

;;; (DEFUN (NEGATE-COMPUTATION NUMBER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/NEGATE-COMPUTATION| (X)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN (WRAP-INTEGER (CL:- 0 (UNWRAP-INTEGER X)))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN (WRAP-FLOAT (CL:- 0.0d0 (UNWRAP-FLOAT X)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (ABS-COMPUTATION NUMBER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/ABS-COMPUTATION| (X)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (CL:< (UNWRAP-INTEGER X) 0)
       (WRAP-INTEGER (CL:- 0 (UNWRAP-INTEGER X))) X)))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (CL:< (UNWRAP-FLOAT X) 0.0d0)
       (WRAP-FLOAT (CL:- 0.0d0 (UNWRAP-FLOAT X))) X)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (FLOOR-COMPUTATION INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/FLOOR-COMPUTATION| (X)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN (WRAP-INTEGER (FLOOR (%WRAPPER-VALUE X)))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN (WRAP-INTEGER (FLOOR (%WRAPPER-VALUE X)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (CEILING-COMPUTATION INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/CEILING-COMPUTATION| (X)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN (WRAP-INTEGER (CEILING (%WRAPPER-VALUE X)))))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN (WRAP-INTEGER (CEILING (%WRAPPER-VALUE X)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (PLUS-CONSTRAINT OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/PLUS-CONSTRAINT| (MISSING-ARGUMENT X1 X2 X3)
  (CL:LET* ((VALUE NULL))
   (CL:CASE (%WRAPPER-VALUE MISSING-ARGUMENT)
    (-1
     (CL:SETQ VALUE
      (CL:IF
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST|
        (|/PL-KERNEL-KB/PLUS-COMPUTATION| X1 X2) X3)
       TRUE-WRAPPER FALSE-WRAPPER)))
    (0 (CL:SETQ VALUE (|/PL-KERNEL-KB/MINUS-COMPUTATION| X3 X2)))
    (1 (CL:SETQ VALUE (|/PL-KERNEL-KB/MINUS-COMPUTATION| X3 X1)))
    (2 (CL:SETQ VALUE (|/PL-KERNEL-KB/PLUS-COMPUTATION| X1 X2)))
    (CL:OTHERWISE))
   VALUE))

;;; (DEFUN (MINUS-CONSTRAINT OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/MINUS-CONSTRAINT| (MISSING-ARGUMENT X1 X2 X3)
  (CL:LET* ((VALUE NULL))
   (CL:CASE (%WRAPPER-VALUE MISSING-ARGUMENT)
    (-1
     (CL:SETQ VALUE
      (CL:IF
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST|
        (|/PL-KERNEL-KB/MINUS-COMPUTATION| X1 X2) X3)
       TRUE-WRAPPER FALSE-WRAPPER)))
    (0 (CL:SETQ VALUE (|/PL-KERNEL-KB/PLUS-COMPUTATION| X2 X3)))
    (1 (CL:SETQ VALUE (|/PL-KERNEL-KB/MINUS-COMPUTATION| X1 X3)))
    (2 (CL:SETQ VALUE (|/PL-KERNEL-KB/MINUS-COMPUTATION| X1 X2)))
    (CL:OTHERWISE))
   VALUE))

;;; (DEFUN (TIMES-CONSTRAINT OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/TIMES-CONSTRAINT| (MISSING-ARGUMENT X1 X2 X3)
  (CL:LET* ((VALUE NULL))
   (CL:CASE (%WRAPPER-VALUE MISSING-ARGUMENT)
    (-1
     (CL:SETQ VALUE
      (CL:IF
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST|
        (|/PL-KERNEL-KB/TIMES-COMPUTATION| X1 X2) X3)
       TRUE-WRAPPER FALSE-WRAPPER)))
    (0 (CL:SETQ VALUE (|/PL-KERNEL-KB/DIVIDE-COMPUTATION| X3 X2)))
    (1 (CL:SETQ VALUE (|/PL-KERNEL-KB/DIVIDE-COMPUTATION| X3 X1)))
    (2 (CL:SETQ VALUE (|/PL-KERNEL-KB/TIMES-COMPUTATION| X1 X2)))
    (CL:OTHERWISE))
   VALUE))

;;; (DEFUN (DIVIDE-CONSTRAINT OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/DIVIDE-CONSTRAINT| (MISSING-ARGUMENT X1 X2 X3)
  (CL:LET* ((VALUE NULL))
   (CL:CASE (%WRAPPER-VALUE MISSING-ARGUMENT)
    (-1
     (CL:LET* ((RATIO (|/PL-KERNEL-KB/DIVIDE-COMPUTATION| X1 X2)))
      (CL:IF (CL:NOT (CL:EQ RATIO NULL))
       (CL:SETQ VALUE
        (CL:IF (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| RATIO X3)
         TRUE-WRAPPER FALSE-WRAPPER))
       (CL:SETQ VALUE FALSE-WRAPPER))))
    (0 (CL:SETQ VALUE (|/PL-KERNEL-KB/TIMES-COMPUTATION| X2 X3)))
    (1 (CL:SETQ VALUE (|/PL-KERNEL-KB/DIVIDE-COMPUTATION| X1 X3)))
    (2 (CL:SETQ VALUE (|/PL-KERNEL-KB/DIVIDE-COMPUTATION| X1 X2)))
    (CL:OTHERWISE))
   VALUE))

;;; (DEFUN (NEGATE-CONSTRAINT OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/NEGATE-CONSTRAINT| (MISSING-ARGUMENT X1 X2)
  (CL:LET* ((VALUE NULL))
   (CL:CASE (%WRAPPER-VALUE MISSING-ARGUMENT)
    (-1
     (CL:SETQ VALUE
      (CL:IF
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| X1
        (|/PL-KERNEL-KB/NEGATE-COMPUTATION| X2))
       TRUE-WRAPPER FALSE-WRAPPER)))
    (0 (CL:SETQ VALUE (|/PL-KERNEL-KB/NEGATE-COMPUTATION| X2)))
    (1 (CL:SETQ VALUE (|/PL-KERNEL-KB/NEGATE-COMPUTATION| X1)))
    (CL:OTHERWISE))
   VALUE))

;;; (DEFUN (SQRT-CONSTRAINT OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/SQRT-CONSTRAINT| (MISSING-ARGUMENT X1 X2)
  (CL:LET* ((VALUE NULL))
   (CL:CASE (%WRAPPER-VALUE MISSING-ARGUMENT)
    (-1
     (CL:SETQ VALUE
      (CL:IF
       (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST|
        (|/PL-KERNEL-KB/TIMES-COMPUTATION| X2 X2) X1)
       TRUE-WRAPPER FALSE-WRAPPER)))
    (0 (CL:SETQ VALUE (|/PL-KERNEL-KB/TIMES-COMPUTATION| X2 X2)))
    (1
     (CL:IF (|/PL-KERNEL-KB/ARITHMETIC-LESS-TEST| X1 (WRAP-INTEGER 0))
      (CL:SETQ VALUE NULL)
      (CL:SETQ VALUE (|/PL-KERNEL-KB/SQRT-COMPUTATION| X1))))
    (CL:OTHERWISE))
   VALUE))

;;; (DEFUN (LOG-COMPUTATION FLOAT-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/LOG-COMPUTATION| (X)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (CL:> (%WRAPPER-VALUE X) 0)
       (WRAP-FLOAT
        (CL:THE CL:DOUBLE-FLOAT
         (CL:LOG (CL:THE CL:DOUBLE-FLOAT (%WRAPPER-VALUE X)))))
       NULL)))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (CL:> (%WRAPPER-VALUE X) 0)
       (WRAP-FLOAT
        (CL:THE CL:DOUBLE-FLOAT
         (CL:LOG
          (CL:THE CL:DOUBLE-FLOAT (NUMBER-WRAPPER-TO-FLOAT X)))))
       NULL)))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (CL:> (%WRAPPER-VALUE X) 0)
       (WRAP-FLOAT
        (CL:THE CL:DOUBLE-FLOAT
         (CL:LOG
          (CL:THE CL:DOUBLE-FLOAT (NUMBER-WRAPPER-TO-FLOAT X)))))
       NULL)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (LOG10-COMPUTATION FLOAT-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/LOG10-COMPUTATION| (X)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (CL:> (%WRAPPER-VALUE X) 0)
       (WRAP-FLOAT
        (CL:LET ((N (%WRAPPER-VALUE X)))
         (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT N))
         (CL:THE CL:DOUBLE-FLOAT (CL:LOG n 10.0d0))))
       NULL)))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (CL:> (%WRAPPER-VALUE X) 0)
       (WRAP-FLOAT
        (CL:LET ((N (NUMBER-WRAPPER-TO-FLOAT X)))
         (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT N))
         (CL:THE CL:DOUBLE-FLOAT (CL:LOG n 10.0d0))))
       NULL)))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:IF (CL:> (%WRAPPER-VALUE X) 0)
       (WRAP-FLOAT
        (CL:LET ((N (NUMBER-WRAPPER-TO-FLOAT X)))
         (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT N))
         (CL:THE CL:DOUBLE-FLOAT (CL:LOG n 10.0d0))))
       NULL)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (EXP-COMPUTATION FLOAT-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/EXP-COMPUTATION| (X)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (WRAP-FLOAT
       (CL:THE CL:DOUBLE-FLOAT
        (CL:EXP (CL:THE CL:DOUBLE-FLOAT (%WRAPPER-VALUE X)))))))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (WRAP-FLOAT
       (CL:THE CL:DOUBLE-FLOAT
        (CL:EXP
         (CL:THE CL:DOUBLE-FLOAT (NUMBER-WRAPPER-TO-FLOAT X)))))))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (WRAP-FLOAT
       (CL:THE CL:DOUBLE-FLOAT
        (CL:EXP
         (CL:THE CL:DOUBLE-FLOAT (NUMBER-WRAPPER-TO-FLOAT X)))))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (EXPT-COMPUTATION FLOAT-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/EXPT-COMPUTATION| (X N)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (WRAP-FLOAT
       (CL:THE CL:DOUBLE-FLOAT
        (CL:EXPT (CL:THE CL:DOUBLE-FLOAT (%WRAPPER-VALUE X))
         (CL:THE CL:DOUBLE-FLOAT (COERCE-TO-FLOAT N)))))))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (WRAP-FLOAT
       (CL:THE CL:DOUBLE-FLOAT
        (CL:EXPT (CL:THE CL:DOUBLE-FLOAT (NUMBER-WRAPPER-TO-FLOAT X))
         (CL:THE CL:DOUBLE-FLOAT (COERCE-TO-FLOAT N)))))))
    ((SUBTYPE-OF-LONG-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (WRAP-FLOAT
       (CL:THE CL:DOUBLE-FLOAT
        (CL:EXPT (CL:THE CL:DOUBLE-FLOAT (NUMBER-WRAPPER-TO-FLOAT X))
         (CL:THE CL:DOUBLE-FLOAT (COERCE-TO-FLOAT N)))))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (LOG-CONSTRAINT OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/LOG-CONSTRAINT| (MISSING-ARGUMENT X LOG)
  (CL:LET* ((VALUE NULL))
   (CL:CASE (%WRAPPER-VALUE MISSING-ARGUMENT)
    (-1
     (CL:SETQ VALUE
      (CL:IF
       (CL:OR
        (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST|
         (|/PL-KERNEL-KB/LOG-COMPUTATION| X) LOG)
        (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| X
         (|/PL-KERNEL-KB/EXP-COMPUTATION| LOG)))
       TRUE-WRAPPER FALSE-WRAPPER)))
    (0 (CL:SETQ VALUE (|/PL-KERNEL-KB/EXP-COMPUTATION| LOG)))
    (1 (CL:SETQ VALUE (|/PL-KERNEL-KB/LOG-COMPUTATION| X)))
    (CL:OTHERWISE))
   VALUE))

;;; (DEFUN (LOG10-CONSTRAINT OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/LOG10-CONSTRAINT| (MISSING-ARGUMENT X LOG)
  (CL:LET* ((VALUE NULL))
   (CL:CASE (%WRAPPER-VALUE MISSING-ARGUMENT)
    (-1
     (CL:SETQ VALUE
      (CL:IF
       (CL:OR
        (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST|
         (|/PL-KERNEL-KB/LOG10-COMPUTATION| X) LOG)
        (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| X
         (|/PL-KERNEL-KB/EXPT-COMPUTATION| (WRAP-FLOAT 10.0d0) LOG)))
       TRUE-WRAPPER FALSE-WRAPPER)))
    (0
     (CL:SETQ VALUE
      (|/PL-KERNEL-KB/EXPT-COMPUTATION| (WRAP-FLOAT 10.0d0) LOG)))
    (1 (CL:SETQ VALUE (|/PL-KERNEL-KB/LOG10-COMPUTATION| X)))
    (CL:OTHERWISE))
   VALUE))

;;; (DEFUN (EXP-CONSTRAINT OBJECT) ...)

(CL:DEFUN |/PL-KERNEL-KB/EXP-CONSTRAINT| (MISSING-ARGUMENT X Y)
  (CL:LET* ((VALUE NULL))
   (CL:CASE (%WRAPPER-VALUE MISSING-ARGUMENT)
    (-1
     (CL:SETQ VALUE
      (CL:IF
       (CL:OR
        (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST|
         (|/PL-KERNEL-KB/EXP-COMPUTATION| X) Y)
        (|/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST| X
         (|/PL-KERNEL-KB/LOG-COMPUTATION| Y)))
       TRUE-WRAPPER FALSE-WRAPPER)))
    (0 (CL:SETQ VALUE (|/PL-KERNEL-KB/LOG-COMPUTATION| Y)))
    (1 (CL:SETQ VALUE (|/PL-KERNEL-KB/EXP-COMPUTATION| X)))
    (CL:OTHERWISE))
   VALUE))

;;; (DEFCLASS INTEGER-INTERVAL ...)

(CL:DEFCLASS |/PL-KERNEL-KB/INTEGER-INTERVAL| (THING)
  ((|/PL-KERNEL-KB/INTERVAL-LOWER-BOUND| :TYPE CL:FIXNUM :INITFORM
    NULL-INTEGER :ALLOCATION :INSTANCE :ACCESSOR
    |/PL-KERNEL-KB/%INTERVAL-LOWER-BOUND|)
   (|/PL-KERNEL-KB/INTERVAL-UPPER-BOUND| :TYPE CL:FIXNUM :INITFORM
    NULL-INTEGER :ALLOCATION :INSTANCE :ACCESSOR
    |/PL-KERNEL-KB/%INTERVAL-UPPER-BOUND|))
  (:DOCUMENTATION "An interval of integers"))

(CL:DEFUN |/PL-KERNEL-KB/NEW-INTEGER-INTERVAL| ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE |/PL-KERNEL-KB/INTEGER-INTERVAL|)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (|/PL-KERNEL-KB/%INTERVAL-UPPER-BOUND| SELF) NULL-INTEGER)
   (CL:SETF (|/PL-KERNEL-KB/%INTERVAL-LOWER-BOUND| SELF) NULL-INTEGER)
   SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF |/PL-KERNEL-KB/INTEGER-INTERVAL|))
  |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTEGER-INTERVAL|)

(CL:DEFUN |/PL-KERNEL-KB/ACCESS-INTEGER-INTERVAL-SLOT-VALUE| (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME
     |/PL-KERNEL-KB/SYM-ARITHMETIC-PL-KERNEL-KB-INTERVAL-LOWER-BOUND|)
    (CL:IF SETVALUE?
     (CL:SETF (|/PL-KERNEL-KB/%INTERVAL-LOWER-BOUND| SELF)
      (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (|/PL-KERNEL-KB/%INTERVAL-LOWER-BOUND| SELF)))))
   ((CL:EQ SLOTNAME
     |/PL-KERNEL-KB/SYM-ARITHMETIC-PL-KERNEL-KB-INTERVAL-UPPER-BOUND|)
    (CL:IF SETVALUE?
     (CL:SETF (|/PL-KERNEL-KB/%INTERVAL-UPPER-BOUND| SELF)
      (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE
      (WRAP-INTEGER (|/PL-KERNEL-KB/%INTERVAL-UPPER-BOUND| SELF)))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

;;; (DEFCLASS INTERVAL-CACHE ...)

(CL:DEFCLASS |/PL-KERNEL-KB/INTERVAL-CACHE| (THING)
  ((HOME-CONTEXT :ALLOCATION :INSTANCE :ACCESSOR %HOME-CONTEXT)
   (INTERVAL-MEMBER :ALLOCATION :INSTANCE :ACCESSOR %INTERVAL-MEMBER)
   (LOWER-BOUND :ALLOCATION :INSTANCE :ACCESSOR %LOWER-BOUND)
   (UPPER-BOUND :ALLOCATION :INSTANCE :ACCESSOR %UPPER-BOUND)
   (STRICT-LOWER-BOUND? :ALLOCATION :INSTANCE :ACCESSOR
    %STRICT-LOWER-BOUND?)
   (STRICT-UPPER-BOUND? :ALLOCATION :INSTANCE :ACCESSOR
    %STRICT-UPPER-BOUND?)))

(CL:DEFUN |/PL-KERNEL-KB/NEW-INTERVAL-CACHE| ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-INSTANCE (CL:QUOTE |/PL-KERNEL-KB/INTERVAL-CACHE|)))
   (CL:SETF (%DYNAMIC-SLOTS SELF) (NEW-KEY-VALUE-LIST))
   (CL:SETF (%SURROGATE-VALUE-INVERSE SELF) NULL)
   (CL:SETF (%STRICT-UPPER-BOUND? SELF) CL:NIL)
   (CL:SETF (%STRICT-LOWER-BOUND? SELF) CL:NIL)
   (CL:SETF (%UPPER-BOUND SELF) NULL)
   (CL:SETF (%LOWER-BOUND SELF) NULL)
   (CL:SETF (%INTERVAL-MEMBER SELF) NULL)
   (CL:SETF (%HOME-CONTEXT SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF |/PL-KERNEL-KB/INTERVAL-CACHE|))
  |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTERVAL-CACHE|)

(CL:DEFUN |/PL-KERNEL-KB/ACCESS-INTERVAL-CACHE-SLOT-VALUE| (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-HOME-CONTEXT|)
    (CL:IF SETVALUE? (CL:SETF (%HOME-CONTEXT SELF) VALUE)
     (CL:SETQ VALUE (%HOME-CONTEXT SELF))))
   ((CL:EQ SLOTNAME
     |/PL-KERNEL-KB/SYM-ARITHMETIC-LOGIC-INTERVAL-MEMBER|)
    (CL:IF SETVALUE? (CL:SETF (%INTERVAL-MEMBER SELF) VALUE)
     (CL:SETQ VALUE (%INTERVAL-MEMBER SELF))))
   ((CL:EQ SLOTNAME |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-LOWER-BOUND|)
    (CL:IF SETVALUE? (CL:SETF (%LOWER-BOUND SELF) VALUE)
     (CL:SETQ VALUE (%LOWER-BOUND SELF))))
   ((CL:EQ SLOTNAME |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-UPPER-BOUND|)
    (CL:IF SETVALUE? (CL:SETF (%UPPER-BOUND SELF) VALUE)
     (CL:SETQ VALUE (%UPPER-BOUND SELF))))
   ((CL:EQ SLOTNAME
     |/PL-KERNEL-KB/SYM-ARITHMETIC-LOGIC-STRICT-LOWER-BOUND?|)
    (CL:IF SETVALUE?
     (CL:SETF (%STRICT-LOWER-BOUND? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%STRICT-LOWER-BOUND? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   ((CL:EQ SLOTNAME
     |/PL-KERNEL-KB/SYM-ARITHMETIC-LOGIC-STRICT-UPPER-BOUND?|)
    (CL:IF SETVALUE?
     (CL:SETF (%STRICT-UPPER-BOUND? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%STRICT-UPPER-BOUND? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:IF SETVALUE?
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF) SLOTNAME VALUE NULL)
     (CL:SETQ VALUE (LOOKUP (%DYNAMIC-SLOTS SELF) SLOTNAME)))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF |/PL-KERNEL-KB/INTERVAL-CACHE|) STREAM)
  (CL:PROGN
   (%%PRINT-STREAM STREAM "|cache-of: " (%INTERVAL-MEMBER SELF) " ")
   (|/PL-KERNEL-KB/PRINT-INTERVAL| STREAM (%LOWER-BOUND SELF)
    (%STRICT-LOWER-BOUND? SELF) (%UPPER-BOUND SELF)
    (%STRICT-UPPER-BOUND? SELF))
   (%%PRINT-STREAM STREAM "|")))

;;; (DEFUN PRINT-INTERVAL ...)

(CL:DEFUN |/PL-KERNEL-KB/PRINT-INTERVAL| (STREAM LOWER STRICT-LOWER? UPPER STRICT-UPPER?)
  (CL:IF STRICT-LOWER? (%%PRINT-STREAM STREAM "(")
   (%%PRINT-STREAM STREAM "["))
  (CL:IF (CL:NOT (CL:EQ LOWER NULL)) (%%PRINT-STREAM STREAM LOWER)
   (%%PRINT-STREAM STREAM "?"))
  (%%PRINT-STREAM STREAM ",")
  (CL:IF (CL:NOT (CL:EQ UPPER NULL)) (%%PRINT-STREAM STREAM UPPER)
   (%%PRINT-STREAM STREAM "?"))
  (CL:IF STRICT-UPPER? (%%PRINT-STREAM STREAM ")")
   (%%PRINT-STREAM STREAM "]")))

;;; (DEFUN (CREATE-INTERVAL-CACHE INTERVAL-CACHE) ...)

(CL:DEFUN |/PL-KERNEL-KB/CREATE-INTERVAL-CACHE| (INTERVALMEMBER)
  (CL:LET* ((INTERVALCACHE (|/PL-KERNEL-KB/NEW-INTERVAL-CACHE|)))
   (CL:SETF (%INTERVAL-MEMBER INTERVALCACHE) INTERVALMEMBER)
   (CL:SETF (%HOME-CONTEXT INTERVALCACHE) *CONTEXT*)
   (ASSERT-BINARY-VALUE
    |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTERVAL-CACHE-OF|
    INTERVALMEMBER INTERVALCACHE)
   INTERVALCACHE))

;;; (DEFUN (GET-INTERVAL-CACHE INTERVAL-CACHE) ...)

(CL:DEFUN |/PL-KERNEL-KB/GET-INTERVAL-CACHE| (SELF)
  (CL:LET*
   ((INTERVALCACHE
     (ACCESS-BINARY-VALUE SELF
      |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTERVAL-CACHE-OF|)))
   (CL:COND
    ((CL:AND (CL:NOT (CL:EQ INTERVALCACHE NULL))
      (CL:NOT (SKOLEM? INTERVALCACHE)))
     (CL:LET*
      ((THISCACHE INTERVALCACHE) (COPYCACHE NULL) (PROPOSITION NULL))
      (CL:WHEN (CL:EQ (%HOME-CONTEXT THISCACHE) *CONTEXT*)
       (CL:RETURN-FROM |/PL-KERNEL-KB/GET-INTERVAL-CACHE| THISCACHE))
      (CL:LET* ((SELF-000 (|/PL-KERNEL-KB/NEW-INTERVAL-CACHE|)))
       (CL:SETF (%HOME-CONTEXT SELF-000) *CONTEXT*)
       (CL:SETF (%INTERVAL-MEMBER SELF-000) SELF)
       (CL:SETF (%LOWER-BOUND SELF-000) (%LOWER-BOUND THISCACHE))
       (CL:SETF (%UPPER-BOUND SELF-000) (%UPPER-BOUND THISCACHE))
       (CL:SETF (%STRICT-LOWER-BOUND? SELF-000)
        (%STRICT-LOWER-BOUND? THISCACHE))
       (CL:SETF (%STRICT-UPPER-BOUND? SELF-000)
        (%STRICT-UPPER-BOUND? THISCACHE))
       (CL:SETQ COPYCACHE SELF-000))
      (CL:LET* ((VALUE-000 NULL))
       (CL:LET*
        ((P NULL)
         (ITER-000
          (ALLOCATE-ITERATOR
           (UNFILTERED-DEPENDENT-PROPOSITIONS SELF
            |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTERVAL-CACHE-OF|))))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ P (%VALUE ITER-000))
         (CL:WHEN
          (CL:EQ (%OPERATOR P)
           |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTERVAL-CACHE-OF|)
          (CL:SETQ VALUE-000 P) (CL:RETURN))))
       (CL:SETQ PROPOSITION VALUE-000))
      (EQUATE-VALUES PROPOSITION
       (VALUE-OF
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         (CL:THE CL:FIXNUM (CL:1- (LENGTH (%ARGUMENTS PROPOSITION))))))
       COPYCACHE)
      COPYCACHE))
    (CL:T (|/PL-KERNEL-KB/CREATE-INTERVAL-CACHE| SELF)))))

;;; (DEFUN SIGNAL-INTERVAL-CLASH ...)

(CL:DEFUN |/PL-KERNEL-KB/SIGNAL-INTERVAL-CLASH| (INTERVAL)
  (MARK-AS-INCOHERENT (%INTERVAL-MEMBER INTERVAL))
  (CL:LET* ((MESSAGE-000 STELLA::NULL-STRING))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE-000))
   (CL:LET* ((*PRINTREADABLY?* CL:T))
    (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
    (CL:SETQ MESSAGE-000
     (CONCATENATE "Clash in interval values " "`" (STRINGIFY INTERVAL)
      "'" "
")))
   (CL:LET*
    ((MESSAGE MESSAGE-000) (CLASH (NEW-INTERVAL-CLASH MESSAGE)))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
    (CL:SETF (%CONTEXT CLASH) *CONTEXT*)
    (CL:SETF (%INTERVAL-MEMBER CLASH) (%INTERVAL-MEMBER INTERVAL))
    (CL:SETF (%LOWER-BOUND CLASH) (%LOWER-BOUND INTERVAL))
    (CL:SETF (%UPPER-BOUND CLASH) (%UPPER-BOUND INTERVAL))
    (CL:SETF (%STRICT-LOWER-BOUND? CLASH)
     (%STRICT-LOWER-BOUND? INTERVAL))
    (CL:SETF (%STRICT-UPPER-BOUND? CLASH)
     (%STRICT-UPPER-BOUND? INTERVAL))
    (CL:ERROR CLASH))))

;;; (DEFUN EVALUATE-ADJACENT-INEQUALITIES ...)

(CL:DEFUN |/PL-KERNEL-KB/EVALUATE-ADJACENT-INEQUALITIES| (SELF)
  (CL:LET*
   ((DEP NULL)
    (ITER-000
     (ALL-SPECIALIZING-DEPENDENT-PROPOSITIONS SELF
      |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INEQUALITY|)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ DEP (%VALUE ITER-000))
    (CL:LET* ((ALWAYS?-000 CL:T))
     (CL:LET*
      ((ARG NULL) (VECTOR-000 (%ARGUMENTS DEP)) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:WHEN
        (CL:NOT
         (CL:OR
          (ISA? (VALUE-OF ARG)
           |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-LOGIC-OBJECT|)
          (CL:NOT (TRUE? DEP))))
        (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:WHEN ALWAYS?-000 (POST-FOR-EVALUATION DEP *CONTEXT*))))))

;;; (DEFMETHOD (INTEGER-VALUED-MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD |/PL-KERNEL-KB/INTEGER-VALUED-MEMBER?| ((INTERVAL |/PL-KERNEL-KB/INTERVAL-CACHE|))
  (CL:LET* ((MEMBER (%INTERVAL-MEMBER INTERVAL)))
   (CL:AND (ISA? MEMBER |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-SKOLEM|)
    (SUBTYPE-OF? (%SKOLEM-TYPE MEMBER)
     |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-INTEGER|))))

;;; (DEFMETHOD (INTEGER-LOWER-BOUND INTEGER-WRAPPER) ...)

(CL:DEFMETHOD |/PL-KERNEL-KB/INTEGER-LOWER-BOUND| ((INTERVAL |/PL-KERNEL-KB/INTERVAL-CACHE|))
  (CL:LET* ((LB (%LOWER-BOUND INTERVAL)))
   (CL:WHEN (CL:NOT (CL:EQ LB NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE LB)))
     (CL:COND
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
       (CL:PROGN
        (CL:IF (%STRICT-LOWER-BOUND? INTERVAL)
         (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-LOWER-BOUND|
          (WRAP-INTEGER (CL:1+ (UNWRAP-INTEGER LB))))
         (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-LOWER-BOUND| LB))))
      ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
       (CL:PROGN
        (CL:IF (%STRICT-LOWER-BOUND? INTERVAL)
         (CL:IF (INTEGER-VALUED? (UNWRAP-FLOAT LB))
          (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-LOWER-BOUND|
           (WRAP-INTEGER (CL:1+ (FLOOR (UNWRAP-FLOAT LB)))))
          (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-LOWER-BOUND|
           (WRAP-INTEGER (CEILING (UNWRAP-FLOAT LB)))))
         (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-LOWER-BOUND|
          (WRAP-INTEGER (CEILING (UNWRAP-FLOAT LB)))))))
      (CL:T
       (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-LOWER-BOUND| NULL)))))
   NULL))

;;; (DEFMETHOD (INTEGER-UPPER-BOUND INTEGER-WRAPPER) ...)

(CL:DEFMETHOD |/PL-KERNEL-KB/INTEGER-UPPER-BOUND| ((INTERVAL |/PL-KERNEL-KB/INTERVAL-CACHE|))
  (CL:LET* ((UB (%UPPER-BOUND INTERVAL)))
   (CL:WHEN (CL:NOT (CL:EQ UB NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE UB)))
     (CL:COND
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
       (CL:PROGN
        (CL:IF (%STRICT-UPPER-BOUND? INTERVAL)
         (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-UPPER-BOUND|
          (WRAP-INTEGER (CL:1- (UNWRAP-INTEGER UB))))
         (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-UPPER-BOUND| UB))))
      ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
       (CL:PROGN
        (CL:IF (%STRICT-UPPER-BOUND? INTERVAL)
         (CL:IF (INTEGER-VALUED? (UNWRAP-FLOAT UB))
          (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-UPPER-BOUND|
           (WRAP-INTEGER (CL:1- (FLOOR (UNWRAP-FLOAT UB)))))
          (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-UPPER-BOUND|
           (WRAP-INTEGER (FLOOR (UNWRAP-FLOAT UB)))))
         (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-UPPER-BOUND|
          (WRAP-INTEGER (FLOOR (UNWRAP-FLOAT UB)))))))
      (CL:T
       (CL:RETURN-FROM |/PL-KERNEL-KB/INTEGER-UPPER-BOUND| NULL)))))
   NULL))

;;; (DEFMETHOD EVALUATE-TIGHTER-INTEGER-INTERVAL ...)

(CL:DEFMETHOD |/PL-KERNEL-KB/EVALUATE-TIGHTER-INTEGER-INTERVAL| ((INTERVAL |/PL-KERNEL-KB/INTERVAL-CACHE|))
  (CL:LET*
   ((LB (|/PL-KERNEL-KB/INTEGER-LOWER-BOUND| INTERVAL))
    (UB (|/PL-KERNEL-KB/INTEGER-UPPER-BOUND| INTERVAL)))
   (CL:WHEN
    (CL:AND (CL:NOT (CL:EQ LB NULL)) (CL:NOT (CL:EQ UB NULL))
     (EQL? LB UB))
    (EQUATE-VALUES NULL (%INTERVAL-MEMBER INTERVAL) LB))))

;;; (DEFMETHOD EVALUATE-TIGHTER-INTERVAL ...)

(CL:DEFMETHOD |/PL-KERNEL-KB/EVALUATE-TIGHTER-INTERVAL| ((INTERVAL |/PL-KERNEL-KB/INTERVAL-CACHE|))
  (CL:WHEN
   (CL:AND (CL:NOT (CL:EQ (%LOWER-BOUND INTERVAL) NULL))
    (CL:NOT (CL:EQ (%UPPER-BOUND INTERVAL) NULL)))
   (CL:IF (EQL? (%LOWER-BOUND INTERVAL) (%UPPER-BOUND INTERVAL))
    (CL:IF
     (CL:OR (%STRICT-LOWER-BOUND? INTERVAL)
      (%STRICT-UPPER-BOUND? INTERVAL))
     (|/PL-KERNEL-KB/SIGNAL-INTERVAL-CLASH| INTERVAL)
     (EQUATE-VALUES NULL (%INTERVAL-MEMBER INTERVAL)
      (%LOWER-BOUND INTERVAL)))
    (CL:HANDLER-CASE
     (CL:PROGN
      (CL:WHEN
       (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
        |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|
        (%LOWER-BOUND INTERVAL) (%UPPER-BOUND INTERVAL))
       (|/PL-KERNEL-KB/SIGNAL-INTERVAL-CLASH| INTERVAL))
      (CL:WHEN (|/PL-KERNEL-KB/INTEGER-VALUED-MEMBER?| INTERVAL)
       (|/PL-KERNEL-KB/EVALUATE-TIGHTER-INTEGER-INTERVAL| INTERVAL)))
     (INCOMPATIBLE-QUANTITY-EXCEPTION ()
      (|/PL-KERNEL-KB/SIGNAL-INTERVAL-CLASH| INTERVAL)))))
  (|/PL-KERNEL-KB/EVALUATE-ADJACENT-INEQUALITIES|
   (%INTERVAL-MEMBER INTERVAL)))

;;; (DEFMETHOD PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE ...)

(CL:DEFMETHOD |/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE| ((SELF |/PL-KERNEL-KB/INTERVAL-CACHE|) VALUE OPERATOR)
  (CL:WHEN (|/PL-KERNEL-KB/NULL-LITERAL-WRAPPER?| VALUE)
   (CL:RETURN-FROM
    |/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE|))
  (CL:WHEN
   (CL:NOT
    (CL:OR
     (ISA? VALUE |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-NUMBER-WRAPPER|)
     (ISA? VALUE
      |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-QUANTITY-LOGIC-WRAPPER|)))
   (CL:RETURN-FROM
    |/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE|))
  (CL:LET* ((TIGHTERINTERVAL? CL:NIL))
   (CL:HANDLER-CASE
    (CL:COND
     ((CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|)
      (CL:WHEN
       (CL:OR (CL:EQ (%LOWER-BOUND SELF) NULL)
        (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->| VALUE
         (%LOWER-BOUND SELF))
        (CL:AND (EQL? VALUE (%LOWER-BOUND SELF))
         (CL:NOT (%STRICT-LOWER-BOUND? SELF))))
       (CL:SETF (%LOWER-BOUND SELF) VALUE)
       (CL:SETF (%STRICT-LOWER-BOUND? SELF) CL:T)
       (CL:SETQ TIGHTERINTERVAL? CL:T)))
     ((CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)
      (CL:WHEN
       (CL:OR (CL:EQ (%LOWER-BOUND SELF) NULL)
        (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->| VALUE
         (%LOWER-BOUND SELF)))
       (CL:SETF (%LOWER-BOUND SELF) VALUE)
       (CL:SETF (%STRICT-LOWER-BOUND? SELF) CL:NIL)
       (CL:SETQ TIGHTERINTERVAL? CL:T)))
     ((CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
      (CL:WHEN
       (CL:OR (CL:EQ (%UPPER-BOUND SELF) NULL)
        (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<| VALUE
         (%UPPER-BOUND SELF))
        (CL:AND (CL:EQ VALUE (%UPPER-BOUND SELF))
         (CL:NOT (%STRICT-UPPER-BOUND? SELF))))
       (CL:SETF (%UPPER-BOUND SELF) VALUE)
       (CL:SETF (%STRICT-UPPER-BOUND? SELF) CL:T)
       (CL:SETQ TIGHTERINTERVAL? CL:T)))
     ((CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
      (CL:WHEN
       (CL:OR (CL:EQ (%UPPER-BOUND SELF) NULL)
        (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<| VALUE
         (%UPPER-BOUND SELF)))
       (CL:SETF (%UPPER-BOUND SELF) VALUE)
       (CL:SETF (%STRICT-UPPER-BOUND? SELF) CL:NIL)
       (CL:SETQ TIGHTERINTERVAL? CL:T)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" OPERATOR
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
    (INCOMPATIBLE-QUANTITY-EXCEPTION ()
     (|/PL-KERNEL-KB/SIGNAL-INTERVAL-CLASH| SELF)))
   (CL:WHEN TIGHTERINTERVAL?
    (|/PL-KERNEL-KB/EVALUATE-TIGHTER-INTERVAL| SELF))))

;;; (DEFUN (INVERSE-INEQUALITY-OPERATOR SURROGATE) ...)

(CL:DEFUN |/PL-KERNEL-KB/INVERSE-INEQUALITY-OPERATOR| (OPERATOR)
  (CL:COND
   ((CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|)
    |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
   ((CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
    |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|)
   ((CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)
    |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
   ((CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
    |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" OPERATOR
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN UNIFY-INTERVAL-CACHES ...)

(CL:DEFUN |/PL-KERNEL-KB/UNIFY-INTERVAL-CACHES| (CACHE1 CACHE2 OPERATOR)
  (CL:COND
   ((CL:OR
     (CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|)
     (CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|))
    (|/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE| CACHE1
     (|/PL-KERNEL-KB/ACCESS-INTERVAL-CACHE-BOUNDS| CACHE2
      |/PL-KERNEL-KB/KWD-ARITHMETIC-LOWER-BOUND|)
     OPERATOR)
    (|/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE| CACHE2
     (|/PL-KERNEL-KB/ACCESS-INTERVAL-CACHE-BOUNDS| CACHE1
      |/PL-KERNEL-KB/KWD-ARITHMETIC-UPPER-BOUND|)
     (|/PL-KERNEL-KB/INVERSE-INEQUALITY-OPERATOR| OPERATOR)))
   ((CL:OR
     (CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
     (CL:EQ OPERATOR |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|))
    (|/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE| CACHE1
     (|/PL-KERNEL-KB/ACCESS-INTERVAL-CACHE-BOUNDS| CACHE2
      |/PL-KERNEL-KB/KWD-ARITHMETIC-UPPER-BOUND|)
     OPERATOR)
    (|/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE| CACHE2
     (|/PL-KERNEL-KB/ACCESS-INTERVAL-CACHE-BOUNDS| CACHE1
      |/PL-KERNEL-KB/KWD-ARITHMETIC-LOWER-BOUND|)
     (|/PL-KERNEL-KB/INVERSE-INEQUALITY-OPERATOR| OPERATOR)))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" OPERATOR
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN (ACCESS-INTERVAL-BOUNDS OBJECT BOOLEAN) ...)

(CL:DEFUN |/PL-KERNEL-KB/ACCESS-INTERVAL-BOUNDS| (X LOWERORUPPER)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-NUMBER-WRAPPER|)
     (CL:PROGN (CL:VALUES X CL:NIL)))
    ((SUBTYPE-OF? TEST-VALUE-000
      |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-QUANTITY-LOGIC-WRAPPER|)
     (CL:PROGN (CL:VALUES X CL:NIL)))
    (CL:T
     (|/PL-KERNEL-KB/ACCESS-INTERVAL-CACHE-BOUNDS|
      (ACCESS-BINARY-VALUE X
       |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTERVAL-CACHE-OF|)
      LOWERORUPPER)))))

;;; (DEFUN (ACCESS-INTERVAL-CACHE-BOUNDS OBJECT BOOLEAN) ...)

(CL:DEFUN |/PL-KERNEL-KB/ACCESS-INTERVAL-CACHE-BOUNDS| (INTERVALCACHE LOWERORUPPER)
  (CL:IF (CL:EQ INTERVALCACHE NULL) (CL:VALUES NULL CL:NIL)
   (CL:COND
    ((CL:EQ LOWERORUPPER |/PL-KERNEL-KB/KWD-ARITHMETIC-LOWER-BOUND|)
     (CL:VALUES (%LOWER-BOUND INTERVALCACHE)
      (%STRICT-LOWER-BOUND? INTERVALCACHE)))
    ((CL:EQ LOWERORUPPER |/PL-KERNEL-KB/KWD-ARITHMETIC-UPPER-BOUND|)
     (CL:VALUES (%UPPER-BOUND INTERVALCACHE)
      (%STRICT-UPPER-BOUND? INTERVALCACHE)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" LOWERORUPPER
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (COMPARE-INTERVAL-BOUNDS? BOOLEAN) ...)

(CL:DEFUN |/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?| (RELATION X Y)
  (CL:WHEN
   (CL:OR (|/PL-KERNEL-KB/NULL-LITERAL-WRAPPER?| X)
    (|/PL-KERNEL-KB/NULL-LITERAL-WRAPPER?| Y))
   (CL:RETURN-FROM |/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?| CL:NIL))
  (CL:WHEN
   (CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=|)
   (CL:RETURN-FROM |/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?| (EQL? X Y)))
  (CL:LET* ((TEST-VALUE-002 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-002
      |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-NUMBER-WRAPPER|)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE Y)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-000
          |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-NUMBER-WRAPPER|)
         (CL:PROGN
          (CL:LET*
           ((FLOAT-X (NUMBER-WRAPPER-TO-FLOAT X))
            (FLOAT-Y (NUMBER-WRAPPER-TO-FLOAT Y)))
           (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT FLOAT-X FLOAT-Y))
           (CL:COND
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
             (<= FLOAT-X FLOAT-Y))
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
             (< FLOAT-X FLOAT-Y))
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)
             (>= FLOAT-X FLOAT-Y))
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|)
             (> FLOAT-X FLOAT-Y))
            (CL:T
             (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
              (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" RELATION
               "' is not a valid case option")
              (CL:ERROR
               (NEW-STELLA-EXCEPTION
                (THE-STRING-READER STREAM-000)))))))))
        ((SUBTYPE-OF? TEST-VALUE-000
          |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-QUANTITY-LOGIC-WRAPPER|)
         (CL:PROGN
          (CL:LET*
           ((QUANTITY-Y (%WRAPPER-VALUE Y))
            (QUANTITY-X (COERCE-TO QUANTITY-Y X)))
           (CL:COND
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
             (LESS-EQUAL? QUANTITY-X QUANTITY-Y))
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
             (LESS? QUANTITY-X QUANTITY-Y))
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)
             (GREATER-EQUAL? QUANTITY-X QUANTITY-Y))
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|)
             (GREATER? QUANTITY-X QUANTITY-Y))
            (CL:T
             (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
              (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" RELATION
               "' is not a valid case option")
              (CL:ERROR
               (NEW-STELLA-EXCEPTION
                (THE-STRING-READER STREAM-001)))))))))
        (CL:T
         (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`"
           TEST-VALUE-000 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))))))
    ((SUBTYPE-OF? TEST-VALUE-002
      |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-QUANTITY-LOGIC-WRAPPER|)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE Y)))
       (CL:COND
        ((SUBTYPE-OF? TEST-VALUE-001
          |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-NUMBER-WRAPPER|)
         (CL:PROGN
          (CL:LET*
           ((QUANTITY-X (%WRAPPER-VALUE X))
            (QUANTITY-Y (COERCE-TO QUANTITY-X Y)))
           (CL:COND
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
             (LESS-EQUAL? QUANTITY-X QUANTITY-Y))
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
             (LESS? QUANTITY-X QUANTITY-Y))
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)
             (GREATER-EQUAL? QUANTITY-X QUANTITY-Y))
            ((CL:EQ RELATION
              |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|)
             (GREATER? QUANTITY-X QUANTITY-Y))
            (CL:T
             (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
              (%%PRINT-STREAM (%NATIVE-STREAM STREAM-003) "`" RELATION
               "' is not a valid case option")
              (CL:ERROR
               (NEW-STELLA-EXCEPTION
                (THE-STRING-READER STREAM-003)))))))))
        ((SUBTYPE-OF? TEST-VALUE-001
          |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-QUANTITY-LOGIC-WRAPPER|)
         (CL:PROGN
          (CL:COND
           ((CL:EQ RELATION
             |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
            (LESS-EQUAL? (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))
           ((CL:EQ RELATION
             |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
            (LESS? (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))
           ((CL:EQ RELATION
             |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)
            (GREATER-EQUAL? (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))
           ((CL:EQ RELATION
             |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|)
            (GREATER? (%WRAPPER-VALUE X) (%WRAPPER-VALUE Y)))
           (CL:T
            (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM (%NATIVE-STREAM STREAM-004) "`" RELATION
              "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION
               (THE-STRING-READER STREAM-004))))))))
        (CL:T
         (CL:LET* ((STREAM-005 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-005) "`"
           TEST-VALUE-001 "' is not a valid case option")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-005)))))))))
    (CL:T
     (CL:LET* ((STREAM-006 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-006) "`" TEST-VALUE-002
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-006))))))))

;;; (DEFUN (NULL-NUMBER? BOOLEAN) ...)

(CL:DEFUN |/PL-KERNEL-KB/NULL-NUMBER?| (SELF)
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM |/PL-KERNEL-KB/NULL-NUMBER?| CL:T))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN (CL:= (%WRAPPER-VALUE SELF) NULL-INTEGER)))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN (CL:= (%WRAPPER-VALUE SELF) NULL-FLOAT)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (NULL-LITERAL-WRAPPER? BOOLEAN) ...)

(CL:DEFUN |/PL-KERNEL-KB/NULL-LITERAL-WRAPPER?| (SELF)
  (CL:WHEN (CL:EQ SELF NULL)
   (CL:RETURN-FROM |/PL-KERNEL-KB/NULL-LITERAL-WRAPPER?| CL:T))
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE SELF)))
   (CL:COND
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN (CL:= (%WRAPPER-VALUE SELF) NULL-INTEGER)))
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN (CL:= (%WRAPPER-VALUE SELF) NULL-FLOAT)))
    ((SUBTYPE-OF? TEST-VALUE-000
      |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-QUANTITY-LOGIC-WRAPPER|)
     (CL:PROGN (CL:EQ (%WRAPPER-VALUE SELF) NULL)))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN (CL:EQ (%WRAPPER-VALUE SELF) STELLA::NULL-STRING)))
    ((SUBTYPE-OF-CHARACTER? TEST-VALUE-000)
     (CL:PROGN (NULL? (%WRAPPER-VALUE SELF))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (SATISFIES-INTERVAL-BOUNDS? BOOLEAN) ...)

(CL:DEFUN |/PL-KERNEL-KB/SATISFIES-INTERVAL-BOUNDS?| (OBJECT VALUE)
  (CL:LET*
   ((LB NULL) (STRICTLOWER? CL:NIL) (UB NULL) (STRICTUPPER? CL:NIL)
    (ANSWER CL:T))
   (CL:MULTIPLE-VALUE-SETQ (LB STRICTLOWER?)
    (|/PL-KERNEL-KB/ACCESS-INTERVAL-BOUNDS| OBJECT
     |/PL-KERNEL-KB/KWD-ARITHMETIC-LOWER-BOUND|))
   (CL:MULTIPLE-VALUE-SETQ (UB STRICTUPPER?)
    (|/PL-KERNEL-KB/ACCESS-INTERVAL-BOUNDS| OBJECT
     |/PL-KERNEL-KB/KWD-ARITHMETIC-UPPER-BOUND|))
   (CL:WHEN (|/PL-KERNEL-KB/NULL-LITERAL-WRAPPER?| VALUE)
    (CL:RETURN-FROM |/PL-KERNEL-KB/SATISFIES-INTERVAL-BOUNDS?| CL:NIL))
   (CL:WHEN (CL:NOT (|/PL-KERNEL-KB/NULL-LITERAL-WRAPPER?| LB))
    (CL:IF STRICTLOWER?
     (CL:SETQ ANSWER
      (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
       |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<| LB VALUE))
     (CL:SETQ ANSWER
      (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
       |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<| LB VALUE))))
   (CL:WHEN (CL:NOT (|/PL-KERNEL-KB/NULL-LITERAL-WRAPPER?| UB))
    (CL:IF STRICTUPPER?
     (CL:SETQ ANSWER
      (CL:AND ANSWER
       (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
        |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<| VALUE UB)))
     (CL:SETQ ANSWER
      (CL:AND ANSWER
       (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
        |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<| VALUE UB)))))
   ANSWER))

;;; (DEFUN (LESS-SPECIALIST-HELPER KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/LESS-SPECIALIST-HELPER| (FRAME RELATION XARG YARG)
  (CL:LET*
   ((X (ARGUMENT-BOUND-TO XARG)) (Y (ARGUMENT-BOUND-TO YARG))
    (XBOUND NULL) (STRICTX? CL:NIL) (YBOUND NULL) (STRICTY? CL:NIL)
    (SUCCESS? CL:NIL))
   (CL:WHEN (CL:EQ Y NULL)
    (CL:WHEN (CL:EQ X NULL)
     (CL:RETURN-FROM |/PL-KERNEL-KB/LESS-SPECIALIST-HELPER|
      |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|))
    (CL:MULTIPLE-VALUE-SETQ (XBOUND STRICTX?)
     (|/PL-KERNEL-KB/ACCESS-INTERVAL-BOUNDS| X
      |/PL-KERNEL-KB/KWD-ARITHMETIC-UPPER-BOUND|))
    (CL:WHEN
     (CL:AND (CL:NOT (|/PL-KERNEL-KB/NULL-LITERAL-WRAPPER?| XBOUND))
      (CL:OR
       (CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
       (ISA? XBOUND
        |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-INTEGER-WRAPPER|)))
     (CL:WHEN
      (CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
      (CL:SETQ XBOUND (WRAP-INTEGER (CL:1+ (%WRAPPER-VALUE XBOUND)))))
     (CL:SETQ SUCCESS? (BIND-VARIABLE-TO-VALUE? YARG XBOUND CL:T)))
    (CL:RETURN-FROM |/PL-KERNEL-KB/LESS-SPECIALIST-HELPER|
     (SELECT-PROOF-RESULT SUCCESS? CL:NIL CL:NIL)))
   (CL:WHEN (CL:EQ X NULL)
    (CL:MULTIPLE-VALUE-SETQ (YBOUND STRICTY?)
     (|/PL-KERNEL-KB/ACCESS-INTERVAL-BOUNDS| Y
      |/PL-KERNEL-KB/KWD-ARITHMETIC-LOWER-BOUND|))
    (CL:WHEN
     (CL:AND (CL:NOT (|/PL-KERNEL-KB/NULL-NUMBER?| YBOUND))
      (CL:OR
       (CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
       (ISA? YBOUND
        |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-INTEGER-WRAPPER|)))
     (CL:WHEN
      (CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
      (CL:SETQ YBOUND (WRAP-INTEGER (CL:1- (%WRAPPER-VALUE YBOUND)))))
     (CL:SETQ SUCCESS? (BIND-VARIABLE-TO-VALUE? XARG YBOUND CL:T)))
    (CL:RETURN-FROM |/PL-KERNEL-KB/LESS-SPECIALIST-HELPER|
     (SELECT-PROOF-RESULT SUCCESS? CL:NIL CL:NIL)))
   (CL:LET* ((SUCCESS? CL:NIL))
    (CL:MULTIPLE-VALUE-SETQ (XBOUND STRICTX?)
     (|/PL-KERNEL-KB/ACCESS-INTERVAL-BOUNDS| X
      |/PL-KERNEL-KB/KWD-ARITHMETIC-UPPER-BOUND|))
    (CL:MULTIPLE-VALUE-SETQ (YBOUND STRICTY?)
     (|/PL-KERNEL-KB/ACCESS-INTERVAL-BOUNDS| Y
      |/PL-KERNEL-KB/KWD-ARITHMETIC-LOWER-BOUND|))
    (CL:HANDLER-CASE
     (CL:COND
      ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
       (CL:SETQ SUCCESS?
        (CL:OR
         (CL:AND (CL:OR STRICTX? STRICTY?)
          (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
           |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<| XBOUND
           YBOUND))
         (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
          |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<| XBOUND
          YBOUND))))
      ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
       (CL:SETQ SUCCESS?
        (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?| RELATION XBOUND
         YBOUND)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" RELATION
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
     (INCOMPATIBLE-QUANTITY-EXCEPTION ()
      (SET-FRAME-TRUTH-VALUE FRAME UNKNOWN-TRUTH-VALUE)
      (CL:RETURN-FROM |/PL-KERNEL-KB/LESS-SPECIALIST-HELPER|
       |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|)))
    (CL:WHEN SUCCESS? (SET-FRAME-TRUTH-VALUE FRAME TRUE-TRUTH-VALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/LESS-SPECIALIST-HELPER|
      |/PL-KERNEL-KB/KWD-ARITHMETIC-FINAL-SUCCESS|))
    (CL:MULTIPLE-VALUE-SETQ (XBOUND STRICTX?)
     (|/PL-KERNEL-KB/ACCESS-INTERVAL-BOUNDS| X
      |/PL-KERNEL-KB/KWD-ARITHMETIC-LOWER-BOUND|))
    (CL:MULTIPLE-VALUE-SETQ (YBOUND STRICTY?)
     (|/PL-KERNEL-KB/ACCESS-INTERVAL-BOUNDS| Y
      |/PL-KERNEL-KB/KWD-ARITHMETIC-UPPER-BOUND|))
    (CL:HANDLER-CASE
     (CL:COND
      ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
       (CL:SETQ SUCCESS?
        (CL:OR
         (CL:AND (CL:OR STRICTX? STRICTY?)
          (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
           |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<| YBOUND
           XBOUND))
         (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
          |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<| YBOUND
          XBOUND))))
      ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
       (CL:SETQ SUCCESS?
        (|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<| YBOUND
         XBOUND)))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" RELATION
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))
     (INCOMPATIBLE-QUANTITY-EXCEPTION ()
      (SET-FRAME-TRUTH-VALUE FRAME UNKNOWN-TRUTH-VALUE)
      (CL:RETURN-FROM |/PL-KERNEL-KB/LESS-SPECIALIST-HELPER|
       |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|)))
    (CL:WHEN SUCCESS? (SET-FRAME-TRUTH-VALUE FRAME FALSE-TRUTH-VALUE)
     (CL:RETURN-FROM |/PL-KERNEL-KB/LESS-SPECIALIST-HELPER|
      |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|)))
   (CL:IF (CL:AND (SKOLEM? X) (SKOLEM? Y))
    |/PL-KERNEL-KB/KWD-ARITHMETIC-FAILURE|
    |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|)))

;;; (DEFUN (INEQUALITY-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/INEQUALITY-SPECIALIST| (FRAME LASTMOVE)
  (CL:SETQ LASTMOVE LASTMOVE)
  (CL:LET*
   ((PROPOSITION (%PROPOSITION FRAME))
    (RELATION (%OPERATOR PROPOSITION)))
   (CL:IF *REVERSEPOLARITY?*
    (CL:LET* ((*REVERSEPOLARITY?* CL:NIL))
     (CL:DECLARE (CL:SPECIAL *REVERSEPOLARITY?*))
     (CL:COND
      ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
       (|/PL-KERNEL-KB/LESS-SPECIALIST-HELPER| FRAME
        |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         1)
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         0)))
      ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
       (|/PL-KERNEL-KB/LESS-SPECIALIST-HELPER| FRAME
        |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         1)
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         0)))
      ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|)
       (|/PL-KERNEL-KB/LESS-SPECIALIST-HELPER| FRAME
        |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         0)
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         1)))
      ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)
       (|/PL-KERNEL-KB/LESS-SPECIALIST-HELPER| FRAME
        |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         0)
        (CL:AREF
         (CL:THE CL:SIMPLE-VECTOR
          (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
         1)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" RELATION
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))
    (CL:COND
     ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|)
      (|/PL-KERNEL-KB/LESS-SPECIALIST-HELPER| FRAME
       |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        0)
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        1)))
     ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
      (|/PL-KERNEL-KB/LESS-SPECIALIST-HELPER| FRAME
       |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        0)
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        1)))
     ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|)
      (|/PL-KERNEL-KB/LESS-SPECIALIST-HELPER| FRAME
       |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        1)
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        0)))
     ((CL:EQ RELATION |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)
      (|/PL-KERNEL-KB/LESS-SPECIALIST-HELPER| FRAME
       |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        1)
       (CL:AREF
        (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
        0)))
     (CL:T
      (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" RELATION
        "' is not a valid case option")
       (CL:ERROR
        (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))))

;;; (DEFUN INEQUALITY-EVALUATOR ...)

(CL:DEFUN |/PL-KERNEL-KB/INEQUALITY-EVALUATOR| (SELF)
  (CL:WHEN (CL:NOT (TRUE? SELF))
   (CL:RETURN-FROM |/PL-KERNEL-KB/INEQUALITY-EVALUATOR|))
  (CL:LET*
   ((ARG1
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
      0))
    (ARG2
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SELF)))
      1))
    (VALUE1 (VALUE-OF ARG1)) (VALUE2 (VALUE-OF ARG2))
    (SKOLEM1?
     (ISA? VALUE1 |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-LOGIC-OBJECT|))
    (SKOLEM2?
     (ISA? VALUE2 |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-LOGIC-OBJECT|))
    (OPERATOR (%OPERATOR SELF)))
   (CL:WHEN (EQL? VALUE1 VALUE2)
    (CL:COND
     ((CL:NOT (EQL? ARG1 VALUE1))
      (CL:COND
       ((CL:NOT (EQL? ARG2 VALUE2))
        (|/PL-KERNEL-KB/UNIFY-INTERVAL-CACHES|
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG1)
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG2)
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
        (|/PL-KERNEL-KB/UNIFY-INTERVAL-CACHES|
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG1)
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG2)
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)
        (CL:SETQ VALUE2 ARG2) (CL:SETQ SKOLEM2? CL:T))
       (CL:T
        (|/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE|
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG1) VALUE2
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
        (|/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE|
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG1) VALUE2
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)))
      (CL:SETQ VALUE1 ARG1) (CL:SETQ SKOLEM1? CL:T))
     ((CL:NOT (EQL? ARG2 VALUE2))
      (CL:COND
       ((CL:NOT (EQL? ARG1 VALUE1))
        (|/PL-KERNEL-KB/UNIFY-INTERVAL-CACHES|
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG2)
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG1)
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
        (|/PL-KERNEL-KB/UNIFY-INTERVAL-CACHES|
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG2)
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG1)
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)
        (CL:SETQ VALUE1 ARG1) (CL:SETQ SKOLEM1? CL:T))
       (CL:T
        (|/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE|
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG2) VALUE1
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|)
        (|/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE|
         (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| ARG2) VALUE1
         |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|)))
      (CL:SETQ VALUE2 ARG2) (CL:SETQ SKOLEM2? CL:T))))
   (CL:IF SKOLEM1?
    (CL:IF SKOLEM2?
     (|/PL-KERNEL-KB/UNIFY-INTERVAL-CACHES|
      (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| VALUE1)
      (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| VALUE2) OPERATOR)
     (|/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE|
      (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| VALUE1) VALUE2 OPERATOR))
    (CL:IF SKOLEM2?
     (|/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE|
      (|/PL-KERNEL-KB/GET-INTERVAL-CACHE| VALUE2) VALUE1
      (|/PL-KERNEL-KB/INVERSE-INEQUALITY-OPERATOR| OPERATOR))
     (CL:COND
      ((|/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?| OPERATOR VALUE1
        VALUE2)
       (ASSIGN-TRUTH-VALUE SELF TRUE-WRAPPER))
      ((TRUE? SELF) (SIGNAL-TRUTH-VALUE-CLASH SELF))
      (CL:T (ASSIGN-TRUTH-VALUE SELF FALSE-WRAPPER)))))))

;;; (DEFUN (STRING-CONCATENATE-COMPUTATION STRING-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-CONCATENATE-COMPUTATION| (X YARGS)
  (CL:LET* ((*PRINTMODE* |/PL-KERNEL-KB/KWD-ARITHMETIC-ORIGINAL|))
   (CL:DECLARE (CL:SPECIAL *PRINTMODE*))
   (CL:LET* ((OUT (NEW-OUTPUT-STRING-STREAM)))
    (%%PRINT-STREAM (%NATIVE-STREAM OUT) (PLI::OBJECT-TO-STRING X))
    (CL:LET* ((ARG NULL) (ITER-000 YARGS))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ ARG (%%VALUE ITER-000))
      (%%PRINT-STREAM (%NATIVE-STREAM OUT) (PLI::OBJECT-TO-STRING ARG))
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (WRAP-STRING (THE-STRING-READER OUT)))))

;;; (DEFUN (SUBSEQUENCE-SPECIALIST KEYWORD) ...)

(CL:DEFUN |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST| (FRAME LASTMOVE)
  (CL:SETQ LASTMOVE LASTMOVE)
  (CL:LET*
   ((ARGUMENTS (%ARGUMENTS (%PROPOSITION FRAME)))
    (SUPERARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 0))
    (P1ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 1))
    (P2ARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 2))
    (SUBARG
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS)) 3))
    (ITERATOR
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
      |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-ITERATOR| NULL)))
   (CL:WHEN (CL:EQ ITERATOR NULL)
    (CL:LET*
     ((SUPERARGVALUE (ARGUMENT-BOUND-TO SUPERARG))
      (SUPER
       (CL:IF (STRING? SUPERARGVALUE) (UNWRAP-STRING SUPERARGVALUE)
        (PLI::OBJECT-TO-STRING SUPERARGVALUE)))
      (SUPERLENGTH NULL-INTEGER) (P1ARGVALUE (ARGUMENT-BOUND-TO P1ARG))
      (P1 NULL-INTEGER) (P2ARGVALUE (ARGUMENT-BOUND-TO P2ARG))
      (P2 NULL-INTEGER) (SUBARGVALUE (ARGUMENT-BOUND-TO SUBARG))
      (SUB
       (CL:IF (STRING? SUBARGVALUE) (UNWRAP-STRING SUBARGVALUE)
        (PLI::OBJECT-TO-STRING SUBARGVALUE)))
      (SUBLENGTH
       (CL:IF (CL:NOT (CL:EQ SUB STELLA::NULL-STRING))
        (CL:THE CL:FIXNUM (CL:LENGTH SUB)) NULL-INTEGER)))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SUPER SUB)
      (CL:TYPE CL:FIXNUM SUPERLENGTH P1 P2 SUBLENGTH))
     (CL:WHEN (CL:EQ SUPER STELLA::NULL-STRING)
      (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
       |/PL-KERNEL-KB/KWD-ARITHMETIC-FAILURE|))
     (CL:SETQ SUPERLENGTH (CL:THE CL:FIXNUM (CL:LENGTH SUPER)))
     (CL:WHEN (CL:NOT (CL:EQ P1ARGVALUE NULL))
      (CL:IF (INTEGER? P1ARGVALUE)
       (CL:SETQ P1 (%WRAPPER-VALUE P1ARGVALUE))
       (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
        |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|))
      (CL:WHEN (CL:OR (CL:< P1 0) (CL:> P1 SUPERLENGTH))
       (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
        |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|)))
     (CL:WHEN (CL:NOT (CL:EQ P2ARGVALUE NULL))
      (CL:IF (INTEGER? P2ARGVALUE)
       (CL:SETQ P2 (%WRAPPER-VALUE P2ARGVALUE))
       (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
        |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|))
      (CL:WHEN (CL:< P2 0) (CL:SETQ P2 (CL:+ SUPERLENGTH P2 1)))
      (CL:WHEN
       (CL:OR (CL:> P2 SUPERLENGTH)
        (CL:AND (CL:NOT (CL:= P1 NULL-INTEGER)) (CL:> P1 P2)))
       (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
        |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|)))
     (CL:COND
      ((CL:EQ SUB STELLA::NULL-STRING)
       (CL:IF
        (CL:AND (CL:NOT (CL:= P1 NULL-INTEGER))
         (CL:NOT (CL:= P2 NULL-INTEGER)))
        (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
         (SELECT-PROOF-RESULT
          (BIND-ARGUMENT-TO-VALUE? SUBARG
           (WRAP-STRING (SUBSEQUENCE SUPER P1 P2)) CL:T)
          CL:NIL CL:T))
        (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
         |/PL-KERNEL-KB/KWD-ARITHMETIC-FAILURE|)))
      ((CL:= P1 NULL-INTEGER)
       (CL:IF (CL:= P2 NULL-INTEGER)
        (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
         |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-ITERATOR|
         (NEW-SUBSTRING-POSITION-ITERATOR SUPER SUB) NULL)
        (CL:COND
         ((CL:> SUBLENGTH P2)
          (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
           |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|))
         ((STRING-EQL? (SUBSEQUENCE SUPER (CL:- P2 SUBLENGTH) P2) SUB)
          (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
           (SELECT-PROOF-RESULT
            (BIND-ARGUMENT-TO-VALUE? P1ARG
             (WRAP-INTEGER (CL:- P2 SUBLENGTH)) CL:T)
            CL:NIL CL:T)))
         (CL:T
          (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
           |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|)))))
      ((CL:= P2 NULL-INTEGER)
       (CL:COND
        ((CL:> (CL:+ P1 SUBLENGTH) SUPERLENGTH)
         (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
          |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|))
        ((STRING-EQL? SUB (SUBSEQUENCE SUPER P1 (CL:+ P1 SUBLENGTH)))
         (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
          (SELECT-PROOF-RESULT
           (BIND-ARGUMENT-TO-VALUE? P2ARG
            (WRAP-INTEGER (CL:+ P1 SUBLENGTH)) CL:T)
           CL:NIL CL:T)))
        (CL:T
         (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
          |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|))))
      (CL:T
       (CL:LET*
        ((MATCH?
          (BIND-ARGUMENT-TO-VALUE? SUBARG
           (WRAP-STRING (SUBSEQUENCE SUPER P1 P2)) CL:T)))
        (SET-FRAME-TRUTH-VALUE FRAME
         (CL:IF MATCH? TRUE-TRUTH-VALUE FALSE-TRUTH-VALUE))
        (CL:RETURN-FROM |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|
         (SELECT-PROOF-RESULT MATCH? CL:NIL CL:T)))))))
   (CL:SETQ ITERATOR
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FRAME)
     |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-ITERATOR| NULL))
   (CL:IF
    (CL:AND (NEXT? ITERATOR)
     (BIND-ARGUMENT-TO-VALUE? P1ARG (%%VALUE (%VALUE ITERATOR)) CL:T)
     (BIND-ARGUMENT-TO-VALUE? P2ARG
      (%%VALUE (%%REST (%VALUE ITERATOR))) CL:T))
    |/PL-KERNEL-KB/KWD-ARITHMETIC-CONTINUING-SUCCESS|
    |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|)))

;;; (DEFUN (NORMALIZE-STRING-COMPUTATION-ARGS STRING INTEGER INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:T CL:T CL:T CL:T)
   (CL:VALUES CL:SIMPLE-STRING CL:FIXNUM CL:FIXNUM))
  |/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS|))
(CL:DEFUN |/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS| (X START END COERCE?)
  (CL:WHEN (CL:NOT (CL:AND (INTEGER? START) (INTEGER? END)))
   (CL:RETURN-FROM |/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS|
    (CL:VALUES STELLA::NULL-STRING NULL-INTEGER NULL-INTEGER)))
  (CL:LET*
   ((THESTART (%WRAPPER-VALUE START)) (THEEND (%WRAPPER-VALUE END))
    (NAME
     (CL:IF (STRING? X) (%WRAPPER-VALUE X) (OBJECT-NAME-STRING X)))
    (NAMELENGTH 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM THESTART THEEND NAMELENGTH)
    (CL:TYPE CL:SIMPLE-STRING NAME))
   (CL:WHEN (CL:AND (CL:EQ NAME STELLA::NULL-STRING) COERCE?)
    (CL:SETQ NAME (PLI::OBJECT-TO-STRING X)))
   (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
    (CL:RETURN-FROM |/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS|
     (CL:VALUES STELLA::NULL-STRING NULL-INTEGER NULL-INTEGER)))
   (CL:SETQ NAMELENGTH (CL:THE CL:FIXNUM (CL:LENGTH NAME)))
   (CL:WHEN (CL:< THESTART 0)
    (CL:SETQ THESTART (CL:1+ (CL:+ NAMELENGTH THESTART))))
   (CL:WHEN (CL:< THESTART 0)
    (CL:RETURN-FROM |/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS|
     (CL:VALUES STELLA::NULL-STRING NULL-INTEGER NULL-INTEGER)))
   (CL:WHEN (CL:< THEEND 0)
    (CL:SETQ THEEND (CL:1+ (CL:+ NAMELENGTH THEEND))))
   (CL:IF (CL:OR (CL:< THEEND 0) (CL:> THEEND NAMELENGTH))
    (CL:VALUES STELLA::NULL-STRING NULL-INTEGER NULL-INTEGER)
    (CL:VALUES NAME THESTART THEEND))))

;;; (DEFUN (STRING-MATCH-COMPUTATION-HELPER INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-MATCH-COMPUTATION-HELPER| (PATTERN X START END IGNORE-CASE?)
  (CL:WHEN (CL:NOT (STRING? PATTERN))
   (CL:RETURN-FROM |/PL-KERNEL-KB/STRING-MATCH-COMPUTATION-HELPER|
    NULL))
  (CL:LET*
   ((THEPATTERN (%WRAPPER-VALUE PATTERN)) (MATCHPOSITION NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING THEPATTERN)
    (CL:TYPE CL:FIXNUM MATCHPOSITION))
   (CL:LET*
    ((NAME STELLA::NULL-STRING) (THESTART NULL-INTEGER)
     (THEEND NULL-INTEGER))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
     (CL:TYPE CL:FIXNUM THESTART THEEND))
    (CL:MULTIPLE-VALUE-SETQ (NAME THESTART THEEND)
     (|/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS| X START END
      CL:NIL))
    (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
     (CL:RETURN-FROM |/PL-KERNEL-KB/STRING-MATCH-COMPUTATION-HELPER|
      NULL))
    (CL:IF IGNORE-CASE?
     (CL:SETQ MATCHPOSITION
      (STRING-SEARCH-IGNORE-CASE NAME THEPATTERN THESTART))
     (CL:SETQ MATCHPOSITION (STRING-SEARCH NAME THEPATTERN THESTART)))
    (CL:IF
     (CL:AND (CL:NOT (CL:= MATCHPOSITION NULL-INTEGER))
      (CL:<=
       (CL:+ MATCHPOSITION (CL:THE CL:FIXNUM (CL:LENGTH THEPATTERN)))
       THEEND))
     (WRAP-INTEGER MATCHPOSITION) NULL))))

;;; (DEFUN (STRING-MATCH-COMPUTATION INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-MATCH-COMPUTATION| (PATTERN X START END)
  (|/PL-KERNEL-KB/STRING-MATCH-COMPUTATION-HELPER| PATTERN X START END
   CL:NIL))

;;; (DEFUN (STRING-MATCH-IGNORE-CASE-COMPUTATION INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-MATCH-IGNORE-CASE-COMPUTATION| (PATTERN X START END)
  (|/PL-KERNEL-KB/STRING-MATCH-COMPUTATION-HELPER| PATTERN X START END
   CL:T))

;;; (DEFUN (STRING-UPCASE-COMPUTATION STRING-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-UPCASE-COMPUTATION| (X START END)
  (CL:LET*
   ((NAME STELLA::NULL-STRING) (THESTART NULL-INTEGER)
    (THEEND NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
    (CL:TYPE CL:FIXNUM THESTART THEEND))
   (CL:MULTIPLE-VALUE-SETQ (NAME THESTART THEEND)
    (|/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS| X START END
     CL:NIL))
   (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
    (CL:RETURN-FROM |/PL-KERNEL-KB/STRING-UPCASE-COMPUTATION| NULL))
   (CL:IF
    (CL:AND (CL:= THESTART 0)
     (CL:= THEEND (CL:THE CL:FIXNUM (CL:LENGTH NAME))))
    (WRAP-STRING (STRING-UPCASE NAME))
    (WRAP-STRING
     (CONCATENATE (SUBSEQUENCE NAME 0 THESTART)
      (STRING-UPCASE (SUBSEQUENCE NAME THESTART THEEND))
      (SUBSEQUENCE NAME THEEND NULL-INTEGER))))))

;;; (DEFUN (STRING-DOWNCASE-COMPUTATION STRING-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-DOWNCASE-COMPUTATION| (X START END)
  (CL:LET*
   ((NAME STELLA::NULL-STRING) (THESTART NULL-INTEGER)
    (THEEND NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
    (CL:TYPE CL:FIXNUM THESTART THEEND))
   (CL:MULTIPLE-VALUE-SETQ (NAME THESTART THEEND)
    (|/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS| X START END
     CL:NIL))
   (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
    (CL:RETURN-FROM |/PL-KERNEL-KB/STRING-DOWNCASE-COMPUTATION| NULL))
   (CL:IF
    (CL:AND (CL:= THESTART 0)
     (CL:= THEEND (CL:THE CL:FIXNUM (CL:LENGTH NAME))))
    (WRAP-STRING (STRING-DOWNCASE NAME))
    (WRAP-STRING
     (CONCATENATE (SUBSEQUENCE NAME 0 THESTART)
      (STRING-DOWNCASE (SUBSEQUENCE NAME THESTART THEEND))
      (SUBSEQUENCE NAME THEEND NULL-INTEGER))))))

;;; (DEFUN (STRING-CAPITALIZE-COMPUTATION STRING-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-CAPITALIZE-COMPUTATION| (X START END)
  (CL:LET*
   ((NAME STELLA::NULL-STRING) (THESTART NULL-INTEGER)
    (THEEND NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
    (CL:TYPE CL:FIXNUM THESTART THEEND))
   (CL:MULTIPLE-VALUE-SETQ (NAME THESTART THEEND)
    (|/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS| X START END
     CL:NIL))
   (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
    (CL:RETURN-FROM |/PL-KERNEL-KB/STRING-CAPITALIZE-COMPUTATION|
     NULL))
   (CL:IF
    (CL:AND (CL:= THESTART 0)
     (CL:= THEEND (CL:THE CL:FIXNUM (CL:LENGTH NAME))))
    (WRAP-STRING (STRING-CAPITALIZE NAME))
    (WRAP-STRING
     (CONCATENATE (SUBSEQUENCE NAME 0 THESTART)
      (STRING-CAPITALIZE (SUBSEQUENCE NAME THESTART THEEND))
      (SUBSEQUENCE NAME THEEND NULL-INTEGER))))))

;;; (DEFUN (STRING-REPLACE-COMPUTATION STRING-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-REPLACE-COMPUTATION| (X FROM TO START END)
  (CL:LET*
   ((NAME STELLA::NULL-STRING) (THESTART NULL-INTEGER)
    (THEEND NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
    (CL:TYPE CL:FIXNUM THESTART THEEND))
   (CL:MULTIPLE-VALUE-SETQ (NAME THESTART THEEND)
    (|/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS| X START END
     CL:NIL))
   (CL:WHEN
    (CL:OR (CL:EQ NAME STELLA::NULL-STRING) (CL:NOT (STRING? FROM))
     (CL:NOT (STRING? TO)))
    (CL:RETURN-FROM |/PL-KERNEL-KB/STRING-REPLACE-COMPUTATION| NULL))
   (CL:IF
    (CL:AND (CL:= THESTART 0)
     (CL:= THEEND (CL:THE CL:FIXNUM (CL:LENGTH NAME))))
    (WRAP-STRING
     (REPLACE-SUBSTRINGS NAME (%WRAPPER-VALUE TO)
      (%WRAPPER-VALUE FROM)))
    (WRAP-STRING
     (CONCATENATE (SUBSEQUENCE NAME 0 THESTART)
      (REPLACE-SUBSTRINGS (SUBSEQUENCE NAME THESTART THEEND)
       (%WRAPPER-VALUE TO) (%WRAPPER-VALUE FROM))
      (SUBSEQUENCE NAME THEEND NULL-INTEGER))))))

;;; (DEFUN (STRING-COMPARE-COMPUTATION-HELPER INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-COMPARE-COMPUTATION-HELPER| (O1 O2 START1 END1 START2 END2 IGNORECASE?)
  (CL:LET*
   ((NAME1 STELLA::NULL-STRING) (THESTART1 NULL-INTEGER)
    (THEEND1 NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME1)
    (CL:TYPE CL:FIXNUM THESTART1 THEEND1))
   (CL:MULTIPLE-VALUE-SETQ (NAME1 THESTART1 THEEND1)
    (|/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS| O1 START1 END1
     CL:NIL))
   (CL:WHEN (CL:EQ NAME1 STELLA::NULL-STRING)
    (CL:RETURN-FROM |/PL-KERNEL-KB/STRING-COMPARE-COMPUTATION-HELPER|
     NULL))
   (CL:LET*
    ((NAME2 STELLA::NULL-STRING) (THESTART2 NULL-INTEGER)
     (THEEND2 NULL-INTEGER))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME2)
     (CL:TYPE CL:FIXNUM THESTART2 THEEND2))
    (CL:MULTIPLE-VALUE-SETQ (NAME2 THESTART2 THEEND2)
     (|/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS| O2 START2 END2
      CL:NIL))
    (CL:WHEN (CL:EQ NAME2 STELLA::NULL-STRING)
     (CL:RETURN-FROM |/PL-KERNEL-KB/STRING-COMPARE-COMPUTATION-HELPER|
      NULL))
    (CL:WHEN
     (CL:OR (CL:> THESTART1 0)
      (CL:< THEEND1 (CL:THE CL:FIXNUM (CL:LENGTH NAME1))))
     (CL:SETQ NAME1 (SUBSEQUENCE NAME1 THESTART1 THEEND1)))
    (CL:WHEN
     (CL:OR (CL:> THESTART2 0)
      (CL:< THEEND2 (CL:THE CL:FIXNUM (CL:LENGTH NAME2))))
     (CL:SETQ NAME2 (SUBSEQUENCE NAME2 THESTART2 THEEND2)))
    (WRAP-INTEGER (STRING-COMPARE NAME1 NAME2 (CL:NOT IGNORECASE?))))))

;;; (DEFUN (STRING-COMPARE-COMPUTATION INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-COMPARE-COMPUTATION| (O1 O2 START1 END1 START2 END2)
  (|/PL-KERNEL-KB/STRING-COMPARE-COMPUTATION-HELPER| O1 O2 START1 END1
   START2 END2 CL:NIL))

;;; (DEFUN (STRING-COMPARE-IGNORE-CASE-COMPUTATION INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-COMPARE-IGNORE-CASE-COMPUTATION| (O1 O2 START1 END1 START2 END2)
  (|/PL-KERNEL-KB/STRING-COMPARE-COMPUTATION-HELPER| O1 O2 START1 END1
   START2 END2 CL:T))

;;; (DEFUN (STRING-TO-NUMBER-COMPUTATION NUMBER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/STRING-TO-NUMBER-COMPUTATION| (X START END)
  (CL:LET*
   ((NAME STELLA::NULL-STRING) (THESTART NULL-INTEGER)
    (THEEND NULL-INTEGER))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME)
    (CL:TYPE CL:FIXNUM THESTART THEEND))
   (CL:MULTIPLE-VALUE-SETQ (NAME THESTART THEEND)
    (|/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS| X START END
     CL:NIL))
   (CL:WHEN (CL:EQ NAME STELLA::NULL-STRING)
    (CL:RETURN-FROM |/PL-KERNEL-KB/STRING-TO-NUMBER-COMPUTATION| NULL))
   (CL:WHEN
    (CL:OR (CL:> THESTART 0)
     (CL:< THEEND (CL:THE CL:FIXNUM (CL:LENGTH NAME))))
    (CL:SETQ NAME (SUBSEQUENCE NAME THESTART THEEND)))
   (CL:HANDLER-CASE
    (CL:RETURN-FROM |/PL-KERNEL-KB/STRING-TO-NUMBER-COMPUTATION|
     (WRAP-INTEGER-VALUE (STRING-TO-INTEGER NAME)))
    (CL:CONDITION ()))
   (CL:HANDLER-CASE
    (CL:RETURN-FROM |/PL-KERNEL-KB/STRING-TO-NUMBER-COMPUTATION|
     (WRAP-FLOAT (STRING-TO-FLOAT NAME)))
    (CL:CONDITION ()))
   NULL))

;;; (DEFUN (LENGTH-COMPUTATION INTEGER-WRAPPER) ...)

(CL:DEFUN |/PL-KERNEL-KB/LENGTH-COMPUTATION| (X)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM |/PL-KERNEL-KB/LENGTH-COMPUTATION|
       (WRAP-INTEGER
        (CL:THE CL:FIXNUM
         (CL:LENGTH (CL:THE CL:SIMPLE-STRING (%WRAPPER-VALUE X))))))))
    ((SUBTYPE-OF? TEST-VALUE-000
      |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-SKOLEM|)
     (CL:PROGN
      (CL:COND
       ((CL:OR (ENUMERATED-LIST? X) (ENUMERATED-SET? X))
        (CL:RETURN-FROM |/PL-KERNEL-KB/LENGTH-COMPUTATION|
         (WRAP-INTEGER
          (CL:1- (LENGTH (%ARGUMENTS (%DEFINING-PROPOSITION X)))))))
       ((LOGICAL-COLLECTION? X)
        (CL:LET* ((LISTVALUE (ASSERTED-COLLECTION-MEMBERS X CL:T)))
         (CL:WHEN (CL:NOT (CL:EQ LISTVALUE NULL))
          (CL:RETURN-FROM |/PL-KERNEL-KB/LENGTH-COMPUTATION|
           (WRAP-INTEGER (LENGTH LISTVALUE)))))))))
    (CL:T)))
  NULL)

(CL:DEFUN |/PL-KERNEL-KB/HELP-STARTUP-ARITHMETIC1| ()
  (CL:PROGN
   (CL:SETQ
    |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTEGER-INTERVAL|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-INTERVAL" NULL 1))
   (CL:SETQ
    |/PL-KERNEL-KB/SYM-ARITHMETIC-PL-KERNEL-KB-INTERVAL-LOWER-BOUND|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL-LOWER-BOUND" NULL 0))
   (CL:SETQ
    |/PL-KERNEL-KB/SYM-ARITHMETIC-PL-KERNEL-KB-INTERVAL-UPPER-BOUND|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL-UPPER-BOUND" NULL 0))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTERVAL-CACHE|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL-CACHE" NULL 1))
   (CL:SETQ |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-HOME-CONTEXT|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOME-CONTEXT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ |/PL-KERNEL-KB/SYM-ARITHMETIC-LOGIC-INTERVAL-MEMBER|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL-MEMBER"
     (GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-LOWER-BOUND|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOWER-BOUND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-UPPER-BOUND|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPPER-BOUND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ |/PL-KERNEL-KB/SYM-ARITHMETIC-LOGIC-STRICT-LOWER-BOUND?|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRICT-LOWER-BOUND?"
     (GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ |/PL-KERNEL-KB/SYM-ARITHMETIC-LOGIC-STRICT-UPPER-BOUND?|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRICT-UPPER-BOUND?"
     (GET-STELLA-MODULE "/LOGIC" CL:T) 0))
   (CL:SETQ
    |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INTERVAL-CACHE-OF|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL-CACHE-OF" NULL 1))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-INEQUALITY|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INEQUALITY" NULL 1))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-LOGIC-OBJECT|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT"
     (GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-SKOLEM|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM"
     (GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-INTEGER|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->|
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">" NULL 1))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-NUMBER-WRAPPER|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-LOGIC-QUANTITY-LOGIC-WRAPPER|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUANTITY-LOGIC-WRAPPER"
     (GET-STELLA-MODULE "/LOGIC" CL:T) 1))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB->=|
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">=" NULL 1))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-<|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<" NULL 1))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=<|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=<" NULL 1))
   (CL:SETQ |/PL-KERNEL-KB/KWD-ARITHMETIC-LOWER-BOUND|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOWER-BOUND" NULL 2))
   (CL:SETQ |/PL-KERNEL-KB/KWD-ARITHMETIC-UPPER-BOUND|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UPPER-BOUND" NULL 2))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-PL-KERNEL-KB-=|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=" NULL 1))
   (CL:SETQ |/PL-KERNEL-KB/KWD-ARITHMETIC-TERMINAL-FAILURE|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TERMINAL-FAILURE" NULL 2))
   (CL:SETQ |/PL-KERNEL-KB/SGT-ARITHMETIC-STELLA-INTEGER-WRAPPER|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ |/PL-KERNEL-KB/KWD-ARITHMETIC-FINAL-SUCCESS|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINAL-SUCCESS" NULL 2))
   (CL:SETQ |/PL-KERNEL-KB/KWD-ARITHMETIC-FAILURE|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ |/PL-KERNEL-KB/KWD-ARITHMETIC-ORIGINAL|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ORIGINAL" NULL 2))
   (CL:SETQ |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-ITERATOR|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ITERATOR"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ |/PL-KERNEL-KB/KWD-ARITHMETIC-CONTINUING-SUCCESS|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONTINUING-SUCCESS" NULL 2))
   (CL:SETQ
    |/PL-KERNEL-KB/SYM-ARITHMETIC-PL-KERNEL-KB-STARTUP-ARITHMETIC|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-ARITHMETIC" NULL 0))
   (CL:SETQ
    |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-METHOD-STARTUP-CLASSNAME|
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN |/PL-KERNEL-KB/HELP-STARTUP-ARITHMETIC2| ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "ARITHMETIC-EQUAL-TEST"
    "(DEFUN (ARITHMETIC-EQUAL-TEST BOOLEAN) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/ARITHMETIC-EQUAL-TEST|) NULL)
   (DEFINE-FUNCTION-OBJECT "ARITHMETIC-LESS-TEST"
    "(DEFUN (ARITHMETIC-LESS-TEST BOOLEAN) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/ARITHMETIC-LESS-TEST|) NULL)
   (DEFINE-FUNCTION-OBJECT "ARITHMETIC-GREATER-TEST"
    "(DEFUN (ARITHMETIC-GREATER-TEST BOOLEAN) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/ARITHMETIC-GREATER-TEST|) NULL)
   (DEFINE-FUNCTION-OBJECT "PLUS-COMPUTATION"
    "(DEFUN (PLUS-COMPUTATION NUMBER-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/PLUS-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "MINUS-COMPUTATION"
    "(DEFUN (MINUS-COMPUTATION NUMBER-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/MINUS-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "TIMES-COMPUTATION"
    "(DEFUN (TIMES-COMPUTATION NUMBER-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/TIMES-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "DIVIDE-COMPUTATION"
    "(DEFUN (DIVIDE-COMPUTATION NUMBER-WRAPPER) ((X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/DIVIDE-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "SQRT-COMPUTATION"
    "(DEFUN (SQRT-COMPUTATION NUMBER-WRAPPER) ((X NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/SQRT-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "NEGATE-COMPUTATION"
    "(DEFUN (NEGATE-COMPUTATION NUMBER-WRAPPER) ((X NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/NEGATE-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "ABS-COMPUTATION"
    "(DEFUN (ABS-COMPUTATION NUMBER-WRAPPER) ((X NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/ABS-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "FLOOR-COMPUTATION"
    "(DEFUN (FLOOR-COMPUTATION INTEGER-WRAPPER) ((X NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/FLOOR-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "CEILING-COMPUTATION"
    "(DEFUN (CEILING-COMPUTATION INTEGER-WRAPPER) ((X NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/CEILING-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "PLUS-CONSTRAINT"
    "(DEFUN (PLUS-CONSTRAINT OBJECT) ((MISSING-ARGUMENT INTEGER-WRAPPER) (X1 NUMBER-WRAPPER) (X2 NUMBER-WRAPPER) (X3 NUMBER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PLUS-CONSTRAINT|) NULL)
   (DEFINE-FUNCTION-OBJECT "MINUS-CONSTRAINT"
    "(DEFUN (MINUS-CONSTRAINT OBJECT) ((MISSING-ARGUMENT INTEGER-WRAPPER) (X1 NUMBER-WRAPPER) (X2 NUMBER-WRAPPER) (X3 NUMBER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/MINUS-CONSTRAINT|) NULL)
   (DEFINE-FUNCTION-OBJECT "TIMES-CONSTRAINT"
    "(DEFUN (TIMES-CONSTRAINT OBJECT) ((MISSING-ARGUMENT INTEGER-WRAPPER) (X1 NUMBER-WRAPPER) (X2 NUMBER-WRAPPER) (X3 NUMBER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/TIMES-CONSTRAINT|) NULL)
   (DEFINE-FUNCTION-OBJECT "DIVIDE-CONSTRAINT"
    "(DEFUN (DIVIDE-CONSTRAINT OBJECT) ((MISSING-ARGUMENT INTEGER-WRAPPER) (X1 NUMBER-WRAPPER) (X2 NUMBER-WRAPPER) (X3 NUMBER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/DIVIDE-CONSTRAINT|) NULL)
   (DEFINE-FUNCTION-OBJECT "NEGATE-CONSTRAINT"
    "(DEFUN (NEGATE-CONSTRAINT OBJECT) ((MISSING-ARGUMENT INTEGER-WRAPPER) (X1 NUMBER-WRAPPER) (X2 NUMBER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/NEGATE-CONSTRAINT|) NULL)
   (DEFINE-FUNCTION-OBJECT "SQRT-CONSTRAINT"
    "(DEFUN (SQRT-CONSTRAINT OBJECT) ((MISSING-ARGUMENT INTEGER-WRAPPER) (X1 NUMBER-WRAPPER) (X2 NUMBER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SQRT-CONSTRAINT|) NULL)
   (DEFINE-FUNCTION-OBJECT "LOG-COMPUTATION"
    "(DEFUN (LOG-COMPUTATION FLOAT-WRAPPER) ((X NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/LOG-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "LOG10-COMPUTATION"
    "(DEFUN (LOG10-COMPUTATION FLOAT-WRAPPER) ((X NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/LOG10-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "EXP-COMPUTATION"
    "(DEFUN (EXP-COMPUTATION FLOAT-WRAPPER) ((X NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/EXP-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPT-COMPUTATION"
    "(DEFUN (EXPT-COMPUTATION FLOAT-WRAPPER) ((X NUMBER-WRAPPER) (N NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/EXPT-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "LOG-CONSTRAINT"
    "(DEFUN (LOG-CONSTRAINT OBJECT) ((MISSING-ARGUMENT INTEGER-WRAPPER) (X NUMBER-WRAPPER) (LOG NUMBER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/LOG-CONSTRAINT|) NULL)
   (DEFINE-FUNCTION-OBJECT "LOG10-CONSTRAINT"
    "(DEFUN (LOG10-CONSTRAINT OBJECT) ((MISSING-ARGUMENT INTEGER-WRAPPER) (X NUMBER-WRAPPER) (LOG NUMBER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/LOG10-CONSTRAINT|) NULL)
   (DEFINE-FUNCTION-OBJECT "EXP-CONSTRAINT"
    "(DEFUN (EXP-CONSTRAINT OBJECT) ((MISSING-ARGUMENT INTEGER-WRAPPER) (X NUMBER-WRAPPER) (Y NUMBER-WRAPPER)))"
    (CL:FUNCTION |/PL-KERNEL-KB/EXP-CONSTRAINT|) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-INTERVAL"
    "(DEFUN PRINT-INTERVAL ((STREAM NATIVE-OUTPUT-STREAM) (LOWER OBJECT) (STRICT-LOWER? BOOLEAN) (UPPER OBJECT) (STRICT-UPPER? BOOLEAN)))"
    (CL:FUNCTION |/PL-KERNEL-KB/PRINT-INTERVAL|) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-INTERVAL-CACHE"
    "(DEFUN (CREATE-INTERVAL-CACHE INTERVAL-CACHE) ((INTERVALMEMBER LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/CREATE-INTERVAL-CACHE|) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-INTERVAL-CACHE"
    "(DEFUN (GET-INTERVAL-CACHE INTERVAL-CACHE) ((SELF LOGIC-OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/GET-INTERVAL-CACHE|) NULL)
   (DEFINE-FUNCTION-OBJECT "SIGNAL-INTERVAL-CLASH"
    "(DEFUN SIGNAL-INTERVAL-CLASH ((INTERVAL INTERVAL-CACHE)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SIGNAL-INTERVAL-CLASH|) NULL)
   (DEFINE-FUNCTION-OBJECT "EVALUATE-ADJACENT-INEQUALITIES"
    "(DEFUN EVALUATE-ADJACENT-INEQUALITIES ((SELF LOGIC-OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/EVALUATE-ADJACENT-INEQUALITIES|) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (INTEGER-VALUED-MEMBER? BOOLEAN) ((INTERVAL INTERVAL-CACHE)))"
    (CL:FUNCTION |/PL-KERNEL-KB/INTEGER-VALUED-MEMBER?|) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (INTEGER-LOWER-BOUND INTEGER-WRAPPER) ((INTERVAL INTERVAL-CACHE)))"
    (CL:FUNCTION |/PL-KERNEL-KB/INTEGER-LOWER-BOUND|) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (INTEGER-UPPER-BOUND INTEGER-WRAPPER) ((INTERVAL INTERVAL-CACHE)))"
    (CL:FUNCTION |/PL-KERNEL-KB/INTEGER-UPPER-BOUND|) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD EVALUATE-TIGHTER-INTEGER-INTERVAL ((INTERVAL INTERVAL-CACHE)))"
    (CL:FUNCTION |/PL-KERNEL-KB/EVALUATE-TIGHTER-INTEGER-INTERVAL|)
    NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD EVALUATE-TIGHTER-INTERVAL ((INTERVAL INTERVAL-CACHE)))"
    (CL:FUNCTION |/PL-KERNEL-KB/EVALUATE-TIGHTER-INTERVAL|) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE ((SELF INTERVAL-CACHE) (VALUE OBJECT) (OPERATOR SURROGATE)))"
    (CL:FUNCTION
     |/PL-KERNEL-KB/PROPAGATE-INEQUALITY-TO-INTERVAL-CACHE|)
    NULL)
   (DEFINE-FUNCTION-OBJECT "INVERSE-INEQUALITY-OPERATOR"
    "(DEFUN (INVERSE-INEQUALITY-OPERATOR SURROGATE) ((OPERATOR SURROGATE)))"
    (CL:FUNCTION |/PL-KERNEL-KB/INVERSE-INEQUALITY-OPERATOR|) NULL)
   (DEFINE-FUNCTION-OBJECT "UNIFY-INTERVAL-CACHES"
    "(DEFUN UNIFY-INTERVAL-CACHES ((CACHE1 INTERVAL-CACHE) (CACHE2 INTERVAL-CACHE) (OPERATOR SURROGATE)))"
    (CL:FUNCTION |/PL-KERNEL-KB/UNIFY-INTERVAL-CACHES|) NULL)
   (DEFINE-FUNCTION-OBJECT "ACCESS-INTERVAL-BOUNDS"
    "(DEFUN (ACCESS-INTERVAL-BOUNDS OBJECT BOOLEAN) ((X OBJECT) (LOWERORUPPER KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/ACCESS-INTERVAL-BOUNDS|) NULL)
   (DEFINE-FUNCTION-OBJECT "ACCESS-INTERVAL-CACHE-BOUNDS"
    "(DEFUN (ACCESS-INTERVAL-CACHE-BOUNDS OBJECT BOOLEAN) ((INTERVALCACHE INTERVAL-CACHE) (LOWERORUPPER KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/ACCESS-INTERVAL-CACHE-BOUNDS|) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPARE-INTERVAL-BOUNDS?"
    "(DEFUN (COMPARE-INTERVAL-BOUNDS? BOOLEAN) ((RELATION SURROGATE) (X OBJECT) (Y OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/COMPARE-INTERVAL-BOUNDS?|) NULL)
   (DEFINE-FUNCTION-OBJECT "NULL-NUMBER?"
    "(DEFUN (NULL-NUMBER? BOOLEAN) ((SELF NUMBER-WRAPPER)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/NULL-NUMBER?|) NULL)
   (DEFINE-FUNCTION-OBJECT "NULL-LITERAL-WRAPPER?"
    "(DEFUN (NULL-LITERAL-WRAPPER? BOOLEAN) ((SELF OBJECT)) :PUBLIC? TRUE)"
    (CL:FUNCTION |/PL-KERNEL-KB/NULL-LITERAL-WRAPPER?|) NULL)
   (DEFINE-FUNCTION-OBJECT "SATISFIES-INTERVAL-BOUNDS?"
    "(DEFUN (SATISFIES-INTERVAL-BOUNDS? BOOLEAN) ((OBJECT OBJECT) (VALUE OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SATISFIES-INTERVAL-BOUNDS?|) NULL)
   (DEFINE-FUNCTION-OBJECT "LESS-SPECIALIST-HELPER"
    "(DEFUN (LESS-SPECIALIST-HELPER KEYWORD) ((FRAME CONTROL-FRAME) (RELATION SURROGATE) (XARG OBJECT) (YARG OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/LESS-SPECIALIST-HELPER|) NULL)
   (DEFINE-FUNCTION-OBJECT "INEQUALITY-SPECIALIST"
    "(DEFUN (INEQUALITY-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/INEQUALITY-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "INEQUALITY-EVALUATOR"
    "(DEFUN INEQUALITY-EVALUATOR ((SELF PROPOSITION)))"
    (CL:FUNCTION |/PL-KERNEL-KB/INEQUALITY-EVALUATOR|) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-CONCATENATE-COMPUTATION"
    "(DEFUN (STRING-CONCATENATE-COMPUTATION STRING-WRAPPER) ((X OBJECT) (YARGS CONS)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STRING-CONCATENATE-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "SUBSEQUENCE-SPECIALIST"
    "(DEFUN (SUBSEQUENCE-SPECIALIST KEYWORD) ((FRAME CONTROL-FRAME) (LASTMOVE KEYWORD)))"
    (CL:FUNCTION |/PL-KERNEL-KB/SUBSEQUENCE-SPECIALIST|) NULL)
   (DEFINE-FUNCTION-OBJECT "NORMALIZE-STRING-COMPUTATION-ARGS"
    "(DEFUN (NORMALIZE-STRING-COMPUTATION-ARGS STRING INTEGER INTEGER) ((X OBJECT) (START OBJECT) (END OBJECT) (COERCE? BOOLEAN)))"
    (CL:FUNCTION |/PL-KERNEL-KB/NORMALIZE-STRING-COMPUTATION-ARGS|)
    NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-MATCH-COMPUTATION-HELPER"
    "(DEFUN (STRING-MATCH-COMPUTATION-HELPER INTEGER-WRAPPER) ((PATTERN OBJECT) (X OBJECT) (START OBJECT) (END OBJECT) (IGNORE-CASE? BOOLEAN)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STRING-MATCH-COMPUTATION-HELPER|) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-MATCH-COMPUTATION"
    "(DEFUN (STRING-MATCH-COMPUTATION INTEGER-WRAPPER) ((PATTERN OBJECT) (X OBJECT) (START OBJECT) (END OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STRING-MATCH-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-MATCH-IGNORE-CASE-COMPUTATION"
    "(DEFUN (STRING-MATCH-IGNORE-CASE-COMPUTATION INTEGER-WRAPPER) ((PATTERN OBJECT) (X OBJECT) (START OBJECT) (END OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STRING-MATCH-IGNORE-CASE-COMPUTATION|)
    NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-UPCASE-COMPUTATION"
    "(DEFUN (STRING-UPCASE-COMPUTATION STRING-WRAPPER) ((X OBJECT) (START OBJECT) (END OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STRING-UPCASE-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-DOWNCASE-COMPUTATION"
    "(DEFUN (STRING-DOWNCASE-COMPUTATION STRING-WRAPPER) ((X OBJECT) (START OBJECT) (END OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STRING-DOWNCASE-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-CAPITALIZE-COMPUTATION"
    "(DEFUN (STRING-CAPITALIZE-COMPUTATION STRING-WRAPPER) ((X OBJECT) (START OBJECT) (END OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STRING-CAPITALIZE-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-REPLACE-COMPUTATION"
    "(DEFUN (STRING-REPLACE-COMPUTATION STRING-WRAPPER) ((X OBJECT) (FROM OBJECT) (TO OBJECT) (START OBJECT) (END OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STRING-REPLACE-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-COMPARE-COMPUTATION-HELPER"
    "(DEFUN (STRING-COMPARE-COMPUTATION-HELPER INTEGER-WRAPPER) ((O1 OBJECT) (O2 OBJECT) (START1 OBJECT) (END1 OBJECT) (START2 OBJECT) (END2 OBJECT) (IGNORECASE? BOOLEAN)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STRING-COMPARE-COMPUTATION-HELPER|)
    NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-COMPARE-COMPUTATION"
    "(DEFUN (STRING-COMPARE-COMPUTATION INTEGER-WRAPPER) ((O1 OBJECT) (O2 OBJECT) (START1 OBJECT) (END1 OBJECT) (START2 OBJECT) (END2 OBJECT)))"
    (CL:FUNCTION |/PL-KERNEL-KB/STRING-COMPARE-COMPUTATION|) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-COMPARE-IGNORE-CASE-COMPUTATION"
    "(DEFUN (STRING-COMPARE-IGNORE-CASE-COMPUTATION INTEGER-WRAPPER) ((O1 OBJECT) (O2 OBJECT) (START1 OBJECT) (END1 OBJECT) (START2 OBJECT) (END2 OBJECT)))"
    (CL:FUNCTION
     |/PL-KERNEL-KB/STRING-COMPARE-IGNORE-CASE-COMPUTATION|)
    NULL)))

(CL:DEFUN |/PL-KERNEL-KB/STARTUP-ARITHMETIC| ()
  (CL:LET*
   ((*MODULE*
     (GET-STELLA-MODULE "/PL-KERNEL-KB" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (|/PL-KERNEL-KB/HELP-STARTUP-ARITHMETIC1|))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INTEGER-INTERVAL"
        "(DEFCLASS INTEGER-INTERVAL (THING) :DOCUMENTATION \"An interval of integers\" :SLOTS ((INTERVAL-LOWER-BOUND :TYPE INTEGER) (INTERVAL-UPPER-BOUND :TYPE INTEGER)))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION |/PL-KERNEL-KB/NEW-INTEGER-INTERVAL|))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION
       |/PL-KERNEL-KB/ACCESS-INTEGER-INTERVAL-SLOT-VALUE|)))
    (CL:LET*
     ((CLASS
       (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "INTERVAL-CACHE"
        "(DEFCLASS INTERVAL-CACHE (THING) :PUBLIC? TRUE :PUBLIC-SLOTS ((HOME-CONTEXT :TYPE CONTEXT) (INTERVAL-MEMBER :TYPE LOGIC-OBJECT) (LOWER-BOUND :TYPE OBJECT) (UPPER-BOUND :TYPE OBJECT) (STRICT-LOWER-BOUND? :TYPE BOOLEAN) (STRICT-UPPER-BOUND? :TYPE BOOLEAN)) :PRINT-FORM (PROGN (PRINT-STREAM STREAM \"|cache-of: \" (INTERVAL-MEMBER SELF) \" \") (PRINT-INTERVAL STREAM (LOWER-BOUND SELF) (STRICT-LOWER-BOUND? SELF) (UPPER-BOUND SELF) (STRICT-UPPER-BOUND? SELF)) (PRINT-STREAM STREAM \"|\")))")))
     (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
      (CL:FUNCTION |/PL-KERNEL-KB/NEW-INTERVAL-CACHE|))
     (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
      (CL:FUNCTION |/PL-KERNEL-KB/ACCESS-INTERVAL-CACHE-SLOT-VALUE|))))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (|/PL-KERNEL-KB/HELP-STARTUP-ARITHMETIC2|)
    (DEFINE-FUNCTION-OBJECT "STRING-TO-NUMBER-COMPUTATION"
     "(DEFUN (STRING-TO-NUMBER-COMPUTATION NUMBER-WRAPPER) ((X OBJECT) (START OBJECT) (END OBJECT)))"
     (CL:FUNCTION |/PL-KERNEL-KB/STRING-TO-NUMBER-COMPUTATION|) NULL)
    (DEFINE-FUNCTION-OBJECT "LENGTH-COMPUTATION"
     "(DEFUN (LENGTH-COMPUTATION INTEGER-WRAPPER) ((X OBJECT)))"
     (CL:FUNCTION |/PL-KERNEL-KB/LENGTH-COMPUTATION|) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-ARITHMETIC"
     "(DEFUN STARTUP-ARITHMETIC () :PUBLIC? TRUE)"
     (CL:FUNCTION |/PL-KERNEL-KB/STARTUP-ARITHMETIC|) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION
        |/PL-KERNEL-KB/SYM-ARITHMETIC-PL-KERNEL-KB-STARTUP-ARITHMETIC|)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      |/PL-KERNEL-KB/SYM-ARITHMETIC-STELLA-METHOD-STARTUP-CLASSNAME|
      (WRAP-STRING "_StartupArithmetic") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "PL-KERNEL"))))))
