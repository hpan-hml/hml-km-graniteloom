;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; case-based.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2010      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-CASE-BASED-WEIGHTED-VOTE NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-SET-NUM-NEIGHBORS NULL)
(CL:DEFVAR KWD-CASE-BASED-COMMON-LISP NULL)
(CL:DEFVAR KWD-CASE-BASED-FUNCTION NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-SET-CASE-SOLUTION-COMBINATION NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-SET-NUM-TRAINING-PER-CASE NULL)
(CL:DEFVAR KWD-CASE-BASED-RETRACT-TRUE NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-FINALIZE-CASES NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-DEFRULE NULL)
(CL:DEFVAR SYM-CASE-BASED-STELLA-FORALL NULL)
(CL:DEFVAR SYM-CASE-BASED-STELLA-=> NULL)
(CL:DEFVAR SYM-CASE-BASED-STELLA-AND NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-CASE-MATCH NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-?X NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-?Y NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-ADD-CASE NULL)
(CL:DEFVAR SYM-CASE-BASED-PL-KERNEL-KB-CASE-MATCH NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-GUESS NULL)
(CL:DEFVAR KWD-CASE-BASED-WEIGHTED-AVERAGE NULL)
(CL:DEFVAR SGT-CASE-BASED-STELLA-FLOAT-WRAPPER NULL)
(CL:DEFVAR SGT-CASE-BASED-STELLA-INTEGER-WRAPPER NULL)
(CL:DEFVAR KWD-CASE-BASED-AVERAGE NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-TRAIN-CASE-MATCHER NULL)
(CL:DEFVAR KWD-CASE-BASED-ASSERT-TRUE NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-OBJECT-NAME NULL)
(CL:DEFVAR SYM-CASE-BASED-STELLA-SECOND NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-CASES NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-TRAIN-AND-TEST-CASE-MATCHER NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-TEST-CASE-BASED-REASONER NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-TEST-CASE-MATCHER NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-CLEAR-SLOT-FROM-CLASS NULL)
(CL:DEFVAR SGT-CASE-BASED-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-CASE-BASED-LOGIC-PATTERN-VARIABLE NULL)
(CL:DEFVAR SGT-CASE-BASED-LOGIC-SKOLEM NULL)
(CL:DEFVAR SGT-CASE-BASED-LOGIC-LOGIC-OBJECT NULL)
(CL:DEFVAR SGT-CASE-BASED-STELLA-CONS NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-SOFT-EQ NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-SET-PRINT-CASE-DISTANCES NULL)
(CL:DEFVAR SYM-CASE-BASED-LOGIC-STARTUP-CASE-BASED NULL)
(CL:DEFVAR SYM-CASE-BASED-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* *TRAINING-EXAMPLES* NULL-FLOAT
  *SAVE-NETWORK-FILE* NULL-INTEGER STANDARD-OUTPUT EOL NIL))

;;; (DEFGLOBAL *LOG-MATCH-RULES* ...)

(CL:DEFVAR *LOG-MATCH-RULES* CL:NIL)

;;; (DEFGLOBAL *LOG-ANTECEDENT-CONSTRUCTION* ...)

(CL:DEFVAR *LOG-ANTECEDENT-CONSTRUCTION* CL:NIL)

;;; (DEFGLOBAL *NUM-NEIGHBORS* ...)

(CL:DEFVAR *NUM-NEIGHBORS* 3)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *NUM-NEIGHBORS*))

;;; (DEFGLOBAL *CASE-SOLUTION-COMBINATION* ...)

(CL:DEFVAR *CASE-SOLUTION-COMBINATION* NULL)

;;; (DEFGLOBAL *CASE-RULE-NAMES* ...)

(CL:DEFVAR *CASE-RULE-NAMES* NULL)

;;; (DEFGLOBAL *NUM-CASES* ...)

(CL:DEFVAR *NUM-CASES* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *NUM-CASES*))

;;; (DEFGLOBAL *NUM-TRAINING-PER-CASE* ...)

(CL:DEFVAR *NUM-TRAINING-PER-CASE* 12)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *NUM-TRAINING-PER-CASE*))

;;; (DEFGLOBAL *CASE-VARIABLE-COUNTER* ...)

(CL:DEFVAR *CASE-VARIABLE-COUNTER* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *CASE-VARIABLE-COUNTER*))

;;; (DEFGLOBAL *BASE-COUNTER* ...)

(CL:DEFVAR *BASE-COUNTER* 0)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *BASE-COUNTER*))

;;; (DEFGLOBAL *VISITED-INSTANCES* ...)

(CL:DEFVAR *VISITED-INSTANCES* NULL)

;;; (DEFGLOBAL *ONLY-VARIABLIZE-VISITED-INSTANCES* ...)

(CL:DEFVAR *ONLY-VARIABLIZE-VISITED-INSTANCES* CL:NIL)

;;; (DEFGLOBAL *VISITED-PROPOSITIONS* ...)

(CL:DEFVAR *VISITED-PROPOSITIONS* NULL)

;;; (DEFGLOBAL *SEEN-INSTANCES* ...)

(CL:DEFVAR *SEEN-INSTANCES* NULL)

;;; (DEFGLOBAL *DELETED-CASE-VARIABLES* ...)

(CL:DEFVAR *DELETED-CASE-VARIABLES* NULL)

;;; (DEFGLOBAL *SYMBOL-VARIABLE-HASH-TABLE* ...)

(CL:DEFVAR *SYMBOL-VARIABLE-HASH-TABLE* NULL)

;;; (DEFGLOBAL *CASE-ANTECEDENT-TABLE* ...)

(CL:DEFVAR *CASE-ANTECEDENT-TABLE* NULL)

;;; (DEFGLOBAL *CASE-TYPES-TABLE* ...)

(CL:DEFVAR *CASE-TYPES-TABLE* NULL)

;;; (DEFGLOBAL *CASE-NAME-TABLE* ...)

(CL:DEFVAR *CASE-NAME-TABLE* NULL)

;;; (DEFUN SET-NUM-NEIGHBORS ...)

(CL:DEFUN %SET-NUM-NEIGHBORS (D)
  "Sets the number of nearest neighbors to predict from."
  (CL:DECLARE (CL:TYPE CL:FIXNUM D))
  #+MCL
  (CL:CHECK-TYPE D CL:FIXNUM)
  (CL:SETQ *NUM-NEIGHBORS* D))

(CL:DEFUN SET-NUM-NEIGHBORS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-NUM-NEIGHBORS (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-NUM-NEIGHBORS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Sets the number of nearest neighbors to predict from."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-NUM-NEIGHBORS|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-NUM-NEIGHBORS)))

;;; (DEFUN SET-CASE-SOLUTION-COMBINATION ...)

(CL:DEFUN %SET-CASE-SOLUTION-COMBINATION (K)
  (CL:SETQ *CASE-SOLUTION-COMBINATION* K))

(CL:DEFMACRO SET-CASE-SOLUTION-COMBINATION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-CASE-SOLUTION-COMBINATION|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-CASE-SOLUTION-COMBINATION)))

;;; (DEFUN SET-NUM-TRAINING-PER-CASE ...)

(CL:DEFUN %SET-NUM-TRAINING-PER-CASE (D)
  "Sets the number of training examples for each case in the training set."
  (CL:DECLARE (CL:TYPE CL:FIXNUM D))
  #+MCL
  (CL:CHECK-TYPE D CL:FIXNUM)
  (CL:SETQ *NUM-TRAINING-PER-CASE* D))

(CL:DEFUN SET-NUM-TRAINING-PER-CASE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-NUM-TRAINING-PER-CASE
   (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-NUM-TRAINING-PER-CASE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Sets the number of training examples for each case in the training set."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-NUM-TRAINING-PER-CASE|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-NUM-TRAINING-PER-CASE)))

;;; (DEFUN CLEAR-CASES ...)

(CL:DEFUN CLEAR-CASES ()
  (CL:LET* ((NAME NULL) (ITER-000 (%LIST.THE-CONS-LIST *CASE-RULE-NAMES*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ NAME (%%VALUE ITER-000))
    (SMART-UPDATE-PROPOSITION NAME KWD-CASE-BASED-RETRACT-TRUE)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:SETQ *NUM-CASES* 0)
  (CL:SETQ *SEEN-INSTANCES* (NEW-LIST))
  (CL:SETQ *VISITED-PROPOSITIONS* (NEW-LIST))
  (CL:SETQ *VISITED-INSTANCES* (NEW-LIST))
  (CL:SETQ *CASE-RULE-NAMES* (NEW-LIST))
  (CL:SETQ *CASE-ANTECEDENT-TABLE* (NEW-STRING-HASH-TABLE))
  (CL:SETQ *CASE-TYPES-TABLE* (NEW-STRING-HASH-TABLE))
  (CL:SETQ *CASE-NAME-TABLE* (NEW-HASH-TABLE))
  (CL:SETQ *CASE-VARIABLE-COUNTER* 0))

;;; (DEFUN ADD-ALL-CLASS-INSTANCES-TO-CASE-RULE ...)

(CL:DEFUN ADD-ALL-CLASS-INSTANCES-TO-CASE-RULE (KIND)
  (CL:LET* ((INSTANCE NULL) (ITER-000 (ALL-CLASS-INSTANCES KIND)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ INSTANCE (%%VALUE ITER-000))
    (BUILD-CASE-FROM-INSTANCE INSTANCE KIND)
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (BUILD-CASE-RULE KIND))

;;; (DEFUN FINALIZE-CASES ...)

(CL:DEFUN %FINALIZE-CASES (KIND)
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE (GET-DESCRIPTION KIND))))
   (BUILD-CASE-RULE CLASS)))

(CL:DEFMACRO FINALIZE-CASES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/FINALIZE-CASES|)) (CL:MACRO-FUNCTION (CL:QUOTE FINALIZE-CASES)))

;;; (DEFUN BUILD-CASE-RULE ...)

(CL:DEFUN BUILD-CASE-RULE (KIND)
  (CL:LET*
   ((RULE-NAME (CONCATENATE (%SURROGATE.SYMBOL-NAME KIND) "-match"))
    (RULE-NAME-SYMBOL (INTERN-SYMBOL RULE-NAME))
    (RULE-ANTECEDENT (LOOKUP *CASE-ANTECEDENT-TABLE* RULE-NAME))
    (RULE-TYPES (LOOKUP *CASE-TYPES-TABLE* RULE-NAME)) (RULE NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RULE-NAME))
   (CL:SETQ RULE
    (LIST* SYM-CASE-BASED-LOGIC-DEFRULE (WRAP-STRING RULE-NAME)
     (CONS
      (LIST* SYM-CASE-BASED-STELLA-FORALL RULE-TYPES
       (CONS
        (LIST* SYM-CASE-BASED-STELLA-=>
         (CONS SYM-CASE-BASED-STELLA-AND
          (CONCATENATE (CONSIFY RULE-ANTECEDENT) NIL))
         (LIST* SYM-CASE-BASED-LOGIC-CASE-MATCH SYM-CASE-BASED-LOGIC-?X
          SYM-CASE-BASED-LOGIC-?Y NIL)
         NIL)
        NIL))
      NIL)))
   (CL:WHEN (CL:NOT (MEMBER? *CASE-RULE-NAMES* RULE-NAME-SYMBOL))
    (PUSH *CASE-RULE-NAMES* RULE-NAME-SYMBOL))
   (CL:WHEN *LOG-MATCH-RULES*
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) RULE EOL))
   (CL:WHEN (CL:NOT (EMPTY? RULE-ANTECEDENT))
    (EVALUATE-LOGIC-COMMAND RULE CL:NIL))))

;;; (DEFUN ADD-CASE ...)

(CL:DEFUN %ADD-CASE (INST KIND)
  (CL:SETQ INST (PERMANENTIFY INST))
  (CL:SETQ KIND (PERMANENTIFY KIND))
  (BUILD-CASE-FROM-INSTANCE (GET-INSTANCE INST)
   (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE (GET-DESCRIPTION KIND))))

(CL:DEFMACRO ADD-CASE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/ADD-CASE|)) (CL:MACRO-FUNCTION (CL:QUOTE ADD-CASE)))

;;; (DEFUN BUILD-CASE-FROM-INSTANCE ...)

(CL:DEFUN BUILD-CASE-FROM-INSTANCE (INST KIND)
  (CL:SETQ *SEEN-INSTANCES* (NEW-LIST))
  (CL:SETQ *DELETED-CASE-VARIABLES* (NEW-LIST))
  (CL:SETQ *NUM-CASES* (CL:1+ *NUM-CASES*))
  (CL:SETQ *BASE-COUNTER* *CASE-VARIABLE-COUNTER*)
  (CL:LET*
   ((NAME (OBJECT-NAME INST)) (ANTECEDENT (GET-ASSERTION-STRUCTURE NAME 1))
    (CLASS (%SURROGATE.SURROGATE-VALUE KIND))
    (CLASS-SYMBOL (OBJECT-NAME CLASS))
    (RULE-NAME (CONCATENATE (OBJECT-NAME-STRING CLASS) "-match"))
    (RULE-ANTECEDENT (LOOKUP *CASE-ANTECEDENT-TABLE* RULE-NAME))
    (RULE-TYPES (LOOKUP *CASE-TYPES-TABLE* RULE-NAME))
    (CASE-LIST (LOOKUP *CASE-NAME-TABLE* CLASS-SYMBOL)) (TYPE-DEFS NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RULE-NAME))
   (CL:IF (CL:EQ CASE-LIST NULL)
    (INSERT-AT *CASE-NAME-TABLE* CLASS-SYMBOL (LIST NAME))
    (CL:PROGN (PUSH CASE-LIST NAME)
     (INSERT-AT *CASE-NAME-TABLE* CLASS-SYMBOL CASE-LIST)))
   (CL:WHEN (CL:EQ RULE-ANTECEDENT NULL) (CL:SETQ RULE-ANTECEDENT (NEW-LIST)))
   (CL:WHEN (CL:EQ RULE-TYPES NULL) (CL:SETQ RULE-TYPES (NEW-LIST)))
   (CL:SETQ *SYMBOL-VARIABLE-HASH-TABLE* (NEW-HASH-TABLE))
   (CL:IF *ONLY-VARIABLIZE-VISITED-INSTANCES*
    (CL:SETQ ANTECEDENT (VARIABLIZE-INSTANCES ANTECEDENT *VISITED-INSTANCES*))
    (CL:SETQ ANTECEDENT (VARIABLIZE-CONS-PROPOSITIONS ANTECEDENT)))
   (CL:LET* ((CLAUSE NULL) (ITER-000 (%LIST.THE-CONS-LIST ANTECEDENT)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CLAUSE (%%VALUE ITER-000))
     (SUBSTITUTE-CONS-TREE CLAUSE SYM-CASE-BASED-LOGIC-?Y
      (LOOKUP *SYMBOL-VARIABLE-HASH-TABLE* NAME))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (INSERT-AT *SYMBOL-VARIABLE-HASH-TABLE* NAME SYM-CASE-BASED-LOGIC-?Y)
   (FILTER-ANTECEDENT ANTECEDENT RULE-NAME)
   (CL:SETQ TYPE-DEFS (BUILD-TYPE-DEFS *SEEN-INSTANCES*))
   (CL:SETQ RULE-ANTECEDENT (CONCATENATE RULE-ANTECEDENT ANTECEDENT))
   (CL:SETQ RULE-TYPES (CONCATENATE RULE-TYPES TYPE-DEFS))
   (INSERT-AT *CASE-ANTECEDENT-TABLE* RULE-NAME RULE-ANTECEDENT)
   (INSERT-AT *CASE-TYPES-TABLE* RULE-NAME RULE-TYPES)))

;;; (DEFUN (CREATE-CASE-INSTANCE-VECTOR VECTOR) ...)

(CL:DEFUN CREATE-CASE-INSTANCE-VECTOR (CLASS)
  (CL:LET*
   ((ITERATOR (ALL-CLASS-INSTANCES CLASS)) (NUM (LENGTH ITERATOR))
    (INSTANCES (NEW-VECTOR NUM)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NUM)) (INST NULL)
     (ITER-001 ITERATOR))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-000 UPPER-BOUND-000) (CL:NOT (CL:EQ ITER-001 NIL)))
     DO (CL:SETQ I ITER-000) (CL:SETQ INST (%%VALUE ITER-001))
     (CL:LET ((SELF (%VECTOR.THE-ARRAY INSTANCES)) (VALUE INST) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   INSTANCES))

;;; (DEFUN (MATCH-INSTANCES FLOAT-WRAPPER) ...)

(CL:DEFUN MATCH-INSTANCES (X Y)
  (CL:LET*
   ((PROP (LIST* SYM-CASE-BASED-PL-KERNEL-KB-CASE-MATCH X (CONS Y NIL))))
   (WRAP-FLOAT
    (RETURN-PARTIAL-TRUTH (MAKE-QUERY NIL (COERCE-TO-TREE PROP) NIL NIL)
     CL:T))))

;;; (DEFUN (CREATE-CASE-VALUE-VECTOR VECTOR) ...)

(CL:DEFUN CREATE-CASE-VALUE-VECTOR (INSTANCES SLOT)
  (CL:LET* ((SLOT-VALUES (NEW-VECTOR (LENGTH INSTANCES))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH INSTANCES))) (INST NULL)
     (ITER-001 (%LIST.THE-CONS-LIST INSTANCES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-000 UPPER-BOUND-000) (CL:NOT (CL:EQ ITER-001 NIL)))
     DO (CL:SETQ I ITER-000) (CL:SETQ INST (%%VALUE ITER-001))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY SLOT-VALUES))
       (VALUE (GET-SLOT-VALUE INST SLOT)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   SLOT-VALUES))

;;; (DEFUN (GUESS OBJECT) ...)

(CL:DEFUN %GUESS (INST-NAME SLOT-NAME)
  (CL:SETQ INST-NAME (PERMANENTIFY INST-NAME))
  (CL:SETQ SLOT-NAME (PERMANENTIFY SLOT-NAME))
  (CL:LET*
   ((PROBE (GET-INSTANCE INST-NAME))
    (CLASS
     (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE
      (LAST (GET-MOST-SPECIFIC-CLASSES PROBE))))
    (RULE-NAME (CONCATENATE (%SURROGATE.SYMBOL-NAME CLASS) "-match"))
    (RULE-NAME-SYMBOL (INTERN-SYMBOL RULE-NAME))
    (INSTANCES (LISTIFY (ALL-CLASS-INSTANCES CLASS)))
    (SLOT
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION SLOT-NAME))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RULE-NAME))
   (CL:WHEN (CL:NOT (MEMBER? *CASE-RULE-NAMES* RULE-NAME-SYMBOL))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Building match rule." EOL)
    (ADD-ALL-CLASS-INSTANCES-TO-CASE-RULE CLASS))
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Generating answer" EOL)
   (GENERATE-CASE-BASED-ANSWER PROBE SLOT INSTANCES)))

(CL:DEFMACRO GUESS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/GUESS|)) (CL:MACRO-FUNCTION (CL:QUOTE GUESS)))

;;; (DEFUN (GENERATE-CASE-BASED-ANSWER OBJECT) ...)

(CL:DEFUN GENERATE-CASE-BASED-ANSWER (PROBE SLOT CASES)
  (CL:LET*
   ((NUM (LENGTH CASES)) (SLOT-VECTOR (CREATE-CASE-VALUE-VECTOR CASES SLOT))
    (MATCH-SCORES (NEW-VECTOR NUM)) (FARTHEST 0)
    (NEAREST-NEIGHBORS (NEW-VECTOR *NUM-NEIGHBORS*)) (MAX 0.0d0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM FARTHEST) (CL:TYPE CL:DOUBLE-FLOAT MAX))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- *NUM-NEIGHBORS*)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY NEAREST-NEIGHBORS)) (VALUE (WRAP-INTEGER 0))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET* ((I NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- NUM)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ I ITER-001)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY MATCH-SCORES)) (VALUE (WRAP-FLOAT 1.0d0))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-002 (CL:1- NUM)) (CASE NULL)
     (ITER-003 (%LIST.THE-CONS-LIST CASES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-002))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-002 UPPER-BOUND-002) (CL:NOT (CL:EQ ITER-003 NIL)))
     DO (CL:SETQ I ITER-002) (CL:SETQ CASE (%%VALUE ITER-003))
     (CL:WHEN (CL:NOT (CL:EQ PROBE CASE))
      (CL:LET* ((SCORE (MATCH-INSTANCES PROBE CASE)))
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY MATCH-SCORES)) (VALUE SCORE) (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:WHEN (CL:> (%FLOAT-WRAPPER.WRAPPER-VALUE SCORE) MAX)
        (CL:SETQ MAX (CL:FLOAT I 0.0d0)))
       (CL:WHEN
        (CL:> (%FLOAT-WRAPPER.WRAPPER-VALUE SCORE)
         (%FLOAT-WRAPPER.WRAPPER-VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY MATCH-SCORES))
           (CL:THE CL:FIXNUM
            (%INTEGER-WRAPPER.WRAPPER-VALUE
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY NEAREST-NEIGHBORS))
              FARTHEST))))))
        (CL:LET
         ((SELF (%VECTOR.THE-ARRAY NEAREST-NEIGHBORS))
          (VALUE (WRAP-INTEGER I)) (POSITION FARTHEST))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (CL:SETQ FARTHEST 0)
        (CL:LET*
         ((J NULL-INTEGER) (ITER-004 1)
          (UPPER-BOUND-003 (CL:1- *NUM-NEIGHBORS*)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-004 UPPER-BOUND-003))
         (CL:LOOP WHILE (CL:<= ITER-004 UPPER-BOUND-003) DO
          (CL:SETQ J ITER-004)
          (CL:WHEN
           (CL:<
            (%FLOAT-WRAPPER.WRAPPER-VALUE
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY MATCH-SCORES))
              (CL:THE CL:FIXNUM
               (%INTEGER-WRAPPER.WRAPPER-VALUE
                (CL:AREF
                 (CL:THE CL:SIMPLE-VECTOR
                  (%VECTOR.THE-ARRAY NEAREST-NEIGHBORS))
                 J)))))
            (%FLOAT-WRAPPER.WRAPPER-VALUE
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY MATCH-SCORES))
              (CL:THE CL:FIXNUM
               (%INTEGER-WRAPPER.WRAPPER-VALUE
                (CL:AREF
                 (CL:THE CL:SIMPLE-VECTOR
                  (%VECTOR.THE-ARRAY NEAREST-NEIGHBORS))
                 FARTHEST))))))
           (CL:SETQ FARTHEST J))
          (CL:SETQ ITER-004 (CL:1+ ITER-004)))))))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))
     (CL:SETQ ITER-003 (%%REST ITER-003))))
   (COMBINE-CASE-ANSWERS NEAREST-NEIGHBORS MATCH-SCORES SLOT-VECTOR)))

;;; (DEFUN (COMBINE-CASE-ANSWERS OBJECT) ...)

(CL:DEFUN COMBINE-CASE-ANSWERS (CLOSEST SCORES SLOTS)
  (CL:SETQ SCORES SCORES)
  (CL:COND
   ((CL:EQ *CASE-SOLUTION-COMBINATION* KWD-CASE-BASED-WEIGHTED-VOTE)
    (CL:LET* ((ANSWER-TABLE (NEW-PROPERTY-LIST)) (KEYS (NEW-LIST)))
     (CL:LET*
      ((NEIGHBOR NULL) (VECTOR-000 CLOSEST) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ NEIGHBOR
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
         INDEX-000))
       (CL:LET*
        ((ANSWER
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOTS))
           (CL:THE CL:FIXNUM (%INTEGER-WRAPPER.WRAPPER-VALUE NEIGHBOR))))
         (VOTES (LOOKUP ANSWER-TABLE ANSWER)))
        (CL:IF (CL:EQ VOTES NULL)
         (CL:PROGN (PUSH KEYS ANSWER)
          (INSERT-AT ANSWER-TABLE ANSWER (WRAP-INTEGER 1)))
         (INSERT-AT ANSWER-TABLE ANSWER
          (WRAP-INTEGER (CL:1+ (%INTEGER-WRAPPER.WRAPPER-VALUE VOTES))))))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
     (CL:LET* ((MAX 0) (ANSWER NULL)) (CL:DECLARE (CL:TYPE CL:FIXNUM MAX))
      (CL:LET* ((KEY NULL) (ITER-000 (%LIST.THE-CONS-LIST KEYS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ KEY (%%VALUE ITER-000))
        (CL:LET* ((VOTES (LOOKUP ANSWER-TABLE KEY)))
         (CL:WHEN (CL:> (%INTEGER-WRAPPER.WRAPPER-VALUE VOTES) MAX)
          (CL:SETQ MAX (%INTEGER-WRAPPER.WRAPPER-VALUE VOTES))
          (CL:SETQ ANSWER KEY)))
        (CL:SETQ ITER-000 (%%REST ITER-000))))
      (CL:RETURN-FROM COMBINE-CASE-ANSWERS ANSWER))))
   ((CL:EQ *CASE-SOLUTION-COMBINATION* KWD-CASE-BASED-WEIGHTED-AVERAGE)
    (CL:IF
     (CL:OR
      (ISA? (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOTS)) 0)
       SGT-CASE-BASED-STELLA-FLOAT-WRAPPER)
      (ISA? (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOTS)) 0)
       SGT-CASE-BASED-STELLA-INTEGER-WRAPPER))
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Weighted average not implemented yet" EOL)
     (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
      "Warning:  Slot type not number.  Cannot average" EOL)))
   ((CL:EQ *CASE-SOLUTION-COMBINATION* KWD-CASE-BASED-AVERAGE)
    (CL:LET*
     ((TEST-VALUE-000
       (SAFE-PRIMARY-TYPE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOTS)) 0))))
     (CL:COND
      ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
       (CL:LET*
        ((SUM
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOTS))
           (CL:THE CL:FIXNUM
            (%INTEGER-WRAPPER.WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CLOSEST))
              0))))))
        (CL:LET*
         ((I NULL-INTEGER) (ITER-001 1)
          (UPPER-BOUND-000 (CL:1- *NUM-NEIGHBORS*)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
         (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-000) DO
          (CL:SETQ I ITER-001)
          (CL:SETQ SUM
           (WRAP-FLOAT
            (CL:+ (%FLOAT-WRAPPER.WRAPPER-VALUE SUM)
             (%FLOAT-WRAPPER.WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOTS))
               (CL:THE CL:FIXNUM
                (%INTEGER-WRAPPER.WRAPPER-VALUE
                 (CL:AREF
                  (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CLOSEST))
                  I))))))))
          (CL:SETQ ITER-001 (CL:1+ ITER-001))))
        (CL:RETURN-FROM COMBINE-CASE-ANSWERS
         (WRAP-FLOAT
          (CL:/ (%FLOAT-WRAPPER.WRAPPER-VALUE SUM) *NUM-NEIGHBORS*)))))
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
       (CL:LET*
        ((SUM
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOTS))
           (CL:THE CL:FIXNUM
            (%INTEGER-WRAPPER.WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CLOSEST))
              0))))))
        (CL:LET*
         ((I NULL-INTEGER) (ITER-002 1)
          (UPPER-BOUND-001 (CL:1- *NUM-NEIGHBORS*)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-001))
         (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-001) DO
          (CL:SETQ I ITER-002)
          (CL:SETQ SUM
           (WRAP-INTEGER
            (CL:+ (%INTEGER-WRAPPER.WRAPPER-VALUE SUM)
             (%INTEGER-WRAPPER.WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOTS))
               (CL:THE CL:FIXNUM
                (%INTEGER-WRAPPER.WRAPPER-VALUE
                 (CL:AREF
                  (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CLOSEST))
                  I))))))))
          (CL:SETQ ITER-002 (CL:1+ ITER-002))))
        (CL:RETURN-FROM COMBINE-CASE-ANSWERS
         (WRAP-FLOAT
          (CL:/ (CL:FLOAT (%INTEGER-WRAPPER.WRAPPER-VALUE SUM) 0.0d0)
           *NUM-NEIGHBORS*)))))
      (CL:T
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "Warning:  Slot type not number.  Cannot average" EOL)))))
   (CL:T))
  (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOTS))
   (CL:THE CL:FIXNUM
    (%INTEGER-WRAPPER.WRAPPER-VALUE
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CLOSEST)) 0)))))

;;; (DEFUN TRAIN-CASE-MATCHER ...)

(CL:DEFUN %TRAIN-CASE-MATCHER (CLASS-NAME SLOT-NAME CYCLES)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CYCLES))
  #+MCL
  (CL:CHECK-TYPE CYCLES CL:FIXNUM)
  (CL:SETQ SLOT-NAME (PERMANENTIFY SLOT-NAME))
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
   "Generating training examples" EOL)
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (SLOT
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE (GET-DESCRIPTION SLOT-NAME)))
    (ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS)))
    (INSTANCES (NEW-VECTOR (LENGTH ILIST))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- (LENGTH ILIST)))
     (INSTANCE NULL) (ITER-001 (%LIST.THE-CONS-LIST ILIST)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-000 UPPER-BOUND-000) (CL:NOT (CL:EQ ITER-001 NIL)))
     DO (CL:SETQ I ITER-000) (CL:SETQ INSTANCE (%%VALUE ITER-001))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY INSTANCES)) (VALUE INSTANCE) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (GENERATE-CASE-RULE-WO-SLOT INSTANCES CLASS-NAME SLOT-NAME)
   (CL:LET* ((NUM (GENERATE-CASE-TRAINING-EXAMPLES INSTANCES SLOT)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM NUM))
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Training case match network" EOL)
    (TRAIN-CACHED-NEURAL-NETWORKS CYCLES (CL:* NUM *NUM-TRAINING-PER-CASE*)))))

(CL:DEFUN TRAIN-CASE-MATCHER-EVALUATOR-WRAPPER (ARGUMENTS)
  (%TRAIN-CASE-MATCHER (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS))
   (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST (%%REST ARGUMENTS))))))

(CL:DEFMACRO TRAIN-CASE-MATCHER (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/TRAIN-CASE-MATCHER|)) (CL:MACRO-FUNCTION (CL:QUOTE TRAIN-CASE-MATCHER)))

;;; (DEFUN GENERATE-CASE-RULE-WO-SLOT ...)

(CL:DEFUN GENERATE-CASE-RULE-WO-SLOT (CASES CLASS-NAME SLOT-NAME)
  (CL:LET*
   ((NUM-CASES (LENGTH CASES))
    (KIND
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (CASE-NAMES (NEW-LIST))
    (SLOT
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE (GET-DESCRIPTION SLOT-NAME)))
    (SLOT-VALUES (NEW-VECTOR NUM-CASES)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-CASES)) (CLEAR-CASES)
   (CL:LET*
    ((CASE NULL) (VECTOR-000 CASES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ CASE
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (OBJECT-NAME CASE) NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST CASE-NAMES) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST CASE-NAMES) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST CASE-NAMES)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS (OBJECT-NAME CASE) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET*
    ((CASE NULL) (VECTOR-001 CASES) (INDEX-001 0)
     (LENGTH-001 (LENGTH VECTOR-001)) (CASE-NAME NULL)
     (ITER-000 (%LIST.THE-CONS-LIST CASE-NAMES)) (I NULL-INTEGER)
     (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 I ITER-001))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-001 LENGTH-001) (CL:NOT (CL:EQ ITER-000 NIL))) DO
     (CL:SETQ CASE
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-001))
       INDEX-001))
     (CL:SETQ CASE-NAME (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET* ((VAL (GET-SLOT-VALUE CASE SLOT)))
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY SLOT-VALUES)) (VALUE VAL) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (SMART-UPDATE-PROPOSITION
       (CONS SLOT-NAME (CONS CASE-NAME (CONS VAL NIL)))
       KWD-CASE-BASED-RETRACT-TRUE))
     (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:LET* ((FPTR (NEW-OUTPUT-FILE-STREAM "current-cases.ste")))
    (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM FPTR)
     "(in-package \"STELLA\")" EOL)
    (CL:LET*
     ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-000 (CL:1- NUM-CASES))
      (CASE-NAME NULL) (ITER-003 (%LIST.THE-CONS-LIST CASE-NAMES)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
     (CL:LOOP WHILE
      (CL:AND (CL:<= ITER-002 UPPER-BOUND-000) (CL:NOT (CL:EQ ITER-003 NIL)))
      DO (CL:SETQ I ITER-002) (CL:SETQ CASE-NAME (%%VALUE ITER-003))
      (BUILD-CASE-FROM-INSTANCE
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CASES)) I) KIND)
      (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM FPTR) "(add-case "
       CASE-NAME ")" EOL)
      (CL:SETQ ITER-002 (CL:1+ ITER-002))
      (CL:SETQ ITER-003 (%%REST ITER-003)))))
   (BUILD-CASE-RULE KIND)
   (CL:LET*
    ((VAL NULL) (VECTOR-002 SLOT-VALUES) (INDEX-002 0)
     (LENGTH-002 (LENGTH VECTOR-002)) (CASE-NAME NULL)
     (ITER-004 (%LIST.THE-CONS-LIST CASE-NAMES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-002 LENGTH-002))
    (CL:LOOP WHILE
     (CL:AND (CL:< INDEX-002 LENGTH-002) (CL:NOT (CL:EQ ITER-004 NIL))) DO
     (CL:SETQ VAL
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-002))
       INDEX-002))
     (CL:SETQ CASE-NAME (%%VALUE ITER-004))
     (SMART-UPDATE-PROPOSITION
      (CONS SLOT-NAME (CONS CASE-NAME (CONS VAL NIL)))
      KWD-CASE-BASED-ASSERT-TRUE)
     (CL:SETQ INDEX-002 (CL:1+ INDEX-002))
     (CL:SETQ ITER-004 (%%REST ITER-004))))))

;;; (DEFUN (TRAIN-AND-TEST-CASE-MATCHER FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:T CL:T CL:FIXNUM CL:FIXNUM CL:FIXNUM) CL:DOUBLE-FLOAT)
  %TRAIN-AND-TEST-CASE-MATCHER))
(CL:DEFUN %TRAIN-AND-TEST-CASE-MATCHER (CLASS-NAME SLOT-NAME NUM-TRAIN NUM-TEST CYCLES)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-TRAIN NUM-TEST CYCLES))
  #+MCL
  (CL:CHECK-TYPE NUM-TRAIN CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NUM-TEST CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE CYCLES CL:FIXNUM)
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (CL:SETQ SLOT-NAME (PERMANENTIFY SLOT-NAME))
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (CASES (LISTIFY (ALL-CLASS-INSTANCES CLASS)))
    (INSTANCES (NEW-VECTOR NUM-TRAIN))
    (SLOT
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE (GET-DESCRIPTION SLOT-NAME)))
    (SLOT-VALUES (NEW-VECTOR (LENGTH CASES))) (NUM-CORRECT 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-CORRECT)) (SHUFFLE-LIST CASES)
   (CL:LET*
    ((CASE NULL) (ITER-000 (%LIST.THE-CONS-LIST CASES)) (I NULL-INTEGER)
     (ITER-001 0) (UPPER-BOUND-000 (CL:1- NUM-TRAIN)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:<= ITER-001 UPPER-BOUND-000))
     DO (CL:SETQ CASE (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:LET ((SELF (%VECTOR.THE-ARRAY INSTANCES)) (VALUE CASE) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (GENERATE-CASE-RULE-WO-SLOT INSTANCES CLASS-NAME SLOT-NAME)
   (RETURN-PARTIAL-TRUTH
    (MAKE-QUERY NIL
     (COERCE-TO-TREE
      (LIST* SYM-CASE-BASED-LOGIC-CASE-MATCH (OBJECT-NAME (FIRST CASES))
       (CONS
        (LIST* SYM-CASE-BASED-LOGIC-OBJECT-NAME
         (LIST* SYM-CASE-BASED-STELLA-SECOND SYM-CASE-BASED-LOGIC-CASES NIL)
         NIL)
        NIL)))
     NIL NIL)
    CL:T)
   (%SAVE-ALL-NEURAL-NETWORKS *SAVE-NETWORK-FILE*)
   (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
    "Training case matcher" EOL)
   (CL:LET* ((NUM-INSTANCES (GENERATE-CASE-TRAINING-EXAMPLES INSTANCES SLOT)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-INSTANCES))
    (%TRAIN-NEURAL-NETWORK CYCLES
     (CL:* NUM-INSTANCES *NUM-TRAINING-PER-CASE*)))
   (CL:LET* ((TRAINING-CASES (NEW-LIST)))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-001 (CL:1- NUM-TRAIN))
      (COLLECT-000 NULL))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-001))
     (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-001) DO (CL:SETQ I ITER-002)
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000
         (CONS
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I)
          NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST TRAINING-CASES) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST TRAINING-CASES) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST TRAINING-CASES)
          COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES)) I)
          NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      (CL:SETQ ITER-002 (CL:1+ ITER-002))))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-003 NUM-TRAIN)
      (UPPER-BOUND-002 (CL:1- (CL:+ NUM-TRAIN NUM-TEST))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003 UPPER-BOUND-002))
     (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-002) DO (CL:SETQ I ITER-003)
      (CL:LET*
       ((PROBE (NTH CASES I))
        (CORRECT-ANSWER
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOT-VALUES))
          I))
        (ANSWER (GENERATE-CASE-BASED-ANSWER PROBE SLOT TRAINING-CASES)))
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) PROBE
        "  Predicted: " ANSWER ", Correct: " CORRECT-ANSWER EOL)
       (CL:WHEN (EQL? ANSWER CORRECT-ANSWER)
        (CL:SETQ NUM-CORRECT (CL:1+ NUM-CORRECT))))
      (CL:SETQ ITER-003 (CL:1+ ITER-003)))))
   (CL:/ (CL:FLOAT NUM-CORRECT 0.0d0) NUM-TEST)))

(CL:DEFUN TRAIN-AND-TEST-CASE-MATCHER-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (%TRAIN-AND-TEST-CASE-MATCHER (%%VALUE ARGUMENTS)
      (%%VALUE (%%REST ARGUMENTS))
      (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST (%%REST ARGUMENTS))))
      (%INTEGER-WRAPPER.WRAPPER-VALUE
       (%%VALUE (%%REST (%%REST (%%REST ARGUMENTS)))))
      (%INTEGER-WRAPPER.WRAPPER-VALUE
       (%%VALUE (%%REST (%%REST (%%REST (%%REST ARGUMENTS)))))))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:IF (CL:NOT (CL:= RESULT NULL-FLOAT)) (WRAP-FLOAT RESULT) NULL)))

(CL:DEFMACRO TRAIN-AND-TEST-CASE-MATCHER (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/TRAIN-AND-TEST-CASE-MATCHER|)) (CL:MACRO-FUNCTION (CL:QUOTE TRAIN-AND-TEST-CASE-MATCHER)))

;;; (DEFUN (TEST-CASE-BASED-REASONER FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:FIXNUM CL:FIXNUM) CL:DOUBLE-FLOAT)
  %TEST-CASE-BASED-REASONER))
(CL:DEFUN %TEST-CASE-BASED-REASONER (CLASS-NAME SLOT-NAME NUM-TRAIN NUM-TEST)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-TRAIN NUM-TEST))
  #+MCL
  (CL:CHECK-TYPE NUM-TRAIN CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NUM-TEST CL:FIXNUM)
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (CL:SETQ SLOT-NAME (PERMANENTIFY SLOT-NAME))
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (CASE-LIST (LISTIFY (ALL-CLASS-INSTANCES CLASS)))
    (NUM-CASES (LENGTH CASE-LIST))
    (SLOT
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE (GET-DESCRIPTION SLOT-NAME)))
    (FPTR (NEW-OUTPUT-FILE-STREAM "cbr-test-output.txt"))
    (TRAINING-CASES (NEW-LIST)) (CASE-VECTOR (NEW-VECTOR NUM-CASES))
    (NUM-CORRECT 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-CASES NUM-CORRECT))
   (SHUFFLE-LIST CASE-LIST)
   (CL:WHEN (CL:> (CL:+ NUM-TRAIN NUM-TEST) NUM-CASES)
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Error:  training and test instances out number total instances" EOL)
    (CL:RETURN-FROM %TEST-CASE-BASED-REASONER 0.0d0))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NUM-CASES))
     (CASE NULL) (ITER-001 (%LIST.THE-CONS-LIST CASE-LIST)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-000 UPPER-BOUND-000) (CL:NOT (CL:EQ ITER-001 NIL)))
     DO (CL:SETQ I ITER-000) (CL:SETQ CASE (%%VALUE ITER-001))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY CASE-VECTOR)) (VALUE CASE) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 1) (UPPER-BOUND-001 NUM-TRAIN)
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-001 NULL-INTEGER)) (CASE NULL)
     (ITER-003 (%LIST.THE-CONS-LIST CASE-LIST)) (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-001))
    (CL:LOOP WHILE
     (CL:AND (CL:OR UNBOUNDED?-000 (CL:<= ITER-002 UPPER-BOUND-001))
      (CL:NOT (CL:EQ ITER-003 NIL)))
     DO (CL:SETQ I ITER-002) (CL:SETQ CASE (%%VALUE ITER-003))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS CASE NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST TRAINING-CASES) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST TRAINING-CASES) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST TRAINING-CASES)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS CASE NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))
     (CL:SETQ ITER-003 (%%REST ITER-003))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-004 NUM-TRAIN)
     (UPPER-BOUND-002 (CL:1- (CL:+ NUM-TRAIN NUM-TEST))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-004 UPPER-BOUND-002))
    (CL:LOOP WHILE (CL:<= ITER-004 UPPER-BOUND-002) DO (CL:SETQ I ITER-004)
     (CL:LET*
      ((PROBE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY CASE-VECTOR)) I))
       (CASE-NAME (OBJECT-NAME PROBE))
       (CORRECT-ANSWER (GET-SLOT-VALUE PROBE SLOT))
       (ANSWER (GENERATE-CASE-BASED-ANSWER PROBE SLOT TRAINING-CASES)))
      (CL:WHEN (EQL? ANSWER CORRECT-ANSWER)
       (CL:SETQ NUM-CORRECT (CL:1+ NUM-CORRECT)))
      (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM FPTR) "Case "
       CASE-NAME " predicted: " ANSWER " correct: " CORRECT-ANSWER)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "Case "
       CASE-NAME " predicted: " ANSWER " correct: " CORRECT-ANSWER)
      (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM FPTR) "  Summary: "
       NUM-CORRECT " out of " NUM-TEST EOL)
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "  Summary: " NUM-CORRECT " out of " NUM-TEST EOL))
     (CL:SETQ ITER-004 (CL:1+ ITER-004))))
   (CL:/ (CL:FLOAT NUM-CORRECT 0.0d0) NUM-TEST)))

(CL:DEFUN TEST-CASE-BASED-REASONER-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (%TEST-CASE-BASED-REASONER (%%VALUE ARGUMENTS)
      (%%VALUE (%%REST ARGUMENTS))
      (%INTEGER-WRAPPER.WRAPPER-VALUE (%%VALUE (%%REST (%%REST ARGUMENTS))))
      (%INTEGER-WRAPPER.WRAPPER-VALUE
       (%%VALUE (%%REST (%%REST (%%REST ARGUMENTS))))))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:IF (CL:NOT (CL:= RESULT NULL-FLOAT)) (WRAP-FLOAT RESULT) NULL)))

(CL:DEFMACRO TEST-CASE-BASED-REASONER (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/TEST-CASE-BASED-REASONER|)) (CL:MACRO-FUNCTION (CL:QUOTE TEST-CASE-BASED-REASONER)))

;;; (DEFUN (TEST-CASE-MATCHER FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:DOUBLE-FLOAT) %TEST-CASE-MATCHER))
(CL:DEFUN %TEST-CASE-MATCHER (CLASS-NAME SLOT-NAME)
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (CL:SETQ SLOT-NAME (PERMANENTIFY SLOT-NAME))
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (CASES (LISTIFY (ALL-CLASS-INSTANCES CLASS)))
    (SLOT
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE (GET-DESCRIPTION SLOT-NAME)))
    (FPTR (NEW-OUTPUT-FILE-STREAM "test-output.txt"))
    (TRAINING-CASE-NAMES (LOOKUP *CASE-NAME-TABLE* CLASS-NAME))
    (TRAINING-CASES (NEW-LIST)) (CASE-NAMES (NEW-LIST)) (TOTAL 0)
    (NUM-CORRECT 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM TOTAL NUM-CORRECT))
   (CL:LET*
    ((CASE NULL) (ITER-000 (%LIST.THE-CONS-LIST CASES)) (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CASE (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS (OBJECT-NAME CASE) NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST CASE-NAMES) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST CASE-NAMES) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST CASE-NAMES)
         COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS (OBJECT-NAME CASE) NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((CASE NULL) (ITER-001 (%LIST.THE-CONS-LIST CASES)) (CASE-NAME NULL)
     (ITER-002 (%LIST.THE-CONS-LIST CASE-NAMES)) (COLLECT-001 NULL))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL))) DO
     (CL:SETQ CASE (%%VALUE ITER-001)) (CL:SETQ CASE-NAME (%%VALUE ITER-002))
     (CL:WHEN (MEMBER? TRAINING-CASE-NAMES CASE-NAME)
      (CL:IF (CL:EQ COLLECT-001 NULL)
       (CL:PROGN (CL:SETQ COLLECT-001 (CONS CASE NIL))
        (CL:IF (CL:EQ (%LIST.THE-CONS-LIST TRAINING-CASES) NIL)
         (CL:SETF (%LIST.THE-CONS-LIST TRAINING-CASES) COLLECT-001)
         (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST TRAINING-CASES)
          COLLECT-001)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-001) (CONS CASE NIL))
        (CL:SETQ COLLECT-001 (%%REST COLLECT-001)))))
     (CL:SETQ ITER-001 (%%REST ITER-001))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:LET*
    ((CASE NULL) (ITER-003 (%LIST.THE-CONS-LIST CASES)) (PROBE NULL)
     (ITER-004 (%LIST.THE-CONS-LIST CASES)) (CASE-NAME NULL)
     (ITER-005 (%LIST.THE-CONS-LIST CASE-NAMES)))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-003 NIL)) (CL:NOT (CL:EQ ITER-004 NIL))
      (CL:NOT (CL:EQ ITER-005 NIL)))
     DO (CL:SETQ CASE (%%VALUE ITER-003)) (CL:SETQ PROBE (%%VALUE ITER-004))
     (CL:SETQ CASE-NAME (%%VALUE ITER-005))
     (CL:WHEN (CL:NOT (MEMBER? TRAINING-CASE-NAMES CASE-NAME))
      (CL:LET*
       ((CORRECT-ANSWER (GET-SLOT-VALUE CASE SLOT))
        (ANSWER (GENERATE-CASE-BASED-ANSWER PROBE SLOT CASES)))
       (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM FPTR) "Case "
        CASE-NAME " predicted: " ANSWER " correct: " CORRECT-ANSWER)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT) "Case "
        CASE-NAME " predicted: " ANSWER " correct: " CORRECT-ANSWER)
       (CL:SETQ TOTAL (CL:1+ TOTAL))
       (CL:WHEN (EQL? ANSWER CORRECT-ANSWER)
        (CL:SETQ NUM-CORRECT (CL:1+ NUM-CORRECT)))
       (%%PRINT-STREAM (%OUTPUT-FILE-STREAM.NATIVE-STREAM FPTR) "  Summary: "
        NUM-CORRECT " out of " TOTAL EOL)
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "  Summary: " NUM-CORRECT " out of " TOTAL EOL)))
     (CL:SETQ ITER-003 (%%REST ITER-003)) (CL:SETQ ITER-004 (%%REST ITER-004))
     (CL:SETQ ITER-005 (%%REST ITER-005))))
   (CL:/ (CL:FLOAT NUM-CORRECT 0.0d0) TOTAL)))

(CL:DEFUN TEST-CASE-MATCHER-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (%TEST-CASE-MATCHER (%%VALUE ARGUMENTS) (%%VALUE (%%REST ARGUMENTS)))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:IF (CL:NOT (CL:= RESULT NULL-FLOAT)) (WRAP-FLOAT RESULT) NULL)))

(CL:DEFMACRO TEST-CASE-MATCHER (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/TEST-CASE-MATCHER|)) (CL:MACRO-FUNCTION (CL:QUOTE TEST-CASE-MATCHER)))

;;; (DEFUN (GENERATE-CASE-TRAINING-EXAMPLES INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM)
  GENERATE-CASE-TRAINING-EXAMPLES))
(CL:DEFUN GENERATE-CASE-TRAINING-EXAMPLES (INSTANCES SLOT)
  (CL:LET*
   ((NUM-INSTANCES (LENGTH INSTANCES))
    (SLOT-VALUES (NEW-VECTOR NUM-INSTANCES)) (K 0) (L 0)
    (INDEX (NEW-VECTOR (CL:* NUM-INSTANCES *NUM-TRAINING-PER-CASE*)))
    (MATCH-SCORES (NEW-VECTOR (CL:* NUM-INSTANCES *NUM-TRAINING-PER-CASE*))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-INSTANCES K L))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NUM-INSTANCES))
     (INST NULL) (VECTOR-000 INSTANCES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE
     (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000 INDEX-000 LENGTH-000))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-000 UPPER-BOUND-000) (CL:< INDEX-000 LENGTH-000)) DO
     (CL:SETQ I ITER-000)
     (CL:SETQ INST
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
       INDEX-000))
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY SLOT-VALUES))
       (VALUE (GET-SLOT-VALUE INST SLOT)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- NUM-INSTANCES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ I ITER-001)
     (CL:LET*
      ((J NULL-INTEGER) (ITER-002 1) (UPPER-BOUND-002 *NUM-TRAINING-PER-CASE*)
       (UNBOUNDED?-000 (CL:= UPPER-BOUND-002 NULL-INTEGER)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-002 UPPER-BOUND-002))
      (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-002 UPPER-BOUND-002))
       DO (CL:SETQ J ITER-002) (CL:SETQ J J)
       (CL:SETQ L (RANDOM NUM-INSTANCES))
       (CL:LOOP WHILE (CL:= I L) DO (CL:SETQ L (RANDOM NUM-INSTANCES)))
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY INDEX)) (VALUE (WRAP-INTEGER L))
         (POSITION K))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:LET
        ((SELF (%VECTOR.THE-ARRAY MATCH-SCORES))
         (VALUE
          (WRAP-FLOAT
           (CALCULATE-CASE-MATCH
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOT-VALUES))
             I)
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY SLOT-VALUES))
             L))))
         (POSITION K))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ K (CL:1+ K)) (CL:SETQ ITER-002 (CL:1+ ITER-002))))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:SETQ K 0) (NORMALIZE-NUMBERS MATCH-SCORES)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-003 0)
     (UPPER-BOUND-003 (CL:1- (LENGTH MATCH-SCORES))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003 UPPER-BOUND-003))
    (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-003) DO (CL:SETQ I ITER-003)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY MATCH-SCORES))
       (VALUE
        (WRAP-FLOAT
         (CL:- 1.0d0
          (%FLOAT-WRAPPER.WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY MATCH-SCORES))
            I)))))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-003 (CL:1+ ITER-003))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-004 0) (UPPER-BOUND-004 (CL:1- NUM-INSTANCES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-004 UPPER-BOUND-004))
    (CL:LOOP WHILE (CL:<= ITER-004 UPPER-BOUND-004) DO (CL:SETQ I ITER-004)
     (CL:LET*
      ((J NULL-INTEGER) (ITER-005 1) (UPPER-BOUND-005 *NUM-TRAINING-PER-CASE*)
       (UNBOUNDED?-001 (CL:= UPPER-BOUND-005 NULL-INTEGER)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-005 UPPER-BOUND-005))
      (CL:LOOP WHILE (CL:OR UNBOUNDED?-001 (CL:<= ITER-005 UPPER-BOUND-005))
       DO (CL:SETQ J ITER-005) (CL:SETQ J J)
       (CL:LET* ((EXAMPLE (NEW-TRAINING-EXAMPLE)))
        (CL:SETF (%TRAINING-EXAMPLE.QUERY EXAMPLE)
         (LIST* SYM-CASE-BASED-PL-KERNEL-KB-CASE-MATCH
          (LOGIC-SYMBOL
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES))
            I))
          (CONS
           (LOGIC-SYMBOL
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INSTANCES))
             (CL:THE CL:FIXNUM
              (%INTEGER-WRAPPER.WRAPPER-VALUE
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY INDEX))
                K)))))
           NIL)))
        (CL:SETF (%TRAINING-EXAMPLE.SCORE EXAMPLE)
         (%FLOAT-WRAPPER.WRAPPER-VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY MATCH-SCORES))
           K)))
        (PUSH *TRAINING-EXAMPLES* EXAMPLE))
       (CL:SETQ K (CL:1+ K)) (CL:SETQ ITER-005 (CL:1+ ITER-005))))
     (CL:SETQ ITER-004 (CL:1+ ITER-004))))
   NUM-INSTANCES))

;;; (DEFUN NORMALIZE-NUMBERS ...)

(CL:DEFUN NORMALIZE-NUMBERS (VECT)
  (CL:LET*
   ((NUM (LENGTH VECT)) (MAX -99999.0d0) (MIN 99999.0d0) (RANGE 0.0d0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM)
    (CL:TYPE CL:DOUBLE-FLOAT MAX MIN RANGE))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NUM)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY VECT))
       (VALUE
        (WRAP-FLOAT
         (CL:* 1.0d0
          (%FLOAT-WRAPPER.WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECT)) I)))))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:WHEN
      (CL:>
       (%FLOAT-WRAPPER.WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECT)) I))
       MAX)
      (CL:SETQ MAX
       (%FLOAT-WRAPPER.WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECT)) I))))
     (CL:WHEN
      (CL:<
       (%FLOAT-WRAPPER.WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECT)) I))
       MIN)
      (CL:SETQ MIN
       (%FLOAT-WRAPPER.WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECT)) I))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETQ RANGE (CL:- MAX MIN))
   (CL:LET* ((I NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- NUM)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ I ITER-001)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY VECT))
       (VALUE
        (WRAP-FLOAT
         (CL:/
          (CL:-
           (%FLOAT-WRAPPER.WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECT)) I))
           MIN)
          RANGE)))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))))

;;; (DEFUN CLEAR-SLOT-FROM-CLASS ...)

(CL:DEFUN %CLEAR-SLOT-FROM-CLASS (CLASS-NAME SLOT-NAME)
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (CL:SETQ SLOT-NAME (PERMANENTIFY SLOT-NAME))
  (CL:LET*
   ((CLASS
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION CLASS-NAME)))
    (CASES (LISTIFY (ALL-CLASS-INSTANCES CLASS)))
    (SLOT
     (%NAMED-DESCRIPTION.SURROGATE-VALUE-INVERSE
      (GET-DESCRIPTION SLOT-NAME))))
   (CL:LET* ((CASE NULL) (ITER-000 (%LIST.THE-CONS-LIST CASES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CASE (%%VALUE ITER-000))
     (SMART-UPDATE-PROPOSITION
      (CONS SLOT-NAME (CONS CASE (CONS (GET-SLOT-VALUE CASE SLOT) NIL)))
      KWD-CASE-BASED-RETRACT-TRUE)
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

(CL:DEFMACRO CLEAR-SLOT-FROM-CLASS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/CLEAR-SLOT-FROM-CLASS|)) (CL:MACRO-FUNCTION (CL:QUOTE CLEAR-SLOT-FROM-CLASS)))

;;; (DEFUN (LOGIC-SYMBOL OBJECT) ...)

(CL:DEFUN LOGIC-SYMBOL (OBJ)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE OBJ)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-CASE-BASED-LOGIC-DESCRIPTION)
     (CL:PROGN OBJ))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-CASE-BASED-LOGIC-PATTERN-VARIABLE)
     (CL:PROGN (INTERN-SYMBOL (GET-SKOLEM-PRINT-NAME OBJ))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-CASE-BASED-LOGIC-SKOLEM)
     (CL:PROGN (INTERN-SYMBOL (GET-SKOLEM-PRINT-NAME OBJ))))
    ((SUBTYPE-OF? TEST-VALUE-000 SGT-CASE-BASED-LOGIC-LOGIC-OBJECT)
     (CL:PROGN
      (INTERN-SYMBOL
       (%SURROGATE.SYMBOL-NAME (%LOGIC-OBJECT.SURROGATE-VALUE-INVERSE OBJ)))))
    (CL:T OBJ))))

;;; (DEFUN (CALCULATE-CASE-MATCH FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:DOUBLE-FLOAT) CALCULATE-CASE-MATCH))
(CL:DEFUN CALCULATE-CASE-MATCH (X Y)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE X)))
   (CL:COND
    ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
     (CL:PROGN
      (ABS
       (CL:- (%FLOAT-WRAPPER.WRAPPER-VALUE X)
        (%FLOAT-WRAPPER.WRAPPER-VALUE Y)))))
    ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
     (CL:PROGN
      (CL:FLOAT
       (ABS
        (CL:- (%INTEGER-WRAPPER.WRAPPER-VALUE X)
         (%INTEGER-WRAPPER.WRAPPER-VALUE Y)))
       0.0d0)))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN (CL:IF (CL:EQ X Y) 1.0d0 0.0d0)))
    (CL:T (CL:FLOAT 0 0.0d0)))))

;;; (DEFUN (GET-MOST-SPECIFIC-CLASSES CONS) ...)

(CL:DEFUN GET-MOST-SPECIFIC-CLASSES (INSTANCE)
  (CL:LET* ((TYPES (ALL-DIRECT-TYPES INSTANCE)))
   (CL:WHEN (CL:EQ TYPES NIL)
    (CL:RETURN-FROM GET-MOST-SPECIFIC-CLASSES (ALL-ASSERTED-TYPES INSTANCE)))
   TYPES))

;;; (DEFUN (FIND-UNIQUE-VARIABLE-NAMES LIST) ...)

(CL:DEFUN FIND-UNIQUE-VARIABLE-NAMES (TREE NAMES)
  (CL:LET* ((ARG NULL) (ITER-000 (%%REST TREE)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ ARG (%%VALUE ITER-000))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 SGT-CASE-BASED-STELLA-CONS)
       (CL:PROGN (FIND-UNIQUE-VARIABLE-NAMES ARG NAMES)))
      ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
       (CL:PROGN (CL:WHEN (CL:NOT (MEMBER? NAMES ARG)) (PUSH NAMES ARG))))
      (CL:T)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  NAMES)

;;; (DEFUN (VARIABLIZE-CONS-PROPOSITIONS (LIST OF CONS)) ...)

(CL:DEFUN VARIABLIZE-CONS-PROPOSITIONS (ANTECEDENT)
  (CL:LET* ((VAR-LIST (NEW-LIST)))
   (CL:LET* ((PROP NULL) (ITER-000 (%LIST.THE-CONS-LIST ANTECEDENT)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PROP (%%VALUE ITER-000))
     (FIND-UNIQUE-VARIABLE-NAMES PROP VAR-LIST)
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (VARIABLIZE-INSTANCES ANTECEDENT VAR-LIST)))

;;; (DEFUN (VARIABLIZE-INSTANCES (LIST OF CONS)) ...)

(CL:DEFUN VARIABLIZE-INSTANCES (FORM INSTANCES)
  (CL:LET* ((BIND NULL) (ITER-000 (%LIST.THE-CONS-LIST INSTANCES)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ BIND (%%VALUE ITER-000))
    (CL:LET*
     ((VAR
       (INTERN-LOGIC-SYMBOL
        (CONCATENATE "?X"
         (STRINGIFY (WRAP-INTEGER *CASE-VARIABLE-COUNTER*))))))
     (CL:SETQ *CASE-VARIABLE-COUNTER* (CL:1+ *CASE-VARIABLE-COUNTER*))
     (INSERT-AT *SYMBOL-VARIABLE-HASH-TABLE* BIND VAR)
     (PUSH *SEEN-INSTANCES* BIND)
     (CL:LET* ((CLAUSE NULL) (ITER-001 (%LIST.THE-CONS-LIST FORM)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ CLAUSE (%%VALUE ITER-001))
       (SUBSTITUTE-CONS-TREE CLAUSE VAR BIND)
       (CL:SETQ ITER-001 (%%REST ITER-001)))))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  FORM)

;;; (DEFUN (STRING-ARGUMENT? BOOLEAN) ...)

(CL:DEFUN STRING-ARGUMENT? (CLAUSE)
  (CL:LET* ((ELE NULL) (ITER-000 CLAUSE))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ ELE (%%VALUE ITER-000))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ELE)))
     (CL:COND
      ((CL:EQ TEST-VALUE-000 SGT-CASE-BASED-STELLA-CONS)
       (CL:PROGN
        (CL:WHEN (STRING-ARGUMENT? ELE)
         (CL:RETURN-FROM STRING-ARGUMENT? CL:T))))
      ((SUBTYPE-OF-STRING? TEST-VALUE-000)
       (CL:PROGN (CL:RETURN-FROM STRING-ARGUMENT? CL:T)))
      (CL:T)))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  CL:NIL)

;;; (DEFUN FILTER-ANTECEDENT ...)

(CL:DEFUN FILTER-ANTECEDENT (ANTECEDENT RULE-NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING RULE-NAME))
  #+MCL
  (CL:CHECK-TYPE RULE-NAME CL:SIMPLE-STRING)
  (CL:LET* ((CLAUSE (ALLOCATE-ITERATOR ANTECEDENT)))
   (CL:LOOP WHILE (NEXT? CLAUSE) DO
    (CL:WHEN (STRING-ARGUMENT? (%LIST-ITERATOR.VALUE CLAUSE))
     (VALUE-SETTER CLAUSE NULL))))
  (REMOVE ANTECEDENT NULL)
  (CL:LET*
   ((RULE-ANT (LOOKUP *CASE-ANTECEDENT-TABLE* RULE-NAME))
    (GENERATED-VARIABLES (LIST (INTERN-LOGIC-SYMBOL "?Y"))) (INDEX 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX))
   (CL:WHEN *LOG-ANTECEDENT-CONSTRUCTION*
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "New clauses: " ANTECEDENT EOL))
   (CL:WHEN (CL:EQ RULE-ANT NULL) (CL:RETURN-FROM FILTER-ANTECEDENT))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 (LENGTH ANTECEDENT)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:SETQ I I)
     (CL:LET*
      ((CLAUSE (NTH ANTECEDENT INDEX))
       (VARS (FIND-MATCHING-CASE-VARS CLAUSE RULE-ANT GENERATED-VARIABLES)))
      (CL:IF (CL:NOT (CL:EQ VARS NIL))
       (CL:PROGN (CL:SETQ ANTECEDENT (REMOVE ANTECEDENT CLAUSE))
        (CL:LET* ((SUB NULL) (ITER-001 VARS))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ SUB (%%VALUE ITER-001))
          (CL:WHEN (SYMBOL? (%%VALUE (%%REST SUB)))
           (PUSH *DELETED-CASE-VARIABLES* (%%VALUE (%%REST SUB)))
           (CL:WHEN (CL:NOT (EQL? (%%VALUE SUB) (%%VALUE (%%REST SUB))))
            (CL:LET* ((ANT NULL) (ITER-002 (%LIST.THE-CONS-LIST ANTECEDENT)))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
              (CL:SETQ ANT (%%VALUE ITER-002))
              (SUBSTITUTE-CONS-TREE ANT (%%VALUE SUB) (%%VALUE (%%REST SUB)))
              (CL:SETQ ITER-002 (%%REST ITER-002))))))
          (CL:SETQ ITER-001 (%%REST ITER-001)))))
       (CL:SETQ INDEX (CL:1+ INDEX))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN *LOG-ANTECEDENT-CONSTRUCTION*
    (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
     "Clauses added to antecedent: " ANTECEDENT EOL))
   NULL))

;;; (DEFUN (FIND-MATCHING-CASE-VARS CONS) ...)

(CL:DEFUN FIND-MATCHING-CASE-VARS (CLAUSE ANTECEDENT GENERATED-VARIABLES)
  (CL:LET* ((PREDICATE (%%VALUE CLAUSE)) (ARITY (LENGTH CLAUSE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
   (CL:LET* ((ANT NULL) (ITER-000 (%LIST.THE-CONS-LIST ANTECEDENT)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ANT (%%VALUE ITER-000))
     (CL:LET* ((REAL-ANT ANT))
      (CL:WHEN *LOG-ANTECEDENT-CONSTRUCTION*
       (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
        "   Comparing " CLAUSE " to " REAL-ANT EOL))
      (CL:WHEN
       (CL:AND (EQL? (%%VALUE REAL-ANT) PREDICATE)
        (PARAMETERS-ALIGNED? CLAUSE REAL-ANT GENERATED-VARIABLES)
        (CL:= (LENGTH REAL-ANT) ARITY))
       (CL:LET* ((SUBS NIL))
        (CL:LET*
         ((VAR1 NULL) (ITER-001 (%%REST CLAUSE)) (VAR2 NULL)
          (ITER-002 (%%REST REAL-ANT)) (COLLECT-000 NULL))
         (CL:LOOP WHILE
          (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL)))
          DO (CL:SETQ VAR1 (%%VALUE ITER-001))
          (CL:SETQ VAR2 (%%VALUE ITER-002)) (PUSH GENERATED-VARIABLES VAR2)
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS (CONS-LIST VAR2 VAR1) NIL))
            (CL:IF (CL:EQ SUBS NIL) (CL:SETQ SUBS COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST SUBS COLLECT-000)))
           (CL:PROGN
            (CL:SETF (%%REST COLLECT-000) (CONS (CONS-LIST VAR2 VAR1) NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
          (CL:SETQ ITER-001 (%%REST ITER-001))
          (CL:SETQ ITER-002 (%%REST ITER-002))))
        (CL:WHEN *LOG-ANTECEDENT-CONSTRUCTION*
         (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
          "   Found match: " SUBS EOL))
        (CL:RETURN-FROM FIND-MATCHING-CASE-VARS SUBS))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   NIL))

;;; (DEFUN (PARAMETERS-ALIGNED? BOOLEAN) ...)

(CL:DEFUN PARAMETERS-ALIGNED? (CLAUSE1 CLAUSE2 VARS)
  (CL:LET* ((VAR NULL) (ITER-000 (%LIST.THE-CONS-LIST VARS)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ VAR (%%VALUE ITER-000))
    (CL:WHEN (CL:NOT (CL:= (POSITION CLAUSE1 VAR 0) (POSITION CLAUSE2 VAR 0)))
     (CL:RETURN-FROM PARAMETERS-ALIGNED? CL:NIL))
    (CL:SETQ ITER-000 (%%REST ITER-000))))
  (CL:LET*
   ((P1 NULL) (ITER-001 (%%REST CLAUSE1)) (P2 NULL)
    (ITER-002 (%%REST CLAUSE2)))
   (CL:LOOP WHILE
    (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL))) DO
    (CL:SETQ P1 (%%VALUE ITER-001)) (CL:SETQ P2 (%%VALUE ITER-002))
    (CL:COND
     ((CONS? P1)
      (CL:WHEN
       (CL:OR (CL:NOT (CONS? P2)) (CL:NOT (PARAMETERS-ALIGNED? P1 P2 VARS)))
       (CL:RETURN-FROM PARAMETERS-ALIGNED? CL:NIL)))
     (CL:T
      (CL:WHEN
       (CL:AND (CL:OR (CL:NOT (VARIABLE-ARG? P1)) (CL:NOT (VARIABLE-ARG? P2)))
        (CL:NOT (EQL? P1 P2)))
       (CL:RETURN-FROM PARAMETERS-ALIGNED? CL:NIL))))
    (CL:SETQ ITER-001 (%%REST ITER-001)) (CL:SETQ ITER-002 (%%REST ITER-002))))
  CL:T)

;;; (DEFUN (VARIABLE-ARG? BOOLEAN) ...)

(CL:DEFUN VARIABLE-ARG? (ARG)
  (CL:COND
   ((SUBTYPE-OF-SYMBOL? (SAFE-PRIMARY-TYPE ARG))
    (CL:PROGN
     (CL:IF
      (CL:EQL
       (CL:LET ((SELF (%SYMBOL.SYMBOL-NAME ARG)) (POSITION 0))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF) (CL:THE CL:FIXNUM POSITION)))
       #\?)
      CL:T CL:NIL)))
   (CL:T CL:NIL)))

;;; (DEFUN (BUILD-VARIABLE-CONSTRAINTS CONS) ...)

(CL:DEFUN BUILD-VARIABLE-CONSTRAINTS (INSTANCES)
  (CL:LET* ((CONSTRAINTS NIL))
   (CL:LET* ((VAR NULL) (ITER-000 (%LIST.THE-CONS-LIST INSTANCES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ VAR (%%VALUE ITER-000))
     (CL:LET* ((NAME (LOOKUP *SYMBOL-VARIABLE-HASH-TABLE* VAR)))
      (CL:WHEN (CL:NOT (MEMBER? *DELETED-CASE-VARIABLES* NAME))
       (CL:SETQ CONSTRAINTS
        (CONS
         (LIST* SYM-CASE-BASED-LOGIC-SOFT-EQ NAME
          (CONS
           (INTERN-LOGIC-SYMBOL
            (CONCATENATE "X" (SUBSEQUENCE (STRINGIFY NAME) 1 NULL-INTEGER)))
           NIL))
         CONSTRAINTS))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   CONSTRAINTS))

;;; (DEFUN (BUILD-TYPE-DEFS (LIST OF SYMBOL)) ...)

(CL:DEFUN BUILD-TYPE-DEFS (INSTANCES)
  (CL:LET* ((TYPE-DEFS (NEW-LIST)) (NAME NULL))
   (CL:LET* ((VAR NULL) (ITER-000 (%LIST.THE-CONS-LIST INSTANCES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ VAR (%%VALUE ITER-000))
     (CL:SETQ NAME (LOOKUP *SYMBOL-VARIABLE-HASH-TABLE* VAR))
     (CL:WHEN (CL:NOT (MEMBER? *DELETED-CASE-VARIABLES* NAME))
      (PUSH TYPE-DEFS NAME))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   TYPE-DEFS))

;;; (DEFGLOBAL *PRINT-CASE-DISTANCES* ...)

(CL:DEFVAR *PRINT-CASE-DISTANCES* CL:NIL)

;;; (DEFUN SET-PRINT-CASE-DISTANCES ...)

(CL:DEFUN %SET-PRINT-CASE-DISTANCES (B)
  (CL:SETQ *PRINT-CASE-DISTANCES* B))

(CL:DEFUN SET-PRINT-CASE-DISTANCES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-PRINT-CASE-DISTANCES
   (%BOOLEAN-WRAPPER.WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-PRINT-CASE-DISTANCES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-PRINT-CASE-DISTANCES|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-PRINT-CASE-DISTANCES)))

;;; (DEFUN (GET-NEAREST-NEIGHBORS (LIST OF TRAINING-EXAMPLE)) ...)

(CL:DEFUN GET-NEAREST-NEIGHBORS (PROBE CASES K)
  (CL:DECLARE (CL:TYPE CL:FIXNUM K))
  #+MCL
  (CL:CHECK-TYPE K CL:FIXNUM)
  (CL:LET*
   ((RESULT (NEW-LIST)) (CURRENT-MODULE *MODULE*) (NEIGHBORS (NEW-VECTOR K))
    (FARTHEST 0) (DISTANCE 0.0d0) (DISTANCES (NEW-VECTOR K)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM FARTHEST)
    (CL:TYPE CL:DOUBLE-FLOAT DISTANCE))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- K)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%VECTOR.THE-ARRAY DISTANCES)) (VALUE (WRAP-FLOAT 999999.0d0))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:WHEN (CL:EQ (%TRAINING-EXAMPLE.INPUT PROBE) NULL)
    (CL:SETF (%TRAINING-EXAMPLE.INPUT PROBE)
     (CREATE-INPUT-SIGNATURE (%TRAINING-EXAMPLE.QUERY PROBE))))
   (CL:LET* ((CASE NULL) (ITER-001 (%LIST.THE-CONS-LIST CASES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ CASE (%%VALUE ITER-001))
     (CL:WHEN (CL:EQ (%TRAINING-EXAMPLE.INPUT CASE) NULL)
      (CL:WHEN (CL:NOT (CL:EQ (%TRAINING-EXAMPLE.MODULE CASE) NULL))
       (CHANGE-MODULE (%TRAINING-EXAMPLE.MODULE CASE)))
      (CL:SETF (%TRAINING-EXAMPLE.INPUT CASE)
       (CREATE-INPUT-SIGNATURE (%TRAINING-EXAMPLE.QUERY CASE)))
      (CHANGE-MODULE CURRENT-MODULE))
     (CL:WHEN (CL:= (LENGTH (%TRAINING-EXAMPLE.INPUT PROBE)) 1)
      (CL:SETF (%TRAINING-EXAMPLE.INPUT PROBE)
       (CREATE-INPUT-SIGNATURE (%TRAINING-EXAMPLE.QUERY PROBE))))
     (CL:SETQ DISTANCE
      (CL:+
       (HAMMING-DISTANCE (%TRAINING-EXAMPLE.INPUT PROBE)
        (%TRAINING-EXAMPLE.INPUT CASE))
       0.0d0))
     (CL:WHEN *PRINT-CASE-DISTANCES*
      (%%PRINT-STREAM (%OUTPUT-STREAM.NATIVE-STREAM STANDARD-OUTPUT)
       "  Distance from " (LAST (%TRAINING-EXAMPLE.QUERY CASE)) ": " DISTANCE
       EOL))
     (CL:SETF (%TRAINING-EXAMPLE.TEMP CASE) DISTANCE)
     (CL:WHEN
      (CL:< DISTANCE
       (%FLOAT-WRAPPER.WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY DISTANCES))
         FARTHEST)))
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY DISTANCES)) (VALUE (WRAP-FLOAT DISTANCE))
        (POSITION FARTHEST))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET
       ((SELF (%VECTOR.THE-ARRAY NEIGHBORS)) (VALUE CASE) (POSITION FARTHEST))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ FARTHEST 0)
      (CL:LET* ((J NULL-INTEGER) (ITER-002 1) (UPPER-BOUND-001 (CL:1- K)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-002 UPPER-BOUND-001))
       (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-001) DO (CL:SETQ J ITER-002)
        (CL:WHEN
         (CL:>
          (%FLOAT-WRAPPER.WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY DISTANCES))
            J))
          (%FLOAT-WRAPPER.WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY DISTANCES))
            FARTHEST)))
         (CL:SETQ FARTHEST J))
        (CL:SETQ ITER-002 (CL:1+ ITER-002)))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-003 0) (UPPER-BOUND-002 (CL:1- K))
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003 UPPER-BOUND-002))
    (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-002) DO (CL:SETQ I ITER-003)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN
       (CL:SETQ COLLECT-000
        (CONS
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY NEIGHBORS)) I)
         NIL))
       (CL:IF (CL:EQ (%LIST.THE-CONS-LIST RESULT) NIL)
        (CL:SETF (%LIST.THE-CONS-LIST RESULT) COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST (%LIST.THE-CONS-LIST RESULT)
         COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000)
        (CONS
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY NEIGHBORS)) I)
         NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-003 (CL:1+ ITER-003))))
   RESULT))

;;; (DEFUN (EUCLIDEAN-DISTANCE FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:DOUBLE-FLOAT) EUCLIDEAN-DISTANCE))
(CL:DEFUN EUCLIDEAN-DISTANCE (VEC1 VEC2)
  (CL:LET* ((RESULT 0.0d0) (DIFF 0.0d0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT DIFF))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- (LENGTH VEC1))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:SETQ DIFF
      (CL:-
       (%FLOAT-WRAPPER.WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VEC1)) I))
       (%FLOAT-WRAPPER.WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VEC2)) I))))
     (CL:SETQ RESULT (CL:+ RESULT (CL:* DIFF DIFF)))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:THE CL:DOUBLE-FLOAT (CL:SQRT RESULT))))

;;; (DEFUN (HAMMING-DISTANCE INTEGER) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION (CL:T CL:T) CL:FIXNUM) HAMMING-DISTANCE))
(CL:DEFUN HAMMING-DISTANCE (VEC1 VEC2)
  (CL:LET* ((RESULT 0)) (CL:DECLARE (CL:TYPE CL:FIXNUM RESULT))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- (LENGTH VEC1))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:WHEN
      (CL:NOT
       (CL:EQ (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VEC1)) I)
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VEC2)) I)))
      (CL:SETQ RESULT (CL:1+ RESULT)))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   RESULT))

;;; (DEFUN (INTERN-LOGIC-SYMBOL SYMBOL) ...)

(CL:DEFUN INTERN-LOGIC-SYMBOL (NAME)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING NAME))
  #+MCL
  (CL:CHECK-TYPE NAME CL:SIMPLE-STRING)
  (INTERN-SYMBOL-IN-MODULE NAME (GET-MODULE (WRAP-STRING "LOGIC")) CL:T))

(CL:DEFUN HELP-STARTUP-CASE-BASED1 ()
  (CL:PROGN
   (CL:SETQ KWD-CASE-BASED-WEIGHTED-VOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHTED-VOTE" NULL 2))
   (CL:SETQ SYM-CASE-BASED-LOGIC-SET-NUM-NEIGHBORS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-NUM-NEIGHBORS" NULL 0))
   (CL:SETQ KWD-CASE-BASED-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-CASE-BASED-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-CASE-BASED-LOGIC-SET-CASE-SOLUTION-COMBINATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-CASE-SOLUTION-COMBINATION" NULL 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-SET-NUM-TRAINING-PER-CASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-NUM-TRAINING-PER-CASE" NULL 0))
   (CL:SETQ KWD-CASE-BASED-RETRACT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT-TRUE" NULL 2))
   (CL:SETQ SYM-CASE-BASED-LOGIC-FINALIZE-CASES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FINALIZE-CASES" NULL 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-DEFRULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRULE" NULL 0))
   (CL:SETQ SYM-CASE-BASED-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-CASE-BASED-STELLA-=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=>" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-CASE-BASED-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-CASE-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CASE-MATCH" NULL 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-?X
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?X" NULL 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-?Y
    (INTERN-RIGID-SYMBOL-WRT-MODULE "?Y" NULL 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-ADD-CASE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-CASE" NULL 0))
   (CL:SETQ SYM-CASE-BASED-PL-KERNEL-KB-CASE-MATCH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CASE-MATCH"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-GUESS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GUESS" NULL 0))
   (CL:SETQ KWD-CASE-BASED-WEIGHTED-AVERAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHTED-AVERAGE" NULL 2))
   (CL:SETQ SGT-CASE-BASED-STELLA-FLOAT-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-CASE-BASED-STELLA-INTEGER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTEGER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-CASE-BASED-AVERAGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AVERAGE" NULL 2))
   (CL:SETQ SYM-CASE-BASED-LOGIC-TRAIN-CASE-MATCHER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRAIN-CASE-MATCHER" NULL 0))
   (CL:SETQ KWD-CASE-BASED-ASSERT-TRUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT-TRUE" NULL 2))
   (CL:SETQ SYM-CASE-BASED-LOGIC-OBJECT-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OBJECT-NAME" NULL 0))
   (CL:SETQ SYM-CASE-BASED-STELLA-SECOND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SECOND"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-CASES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CASES" NULL 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-TRAIN-AND-TEST-CASE-MATCHER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRAIN-AND-TEST-CASE-MATCHER" NULL 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-TEST-CASE-BASED-REASONER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TEST-CASE-BASED-REASONER" NULL 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-TEST-CASE-MATCHER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TEST-CASE-MATCHER" NULL 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-CLEAR-SLOT-FROM-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLEAR-SLOT-FROM-CLASS" NULL 0))
   (CL:SETQ SGT-CASE-BASED-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-CASE-BASED-LOGIC-PATTERN-VARIABLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN-VARIABLE" NULL 1))
   (CL:SETQ SGT-CASE-BASED-LOGIC-SKOLEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SKOLEM" NULL 1))
   (CL:SETQ SGT-CASE-BASED-LOGIC-LOGIC-OBJECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOGIC-OBJECT" NULL 1))
   (CL:SETQ SGT-CASE-BASED-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ SYM-CASE-BASED-LOGIC-SOFT-EQ
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SOFT-EQ" NULL 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-SET-PRINT-CASE-DISTANCES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-PRINT-CASE-DISTANCES" NULL 0))
   (CL:SETQ SYM-CASE-BASED-LOGIC-STARTUP-CASE-BASED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-CASE-BASED" NULL 0))
   (CL:SETQ SYM-CASE-BASED-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-CASE-BASED2 ()
  (CL:PROGN (CL:SETQ *CASE-SOLUTION-COMBINATION* KWD-CASE-BASED-WEIGHTED-VOTE)
   (CL:SETQ *CASE-RULE-NAMES* (NEW-LIST))
   (CL:SETQ *VISITED-INSTANCES* (NEW-LIST))
   (CL:SETQ *VISITED-PROPOSITIONS* (NEW-LIST))
   (CL:SETQ *CASE-ANTECEDENT-TABLE* (NEW-STRING-HASH-TABLE))
   (CL:SETQ *CASE-TYPES-TABLE* (NEW-STRING-HASH-TABLE))
   (CL:SETQ *CASE-NAME-TABLE* (NEW-HASH-TABLE))))

(CL:DEFUN HELP-STARTUP-CASE-BASED3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "SET-NUM-NEIGHBORS"
    "(DEFUN SET-NUM-NEIGHBORS ((D INTEGER)) :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Sets the number of nearest neighbors to predict from.\")"
    (CL:FUNCTION %SET-NUM-NEIGHBORS)
    (CL:FUNCTION SET-NUM-NEIGHBORS-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-CASE-SOLUTION-COMBINATION"
    "(DEFUN SET-CASE-SOLUTION-COMBINATION ((K KEYWORD)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-CASE-SOLUTION-COMBINATION) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-NUM-TRAINING-PER-CASE"
    "(DEFUN SET-NUM-TRAINING-PER-CASE ((D INTEGER)) :COMMAND? TRUE :PUBLIC? TRUE :DOCUMENTATION \"Sets the number of training examples for each case in the training set.\")"
    (CL:FUNCTION %SET-NUM-TRAINING-PER-CASE)
    (CL:FUNCTION SET-NUM-TRAINING-PER-CASE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "CLEAR-CASES"
    "(DEFUN CLEAR-CASES () :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR-CASES) NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-ALL-CLASS-INSTANCES-TO-CASE-RULE"
    "(DEFUN ADD-ALL-CLASS-INSTANCES-TO-CASE-RULE ((KIND SURROGATE)))"
    (CL:FUNCTION ADD-ALL-CLASS-INSTANCES-TO-CASE-RULE) NULL)
   (DEFINE-FUNCTION-OBJECT "FINALIZE-CASES"
    "(DEFUN FINALIZE-CASES ((KIND SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %FINALIZE-CASES) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-CASE-RULE"
    "(DEFUN BUILD-CASE-RULE ((KIND SURROGATE)))" (CL:FUNCTION BUILD-CASE-RULE)
    NULL)
   (DEFINE-FUNCTION-OBJECT "ADD-CASE"
    "(DEFUN ADD-CASE ((INST SYMBOL) (KIND SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %ADD-CASE) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-CASE-FROM-INSTANCE"
    "(DEFUN BUILD-CASE-FROM-INSTANCE ((INST LOGIC-OBJECT) (KIND SURROGATE)))"
    (CL:FUNCTION BUILD-CASE-FROM-INSTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-CASE-INSTANCE-VECTOR"
    "(DEFUN (CREATE-CASE-INSTANCE-VECTOR VECTOR) ((CLASS SURROGATE)))"
    (CL:FUNCTION CREATE-CASE-INSTANCE-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "MATCH-INSTANCES"
    "(DEFUN (MATCH-INSTANCES FLOAT-WRAPPER) ((X LOGIC-OBJECT) (Y LOGIC-OBJECT)))"
    (CL:FUNCTION MATCH-INSTANCES) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-CASE-VALUE-VECTOR"
    "(DEFUN (CREATE-CASE-VALUE-VECTOR VECTOR) ((INSTANCES (LIST OF LOGIC-OBJECT)) (SLOT SURROGATE)))"
    (CL:FUNCTION CREATE-CASE-VALUE-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "GUESS"
    "(DEFUN (GUESS OBJECT) ((INST-NAME SYMBOL) (SLOT-NAME SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %GUESS) NULL)
   (DEFINE-FUNCTION-OBJECT "GENERATE-CASE-BASED-ANSWER"
    "(DEFUN (GENERATE-CASE-BASED-ANSWER OBJECT) ((PROBE LOGIC-OBJECT) (SLOT SURROGATE) (CASES LIST)))"
    (CL:FUNCTION GENERATE-CASE-BASED-ANSWER) NULL)
   (DEFINE-FUNCTION-OBJECT "COMBINE-CASE-ANSWERS"
    "(DEFUN (COMBINE-CASE-ANSWERS OBJECT) ((CLOSEST (VECTOR OF INTEGER-WRAPPER)) (SCORES (VECTOR OF FLOAT-WRAPPER)) (SLOTS (VECTOR OF OBJECT))))"
    (CL:FUNCTION COMBINE-CASE-ANSWERS) NULL)
   (DEFINE-FUNCTION-OBJECT "TRAIN-CASE-MATCHER"
    "(DEFUN TRAIN-CASE-MATCHER ((CLASS-NAME SYMBOL) (SLOT-NAME SYMBOL) (CYCLES INTEGER)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %TRAIN-CASE-MATCHER)
    (CL:FUNCTION TRAIN-CASE-MATCHER-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "GENERATE-CASE-RULE-WO-SLOT"
    "(DEFUN GENERATE-CASE-RULE-WO-SLOT ((CASES (VECTOR OF LOGIC-OBJECT)) (CLASS-NAME SYMBOL) (SLOT-NAME SYMBOL)))"
    (CL:FUNCTION GENERATE-CASE-RULE-WO-SLOT) NULL)
   (DEFINE-FUNCTION-OBJECT "TRAIN-AND-TEST-CASE-MATCHER"
    "(DEFUN (TRAIN-AND-TEST-CASE-MATCHER FLOAT) ((CLASS-NAME SYMBOL) (SLOT-NAME SYMBOL) (NUM-TRAIN INTEGER) (NUM-TEST INTEGER) (CYCLES INTEGER)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %TRAIN-AND-TEST-CASE-MATCHER)
    (CL:FUNCTION TRAIN-AND-TEST-CASE-MATCHER-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "TEST-CASE-BASED-REASONER"
    "(DEFUN (TEST-CASE-BASED-REASONER FLOAT) ((CLASS-NAME SYMBOL) (SLOT-NAME SYMBOL) (NUM-TRAIN INTEGER) (NUM-TEST INTEGER)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %TEST-CASE-BASED-REASONER)
    (CL:FUNCTION TEST-CASE-BASED-REASONER-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "TEST-CASE-MATCHER"
    "(DEFUN (TEST-CASE-MATCHER FLOAT) ((CLASS-NAME SYMBOL) (SLOT-NAME SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %TEST-CASE-MATCHER)
    (CL:FUNCTION TEST-CASE-MATCHER-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "GENERATE-CASE-TRAINING-EXAMPLES"
    "(DEFUN (GENERATE-CASE-TRAINING-EXAMPLES INTEGER) ((INSTANCES (VECTOR OF LOGIC-OBJECT)) (SLOT SURROGATE)))"
    (CL:FUNCTION GENERATE-CASE-TRAINING-EXAMPLES) NULL)
   (DEFINE-FUNCTION-OBJECT "NORMALIZE-NUMBERS"
    "(DEFUN NORMALIZE-NUMBERS ((VECT (VECTOR OF FLOAT-WRAPPER))))"
    (CL:FUNCTION NORMALIZE-NUMBERS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-SLOT-FROM-CLASS"
    "(DEFUN CLEAR-SLOT-FROM-CLASS ((CLASS-NAME SYMBOL) (SLOT-NAME SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %CLEAR-SLOT-FROM-CLASS) NULL)
   (DEFINE-FUNCTION-OBJECT "LOGIC-SYMBOL"
    "(DEFUN (LOGIC-SYMBOL OBJECT) ((OBJ OBJECT)))" (CL:FUNCTION LOGIC-SYMBOL)
    NULL)
   (DEFINE-FUNCTION-OBJECT "CALCULATE-CASE-MATCH"
    "(DEFUN (CALCULATE-CASE-MATCH FLOAT) ((X OBJECT) (Y OBJECT)))"
    (CL:FUNCTION CALCULATE-CASE-MATCH) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-MOST-SPECIFIC-CLASSES"
    "(DEFUN (GET-MOST-SPECIFIC-CLASSES CONS) ((INSTANCE LOGIC-OBJECT)))"
    (CL:FUNCTION GET-MOST-SPECIFIC-CLASSES) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-UNIQUE-VARIABLE-NAMES"
    "(DEFUN (FIND-UNIQUE-VARIABLE-NAMES LIST) ((TREE CONS) (NAMES (LIST OF SYMBOL))))"
    (CL:FUNCTION FIND-UNIQUE-VARIABLE-NAMES) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLIZE-CONS-PROPOSITIONS"
    "(DEFUN (VARIABLIZE-CONS-PROPOSITIONS (LIST OF CONS)) ((ANTECEDENT (LIST OF CONS))))"
    (CL:FUNCTION VARIABLIZE-CONS-PROPOSITIONS) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLIZE-INSTANCES"
    "(DEFUN (VARIABLIZE-INSTANCES (LIST OF CONS)) ((FORM (LIST OF CONS)) (INSTANCES (LIST OF OBJECT))))"
    (CL:FUNCTION VARIABLIZE-INSTANCES) NULL)
   (DEFINE-FUNCTION-OBJECT "STRING-ARGUMENT?"
    "(DEFUN (STRING-ARGUMENT? BOOLEAN) ((CLAUSE CONS)))"
    (CL:FUNCTION STRING-ARGUMENT?) NULL)
   (DEFINE-FUNCTION-OBJECT "FILTER-ANTECEDENT"
    "(DEFUN FILTER-ANTECEDENT ((ANTECEDENT (LIST OF CONS)) (RULE-NAME STRING)))"
    (CL:FUNCTION FILTER-ANTECEDENT) NULL)
   (DEFINE-FUNCTION-OBJECT "FIND-MATCHING-CASE-VARS"
    "(DEFUN (FIND-MATCHING-CASE-VARS CONS) ((CLAUSE CONS) (ANTECEDENT (LIST OF CONS)) (GENERATED-VARIABLES LIST)))"
    (CL:FUNCTION FIND-MATCHING-CASE-VARS) NULL)
   (DEFINE-FUNCTION-OBJECT "PARAMETERS-ALIGNED?"
    "(DEFUN (PARAMETERS-ALIGNED? BOOLEAN) ((CLAUSE1 CONS) (CLAUSE2 CONS) (VARS LIST)))"
    (CL:FUNCTION PARAMETERS-ALIGNED?) NULL)
   (DEFINE-FUNCTION-OBJECT "VARIABLE-ARG?"
    "(DEFUN (VARIABLE-ARG? BOOLEAN) ((ARG OBJECT)))"
    (CL:FUNCTION VARIABLE-ARG?) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-VARIABLE-CONSTRAINTS"
    "(DEFUN (BUILD-VARIABLE-CONSTRAINTS CONS) ((INSTANCES (LIST OF SYMBOL))))"
    (CL:FUNCTION BUILD-VARIABLE-CONSTRAINTS) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-TYPE-DEFS"
    "(DEFUN (BUILD-TYPE-DEFS (LIST OF SYMBOL)) ((INSTANCES (LIST OF SYMBOL))))"
    (CL:FUNCTION BUILD-TYPE-DEFS) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-PRINT-CASE-DISTANCES"
    "(DEFUN SET-PRINT-CASE-DISTANCES ((B BOOLEAN)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-PRINT-CASE-DISTANCES)
    (CL:FUNCTION SET-PRINT-CASE-DISTANCES-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "GET-NEAREST-NEIGHBORS"
    "(DEFUN (GET-NEAREST-NEIGHBORS (LIST OF TRAINING-EXAMPLE)) ((PROBE TRAINING-EXAMPLE) (CASES (LIST OF TRAINING-EXAMPLE)) (K INTEGER)))"
    (CL:FUNCTION GET-NEAREST-NEIGHBORS) NULL)
   (DEFINE-FUNCTION-OBJECT "EUCLIDEAN-DISTANCE"
    "(DEFUN (EUCLIDEAN-DISTANCE FLOAT) ((VEC1 (VECTOR OF FLOAT-WRAPPER)) (VEC2 (VECTOR OF FLOAT-WRAPPER))))"
    (CL:FUNCTION EUCLIDEAN-DISTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "HAMMING-DISTANCE"
    "(DEFUN (HAMMING-DISTANCE INTEGER) ((VEC1 (VECTOR OF INTEGER-WRAPPER)) (VEC2 (VECTOR OF INTEGER-WRAPPER))))"
    (CL:FUNCTION HAMMING-DISTANCE) NULL)
   (DEFINE-FUNCTION-OBJECT "INTERN-LOGIC-SYMBOL"
    "(DEFUN (INTERN-LOGIC-SYMBOL SYMBOL) ((NAME STRING)))"
    (CL:FUNCTION INTERN-LOGIC-SYMBOL) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-CASE-BASED"
    "(DEFUN STARTUP-CASE-BASED () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-CASE-BASED) NULL)
   (CL:LET*
    ((FUNCTION (LOOKUP-FUNCTION SYM-CASE-BASED-LOGIC-STARTUP-CASE-BASED)))
    (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
     SYM-CASE-BASED-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupCaseBased") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-CASE-BASED ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-CASE-BASED1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4) (HELP-STARTUP-CASE-BASED2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-CASE-BASED3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOG-MATCH-RULES* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LOG-ANTECEDENT-CONSTRUCTION* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NUM-NEIGHBORS* INTEGER 3)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CASE-SOLUTION-COMBINATION* KEYWORD :WEIGHTED-VOTE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CASE-RULE-NAMES* (LIST OF SYMBOL) (NEW (LIST OF SYMBOL)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NUM-CASES* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NUM-TRAINING-PER-CASE* INTEGER 12)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CASE-VARIABLE-COUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *BASE-COUNTER* INTEGER 0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *VISITED-INSTANCES* (LIST OF SYMBOL) (NEW (LIST OF SYMBOL)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ONLY-VARIABLIZE-VISITED-INSTANCES* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *VISITED-PROPOSITIONS* (LIST OF PROPOSITION) (NEW (LIST OF PROPOSITION)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SEEN-INSTANCES* (LIST OF SYMBOL) NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DELETED-CASE-VARIABLES* (LIST OF SYMBOL) NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SYMBOL-VARIABLE-HASH-TABLE* (HASH-TABLE OF SYMBOL SYMBOL) NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CASE-ANTECEDENT-TABLE* (STRING-HASH-TABLE OF STRING (LIST OF CONS)) (NEW (STRING-HASH-TABLE OF STRING (LIST OF CONS))))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CASE-TYPES-TABLE* (STRING-HASH-TABLE OF STRING (LIST OF SYMBOL)) (NEW (STRING-HASH-TABLE OF STRING (LIST OF SYMBOL))))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *CASE-NAME-TABLE* (HASH-TABLE OF SYMBOL (LIST OF SYMBOL)) (NEW (HASH-TABLE OF SYMBOL (LIST OF SYMBOL))))")
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-SET-NUM-NEIGHBORS
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-SET-CASE-SOLUTION-COMBINATION
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-SET-NUM-TRAINING-PER-CASE
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-FINALIZE-CASES
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-ADD-CASE
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-GUESS
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-TRAIN-CASE-MATCHER
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-TRAIN-AND-TEST-CASE-MATCHER
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-TEST-CASE-BASED-REASONER
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-TEST-CASE-MATCHER
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-CLEAR-SLOT-FROM-CLASS
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PRINT-CASE-DISTANCES* BOOLEAN FALSE)")
    (REGISTER-NATIVE-NAME SYM-CASE-BASED-LOGIC-SET-PRINT-CASE-DISTANCES
     KWD-CASE-BASED-COMMON-LISP KWD-CASE-BASED-FUNCTION))))
