;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; loom-to-kif.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2010      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-INVERSE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-INVERSE NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-BINARY NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-UNARY NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-KAPPA NULL)
(CL:DEFVAR SGT-LOOM-TO-KIF-STELLA-CONS NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-AT-LEAST NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-AT-MOST NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-EXACTLY NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-ALL NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-SOME NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-THE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-FILLED-BY NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-FILLERS NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-NOT-FILLED-BY NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-QUALIFIED-RANGE-CARDINALITY-LOWER-BOUND NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-QUALIFIED-RANGE-CARDINALITY-UPPER-BOUND NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-QUALIFIED-RANGE-CARDINALITY NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-CARDINALITY-LOWER-BOUND NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-CARDINALITY-UPPER-BOUND NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-CARDINALITY NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-EXISTS NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-=> NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-AND NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-TYPE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-NOT NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-RELATES NULL)
(CL:DEFVAR SGT-LOOM-TO-KIF-STELLA-NUMBER-WRAPPER NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-FOR-SOME NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-FORALL NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-THROUGH NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-INTERVAL++ NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-INTERVAL+- NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-INTERVAL-+ NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-INTERVAL-- NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-=< NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-< NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA->= NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-> NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-OR NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-SAME-AS NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-<= NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-<> NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-= NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-ONE-OF NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-THE-ORDERED-SET NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-SATISFIES NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-DOMAIN NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-DOMAINS NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-RANGE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-COMPOSE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-MEMBER-OF NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-SETOF NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-LISTOF NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-ERROR NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-ABOUT NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-CREATE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-SUPERRELATIONS NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-SUPERCONCEPTS NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-SUBSET-OF NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-QUOTE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-RETRACT NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-ASSERT NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-3-VALUED-P NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-ASK NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-NULL NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-CONSIFY NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-RETRIEVE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-PROGN NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-EVAL-WHEN NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-TELL NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-FORGET NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-TELLM NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-FORGETM NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-CREATEM NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-DEFCONCEPT NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-DEFSET NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-DEFRELATION NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-DEFPROPERTY NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-DEFCONTEXT NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-ADD-VALUE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-SET-VALUE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-FADD-VALUE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-CHANGE-CONTEXT NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-IN-CONTEXT NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-IN-KB NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-CC NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-NIL NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-IN-DIALECT NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-KIF NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-IN-MODULE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-TRANSLATE-LOOM-FILE NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-COMMON-LISP NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-FUNCTION NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-THING NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-MUTUALLY-DISJOINT-COLLECTION NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-SETOF NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-COVERING NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-SINGLE-VALUED NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-CLOSED-WORLD NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-CLOSED NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-COMMUTATIVE NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-COMMUTATIVE NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-SYMMETRIC NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-PL-KERNEL-KB-SYMMETRIC NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-CLOS-CLASS NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-MULTIPLE-VALUED NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-HASH-ON-DOMAINS NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-NON-EXPORTED NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-PERFECT NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-CLOSED-ON-CONSTANTS NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-BACKWARD-CHAINING NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-MONOTONIC NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-TEMPORAL NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-~> NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-ATTRIBUTES NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-CHARACTERISTICS NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-PARTITION NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-PARTITIONS NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-IMPLIES NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-CONSTRAINTS NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-EXHAUSTIVE-PARTITION NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-EXHAUSTIVE-PARTITIONS NULL)
(CL:DEFVAR SGT-LOOM-TO-KIF-STELLA-STRING-WRAPPER NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-IS-PRIMITIVE NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-IS NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-DEFAULTS NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-DOMAIN NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-DOMAINS NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-RANGE NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-ARITY NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-IN-PARTITION NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-ANNOTATIONS NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-ROLES NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-NAME NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-IDENTIFIER NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-DEFFUNCTION NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF--> NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-DOCUMENTATION NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-<<=>> NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-=>> NULL)
(CL:DEFVAR KWD-LOOM-TO-KIF-AXIOMS NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-LOGIC-STARTUP-LOOM-TO-KIF NULL)
(CL:DEFVAR SYM-LOOM-TO-KIF-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* STANDARD-ERROR *LOGIC-MODULE*
  STANDARD-OUTPUT EOL NIL SYSTEM-DEFINED-ARGUMENT-NAMES))

;;; (DEFUN (LOOM-ARGUMENT-DESCRIPTION-TO-KIF OBJECT) ...)

(CL:DEFUN LOOM-ARGUMENT-DESCRIPTION-TO-KIF (TREE ARITY)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-LOOM-TO-KIF-STELLA-CONS)
    (CL:PROGN
     (CL:WHEN
      (CL:OR (CL:EQ (%%VALUE TREE) SYM-LOOM-TO-KIF-STELLA-INVERSE)
       (CL:EQ (%%VALUE TREE) SYM-LOOM-TO-KIF-PL-KERNEL-KB-INVERSE))
      (CL:RETURN-FROM LOOM-ARGUMENT-DESCRIPTION-TO-KIF
       (LIST* SYM-LOOM-TO-KIF-PL-KERNEL-KB-INVERSE
        (LOOM-ARGUMENT-DESCRIPTION-TO-KIF (%%VALUE (%%REST TREE))
         KWD-LOOM-TO-KIF-BINARY)
        NIL)))
     (CL:LET*
      ((X (NTH SYSTEM-DEFINED-ARGUMENT-NAMES 0))
       (Y (NTH SYSTEM-DEFINED-ARGUMENT-NAMES 1))
       (KAPPAARGS
        (CL:IF (CL:EQ ARITY KWD-LOOM-TO-KIF-UNARY) (CONS-LIST X)
         (CONS-LIST X Y)))
       (IMPLICITARGS (COPY-CONS-LIST KAPPAARGS)))
      (LIST* SYM-LOOM-TO-KIF-LOGIC-KAPPA KAPPAARGS
       (CONS (LOOM-DESCRIPTION-TO-KIF TREE IMPLICITARGS) NIL)))))
   (CL:T TREE)))

;;; (DEFUN (LOOM-RESTRICTION-TO-KIF CONS) ...)

(CL:DEFUN LOOM-RESTRICTION-TO-KIF (TREE IMPLICITVARIABLE)
  (CL:LET*
   ((OPERATOR (%%VALUE TREE)) (ROLE NULL) (ARGUMENT NULL)
    (EXISTSVARIABLE NULL) (QUALIFICATION (FOURTH TREE)))
   (CL:IF
    (MEMBER?
     (GET-QUOTED-TREE "((AT-LEAST AT-MOST EXACTLY) \"/LOGIC\")" "/LOGIC")
     OPERATOR)
    (CL:PROGN (CL:SETQ ARGUMENT (%%VALUE (%%REST TREE)))
     (CL:SETQ ROLE (%%VALUE (%%REST (%%REST TREE)))))
    (CL:PROGN (CL:SETQ ROLE (%%VALUE (%%REST TREE)))
     (CL:SETQ ARGUMENT (%%VALUE (%%REST (%%REST TREE))))))
   (CL:COND
    ((CL:OR (CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-AT-LEAST)
      (CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-AT-MOST)
      (CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-EXACTLY))
     (CL:IF (CL:NOT (CL:EQ QUALIFICATION NULL))
      (CL:COND
       ((CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-AT-LEAST)
        (CL:SETQ OPERATOR
         SYM-LOOM-TO-KIF-PL-KERNEL-KB-QUALIFIED-RANGE-CARDINALITY-LOWER-BOUND))
       ((CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-AT-MOST)
        (CL:SETQ OPERATOR
         SYM-LOOM-TO-KIF-PL-KERNEL-KB-QUALIFIED-RANGE-CARDINALITY-UPPER-BOUND))
       ((CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-EXACTLY)
        (CL:SETQ OPERATOR
         SYM-LOOM-TO-KIF-PL-KERNEL-KB-QUALIFIED-RANGE-CARDINALITY))
       (CL:T
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" OPERATOR
          "' is not a valid case option")
         (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
      (CL:COND
       ((CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-AT-LEAST)
        (CL:SETQ OPERATOR
         SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-CARDINALITY-LOWER-BOUND))
       ((CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-AT-MOST)
        (CL:SETQ OPERATOR
         SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-CARDINALITY-UPPER-BOUND))
       ((CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-EXACTLY)
        (CL:SETQ OPERATOR SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-CARDINALITY))
       (CL:T
        (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" OPERATOR
          "' is not a valid case option")
         (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
     (CONS OPERATOR
      (CONS (LOOM-ARGUMENT-DESCRIPTION-TO-KIF ROLE KWD-LOOM-TO-KIF-BINARY)
       (CONS IMPLICITVARIABLE
        (CONS ARGUMENT
         (CONCATENATE
          (CL:IF (CL:NOT (CL:EQ QUALIFICATION NULL))
           (CONS-LIST
            (LOOM-ARGUMENT-DESCRIPTION-TO-KIF QUALIFICATION
             KWD-LOOM-TO-KIF-UNARY))
           NIL)
          NIL))))))
    ((CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-ALL)
     (CL:IF (CL:NOT (CL:EQ QUALIFICATION NULL))
      (CL:PROGN
       (CL:LET* ((V NULL) (ITER-000 SYSTEM-DEFINED-ARGUMENT-NAMES))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ V (%%VALUE ITER-000))
         (CL:WHEN (CL:NOT (CL:EQ IMPLICITVARIABLE V))
          (CL:SETQ EXISTSVARIABLE V) (CL:RETURN))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (LIST* SYM-LOOM-TO-KIF-STELLA-EXISTS (CONS EXISTSVARIABLE NIL)
        (LIST* SYM-LOOM-TO-KIF-STELLA-=>
         (LIST* SYM-LOOM-TO-KIF-STELLA-AND
          (CONS (LOOM-ARGUMENT-DESCRIPTION-TO-KIF ROLE KWD-LOOM-TO-KIF-BINARY)
           (CONS IMPLICITVARIABLE (CONS EXISTSVARIABLE NIL)))
          (CONS
           (LOOM-ARGUMENT-DESCRIPTION-TO-KIF QUALIFICATION
            KWD-LOOM-TO-KIF-UNARY)
           (CONS EXISTSVARIABLE NIL))
          NIL)
         (CONS
          (LOOM-ARGUMENT-DESCRIPTION-TO-KIF ARGUMENT KWD-LOOM-TO-KIF-UNARY)
          (CONS (NTH SYSTEM-DEFINED-ARGUMENT-NAMES 0) NIL))
         NIL)
        NIL))
      (LIST* SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-TYPE
       (LOOM-ARGUMENT-DESCRIPTION-TO-KIF ROLE KWD-LOOM-TO-KIF-BINARY)
       (CONS IMPLICITVARIABLE
        (CONS
         (LOOM-ARGUMENT-DESCRIPTION-TO-KIF ARGUMENT KWD-LOOM-TO-KIF-UNARY)
         NIL)))))
    ((CL:EQ OPERATOR SYM-LOOM-TO-KIF-STELLA-SOME)
     (LOOM-RESTRICTION-TO-KIF
      (LIST* SYM-LOOM-TO-KIF-LOGIC-AT-LEAST (WRAP-INTEGER 1) ROLE
       (CONS ARGUMENT NIL))
      IMPLICITVARIABLE))
    ((CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-THE)
     (LOOM-DESCRIPTION-TO-KIF
      (LIST* SYM-LOOM-TO-KIF-STELLA-AND
       (LIST* SYM-LOOM-TO-KIF-LOGIC-EXACTLY (WRAP-INTEGER 1) ROLE NIL)
       (LIST* SYM-LOOM-TO-KIF-LOGIC-ALL ROLE (CONS ARGUMENT NIL)) NIL)
      (CONS-LIST IMPLICITVARIABLE)))
    ((CL:OR (CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-FILLED-BY)
      (CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-FILLERS))
     (CL:LET*
      ((CLAUSES NIL)
       (TRANSLATEDROLE
        (LOOM-ARGUMENT-DESCRIPTION-TO-KIF ROLE KWD-LOOM-TO-KIF-BINARY)))
      (CL:LET*
       ((FILLER NULL) (ITER-001 (%%REST (%%REST TREE))) (COLLECT-000 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ FILLER (%%VALUE ITER-001))
        (CL:IF (CL:EQ COLLECT-000 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-000
           (CONS
            (CONS TRANSLATEDROLE (CONS IMPLICITVARIABLE (CONS FILLER NIL)))
            NIL))
          (CL:IF (CL:EQ CLAUSES NIL) (CL:SETQ CLAUSES COLLECT-000)
           (ADD-CONS-TO-END-OF-CONS-LIST CLAUSES COLLECT-000)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-000)
           (CONS
            (CONS TRANSLATEDROLE (CONS IMPLICITVARIABLE (CONS FILLER NIL)))
            NIL))
          (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
        (CL:SETQ ITER-001 (%%REST ITER-001))))
      (CONJOIN-SENTENCES CLAUSES)))
    ((CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-NOT-FILLED-BY)
     (CL:LET*
      ((CLAUSES NIL)
       (TRANSLATEDROLE
        (LOOM-ARGUMENT-DESCRIPTION-TO-KIF ROLE KWD-LOOM-TO-KIF-BINARY)))
      (CL:LET*
       ((FILLER NULL) (ITER-002 (%%REST (%%REST TREE))) (COLLECT-001 NULL))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
        (CL:SETQ FILLER (%%VALUE ITER-002))
        (CL:IF (CL:EQ COLLECT-001 NULL)
         (CL:PROGN
          (CL:SETQ COLLECT-001
           (CONS
            (LIST* SYM-LOOM-TO-KIF-STELLA-NOT
             (CONS TRANSLATEDROLE (CONS IMPLICITVARIABLE (CONS FILLER NIL)))
             NIL)
            NIL))
          (CL:IF (CL:EQ CLAUSES NIL) (CL:SETQ CLAUSES COLLECT-001)
           (ADD-CONS-TO-END-OF-CONS-LIST CLAUSES COLLECT-001)))
         (CL:PROGN
          (CL:SETF (%%REST COLLECT-001)
           (CONS
            (LIST* SYM-LOOM-TO-KIF-STELLA-NOT
             (CONS TRANSLATEDROLE (CONS IMPLICITVARIABLE (CONS FILLER NIL)))
             NIL)
            NIL))
          (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
        (CL:SETQ ITER-002 (%%REST ITER-002))))
      (CONJOIN-SENTENCES CLAUSES)))
    (CL:T
     (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" OPERATOR
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002))))))))

;;; (DEFUN (LOOM-RELATES-TO-KIF CONS) ...)

(CL:DEFUN LOOM-RELATES-TO-KIF (TREE IMPLICITVARIABLES)
  (CL:WHEN (CL:EQ (%%VALUE TREE) SYM-LOOM-TO-KIF-LOGIC-RELATES)
   (CL:SETQ TREE (%%REST TREE)))
  (CL:LET*
   ((CLAUSES NIL) (EXISTSVARIABLES NIL) (ARGUMENTS NIL) (SKOLEMVARIABLES NIL))
   (CL:LET* ((V NULL) (ITER-000 SYSTEM-DEFINED-ARGUMENT-NAMES))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ V (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (CL:NOT (MEMBER? IMPLICITVARIABLES V))
       (CL:< (LENGTH SKOLEMVARIABLES) (CL:1- (LENGTH TREE))))
      (CL:SETQ SKOLEMVARIABLES (CONS V SKOLEMVARIABLES)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:LET*
    ((ARG NULL) (ITER-001 (%%REST TREE)) (V NULL) (ITER-002 SKOLEMVARIABLES)
     (COLLECT-000 NULL))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-001 NIL)) (CL:NOT (CL:EQ ITER-002 NIL))) DO
     (CL:SETQ ARG (%%VALUE ITER-001)) (CL:SETQ V (%%VALUE ITER-002))
     (CL:TAGBODY
      (CL:PROGN
       (CL:WHEN (ISA? ARG SGT-LOOM-TO-KIF-STELLA-NUMBER-WRAPPER)
        (CL:SETQ ARGUMENTS (CONS ARG ARGUMENTS)) (CL:GO :CONTINUE))
       (CL:SETQ ARGUMENTS (CONS V ARGUMENTS))
       (CL:SETQ EXISTSVARIABLES (CONS V EXISTSVARIABLES)))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000
         (CONS
          (LOOM-DESCRIPTION-TO-KIF ARG
           (CONS-LIST (%%VALUE IMPLICITVARIABLES) V))
          NIL))
        (CL:IF (CL:EQ CLAUSES NIL) (CL:SETQ CLAUSES COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST CLAUSES COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS
          (LOOM-DESCRIPTION-TO-KIF ARG
           (CONS-LIST (%%VALUE IMPLICITVARIABLES) V))
          NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
      :CONTINUE)
     (CL:SETQ ITER-001 (%%REST ITER-001))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (LIST* SYM-LOOM-TO-KIF-STELLA-EXISTS (REVERSE EXISTSVARIABLES)
    (CONS
     (CONS SYM-LOOM-TO-KIF-STELLA-AND
      (CONCATENATE CLAUSES
       (CONS (LOOM-DESCRIPTION-TO-KIF (%%VALUE TREE) (REVERSE ARGUMENTS))
        NIL)))
     NIL))))

;;; (DEFUN SUBSTITUTE-VARIABLES-IN-TREE ...)

(CL:DEFUN SUBSTITUTE-VARIABLES-IN-TREE (TREE SUBSTITUTION)
  (CL:LET* ((OPERATOR (%%VALUE TREE)))
   (CL:LET* ((TEST-VALUE-000 OPERATOR))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-EXISTS)
       (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-FOR-SOME)
       (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-FORALL))
      (CL:WHEN (CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-FOR-SOME)
       (FIRST-SETTER TREE SYM-LOOM-TO-KIF-STELLA-EXISTS))
      (CL:LET* ((VARIABLES (%%VALUE (%%REST TREE))))
       (CL:WHEN (CL:NOT (CONS? VARIABLES))
        (CL:SETQ VARIABLES (CONS-LIST VARIABLES)))
       (CL:LET* ((V1 NULL) (ITER-000 VARIABLES))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ V1 (%%VALUE ITER-000))
         (CL:WHEN (MEMBER? SUBSTITUTION V1)
          (CL:LET* ((V2 NULL) (ITER-001 SYSTEM-DEFINED-ARGUMENT-NAMES))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
            (CL:SETQ V2 (%%VALUE ITER-001))
            (CL:WHEN (CL:NOT (MEMBER? SUBSTITUTION V2))
             (CL:SETQ SUBSTITUTION (CONS V2 SUBSTITUTION))
             (CL:SETQ SUBSTITUTION (CONS V1 SUBSTITUTION)) (CL:RETURN))
            (CL:SETQ ITER-001 (%%REST ITER-001)))))
         (CL:SETQ ITER-000 (%%REST ITER-000)))))
      (SUBSTITUTE-VARIABLES-IN-TREE (%%REST TREE) SUBSTITUTION))
     (CL:T
      (CL:LET* ((IT1 (ALLOCATE-ITERATOR TREE)))
       (CL:LOOP WHILE (NEXT? IT1) DO
        (CL:LET* ((ARG (%VALUE IT1)))
         (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE ARG)))
          (CL:COND
           ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
            (CL:PROGN
             (CL:WHEN (QUESTION-MARK-SYMBOL? ARG)
              (CL:LET* ((IT2 (ALLOCATE-ITERATOR SUBSTITUTION)))
               (CL:LOOP WHILE (NEXT? IT2) DO
                (CL:WHEN (CL:EQ (%VALUE IT2) ARG) (NEXT? IT2)
                 (VALUE-SETTER IT1 (%VALUE IT2)) (CL:RETURN)))))))
           ((CL:EQ TEST-VALUE-001 SGT-LOOM-TO-KIF-STELLA-CONS)
            (CL:PROGN (SUBSTITUTE-VARIABLES-IN-TREE ARG SUBSTITUTION)))
           (CL:T)))))))))))

;;; (DEFUN (LOOM-THROUGH-TO-KIF CONS) ...)

(CL:DEFUN LOOM-THROUGH-TO-KIF (TREE IMPLICITVARIABLES)
  (CL:LET*
   ((LOWERBOUND (%%VALUE (%%REST TREE)))
    (UPPERBOUND (%%VALUE (%%REST (%%REST TREE)))) (CLAUSES NIL))
   (CL:WHEN (ISA? UPPERBOUND SGT-LOOM-TO-KIF-STELLA-NUMBER-WRAPPER)
    (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
     (CL:COND
      ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-THROUGH)
        (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-INTERVAL++)
        (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-INTERVAL+-))
       (CL:SETQ CLAUSES
        (CONS
         (LIST* SYM-LOOM-TO-KIF-STELLA-=< (%%VALUE IMPLICITVARIABLES)
          (CONS UPPERBOUND NIL))
         CLAUSES)))
      ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-INTERVAL-+)
        (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-INTERVAL--))
       (CL:SETQ CLAUSES
        (CONS
         (LIST* SYM-LOOM-TO-KIF-STELLA-< (%%VALUE IMPLICITVARIABLES)
          (CONS UPPERBOUND NIL))
         CLAUSES)))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
         "' is not a valid case option")
        (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))
   (CL:WHEN (ISA? LOWERBOUND SGT-LOOM-TO-KIF-STELLA-NUMBER-WRAPPER)
    (CL:LET* ((TEST-VALUE-001 (%%VALUE TREE)))
     (CL:COND
      ((CL:OR (CL:EQ TEST-VALUE-001 SYM-LOOM-TO-KIF-LOGIC-THROUGH)
        (CL:EQ TEST-VALUE-001 SYM-LOOM-TO-KIF-LOGIC-INTERVAL++)
        (CL:EQ TEST-VALUE-001 SYM-LOOM-TO-KIF-LOGIC-INTERVAL-+))
       (CL:SETQ CLAUSES
        (CONS
         (LIST* SYM-LOOM-TO-KIF-STELLA->= (%%VALUE IMPLICITVARIABLES)
          (CONS LOWERBOUND NIL))
         CLAUSES)))
      ((CL:OR (CL:EQ TEST-VALUE-001 SYM-LOOM-TO-KIF-LOGIC-INTERVAL+-)
        (CL:EQ TEST-VALUE-001 SYM-LOOM-TO-KIF-LOGIC-INTERVAL--))
       (CL:SETQ CLAUSES
        (CONS
         (LIST* SYM-LOOM-TO-KIF-STELLA-> (%%VALUE IMPLICITVARIABLES)
          (CONS LOWERBOUND NIL))
         CLAUSES)))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" TEST-VALUE-001
         "' is not a valid case option")
        (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
   (CONJOIN-SENTENCES CLAUSES)))

;;; (DEFUN (LOOM-SATISFIES-TO-KIF CONS) ...)

(CL:DEFUN LOOM-SATISFIES-TO-KIF (TREE IMPLICITVARIABLES)
  (CL:LET*
   ((IOVARIABLES (%%VALUE (%%REST TREE)))
    (BODY (%%VALUE (%%REST (%%REST TREE)))) (SUBSTITUTION NIL))
   (CL:WHEN (CL:NOT (CONS? IOVARIABLES))
    (CL:SETQ IOVARIABLES (CONS-LIST IOVARIABLES)))
   (CL:LET*
    ((V1 NULL) (ITER-000 IOVARIABLES) (V2 NULL) (ITER-001 IMPLICITVARIABLES))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-001 NIL))) DO
     (CL:SETQ V1 (%%VALUE ITER-000)) (CL:SETQ V2 (%%VALUE ITER-001))
     (CL:SETQ SUBSTITUTION (CONS V2 SUBSTITUTION))
     (CL:SETQ SUBSTITUTION (CONS V1 SUBSTITUTION))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (SUBSTITUTE-VARIABLES-IN-TREE BODY SUBSTITUTION) BODY))

;;; (DEFUN (LOOM-DESCRIPTION-TO-KIF CONS) ...)

(CL:DEFUN LOOM-DESCRIPTION-TO-KIF (TREE IMPLICITVARIABLES)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-LOOM-TO-KIF-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((OPERATOR (%%VALUE TREE)))
      (CL:LET* ((TEST-VALUE-000 OPERATOR))
       (CL:COND
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-AND)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-OR)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-NOT))
         (CL:LET* ((CLAUSES NIL))
          (CL:LET* ((ARG NULL) (ITER-000 (%%REST TREE)) (COLLECT-000 NULL))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
            (CL:SETQ ARG (%%VALUE ITER-000))
            (CL:IF (CL:EQ COLLECT-000 NULL)
             (CL:PROGN
              (CL:SETQ COLLECT-000
               (CONS (LOOM-DESCRIPTION-TO-KIF ARG IMPLICITVARIABLES) NIL))
              (CL:IF (CL:EQ CLAUSES NIL) (CL:SETQ CLAUSES COLLECT-000)
               (ADD-CONS-TO-END-OF-CONS-LIST CLAUSES COLLECT-000)))
             (CL:PROGN
              (CL:SETF (%%REST COLLECT-000)
               (CONS (LOOM-DESCRIPTION-TO-KIF ARG IMPLICITVARIABLES) NIL))
              (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
            (CL:SETQ ITER-000 (%%REST ITER-000))))
          (CONS OPERATOR (CONCATENATE CLAUSES NIL))))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-AT-LEAST)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-AT-MOST)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-EXACTLY)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-ALL)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-SOME)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-THE)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-FILLED-BY)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-FILLERS))
         (LOOM-RESTRICTION-TO-KIF TREE (%%VALUE IMPLICITVARIABLES)))
        ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-SAME-AS)
         (CL:LET* ((SELFVARIABLE (%%VALUE IMPLICITVARIABLES)) (Y NULL))
          (CL:LET* ((V NULL) (ITER-001 SYSTEM-DEFINED-ARGUMENT-NAMES))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
            (CL:SETQ V (%%VALUE ITER-001))
            (CL:WHEN (CL:NOT (CL:EQ V SELFVARIABLE)) (CL:SETQ Y V)
             (CL:RETURN))
            (CL:SETQ ITER-001 (%%REST ITER-001))))
          (CL:LET*
           ((LOCALIMPLICITVARIABLES (CONS-LIST SELFVARIABLE Y)) (CLAUSES NIL))
           (CL:LET* ((ARG NULL) (ITER-002 (%%REST TREE)) (COLLECT-001 NULL))
            (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
             (CL:SETQ ARG (%%VALUE ITER-002))
             (CL:IF (CL:EQ COLLECT-001 NULL)
              (CL:PROGN
               (CL:SETQ COLLECT-001
                (CONS (LOOM-DESCRIPTION-TO-KIF ARG LOCALIMPLICITVARIABLES)
                 NIL))
               (CL:IF (CL:EQ CLAUSES NIL) (CL:SETQ CLAUSES COLLECT-001)
                (ADD-CONS-TO-END-OF-CONS-LIST CLAUSES COLLECT-001)))
              (CL:PROGN
               (CL:SETF (%%REST COLLECT-001)
                (CONS (LOOM-DESCRIPTION-TO-KIF ARG LOCALIMPLICITVARIABLES)
                 NIL))
               (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
             (CL:SETQ ITER-002 (%%REST ITER-002))))
           (LIST* SYM-LOOM-TO-KIF-STELLA-EXISTS Y
            (CONS (CONS SYM-LOOM-TO-KIF-STELLA-AND (CONCATENATE CLAUSES NIL))
             NIL)))))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-RELATES)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA->)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-<)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA->=)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-<=)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-<>)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-=))
         (LOOM-RELATES-TO-KIF TREE IMPLICITVARIABLES))
        ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-ONE-OF)
         (CONS SYM-LOOM-TO-KIF-PL-KERNEL-KB-MEMBER-OF
          (CONCATENATE (COPY-CONS-LIST IMPLICITVARIABLES)
           (CONS
            (CONS SYM-LOOM-TO-KIF-STELLA-SETOF
             (CONCATENATE (%%REST TREE) NIL))
            NIL))))
        ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-THE-ORDERED-SET)
         (CONS SYM-LOOM-TO-KIF-PL-KERNEL-KB-MEMBER-OF
          (CONCATENATE (COPY-CONS-LIST IMPLICITVARIABLES)
           (CONS
            (CONS SYM-LOOM-TO-KIF-LOGIC-LISTOF
             (CONCATENATE (%%REST TREE) NIL))
            NIL))))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-THROUGH)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-INTERVAL++)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-INTERVAL+-)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-INTERVAL-+)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-INTERVAL--))
         (LOOM-THROUGH-TO-KIF TREE IMPLICITVARIABLES))
        ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-SATISFIES)
         (LOOM-SATISFIES-TO-KIF TREE IMPLICITVARIABLES))
        ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-DOMAIN)
         (LOOM-DESCRIPTION-TO-KIF (%%VALUE (%%REST TREE))
          (CONS-LIST (%%VALUE IMPLICITVARIABLES))))
        ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-DOMAINS)
         (CL:LET* ((CLAUSES NIL))
          (CL:LET*
           ((DOMAIN NULL) (ITER-003 (%%REST TREE)) (VAR NULL)
            (ITER-004 IMPLICITVARIABLES) (COLLECT-002 NULL))
           (CL:LOOP WHILE
            (CL:AND (CL:NOT (CL:EQ ITER-003 NIL))
             (CL:NOT (CL:EQ ITER-004 NIL)))
            DO (CL:SETQ DOMAIN (%%VALUE ITER-003))
            (CL:SETQ VAR (%%VALUE ITER-004))
            (CL:IF (CL:EQ COLLECT-002 NULL)
             (CL:PROGN
              (CL:SETQ COLLECT-002
               (CONS (LOOM-DESCRIPTION-TO-KIF DOMAIN (CONS-LIST VAR)) NIL))
              (CL:IF (CL:EQ CLAUSES NIL) (CL:SETQ CLAUSES COLLECT-002)
               (ADD-CONS-TO-END-OF-CONS-LIST CLAUSES COLLECT-002)))
             (CL:PROGN
              (CL:SETF (%%REST COLLECT-002)
               (CONS (LOOM-DESCRIPTION-TO-KIF DOMAIN (CONS-LIST VAR)) NIL))
              (CL:SETQ COLLECT-002 (%%REST COLLECT-002))))
            (CL:SETQ ITER-003 (%%REST ITER-003))
            (CL:SETQ ITER-004 (%%REST ITER-004))))
          (CONJOIN-SENTENCES CLAUSES)))
        ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-RANGE)
         (LOOM-DESCRIPTION-TO-KIF (%%VALUE (%%REST TREE))
          (CONS-LIST (LAST IMPLICITVARIABLES))))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-INVERSE)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-PL-KERNEL-KB-INVERSE))
         (CL:LET*
          ((INVERSEIMPLICITVARIABLES
            (CONS-LIST (%%VALUE (%%REST IMPLICITVARIABLES))
             (%%VALUE IMPLICITVARIABLES))))
          (LOOM-DESCRIPTION-TO-KIF (%%VALUE (%%REST TREE))
           INVERSEIMPLICITVARIABLES)))
        ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-COMPOSE)
         (CL:LET*
          ((CHAIN
            (CONS (%%VALUE (%%REST TREE))
             (CONS (%%VALUE IMPLICITVARIABLES) NIL))))
          (CL:LET* ((FUNCTION NULL) (ITER-005 (%%REST (%%REST TREE))))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
            (CL:SETQ FUNCTION (%%VALUE ITER-005))
            (CL:SETQ CHAIN (CONS FUNCTION (CONS CHAIN NIL)))
            (CL:SETQ ITER-005 (%%REST ITER-005))))
          (CONCATENATE CHAIN
           (CONS (%%VALUE (%%REST IMPLICITVARIABLES)) NIL))))
        (CL:T
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
          "Illegal or unimplemented Loom operator cannot be translated to KIF."
          EOL "   Problem expression:  `" TREE "'" EOL EOL)
         NIL))))))
   (CL:T
    (CL:COND
     ((CL:EQ TREE SYM-LOOM-TO-KIF-LOGIC-<>)
      (LIST* SYM-LOOM-TO-KIF-STELLA-NOT
       (CONS SYM-LOOM-TO-KIF-STELLA-=
        (CONCATENATE (COPY-CONS-LIST IMPLICITVARIABLES) NIL))
       NIL))
     (CL:T (CONS TREE (CONCATENATE (COPY-CONS-LIST IMPLICITVARIABLES) NIL)))))))

;;; (DEFUN (LOOM-DESCRIPTION-OPERATOR? BOOLEAN) ...)

(CL:DEFUN LOOM-DESCRIPTION-OPERATOR? (SELF)
  (MEMBER?
   (GET-QUOTED-TREE
    "((AND OR NOT AT-LEAST AT-MOST EXACTLY ALL SOME THE FILLED-BY FILLERS SAME-AS RELATES ONE-OF THROUGH) \"/LOGIC\")"
    "/LOGIC")
   SELF))

;;; (DEFUN (LOOM-SENTENCE-TO-KIF OBJECT) ...)

(CL:DEFUN LOOM-SENTENCE-TO-KIF (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-LOOM-TO-KIF-STELLA-CONS)
    (CL:PROGN
     (CL:WHEN (CL:NOT (SYMBOL? (%%VALUE TREE)))
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (CL:LET* ((*PRINTREADABLY?* CL:T))
        (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "ERROR: Illegal clause `"
         TREE "' in Loom formula.." EOL)
        (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000 KWD-LOOM-TO-KIF-ERROR))
       (CL:ERROR (NEW-PROPOSITION-ERROR (THE-STRING-READER STREAM-000)))))
     (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-AND)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-OR)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-NOT))
        (CL:LET* ((CLAUSES NIL))
         (CL:LET* ((ARG NULL) (ITER-000 (%%REST TREE)) (COLLECT-000 NULL))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:SETQ ARG (%%VALUE ITER-000))
           (CL:IF (CL:EQ COLLECT-000 NULL)
            (CL:PROGN
             (CL:SETQ COLLECT-000 (CONS (LOOM-SENTENCE-TO-KIF ARG) NIL))
             (CL:IF (CL:EQ CLAUSES NIL) (CL:SETQ CLAUSES COLLECT-000)
              (ADD-CONS-TO-END-OF-CONS-LIST CLAUSES COLLECT-000)))
            (CL:PROGN
             (CL:SETF (%%REST COLLECT-000)
              (CONS (LOOM-SENTENCE-TO-KIF ARG) NIL))
             (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
           (CL:SETQ ITER-000 (%%REST ITER-000))))
         (CL:SETQ CLAUSES (REVERSE CLAUSES))
         (CL:SETQ CLAUSES (CONS (%%VALUE TREE) CLAUSES)) CLAUSES))
       ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-ABOUT)
        (CL:LET* ((ABOUTCLAUSES NIL) (IMPLICITVARIABLES NULL))
         (CL:LET* ((CLAUSE NULL) (ITER-001 (%%REST (%%REST TREE))))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ CLAUSE (%%VALUE ITER-001))
           (CL:SETQ IMPLICITVARIABLES (CONS-LIST (%%VALUE (%%REST TREE))))
           (CL:COND
            ((CL:NOT (CONS? CLAUSE))
             (CL:SETQ ABOUTCLAUSES
              (CONS (CONS CLAUSE (CONCATENATE IMPLICITVARIABLES NIL))
               ABOUTCLAUSES)))
            ((LOOM-DESCRIPTION-OPERATOR? (%%VALUE CLAUSE))
             (CL:SETQ ABOUTCLAUSES
              (CONS (LOOM-DESCRIPTION-TO-KIF CLAUSE IMPLICITVARIABLES)
               ABOUTCLAUSES)))
            (CL:T
             (CL:LET* ((EXPRESSION CLAUSE))
              (CL:SETQ ABOUTCLAUSES
               (CONS
                (CONS (%%VALUE EXPRESSION)
                 (CONCATENATE IMPLICITVARIABLES
                  (CONCATENATE (COPY-CONS-LIST (%%REST EXPRESSION)) NIL)))
                ABOUTCLAUSES)))))
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (CONJOIN-SENTENCES (REVERSE ABOUTCLAUSES))))
       ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-CREATE)
        (TRANSLATE-LOOM-CREATE-CLAUSE (%%REST TREE)))
       (CL:T TREE)))))
   (CL:T TREE)))

;;; (DEFUN (COMPUTE-LOOM-DESCRIPTION-ARITY INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:FIXNUM) COMPUTE-LOOM-DESCRIPTION-ARITY))
(CL:DEFUN COMPUTE-LOOM-DESCRIPTION-ARITY (TREE)
  (CL:LET* ((TEST-VALUE-001 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-001)
     (CL:PROGN
      (CL:LET* ((DESCRIPTION (GET-DESCRIPTION TREE)))
       (CL:WHEN (CL:NOT (CL:EQ DESCRIPTION NULL))
        (CL:RETURN-FROM COMPUTE-LOOM-DESCRIPTION-ARITY
         (ARITY DESCRIPTION))))))
    ((CL:EQ TEST-VALUE-001 SGT-LOOM-TO-KIF-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
       (CL:COND
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-AND)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-OR))
         (CL:LET* ((ARG NULL) (ITER-000 (%%REST TREE)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:SETQ ARG (%%VALUE ITER-000))
           (CL:LET* ((GUESS (COMPUTE-LOOM-DESCRIPTION-ARITY ARG)))
            (CL:DECLARE (CL:TYPE CL:FIXNUM GUESS))
            (CL:WHEN (CL:> GUESS 0)
             (CL:RETURN-FROM COMPUTE-LOOM-DESCRIPTION-ARITY GUESS)))
           (CL:SETQ ITER-000 (%%REST ITER-000)))))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-AT-LEAST)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-AT-MOST)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-ALL)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-SAME-AS))
         (CL:RETURN-FROM COMPUTE-LOOM-DESCRIPTION-ARITY 1))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-DOMAIN)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-RANGE)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-INVERSE)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-PL-KERNEL-KB-INVERSE)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-COMPOSE))
         (CL:RETURN-FROM COMPUTE-LOOM-DESCRIPTION-ARITY 2))
        ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA->)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-<)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA->=)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-<=)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-<>)
          (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-=))
         (CL:RETURN-FROM COMPUTE-LOOM-DESCRIPTION-ARITY
          (LENGTH (%%REST TREE))))
        ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-RELATES)
         (CL:RETURN-FROM COMPUTE-LOOM-DESCRIPTION-ARITY
          (LENGTH (%%REST (%%REST TREE)))))
        ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-SATISFIES)
         (CL:LET* ((VARIABLES (%%VALUE (%%REST TREE))))
          (CL:IF (CONS? VARIABLES)
           (CL:RETURN-FROM COMPUTE-LOOM-DESCRIPTION-ARITY (LENGTH VARIABLES))
           (CL:RETURN-FROM COMPUTE-LOOM-DESCRIPTION-ARITY 1))))
        (CL:T)))))
    (CL:T)))
  -1)

;;; (DEFUN (ELIMINATE-LOOM-KEYWORDS OBJECT) ...)

(CL:DEFUN ELIMINATE-LOOM-KEYWORDS (TREE)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE TREE)))
   (CL:COND
    ((SUBTYPE-OF-KEYWORD? TEST-VALUE-000)
     (CL:PROGN
      (CL:RETURN-FROM ELIMINATE-LOOM-KEYWORDS
       (INTERN-SYMBOL-IN-MODULE (%SYMBOL-NAME TREE) *LOGIC-MODULE* CL:NIL))))
    ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
     (CL:PROGN
      (CL:COND
       ((CL:OR (CL:EQ TREE SYM-LOOM-TO-KIF-LOGIC-SUPERRELATIONS)
         (CL:EQ TREE SYM-LOOM-TO-KIF-LOGIC-SUPERCONCEPTS))
        (CL:RETURN-FROM ELIMINATE-LOOM-KEYWORDS
         SYM-LOOM-TO-KIF-PL-KERNEL-KB-SUBSET-OF))
       (CL:T))
      (CL:WHEN (STRING-EQL? (%SYMBOL-NAME TREE) "/=")
       (CL:RETURN-FROM ELIMINATE-LOOM-KEYWORDS SYM-LOOM-TO-KIF-LOGIC-<>))))
    ((CL:EQ TEST-VALUE-000 SGT-LOOM-TO-KIF-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((IT (ALLOCATE-ITERATOR TREE)))
       (CL:LOOP WHILE (NEXT? IT) DO
        (VALUE-SETTER IT (ELIMINATE-LOOM-KEYWORDS (%VALUE IT)))))
      (CL:WHEN
       (CL:OR (CL:EQ (%%VALUE TREE) NULL) (CL:NOT (SYMBOL? (%%VALUE TREE))))
       (CL:RETURN-FROM ELIMINATE-LOOM-KEYWORDS TREE))
      (CL:LET* ((OPERATOR (%%VALUE TREE)))
       (CL:COND
        ((CL:EQ OPERATOR SYM-LOOM-TO-KIF-STELLA-QUOTE)
         (CL:RETURN-FROM ELIMINATE-LOOM-KEYWORDS (%%VALUE (%%REST TREE))))
        (CL:T)))))
    (CL:T)))
  TREE)

;;; (DEFUN (YIELD-IMPLICIT-VARIABLES (CONS OF SYMBOL)) ...)

(CL:DEFUN YIELD-IMPLICIT-VARIABLES (ARITY)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:LET* ((VARIABLES NIL))
   (CL:LET*
    ((I (INTERVAL 1 ARITY)) (V NULL) (ITER-000 SYSTEM-DEFINED-ARGUMENT-NAMES)
     (COLLECT-000 NULL))
    (CL:LOOP WHILE (CL:AND (NEXT? I) (CL:NOT (CL:EQ ITER-000 NIL))) DO
     (CL:SETQ V (%%VALUE ITER-000))
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS V NIL))
       (CL:IF (CL:EQ VARIABLES NIL) (CL:SETQ VARIABLES COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST VARIABLES COLLECT-000)))
      (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS V NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   VARIABLES))

;;; (DEFUN (HELP-TRANSLATE-LOOM-DESCRIPTION-TO-KIF CONS) ...)

(CL:DEFUN HELP-TRANSLATE-LOOM-DESCRIPTION-TO-KIF (TREE IMPLICITVARIABLES)
  (LOOM-DESCRIPTION-TO-KIF (ELIMINATE-LOOM-KEYWORDS TREE) IMPLICITVARIABLES))

;;; (DEFUN (TRANSLATE-LOOM-DESCRIPTION-TO-KIF CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-DESCRIPTION-TO-KIF (TREE)
  (CL:HANDLER-CASE
   (CL:LET*
    ((ARITY (COMPUTE-LOOM-DESCRIPTION-ARITY TREE))
     (IMPLICITVARIABLES
      (YIELD-IMPLICIT-VARIABLES (CL:IF (CL:> ARITY 0) ARITY 1))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
    (CL:RETURN-FROM TRANSLATE-LOOM-DESCRIPTION-TO-KIF
     (LIST* SYM-LOOM-TO-KIF-LOGIC-KAPPA IMPLICITVARIABLES
      (CONS (HELP-TRANSLATE-LOOM-DESCRIPTION-TO-KIF TREE IMPLICITVARIABLES)
       NIL))))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) (EXCEPTION-MESSAGE E))
    NULL)))

;;; (DEFUN (TRANSLATE-LOOM-SENTENCE-TO-KIF OBJECT) ...)

(CL:DEFUN TRANSLATE-LOOM-SENTENCE-TO-KIF (TREE)
  (CL:HANDLER-CASE
   (CL:RETURN-FROM TRANSLATE-LOOM-SENTENCE-TO-KIF
    (LOOM-SENTENCE-TO-KIF (ELIMINATE-LOOM-KEYWORDS TREE)))
   (LOGIC-EXCEPTION (E)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) (EXCEPTION-MESSAGE E))
    NULL)))

;;; (DEFUN (TRANSLATE-LOOM-ASSERTIONS CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-ASSERTIONS (TREE RETRACT?)
  (CL:IF (CL:EQ (%%REST TREE) NIL) (CL:SETQ TREE (%%VALUE TREE))
   (CL:SETQ TREE (CONS SYM-LOOM-TO-KIF-STELLA-AND TREE)))
  (CL:LET*
   ((VERB
     (CL:IF RETRACT? SYM-LOOM-TO-KIF-STELLA-RETRACT
      SYM-LOOM-TO-KIF-STELLA-ASSERT))
    (PROPOSITION (TRANSLATE-LOOM-SENTENCE-TO-KIF TREE)))
   (CL:IF (CL:NOT (CL:EQ TREE NULL)) (CONS VERB (CONS PROPOSITION NIL)) NULL)))

;;; (DEFUN (TRANSLATE-LOOM-ASK CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-ASK (TREE)
  (CL:LET*
   ((SENTENCE (TRANSLATE-LOOM-SENTENCE-TO-KIF (%%VALUE (%%REST TREE)))))
   (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
    (CL:SETF (%THE-PLIST SELF-000) (%%REST (%%REST TREE)))
    (CL:LET* ((OPTIONS SELF-000))
     (CL:LET* ((KEYWORD NULL) (VALUE NULL) (ITER-000 (%THE-PLIST OPTIONS)))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ KEYWORD (%%VALUE ITER-000))
       (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
       (CL:COND
        ((CL:EQ KEYWORD KWD-LOOM-TO-KIF-3-VALUED-P) (CL:SETQ VALUE VALUE)
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
          "Sorry, 3-valued 'ask' not yet implemented in PowerLoom." EOL
          "Please complain to your PowerLoom dealer." EOL EOL))
        (CL:T
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
          "Illegal or unimplemented option to 'ask': `" KEYWORD "'" EOL)))
       (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
     (CL:IF (CL:NOT (CL:EQ SENTENCE NULL))
      (LIST* SYM-LOOM-TO-KIF-STELLA-ASK SENTENCE NIL) NULL)))))

;;; (DEFUN (TRANSLATE-LOOM-RETRIEVE CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-RETRIEVE (TREE)
  (CL:LET*
   ((VARIABLES (%%VALUE (%%REST TREE)))
    (QUERYBODY
     (TRANSLATE-LOOM-SENTENCE-TO-KIF (%%VALUE (%%REST (%%REST TREE))))))
   (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
    (CL:SETF (%THE-PLIST SELF-000) (NTH-REST TREE 3))
    (CL:LET* ((OPTIONS SELF-000) (NULLS NIL))
     (CL:WHEN (CL:NOT (EMPTY? OPTIONS))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "'loom::retrieve' options not yet implemented" EOL))
     (CL:LET* ((I (ALLOCATE-ITERATOR VARIABLES)))
      (CL:LOOP WHILE (NEXT? I) DO
       (CL:SETQ NULLS (CONS SYM-LOOM-TO-KIF-STELLA-NULL NULLS))))
     (LIST* SYM-LOOM-TO-KIF-STELLA-CONSIFY
      (LIST* SYM-LOOM-TO-KIF-STELLA-RETRIEVE SYM-LOOM-TO-KIF-LOGIC-ALL
       VARIABLES (CONS QUERYBODY NIL))
      NIL)))))

;;; (DEFUN (TRANSLATE-ONE-LOOM-FORM CONS) ...)

(CL:DEFUN TRANSLATE-ONE-LOOM-FORM (TREE)
  (CL:COND
   ((CL:EQ (SAFE-PRIMARY-TYPE TREE) SGT-LOOM-TO-KIF-STELLA-CONS)
    (CL:PROGN
     (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-PROGN)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-EVAL-WHEN))
        (CL:LET* ((FORMS NIL) (TRANSLATION NULL))
         (CL:LET* ((ITEM NULL) (ITER-000 (%%REST TREE)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:SETQ ITEM (%%VALUE ITER-000))
           (CL:SETQ TRANSLATION (TRANSLATE-ONE-LOOM-FORM ITEM))
           (CL:WHEN (CL:NOT (CL:EQ TRANSLATION NULL))
            (CL:IF (ISA? (%%VALUE TRANSLATION) SGT-LOOM-TO-KIF-STELLA-CONS)
             (CL:LET* ((SUBFORM NULL) (ITER-001 TRANSLATION))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
               (CL:SETQ SUBFORM (%%VALUE ITER-001))
               (CL:SETQ FORMS (CONS SUBFORM FORMS))
               (CL:SETQ ITER-001 (%%REST ITER-001))))
             (CL:SETQ FORMS (CONS TRANSLATION FORMS))))
           (CL:SETQ ITER-000 (%%REST ITER-000))))
         (REVERSE FORMS)))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-ASK)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-RETRIEVE)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-TELL)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-FORGET)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-TELLM)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-FORGETM))
        (TRANSLATE-LOOM-STATEMENT TREE))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-CREATE)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-CREATEM))
        (DESTRUCTIVELY-UNQUOTE-TOP-LEVEL TREE)
        (TRANSLATE-LOOM-STATEMENT TREE))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-DEFCONCEPT)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-DEFSET)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-DEFRELATION)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-DEFPROPERTY))
        (TRANSLATE-LOOM-DEFINITION TREE))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-DEFCONTEXT)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-ADD-VALUE)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-SET-VALUE)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-FADD-VALUE))
        (CL:WARN "Translation of `~A' is not implemented yet!" (%%VALUE TREE))
        NULL)
       ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-CHANGE-CONTEXT)
        (TRANSLATE-LOOM-CONTEXT-CHANGE TREE CL:T))
       ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-IN-CONTEXT)
         (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-IN-KB))
        (TRANSLATE-LOOM-CONTEXT-CHANGE TREE CL:NIL))
       ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-CC)
        (CL:IF (CL:NOT (CL:EQ (%%VALUE (%%REST TREE)) NULL))
         (TRANSLATE-LOOM-CONTEXT-CHANGE TREE CL:NIL) NULL))
       (CL:T NULL)))))
   (CL:T NULL)))

;;; (DEFUN (SAFE-GET-NEXT-S-EXPRESSION OBJECT) ...)

(CL:DEFUN SAFE-GET-NEXT-S-EXPRESSION (ITER)
  (CL:LET* ((CONTINUE? CL:T) (RESULT NULL))
   (CL:LOOP WHILE CONTINUE? DO
    (CL:HANDLER-CASE
     (CL:PROGN (CL:WHEN (NEXT? ITER) (CL:SETQ RESULT (%VALUE ITER)))
      (CL:SETQ CONTINUE? CL:NIL))
     (READ-EXCEPTION (E)
      (CL:WARN "Read Exception `~A'~%" (EXCEPTION-MESSAGE E)))))
   RESULT))

;;; (DEFUN DESTRUCTIVELY-UNQUOTE-TOP-LEVEL ...)

(CL:DEFUN DESTRUCTIVELY-UNQUOTE-TOP-LEVEL (TREE)
  (CL:LOOP WHILE (CL:NOT (CL:EQ TREE NIL)) DO
   (CL:WHEN
    (CL:AND (ISA? (%%VALUE TREE) SGT-LOOM-TO-KIF-STELLA-CONS)
     (CL:EQ SYM-LOOM-TO-KIF-STELLA-QUOTE (%%VALUE (%%VALUE TREE))))
    (FIRST-SETTER TREE (%%VALUE (%%REST (%%VALUE TREE))))
    (CL:WHEN (CL:EQ (%%VALUE TREE) SYM-LOOM-TO-KIF-STELLA-NIL)
     (FIRST-SETTER TREE NIL)))
   (CL:SETQ TREE (%%REST TREE))))

;;; (DEFUN TRANSLATE-LOOM-FILE ...)

(CL:DEFUN %TRANSLATE-LOOM-FILE (INPUT OUTPUT)
  "Translate the Loom file `input' to PowerLoom and write the
translation to the file `output'.  Note that this will only
work for fairly vanilla Loom files that do not contain any
Lisp-isms.  It might require to clean the Loom file manually
before this translation will work."
  (CL:LET* ((*PRINTREADABLY?* CL:T) (*PRINTPRETTY?* CL:T))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?* *PRINTPRETTY?*))
   (CL:LET* ((IN NULL))
    (CL:UNWIND-PROTECT
     (CL:PROGN (CL:SETQ IN (OPEN-INPUT-FILE INPUT))
      (CL:LET* ((OUT NULL))
       (CL:UNWIND-PROTECT
        (CL:PROGN (CL:SETQ OUT (OPEN-OUTPUT-FILE OUTPUT))
         (CL:LET*
          ((TRANSLATION NIL) (ITER (S-EXPRESSIONS IN))
           (FORM (SAFE-GET-NEXT-S-EXPRESSION ITER)) (DIALECT-EMITTED? CL:NIL))
          (%%PRINT-STREAM (%NATIVE-STREAM OUT)
           ";; Automatic Translation for file " INPUT EOL EOL)
          (CL:LOOP WHILE (CL:NOT (CL:EQ FORM NULL)) DO
           (CL:SETQ TRANSLATION (TRANSLATE-ONE-LOOM-FORM FORM))
           (CL:COND ((CL:EQ TRANSLATION NULL)) ((CL:EQ TRANSLATION NIL))
            ((ISA? (%%VALUE TRANSLATION) SGT-LOOM-TO-KIF-STELLA-CONS)
             (CL:SETQ DIALECT-EMITTED? CL:T)
             (%%PRINT-STREAM (%NATIVE-STREAM OUT)
              (LIST* SYM-LOOM-TO-KIF-LOGIC-IN-DIALECT KWD-LOOM-TO-KIF-KIF NIL)
              EOL EOL)
             (CL:LET* ((SUBFORM NULL) (ITER-000 TRANSLATION))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
               (CL:SETQ SUBFORM (%%VALUE ITER-000))
               (%%PRINT-STREAM (%NATIVE-STREAM OUT) SUBFORM EOL EOL)
               (CL:SETQ ITER-000 (%%REST ITER-000)))))
            (CL:T
             (CL:WHEN
              (CL:AND (CL:NOT DIALECT-EMITTED?)
               (CL:NOT
                (CL:EQ (%%VALUE TRANSLATION)
                 SYM-LOOM-TO-KIF-STELLA-IN-MODULE)))
              (CL:SETQ DIALECT-EMITTED? CL:T)
              (%%PRINT-STREAM (%NATIVE-STREAM OUT)
               (LIST* SYM-LOOM-TO-KIF-LOGIC-IN-DIALECT KWD-LOOM-TO-KIF-KIF
                NIL)
               EOL EOL))
             (%%PRINT-STREAM (%NATIVE-STREAM OUT) TRANSLATION EOL EOL)))
           (CL:SETQ FORM (SAFE-GET-NEXT-S-EXPRESSION ITER)))))
        (CL:WHEN (CL:NOT (CL:EQ OUT NULL)) (FREE OUT)))))
     (CL:WHEN (CL:NOT (CL:EQ IN NULL)) (FREE IN))))))

(CL:DEFUN TRANSLATE-LOOM-FILE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%TRANSLATE-LOOM-FILE (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO TRANSLATE-LOOM-FILE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Translate the Loom file `input' to PowerLoom and write the
translation to the file `output'.  Note that this will only
work for fairly vanilla Loom files that do not contain any
Lisp-isms.  It might require to clean the Loom file manually
before this translation will work."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/TRANSLATE-LOOM-FILE|)) (CL:MACRO-FUNCTION (CL:QUOTE TRANSLATE-LOOM-FILE)))

;;; (DEFUN (TRANSLATE-LOOM-STATEMENT CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-STATEMENT (TREE)
  (CL:LET* ((TEST-VALUE-000 (%%VALUE TREE)))
   (CL:COND
    ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-ASK)
     (TRANSLATE-LOOM-ASK TREE))
    ((CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-STELLA-RETRIEVE)
     (TRANSLATE-LOOM-RETRIEVE TREE))
    ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-TELL)
      (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-TELLM))
     (TRANSLATE-LOOM-ASSERTIONS (%%REST TREE) CL:NIL))
    ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-FORGET)
      (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-FORGETM))
     (TRANSLATE-LOOM-ASSERTIONS (%%REST TREE) CL:T))
    ((CL:OR (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-CREATE)
      (CL:EQ TEST-VALUE-000 SYM-LOOM-TO-KIF-LOGIC-CREATEM))
     (TRANSLATE-LOOM-ASSERTIONS
      (CONS-LIST (TRANSLATE-LOOM-CREATE-CLAUSE (%%REST TREE))) CL:T))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (TRANSLATE-LOOM-CREATE-CLAUSE CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-CREATE-CLAUSE (TREE)
  (CL:IF (CL:EQ (%%VALUE (%%REST TREE)) NIL)
   (LIST* SYM-LOOM-TO-KIF-STELLA-THING (%%VALUE TREE) NIL)
   (CONS (%%VALUE (%%REST TREE)) (CONS (%%VALUE TREE) NIL))))

;;; (DEFUN (GUESS-LOOM-DEFINITION-ARITY INTEGER) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:FIXNUM CL:T CL:T) CL:FIXNUM)
  GUESS-LOOM-DEFINITION-ARITY))
(CL:DEFUN GUESS-LOOM-DEFINITION-ARITY (ARITY DEFINITION CONSTRAINTS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
  #+MCL
  (CL:CHECK-TYPE ARITY CL:FIXNUM)
  (CL:WHEN (CL:AND (CL:= ARITY -1) (CL:NOT (CL:EQ DEFINITION NULL)))
   (CL:SETQ ARITY (COMPUTE-LOOM-DESCRIPTION-ARITY DEFINITION)))
  (CL:WHEN (CL:= ARITY -1)
   (CL:LET* ((C NULL) (ITER-000 CONSTRAINTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ C (%%VALUE ITER-000))
     (CL:SETQ ARITY (COMPUTE-LOOM-DESCRIPTION-ARITY C))
     (CL:WHEN (CL:> ARITY 0) (CL:RETURN))
     (CL:SETQ ITER-000 (%%REST ITER-000)))))
  (CL:WHEN (CL:= ARITY -1) (CL:SETQ ARITY 2))
  ARITY)

;;; (DEFUN (CONJOIN-SENTENCES OBJECT) ...)

(CL:DEFUN CONJOIN-SENTENCES (SENTENCES)
  (CL:SETQ SENTENCES (REMOVE SENTENCES NIL))
  (CL:COND ((CL:EQ SENTENCES NIL) NIL)
   ((CL:EQ (%%REST SENTENCES) NIL) (%%VALUE SENTENCES))
   (CL:T (CL:SETQ SENTENCES (CONS SYM-LOOM-TO-KIF-STELLA-AND SENTENCES))
    SENTENCES)))

;;; (DEFUN (TRANSLATE-LOOM-PARTITIONS CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-PARTITIONS (PARTITIONS EXHAUSTIVE? PARENTCONCEPT)
  (CL:LET* ((AXIOMS NIL) (PARTITION-LIST NIL))
   (CL:WHEN (CL:NOT (CONS? PARTITIONS))
    (CL:SETQ PARTITIONS (CONS-LIST PARTITIONS)))
   (CL:IF (CONS? (%%VALUE PARTITIONS)) (CL:SETQ PARTITION-LIST PARTITIONS)
    (CL:LET* ((CLAUSE NULL) (ITER-000 PARTITIONS))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ CLAUSE (%%VALUE ITER-000))
      (CL:SETQ PARTITION-LIST (CONS (CONS-LIST CLAUSE) PARTITION-LIST))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   (CL:LET* ((CLAUSE NULL) (ITER-001 PARTITION-LIST))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ CLAUSE (%%VALUE ITER-001))
     (CL:LET*
      ((NAME (%%VALUE CLAUSE)) (CONCEPTS (%%VALUE (%%REST CLAUSE)))
       (LOCALAXIOMS NIL))
      (CL:SETQ LOCALAXIOMS
       (CONS
        (LIST* SYM-LOOM-TO-KIF-PL-KERNEL-KB-MUTUALLY-DISJOINT-COLLECTION NAME
         NIL)
        LOCALAXIOMS))
      (CL:WHEN (CL:NOT (CL:EQ CONCEPTS NULL))
       (CL:SETQ LOCALAXIOMS
        (CONS
         (LIST* SYM-LOOM-TO-KIF-STELLA-= NAME
          (CONS
           (CONS SYM-LOOM-TO-KIF-PL-KERNEL-KB-SETOF
            (CONCATENATE CONCEPTS NIL))
           NIL))
         LOCALAXIOMS)))
      (CL:WHEN EXHAUSTIVE?
       (CL:SETQ LOCALAXIOMS
        (CONS
         (LIST* SYM-LOOM-TO-KIF-PL-KERNEL-KB-COVERING NAME
          (CONS PARENTCONCEPT NIL))
         LOCALAXIOMS)))
      (CL:SETQ AXIOMS
       (CONS (CONJOIN-SENTENCES (REVERSE LOCALAXIOMS)) AXIOMS)))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   AXIOMS))

;;; (DEFUN (TRANSLATE-LOOM-CHARACTERISTICS CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-CHARACTERISTICS (CHARACTERISTICS NAME)
  (CL:LET* ((AXIOMS NIL))
   (CL:WHEN (CL:NOT (CONS? CHARACTERISTICS))
    (CL:SETQ CHARACTERISTICS (CONS-LIST CHARACTERISTICS)))
   (CL:LET* ((CH NULL) (ITER-000 CHARACTERISTICS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CH (%%VALUE ITER-000))
     (CL:LET* ((TEST-VALUE-000 CH))
      (CL:COND ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-SINGLE-VALUED))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-CLOSED-WORLD)
        (CL:SETQ AXIOMS
         (CONS (LIST* SYM-LOOM-TO-KIF-PL-KERNEL-KB-CLOSED NAME NIL) AXIOMS)))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-COMMUTATIVE)
        (CL:SETQ AXIOMS
         (CONS (LIST* SYM-LOOM-TO-KIF-PL-KERNEL-KB-COMMUTATIVE NAME NIL)
          AXIOMS)))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-SYMMETRIC)
        (CL:SETQ AXIOMS
         (CONS (LIST* SYM-LOOM-TO-KIF-PL-KERNEL-KB-SYMMETRIC NAME NIL)
          AXIOMS)))
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-CLOS-CLASS)
         (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-MULTIPLE-VALUED)
         (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-HASH-ON-DOMAINS)
         (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-NON-EXPORTED)
         (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-PERFECT)
         (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-CLOSED-ON-CONSTANTS)
         (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-BACKWARD-CHAINING)
         (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-MONOTONIC)
         (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-TEMPORAL)))
       (CL:T
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
         "Skipping unimplemented relation characteristic: `" CH "'" EOL
         "   in Loom definition of: `" NAME "'" EOL EOL))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CONJOIN-SENTENCES AXIOMS)))

;;; (DEFUN (TRANSLATE-LOOM-ANNOTATIONS CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-ANNOTATIONS (ANNOTATIONS NAME)
  (CL:WHEN (CL:NOT (CONS? ANNOTATIONS))
   (CL:SETQ ANNOTATIONS (CONS-LIST ANNOTATIONS)))
  (CL:LET* ((AXIOMS NIL))
   (CL:LET* ((TERM NULL) (ITER-000 ANNOTATIONS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ TERM (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (CONS? TERM)) (CL:SETQ TERM (CONS-LIST TERM)))
     (CL:LET* ((CLAUSE TERM))
      (CL:SETQ AXIOMS
       (CONS
        (CONS (%%VALUE CLAUSE) (CONS NAME (CONCATENATE (%%REST CLAUSE) NIL)))
        AXIOMS)))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CONJOIN-SENTENCES AXIOMS)))

;;; (DEFUN (TRANSLATE-LOOM-DEFAULTS CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-DEFAULTS (DEFAULT-TREE VARIABLES)
  (LIST* SYM-LOOM-TO-KIF-LOGIC-~>
   (HELP-TRANSLATE-LOOM-DESCRIPTION-TO-KIF DEFAULT-TREE VARIABLES) NIL))

;;; (DEFUN (SIMPLIFY-TOP-LEVEL-LOOM-KEYWORDS KEYWORD) ...)

(CL:DEFUN SIMPLIFY-TOP-LEVEL-LOOM-KEYWORDS (KEYWORD)
  (CL:COND
   ((CL:EQ KEYWORD KWD-LOOM-TO-KIF-ATTRIBUTES)
    KWD-LOOM-TO-KIF-CHARACTERISTICS)
   ((CL:EQ KEYWORD KWD-LOOM-TO-KIF-PARTITION) KWD-LOOM-TO-KIF-PARTITIONS)
   ((CL:EQ KEYWORD KWD-LOOM-TO-KIF-IMPLIES) KWD-LOOM-TO-KIF-CONSTRAINTS)
   ((CL:EQ KEYWORD KWD-LOOM-TO-KIF-EXHAUSTIVE-PARTITION)
    KWD-LOOM-TO-KIF-EXHAUSTIVE-PARTITIONS)
   (CL:T KEYWORD)))

;;; (DEFUN (TRANSLATE-LOOM-DEFINITION CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-DEFINITION (TREE)
  (CL:LET*
   ((OPERATOR (%%VALUE TREE)) (NAME (%%VALUE (%%REST TREE))) (DOCSTRING NULL)
    (OPTIONS NULL) (ARITY -1) (DEFINITION NULL) (CONSTRAINTS NIL)
    (DEFAULTS NIL) (AXIOMS NIL) (KIFDEFINITION NULL) (KIFCONSTRAINT NULL)
    (KIFAXIOM NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM ARITY))
   (CL:IF
    (CL:AND (CL:NOT (CL:EQ (%%VALUE (%%REST (%%REST TREE))) NULL))
     (ISA? (%%VALUE (%%REST (%%REST TREE)))
      SGT-LOOM-TO-KIF-STELLA-STRING-WRAPPER))
    (CL:PROGN (CL:SETQ DOCSTRING (%%VALUE (%%REST (%%REST TREE))))
     (CL:LET* ((SELF-000 (NEW-PROPERTY-LIST)))
      (CL:SETF (%THE-PLIST SELF-000) (%%REST (%%REST (%%REST TREE))))
      (CL:SETQ OPTIONS SELF-000)))
    (CL:LET* ((SELF-001 (NEW-PROPERTY-LIST)))
     (CL:SETF (%THE-PLIST SELF-001) (%%REST (%%REST TREE)))
     (CL:SETQ OPTIONS SELF-001)))
   (CL:WHEN
    (MEMBER? (GET-QUOTED-TREE "((DEFCONCEPT DEFSET) \"/LOGIC\")" "/LOGIC")
     OPERATOR)
    (CL:SETQ ARITY 1) (CL:SETQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-DEFCONCEPT))
   (CL:WHEN (CL:EQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-DEFPROPERTY)
    (CL:SETQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-DEFRELATION) (CL:SETQ ARITY 1))
   (CL:LET* ((KEYWORD NULL) (VALUE NULL) (ITER-000 (%THE-PLIST OPTIONS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ KEYWORD (%%VALUE ITER-000))
     (CL:SETQ VALUE (%%VALUE (%%REST ITER-000)))
     (CL:SETQ KEYWORD (SIMPLIFY-TOP-LEVEL-LOOM-KEYWORDS KEYWORD))
     (CL:LET* ((TEST-VALUE-000 KEYWORD))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-IS-PRIMITIVE)
        (CL:SETQ CONSTRAINTS (CONS VALUE CONSTRAINTS)))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-IS) (CL:SETQ DEFINITION VALUE))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-CONSTRAINTS)
        (CL:SETQ CONSTRAINTS (CONS VALUE CONSTRAINTS)))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-DEFAULTS)
        (CL:SETQ DEFAULTS (CONS VALUE DEFAULTS)))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-DOMAIN)
        (CL:SETQ CONSTRAINTS
         (CONS (LIST* SYM-LOOM-TO-KIF-LOGIC-DOMAIN VALUE NIL) CONSTRAINTS))
        (CL:WHEN (CL:< ARITY 0) (CL:SETQ ARITY 2)))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-DOMAINS)
        (CL:SETQ CONSTRAINTS
         (CONS (CONS SYM-LOOM-TO-KIF-LOGIC-DOMAINS (CONCATENATE VALUE NIL))
          CONSTRAINTS))
        (CL:WHEN (CL:< ARITY 0) (CL:SETQ ARITY (CL:1+ (LENGTH VALUE)))))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-RANGE)
        (CL:SETQ CONSTRAINTS
         (CONS (LIST* SYM-LOOM-TO-KIF-LOGIC-RANGE VALUE NIL) CONSTRAINTS))
        (CL:WHEN (CL:< ARITY 0) (CL:SETQ ARITY 2)))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-ARITY)
        (CL:SETQ ARITY (%WRAPPER-VALUE VALUE)))
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-PARTITIONS)
         (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-EXHAUSTIVE-PARTITIONS))
        (CL:LET*
         ((P NULL)
          (ITER-001
           (TRANSLATE-LOOM-PARTITIONS VALUE
            (CL:EQ KEYWORD KWD-LOOM-TO-KIF-EXHAUSTIVE-PARTITIONS) NAME)))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ P (%%VALUE ITER-001)) (CL:SETQ AXIOMS (CONS P AXIOMS))
          (CL:SETQ ITER-001 (%%REST ITER-001)))))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-IN-PARTITION)
        (CL:SETQ AXIOMS
         (CONS
          (LIST* SYM-LOOM-TO-KIF-PL-KERNEL-KB-MEMBER-OF NAME (CONS VALUE NIL))
          AXIOMS)))
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-CHARACTERISTICS)
         (CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-ATTRIBUTES))
        (CL:SETQ AXIOMS
         (CONS (TRANSLATE-LOOM-CHARACTERISTICS VALUE NAME) AXIOMS)))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-ANNOTATIONS)
        (CL:SETQ AXIOMS
         (CONS (TRANSLATE-LOOM-ANNOTATIONS VALUE NAME) AXIOMS)))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-ROLES)
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
         ":roles OPTION NOT YET IMPLEMENTED" EOL))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-NAME))
       ((CL:EQ TEST-VALUE-000 KWD-LOOM-TO-KIF-IDENTIFIER)
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Note: Definition `"
         NAME "' is also known as `" VALUE "'" EOL EOL))
       (CL:T
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
         "Skipping unimplemented keyword: `" KEYWORD "'" EOL
         "   in Loom definition: `" TREE "'" EOL EOL))))
     (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))))
   (CL:SETQ ARITY (GUESS-LOOM-DEFINITION-ARITY ARITY DEFINITION CONSTRAINTS))
   (CL:LET*
    ((VARIABLES (YIELD-IMPLICIT-VARIABLES ARITY))
     (CHARACTERISTICS (LOOKUP OPTIONS KWD-LOOM-TO-KIF-CHARACTERISTICS))
     (CONVERTTOFUNCTION?
      (CL:AND (CL:NOT (CL:EQ CHARACTERISTICS NULL))
       (CL:OR (CL:EQ CHARACTERISTICS KWD-LOOM-TO-KIF-SINGLE-VALUED)
        (CL:AND (CONS? CHARACTERISTICS)
         (MEMBER? CHARACTERISTICS KWD-LOOM-TO-KIF-SINGLE-VALUED)))))
     (RESULTCLAUSE NIL))
    (CL:WHEN (CL:NOT (CL:EQ CONSTRAINTS NIL))
     (CL:SETQ KIFCONSTRAINT
      (HELP-TRANSLATE-LOOM-DESCRIPTION-TO-KIF (CONJOIN-SENTENCES CONSTRAINTS)
       VARIABLES)))
    (CL:LET* ((DEFAULT NULL) (ITER-002 DEFAULTS))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
      (CL:SETQ DEFAULT (%%VALUE ITER-002))
      (CL:SETQ AXIOMS
       (CONS (TRANSLATE-LOOM-DEFAULTS DEFAULT VARIABLES) AXIOMS))
      (CL:SETQ ITER-002 (%%REST ITER-002))))
    (CL:WHEN (CL:NOT (CL:EQ AXIOMS NIL))
     (CL:SETQ KIFAXIOM (CONJOIN-SENTENCES AXIOMS))
     (CL:WHEN (CL:EQ KIFAXIOM NIL) (CL:SETQ KIFAXIOM NULL)))
    (CL:WHEN (CL:NOT (CL:EQ DEFINITION NULL))
     (CL:SETQ KIFDEFINITION
      (HELP-TRANSLATE-LOOM-DESCRIPTION-TO-KIF DEFINITION VARIABLES)))
    (CL:WHEN CONVERTTOFUNCTION?
     (CL:SETQ OPERATOR SYM-LOOM-TO-KIF-LOGIC-DEFFUNCTION)
     (CL:SETQ RESULTCLAUSE (LIST* KWD-LOOM-TO-KIF--> (LAST VARIABLES) NIL))
     (CL:SETQ VARIABLES (CONSIFY (BUT-LAST VARIABLES))))
    (CONS OPERATOR
     (CONS NAME
      (CONS VARIABLES
       (CONCATENATE RESULTCLAUSE
        (CONCATENATE
         (CL:IF (CL:NOT (CL:EQ DOCSTRING NULL))
          (LIST* KWD-LOOM-TO-KIF-DOCUMENTATION DOCSTRING NIL) NIL)
         (CONCATENATE
          (CL:IF (CL:NOT (CL:EQ KIFDEFINITION NULL))
           (LIST* KWD-LOOM-TO-KIF-<<=>> KIFDEFINITION NIL) NIL)
          (CONCATENATE
           (CL:IF (CL:NOT (CL:EQ KIFCONSTRAINT NULL))
            (LIST* KWD-LOOM-TO-KIF-=>> KIFCONSTRAINT NIL) NIL)
           (CONCATENATE
            (CL:IF (CL:NOT (CL:EQ KIFAXIOM NULL))
             (LIST* KWD-LOOM-TO-KIF-AXIOMS KIFAXIOM NIL) NIL)
            NIL)))))))))))

;;; (DEFUN (TRANSLATE-LOOM-CONTEXT-CHANGE CONS) ...)

(CL:DEFUN TRANSLATE-LOOM-CONTEXT-CHANGE (TREE NEEDSQUOTE?)
  (CL:LET* ((CONTEXTFORM (%%VALUE (%%REST TREE))))
   (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE CONTEXTFORM)))
    (CL:COND
     ((SUBTYPE-OF-STRING? TEST-VALUE-000)
      (CL:PROGN (LIST* SYM-LOOM-TO-KIF-STELLA-IN-MODULE CONTEXTFORM NIL)))
     ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
      (CL:PROGN
       (CL:IF NEEDSQUOTE?
        (CL:PROGN
         (CL:WHEN
          (CL:NOT (STRING-EQL? (%SYMBOL-NAME CONTEXTFORM) "SAVEDCONTEXT"))
          (CL:WARN "Can't translate `~A' with a non-constant argument" TREE))
         NULL)
        (LIST* SYM-LOOM-TO-KIF-STELLA-IN-MODULE
         (WRAP-STRING (%SYMBOL-NAME CONTEXTFORM)) NIL))))
     ((CL:EQ TEST-VALUE-000 SGT-LOOM-TO-KIF-STELLA-CONS)
      (CL:PROGN (TRANSLATE-LOOM-CONTEXT-CHANGE CONTEXTFORM CL:NIL)))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" TEST-VALUE-000
        "' is not a valid case option")
       (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))))

(CL:DEFUN HELP-STARTUP-LOOM-TO-KIF1 ()
  (CL:PROGN
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-INVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INVERSE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ KWD-LOOM-TO-KIF-BINARY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BINARY" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-UNARY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNARY" NULL 2))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-KAPPA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KAPPA" NULL 0))
   (CL:SETQ SGT-LOOM-TO-KIF-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-AT-LEAST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AT-LEAST" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-AT-MOST
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AT-MOST" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-EXACTLY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXACTLY" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-ALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALL" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-SOME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SOME" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-THE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-FILLED-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILLED-BY" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-FILLERS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FILLERS" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-NOT-FILLED-BY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT-FILLED-BY" NULL 0))
   (CL:SETQ
    SYM-LOOM-TO-KIF-PL-KERNEL-KB-QUALIFIED-RANGE-CARDINALITY-LOWER-BOUND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUALIFIED-RANGE-CARDINALITY-LOWER-BOUND"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ
    SYM-LOOM-TO-KIF-PL-KERNEL-KB-QUALIFIED-RANGE-CARDINALITY-UPPER-BOUND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUALIFIED-RANGE-CARDINALITY-UPPER-BOUND"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-QUALIFIED-RANGE-CARDINALITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUALIFIED-RANGE-CARDINALITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-CARDINALITY-LOWER-BOUND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANGE-CARDINALITY-LOWER-BOUND"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-CARDINALITY-UPPER-BOUND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANGE-CARDINALITY-UPPER-BOUND"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-CARDINALITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANGE-CARDINALITY"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-EXISTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXISTS"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-=>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=>" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-RANGE-TYPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANGE-TYPE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-RELATES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RELATES" NULL 0))
   (CL:SETQ SGT-LOOM-TO-KIF-STELLA-NUMBER-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NUMBER-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-FOR-SOME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FOR-SOME" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-FORALL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORALL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-THROUGH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THROUGH" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-INTERVAL++
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL++" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-INTERVAL+-
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL+-" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-INTERVAL-+
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL-+" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-INTERVAL--
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INTERVAL--" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-=<
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=<" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-<
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<" (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA->=
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">=" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA->
    (INTERN-RIGID-SYMBOL-WRT-MODULE ">" (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-SAME-AS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAME-AS" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-<=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<=" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-<>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<>" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-=
    (INTERN-RIGID-SYMBOL-WRT-MODULE "=" (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-ONE-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ONE-OF" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-THE-ORDERED-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THE-ORDERED-SET" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-SATISFIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SATISFIES" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-DOMAIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOMAIN" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-DOMAINS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOMAINS" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-RANGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANGE" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-COMPOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPOSE" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-MEMBER-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MEMBER-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-SETOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-LISTOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LISTOF" NULL 0))
   (CL:SETQ KWD-LOOM-TO-KIF-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-ABOUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ABOUT" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-CREATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATE" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-SUPERRELATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPERRELATIONS" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-SUPERCONCEPTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUPERCONCEPTS" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-SUBSET-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBSET-OF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))))

(CL:DEFUN HELP-STARTUP-LOOM-TO-KIF2 ()
  (CL:PROGN
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-QUOTE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUOTE" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-RETRACT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-ASSERT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-LOOM-TO-KIF-3-VALUED-P
    (INTERN-RIGID-SYMBOL-WRT-MODULE "3-VALUED-P" NULL 2))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-ASK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASK" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-NULL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NULL" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-CONSIFY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSIFY"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-RETRIEVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRIEVE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-PROGN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROGN" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-EVAL-WHEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EVAL-WHEN" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-TELL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TELL" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-FORGET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORGET" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-TELLM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TELLM" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-FORGETM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORGETM" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-CREATEM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CREATEM" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-DEFCONCEPT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCONCEPT" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-DEFSET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFSET" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-DEFRELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFRELATION" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-DEFPROPERTY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFPROPERTY" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-DEFCONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFCONTEXT" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-ADD-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ADD-VALUE" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-SET-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-VALUE" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-FADD-VALUE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FADD-VALUE" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-CHANGE-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHANGE-CONTEXT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-IN-CONTEXT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-CONTEXT" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-IN-KB
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-KB" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-CC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CC" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-NIL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NIL" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-IN-DIALECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-DIALECT" NULL 0))
   (CL:SETQ KWD-LOOM-TO-KIF-KIF (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF" NULL 2))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-IN-MODULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-MODULE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-TRANSLATE-LOOM-FILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRANSLATE-LOOM-FILE" NULL 0))
   (CL:SETQ KWD-LOOM-TO-KIF-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-THING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "THING" (GET-STELLA-MODULE "/STELLA" CL:T)
     0))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-MUTUALLY-DISJOINT-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MUTUALLY-DISJOINT-COLLECTION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-SETOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SETOF"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-COVERING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COVERING"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ KWD-LOOM-TO-KIF-SINGLE-VALUED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SINGLE-VALUED" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-CLOSED-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED-WORLD" NULL 2))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-CLOSED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ KWD-LOOM-TO-KIF-COMMUTATIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMUTATIVE" NULL 2))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-COMMUTATIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMUTATIVE"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ KWD-LOOM-TO-KIF-SYMMETRIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMMETRIC" NULL 2))
   (CL:SETQ SYM-LOOM-TO-KIF-PL-KERNEL-KB-SYMMETRIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SYMMETRIC"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 0))
   (CL:SETQ KWD-LOOM-TO-KIF-CLOS-CLASS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOS-CLASS" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-MULTIPLE-VALUED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MULTIPLE-VALUED" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-HASH-ON-DOMAINS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HASH-ON-DOMAINS" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-NON-EXPORTED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NON-EXPORTED" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-PERFECT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PERFECT" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-CLOSED-ON-CONSTANTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLOSED-ON-CONSTANTS" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-BACKWARD-CHAINING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKWARD-CHAINING" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-MONOTONIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MONOTONIC" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-TEMPORAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TEMPORAL" NULL 2))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-~>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "~>" NULL 0))
   (CL:SETQ KWD-LOOM-TO-KIF-ATTRIBUTES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ATTRIBUTES" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-CHARACTERISTICS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CHARACTERISTICS" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-PARTITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTITION" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-PARTITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTITIONS" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))))

(CL:DEFUN HELP-STARTUP-LOOM-TO-KIF3 ()
  (CL:PROGN
   (CL:SETQ KWD-LOOM-TO-KIF-CONSTRAINTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONSTRAINTS" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-EXHAUSTIVE-PARTITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXHAUSTIVE-PARTITION" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-EXHAUSTIVE-PARTITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXHAUSTIVE-PARTITIONS" NULL 2))
   (CL:SETQ SGT-LOOM-TO-KIF-STELLA-STRING-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRING-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-LOOM-TO-KIF-IS-PRIMITIVE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IS-PRIMITIVE" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-IS (INTERN-RIGID-SYMBOL-WRT-MODULE "IS" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-DEFAULTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFAULTS" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-DOMAIN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOMAIN" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-DOMAINS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOMAINS" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-RANGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RANGE" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-ARITY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARITY" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-IN-PARTITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IN-PARTITION" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-ANNOTATIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ANNOTATIONS" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-ROLES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ROLES" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-NAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAME" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-IDENTIFIER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IDENTIFIER" NULL 2))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-DEFFUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFFUNCTION" NULL 0))
   (CL:SETQ KWD-LOOM-TO-KIF--> (INTERN-RIGID-SYMBOL-WRT-MODULE "->" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-DOCUMENTATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DOCUMENTATION" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-<<=>>
    (INTERN-RIGID-SYMBOL-WRT-MODULE "<<=>>" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-=>> (INTERN-RIGID-SYMBOL-WRT-MODULE "=>>" NULL 2))
   (CL:SETQ KWD-LOOM-TO-KIF-AXIOMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AXIOMS" NULL 2))
   (CL:SETQ SYM-LOOM-TO-KIF-LOGIC-STARTUP-LOOM-TO-KIF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-LOOM-TO-KIF" NULL 0))
   (CL:SETQ SYM-LOOM-TO-KIF-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN STARTUP-LOOM-TO-KIF ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-LOOM-TO-KIF1)
    (HELP-STARTUP-LOOM-TO-KIF2) (HELP-STARTUP-LOOM-TO-KIF3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "LOOM-ARGUMENT-DESCRIPTION-TO-KIF"
     "(DEFUN (LOOM-ARGUMENT-DESCRIPTION-TO-KIF OBJECT) ((TREE OBJECT) (ARITY KEYWORD)))"
     (CL:FUNCTION LOOM-ARGUMENT-DESCRIPTION-TO-KIF) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOM-RESTRICTION-TO-KIF"
     "(DEFUN (LOOM-RESTRICTION-TO-KIF CONS) ((TREE CONS) (IMPLICITVARIABLE SYMBOL)))"
     (CL:FUNCTION LOOM-RESTRICTION-TO-KIF) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOM-RELATES-TO-KIF"
     "(DEFUN (LOOM-RELATES-TO-KIF CONS) ((TREE CONS) (IMPLICITVARIABLES (CONS OF SYMBOL))))"
     (CL:FUNCTION LOOM-RELATES-TO-KIF) NULL)
    (DEFINE-FUNCTION-OBJECT "SUBSTITUTE-VARIABLES-IN-TREE"
     "(DEFUN SUBSTITUTE-VARIABLES-IN-TREE ((TREE CONS) (SUBSTITUTION CONS)))"
     (CL:FUNCTION SUBSTITUTE-VARIABLES-IN-TREE) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOM-THROUGH-TO-KIF"
     "(DEFUN (LOOM-THROUGH-TO-KIF CONS) ((TREE CONS) (IMPLICITVARIABLES (CONS OF SYMBOL))))"
     (CL:FUNCTION LOOM-THROUGH-TO-KIF) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOM-SATISFIES-TO-KIF"
     "(DEFUN (LOOM-SATISFIES-TO-KIF CONS) ((TREE CONS) (IMPLICITVARIABLES (CONS OF SYMBOL))))"
     (CL:FUNCTION LOOM-SATISFIES-TO-KIF) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOM-DESCRIPTION-TO-KIF"
     "(DEFUN (LOOM-DESCRIPTION-TO-KIF CONS) ((TREE OBJECT) (IMPLICITVARIABLES (CONS OF SYMBOL))))"
     (CL:FUNCTION LOOM-DESCRIPTION-TO-KIF) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOM-DESCRIPTION-OPERATOR?"
     "(DEFUN (LOOM-DESCRIPTION-OPERATOR? BOOLEAN) ((SELF OBJECT)))"
     (CL:FUNCTION LOOM-DESCRIPTION-OPERATOR?) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOM-SENTENCE-TO-KIF"
     "(DEFUN (LOOM-SENTENCE-TO-KIF OBJECT) ((TREE OBJECT)))"
     (CL:FUNCTION LOOM-SENTENCE-TO-KIF) NULL)
    (DEFINE-FUNCTION-OBJECT "COMPUTE-LOOM-DESCRIPTION-ARITY"
     "(DEFUN (COMPUTE-LOOM-DESCRIPTION-ARITY INTEGER) ((TREE OBJECT)))"
     (CL:FUNCTION COMPUTE-LOOM-DESCRIPTION-ARITY) NULL)
    (DEFINE-FUNCTION-OBJECT "ELIMINATE-LOOM-KEYWORDS"
     "(DEFUN (ELIMINATE-LOOM-KEYWORDS OBJECT) ((TREE OBJECT)))"
     (CL:FUNCTION ELIMINATE-LOOM-KEYWORDS) NULL)
    (DEFINE-FUNCTION-OBJECT "YIELD-IMPLICIT-VARIABLES"
     "(DEFUN (YIELD-IMPLICIT-VARIABLES (CONS OF SYMBOL)) ((ARITY INTEGER)))"
     (CL:FUNCTION YIELD-IMPLICIT-VARIABLES) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-TRANSLATE-LOOM-DESCRIPTION-TO-KIF"
     "(DEFUN (HELP-TRANSLATE-LOOM-DESCRIPTION-TO-KIF CONS) ((TREE OBJECT) (IMPLICITVARIABLES (CONS OF SYMBOL))))"
     (CL:FUNCTION HELP-TRANSLATE-LOOM-DESCRIPTION-TO-KIF) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-DESCRIPTION-TO-KIF"
     "(DEFUN (TRANSLATE-LOOM-DESCRIPTION-TO-KIF CONS) ((TREE OBJECT)) :PUBLIC? TRUE)"
     (CL:FUNCTION TRANSLATE-LOOM-DESCRIPTION-TO-KIF) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-SENTENCE-TO-KIF"
     "(DEFUN (TRANSLATE-LOOM-SENTENCE-TO-KIF OBJECT) ((TREE OBJECT)) :PUBLIC? TRUE)"
     (CL:FUNCTION TRANSLATE-LOOM-SENTENCE-TO-KIF) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-ASSERTIONS"
     "(DEFUN (TRANSLATE-LOOM-ASSERTIONS CONS) ((TREE CONS) (RETRACT? BOOLEAN)) :PUBLIC? TRUE)"
     (CL:FUNCTION TRANSLATE-LOOM-ASSERTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-ASK"
     "(DEFUN (TRANSLATE-LOOM-ASK CONS) ((TREE CONS)) :PUBLIC? TRUE)"
     (CL:FUNCTION TRANSLATE-LOOM-ASK) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-RETRIEVE"
     "(DEFUN (TRANSLATE-LOOM-RETRIEVE CONS) ((TREE CONS)) :PUBLIC? TRUE)"
     (CL:FUNCTION TRANSLATE-LOOM-RETRIEVE) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-ONE-LOOM-FORM"
     "(DEFUN (TRANSLATE-ONE-LOOM-FORM CONS) ((TREE OBJECT)))"
     (CL:FUNCTION TRANSLATE-ONE-LOOM-FORM) NULL)
    (DEFINE-FUNCTION-OBJECT "SAFE-GET-NEXT-S-EXPRESSION"
     "(DEFUN (SAFE-GET-NEXT-S-EXPRESSION OBJECT) ((ITER S-EXPRESSION-ITERATOR)))"
     (CL:FUNCTION SAFE-GET-NEXT-S-EXPRESSION) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTRUCTIVELY-UNQUOTE-TOP-LEVEL"
     "(DEFUN DESTRUCTIVELY-UNQUOTE-TOP-LEVEL ((TREE CONS)))"
     (CL:FUNCTION DESTRUCTIVELY-UNQUOTE-TOP-LEVEL) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-FILE"
     "(DEFUN TRANSLATE-LOOM-FILE ((INPUT FILE-NAME) (OUTPUT FILE-NAME)) :DOCUMENTATION \"Translate the Loom file `input' to PowerLoom and write the
translation to the file `output'.  Note that this will only
work for fairly vanilla Loom files that do not contain any
Lisp-isms.  It might require to clean the Loom file manually
before this translation will work.\" :PUBLIC? TRUE :COMMAND? TRUE)"
     (CL:FUNCTION %TRANSLATE-LOOM-FILE)
     (CL:FUNCTION TRANSLATE-LOOM-FILE-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-STATEMENT"
     "(DEFUN (TRANSLATE-LOOM-STATEMENT CONS) ((TREE CONS)) :PUBLIC? TRUE)"
     (CL:FUNCTION TRANSLATE-LOOM-STATEMENT) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-CREATE-CLAUSE"
     "(DEFUN (TRANSLATE-LOOM-CREATE-CLAUSE CONS) ((TREE CONS)))"
     (CL:FUNCTION TRANSLATE-LOOM-CREATE-CLAUSE) NULL)
    (DEFINE-FUNCTION-OBJECT "GUESS-LOOM-DEFINITION-ARITY"
     "(DEFUN (GUESS-LOOM-DEFINITION-ARITY INTEGER) ((ARITY INTEGER) (DEFINITION OBJECT) (CONSTRAINTS CONS)))"
     (CL:FUNCTION GUESS-LOOM-DEFINITION-ARITY) NULL)
    (DEFINE-FUNCTION-OBJECT "CONJOIN-SENTENCES"
     "(DEFUN (CONJOIN-SENTENCES OBJECT) ((SENTENCES CONS)))"
     (CL:FUNCTION CONJOIN-SENTENCES) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-PARTITIONS"
     "(DEFUN (TRANSLATE-LOOM-PARTITIONS CONS) ((PARTITIONS OBJECT) (EXHAUSTIVE? BOOLEAN) (PARENTCONCEPT SYMBOL)))"
     (CL:FUNCTION TRANSLATE-LOOM-PARTITIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-CHARACTERISTICS"
     "(DEFUN (TRANSLATE-LOOM-CHARACTERISTICS CONS) ((CHARACTERISTICS OBJECT) (NAME SYMBOL)))"
     (CL:FUNCTION TRANSLATE-LOOM-CHARACTERISTICS) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-ANNOTATIONS"
     "(DEFUN (TRANSLATE-LOOM-ANNOTATIONS CONS) ((ANNOTATIONS OBJECT) (NAME SYMBOL)))"
     (CL:FUNCTION TRANSLATE-LOOM-ANNOTATIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-DEFAULTS"
     "(DEFUN (TRANSLATE-LOOM-DEFAULTS CONS) ((DEFAULT-TREE OBJECT) (VARIABLES CONS)))"
     (CL:FUNCTION TRANSLATE-LOOM-DEFAULTS) NULL)
    (DEFINE-FUNCTION-OBJECT "SIMPLIFY-TOP-LEVEL-LOOM-KEYWORDS"
     "(DEFUN (SIMPLIFY-TOP-LEVEL-LOOM-KEYWORDS KEYWORD) ((KEYWORD KEYWORD)))"
     (CL:FUNCTION SIMPLIFY-TOP-LEVEL-LOOM-KEYWORDS) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-DEFINITION"
     "(DEFUN (TRANSLATE-LOOM-DEFINITION CONS) ((TREE CONS)) :PUBLIC? TRUE)"
     (CL:FUNCTION TRANSLATE-LOOM-DEFINITION) NULL)
    (DEFINE-FUNCTION-OBJECT "TRANSLATE-LOOM-CONTEXT-CHANGE"
     "(DEFUN (TRANSLATE-LOOM-CONTEXT-CHANGE CONS) ((TREE CONS) (NEEDSQUOTE? BOOLEAN)))"
     (CL:FUNCTION TRANSLATE-LOOM-CONTEXT-CHANGE) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-LOOM-TO-KIF"
     "(DEFUN STARTUP-LOOM-TO-KIF () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-LOOM-TO-KIF) NULL)
    (CL:LET*
     ((FUNCTION (LOOKUP-FUNCTION SYM-LOOM-TO-KIF-LOGIC-STARTUP-LOOM-TO-KIF)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-LOOM-TO-KIF-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupLoomToKif") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (REGISTER-NATIVE-NAME SYM-LOOM-TO-KIF-LOGIC-TRANSLATE-LOOM-FILE
     KWD-LOOM-TO-KIF-COMMON-LISP KWD-LOOM-TO-KIF-FUNCTION))))
