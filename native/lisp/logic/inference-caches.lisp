;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; inference-caches.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2010      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-MONOTONIC? NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-STELLA-WORLD NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-JUST-IN-TIME NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-META NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-TMS NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES? NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-PREORDER NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-LOGIC-DESCRIPTION NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-STELLA-LITERAL-WRAPPER NULL)
(CL:DEFVAR SGT-INFERENCE-CACHES-PL-KERNEL-KB-HIDDEN-RELATION NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-RETRACT NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED? NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-PERFORMANCE-CLUES NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-PROPAGATE-CONSTRAINTS NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-COMMON-LISP NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-FUNCTION NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-REPROPAGATE-CONSTRAINTS NULL)
(CL:DEFVAR KWD-INFERENCE-CACHES-FORCE NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-STELLA-RUN-FORWARD-RULES NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-LOGIC-STARTUP-INFERENCE-CACHES NULL)
(CL:DEFVAR SYM-INFERENCE-CACHES-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* STANDARD-ERROR *QUERYITERATOR*
  *TRACED-KEYWORDS* STANDARD-OUTPUT EOL *JUST-IN-TIME-FORWARD-INFERENCE?*
  *CONTEXT* NIL TRUE-WRAPPER FALSE-WRAPPER))

;;; (DEFUN (WORLD-STATE? BOOLEAN) ...)

(CL:DEFUN WORLD-STATE? (SELF)
  (CL:COND
   ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE SELF) SGT-INFERENCE-CACHES-STELLA-WORLD)
    (CL:PROGN
     (CL:AND
      (CL:EQ
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
        SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL)
       NULL)
      (CL:NOT
       (%WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
         SYM-INFERENCE-CACHES-LOGIC-MONOTONIC? FALSE-WRAPPER))))))
   (CL:T CL:T)))

;;; (DEFUN (GET-WORLD-STATE CONTEXT) ...)

(CL:DEFUN GET-WORLD-STATE (SELF)
  (CL:IF (WORLD-STATE? SELF) SELF (%BASE-MODULE SELF)))

;;; (DEFUN (LOOKUP-INFERENCE-CACHE WORLD) ...)

(CL:DEFUN LOOKUP-INFERENCE-CACHE (CONTEXT KIND)
  (CL:LET* ((CACHEWORLD NULL))
   (CL:COND
    ((CL:EQ KIND KWD-INFERENCE-CACHES-JUST-IN-TIME)
     (CL:SETQ CACHEWORLD
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL)))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-META)
     (CL:SETQ CACHEWORLD
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL)))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-TMS)
     (CL:SETQ CACHEWORLD
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   CACHEWORLD))

;;; (DEFUN INITIALIZE-INFERENCE-WORLD ...)

(CL:DEFUN INITIALIZE-INFERENCE-WORLD (WORLD))

;;; (DEFUN (CREATE-INFERENCE-CACHE WORLD) ...)

(CL:DEFUN CREATE-INFERENCE-CACHE (CONTEXT KIND)
  (CL:LET*
   ((WORLD
     (CREATE-WORLD
      (CL:IF
       (MEMBER? (GET-QUOTED-TREE "((:JUST-IN-TIME :TMS) \"/LOGIC\")" "/LOGIC")
        KIND)
       (GET-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-META) CONTEXT)
      STELLA::NULL-STRING)))
   (CL:COND
    ((CL:EQ KIND KWD-INFERENCE-CACHES-JUST-IN-TIME)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE WORLD NULL))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-META)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
      SYM-INFERENCE-CACHES-LOGIC-MONOTONIC? TRUE-WRAPPER FALSE-WRAPPER)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
      SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES?
      (CL:IF (CL:NOT (NEXT? (ALL-PROPOSITIONS (%BASE-MODULE CONTEXT) CL:T)))
       TRUE-WRAPPER FALSE-WRAPPER)
      FALSE-WRAPPER)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE WORLD NULL))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-TMS)
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE WORLD NULL))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
    SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF CONTEXT NULL)
   (INITIALIZE-INFERENCE-WORLD WORLD) WORLD))

;;; (DEFUN (GET-INFERENCE-CACHE WORLD) ...)

(CL:DEFUN GET-INFERENCE-CACHE (CONTEXT KIND)
  (CL:WHEN (CL:NOT (WORLD-STATE? CONTEXT))
   (CL:RETURN-FROM GET-INFERENCE-CACHE CONTEXT))
  (CL:LET* ((WORLD (LOOKUP-INFERENCE-CACHE CONTEXT KIND)))
   (CL:WHEN (CL:NOT (CL:EQ WORLD NULL))
    (CL:RETURN-FROM GET-INFERENCE-CACHE WORLD))
   (PROCESS-CHECK-TYPES-AGENDA)
   (CL:SETQ WORLD (CREATE-INFERENCE-CACHE CONTEXT KIND))
   (CL:COND ((CL:EQ KIND KWD-INFERENCE-CACHES-JUST-IN-TIME))
    ((CL:OR (CL:EQ KIND KWD-INFERENCE-CACHES-META)
      (CL:EQ KIND KWD-INFERENCE-CACHES-TMS))
     (CL:LET*
      ((PARENTMODULE NULL)
       (ITER-000 (%THE-CONS-LIST (%PARENT-MODULES (%BASE-MODULE CONTEXT)))))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ PARENTMODULE (%%VALUE ITER-000))
       (INHERIT-CACHED-INFERENCES (LOOKUP-INFERENCE-CACHE PARENTMODULE KIND)
        WORLD)
       (CL:SETQ ITER-000 (%%REST ITER-000)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   WORLD))

;;; (DEFUN DESTROY-INFERENCE-CACHE ...)

(CL:DEFUN DESTROY-INFERENCE-CACHE (CONTEXT KIND)
  (CL:LET* ((CACHE NULL))
   (CL:COND
    ((CL:EQ KIND KWD-INFERENCE-CACHES-JUST-IN-TIME)
     (CL:SETQ CACHE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL NULL))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-META)
     (CL:SETQ CACHE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL NULL))
    ((CL:EQ KIND KWD-INFERENCE-CACHES-TMS)
     (CL:SETQ CACHE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
       SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CONTEXT)
      SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL NULL))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" KIND
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:WHEN (CL:AND (CL:NOT (CL:EQ CACHE NULL)) (CL:NOT (DELETED? CACHE)))
    (DESTROY-WORLD CACHE))))

;;; (DEFUN DESTROY-ALL-INFERENCE-CACHES ...)

(CL:DEFUN DESTROY-ALL-INFERENCE-CACHES (CONTEXT KIND)
  (DESTROY-INFERENCE-CACHE CONTEXT KIND)
  (CL:LET*
   ((CHILD NULL)
    (ITER-000 (ALL-SUBCONTEXTS *CONTEXT* KWD-INFERENCE-CACHES-PREORDER)))
   (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ CHILD (%VALUE ITER-000))
    (CL:WHEN (WORLD-STATE? CHILD) (DESTROY-INFERENCE-CACHE CHILD KIND)))))

;;; (DEFUN UNLINK-INFERENCE-CACHE ...)

(CL:DEFUN UNLINK-INFERENCE-CACHE (SELF)
  (CL:WHEN
   (CL:NOT
    (CL:EQ
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
      SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL)
     NULL))
   (CL:LET*
    ((WORLDSTATE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
       SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL)))
    (CL:COND
     ((CL:EQ SELF
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
        SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
       SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL NULL))
     ((CL:EQ SELF
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
        SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
       SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE NULL NULL))
     ((CL:EQ SELF
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
        SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL))
      (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLDSTATE)
       SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE NULL
       NULL)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SELF)
     SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF NULL NULL))))

;;; (DEFUN DESTROY-INFERENCE-CACHES ...)

(CL:DEFUN DESTROY-INFERENCE-CACHES (CONTEXT)
  (DESTROY-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-JUST-IN-TIME)
  (DESTROY-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-META)
  (DESTROY-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-TMS))

;;; (DEFSPECIAL *INVISIBLEASSERTION?* ...)

(CL:DEFVAR *INVISIBLEASSERTION?* CL:NIL
  "Used to signal an assertion that doesn't
blow away inference caches.")

;;; (DEFUN (META-PROPOSITION? BOOLEAN) ...)

(CL:DEFUN META-PROPOSITION? (PROPOSITION)
  (CL:WHEN (CL:EQ PROPOSITION NULL) (CL:RETURN-FROM META-PROPOSITION? CL:NIL))
  (CL:LET* ((POINTSTOMETAOBJECT? CL:NIL))
   (CL:LET*
    ((ARG NULL) (VECTOR-000 (%ARGUMENTS PROPOSITION)) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ ARG
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
      (CL:COND
       ((SUBTYPE-OF? TEST-VALUE-000 SGT-INFERENCE-CACHES-LOGIC-DESCRIPTION)
        (CL:PROGN (CL:SETQ POINTSTOMETAOBJECT? CL:T)))
       ((SUBTYPE-OF? TEST-VALUE-000
         SGT-INFERENCE-CACHES-STELLA-LITERAL-WRAPPER)
        (CL:PROGN))
       (CL:T (CL:RETURN-FROM META-PROPOSITION? CL:NIL))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   POINTSTOMETAOBJECT?))

;;; (DEFUN HANDLE-OUT-OF-DATE-INFERENCE-CACHE ...)

(CL:DEFUN HANDLE-OUT-OF-DATE-INFERENCE-CACHE (ASSERTORRETRACT PROPOSITION)
  (CL:WHEN (WORLD-STATE? *CONTEXT*)
   (CL:WHEN
    (CL:OR
     (CL:EQ (LOOKUP-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-META) NULL)
     (CL:NOT (CL:EQ *QUERYITERATOR* NULL)) (DESCRIPTION-MODE?)
     *INVISIBLEASSERTION?*)
    (CL:RETURN-FROM HANDLE-OUT-OF-DATE-INFERENCE-CACHE))
   (CL:LET*
    ((DESCRIPTION
      (CL:IF (CL:NOT (CL:EQ PROPOSITION NULL))
       (GET-DESCRIPTION (%OPERATOR PROPOSITION)) NULL)))
    (CL:WHEN
     (CL:AND (CL:NOT (CL:EQ DESCRIPTION NULL))
      (TEST-PROPERTY? DESCRIPTION
       SGT-INFERENCE-CACHES-PL-KERNEL-KB-HIDDEN-RELATION))
     (CL:RETURN-FROM HANDLE-OUT-OF-DATE-INFERENCE-CACHE)))
   (CL:COND
    ((CL:AND (META-PROPOSITION? PROPOSITION)
      (CL:EQ ASSERTORRETRACT KWD-INFERENCE-CACHES-RETRACT)
      (CL:NOT
       (%WRAPPER-VALUE
        (DYNAMIC-SLOT-VALUE
         (%DYNAMIC-SLOTS
          (LOOKUP-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-META))
         SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED? FALSE-WRAPPER))))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
       (MEMB? *TRACED-KEYWORDS* KWD-INFERENCE-CACHES-PERFORMANCE-CLUES))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "DELETING META CACHE"
       EOL))
     (DESTROY-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-META))
    (*JUST-IN-TIME-FORWARD-INFERENCE?*
     (CL:WHEN
      (CL:NOT
       (CL:EQ
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS *CONTEXT*)
         SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE NULL)
        NULL))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ *TRACED-KEYWORDS* NULL))
        (MEMB? *TRACED-KEYWORDS* KWD-INFERENCE-CACHES-PERFORMANCE-CLUES))
       (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "DELETING JIT CACHE"
        EOL))
      (DESTROY-ALL-INFERENCE-CACHES *CONTEXT*
       KWD-INFERENCE-CACHES-JUST-IN-TIME)))
    (CL:T
     (CL:LET*
      ((CACHE (LOOKUP-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-TMS)))
      (CL:WHEN
       (CL:AND (CL:NOT (CL:EQ CACHE NULL))
        (CL:NOT
         (%WRAPPER-VALUE
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS CACHE)
           SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED? FALSE-WRAPPER))))
       (DESTROY-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-TMS)))))
   (CL:RETURN-FROM HANDLE-OUT-OF-DATE-INFERENCE-CACHE))
  (CL:LET* ((WORLD *CONTEXT*))
   (CL:WHEN
    (CL:AND
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
       SYM-INFERENCE-CACHES-LOGIC-MONOTONIC? FALSE-WRAPPER))
     (CL:EQ ASSERTORRETRACT KWD-INFERENCE-CACHES-RETRACT))
    (CL:IF (CL:NOT (CL:EQ PROPOSITION NULL))
     (CL:WARN
      "Retraction of `~A' occurred in world `~A' which is marked monotonic."
      PROPOSITION WORLD)
     (CL:WARN "Retraction occurred in world `~A' which is marked monotonic."
      WORLD)))
   (CL:WHEN
    (CL:NOT
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
       SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED? FALSE-WRAPPER)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS WORLD)
     SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES? FALSE-WRAPPER
     FALSE-WRAPPER))))

;;; (DEFUN (BEST-INFERENCE-CACHE WORLD) ...)

(CL:DEFUN BEST-INFERENCE-CACHE (CONTEXT)
  (CL:WHEN *JUST-IN-TIME-FORWARD-INFERENCE?*
   (CL:RETURN-FROM BEST-INFERENCE-CACHE
    (GET-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-JUST-IN-TIME)))
  (CL:LET* ((CACHE (LOOKUP-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-TMS)))
   (CL:IF (CL:NOT (CL:EQ CACHE NULL)) CACHE
    (LOOKUP-INFERENCE-CACHE CONTEXT KWD-INFERENCE-CACHES-META))))

;;; (DEFUN (GET-QUERY-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-QUERY-CONTEXT ()
  (CL:WHEN (CL:NOT (WORLD-STATE? *CONTEXT*))
   (CL:RETURN-FROM GET-QUERY-CONTEXT *CONTEXT*))
  (CL:LET* ((CACHE (BEST-INFERENCE-CACHE *CONTEXT*)))
   (CL:IF (CL:NOT (CL:EQ CACHE NULL)) CACHE *CONTEXT*)))

;;; (DEFUN (GET-PROPERTY-TEST-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-PROPERTY-TEST-CONTEXT ()
  (CL:LET*
   ((CONSTRAINTPROPAGATIONWORLD
     (LOOKUP-CONSTRAINT-PROPAGATION-WORLD *CONTEXT*)))
   (CL:IF (CL:EQ CONSTRAINTPROPAGATIONWORLD NULL) *CONTEXT*
    CONSTRAINTPROPAGATIONWORLD)))

;;; (DEFUN (GET-INFERABLE-TEST-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-INFERABLE-TEST-CONTEXT ()
  (CL:IF (CL:NOT (WORLD-STATE? *CONTEXT*)) *CONTEXT*
   (CL:LET*
    ((TEMP-000 (LOOKUP-INFERENCE-CACHE *CONTEXT* KWD-INFERENCE-CACHES-META)))
    (CL:LET*
     ((VALUE-000 (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 *CONTEXT*)))
     VALUE-000))))

;;; (DEFUN (GET-TOP-LEVEL-UPDATE-CONTEXT CONTEXT) ...)

(CL:DEFUN GET-TOP-LEVEL-UPDATE-CONTEXT ()
  (GET-WORLD-STATE *CONTEXT*))

;;; (DEFUN (LOOKUP-CONSTRAINT-PROPAGATION-WORLD WORLD) ...)

(CL:DEFUN LOOKUP-CONSTRAINT-PROPAGATION-WORLD (SELF)
  (CL:IF (WORLD-STATE? SELF)
   (CL:IF *JUST-IN-TIME-FORWARD-INFERENCE?*
    (CL:IF (CL:NOT (CL:EQ *QUERYITERATOR* NULL))
     (GET-INFERENCE-CACHE SELF KWD-INFERENCE-CACHES-JUST-IN-TIME)
     (LOOKUP-INFERENCE-CACHE SELF KWD-INFERENCE-CACHES-JUST-IN-TIME))
    (LOOKUP-INFERENCE-CACHE SELF KWD-INFERENCE-CACHES-TMS))
   SELF))

;;; (DEFUN INHERIT-CACHED-INFERENCES ...)

(CL:DEFUN INHERIT-CACHED-INFERENCES (FROMWORLD TOWORLD)
  (CL:SETQ TOWORLD TOWORLD)
  (CL:WHEN (CL:EQ FROMWORLD NULL) NULL))

;;; (DEFUN INHERIT-TRUTH-VALUE-UPDATE ...)

(CL:DEFUN INHERIT-TRUTH-VALUE-UPDATE (PROPOSITION TOWORLD))

;;; (DEFUN INHERIT-VARIABLE-VALUE-UPDATE ...)

(CL:DEFUN INHERIT-VARIABLE-VALUE-UPDATE (SKOLEM TOWORLD))

;;; (DEFUN CALL-PROPAGATE-CONSTRAINTS ...)

(CL:DEFUN CALL-PROPAGATE-CONSTRAINTS (CONTEXT)
  "Trigger constraint propagation over all propositions
in the module or world `context'."
  (CL:LET*
   ((WORLDSTATE (GET-WORLD-STATE CONTEXT))
    (PROPAGATIONWORLD
     (GET-INFERENCE-CACHE WORLDSTATE KWD-INFERENCE-CACHES-META)))
   (CL:WHEN
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPAGATIONWORLD)
      SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES? FALSE-WRAPPER))
    (CL:RETURN-FROM CALL-PROPAGATE-CONSTRAINTS))
   (CL:HANDLER-CASE
    (CL:LET* ((P NULL) (ITER-000 (ALL-PROPOSITIONS WORLDSTATE CL:T)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
      (REACT-TO-KB-UPDATE PROPAGATIONWORLD P)))
    (CLASH (E)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) (EXCEPTION-MESSAGE E)
      EOL)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR)
      "One or more facts need to be retracted to eliminate" EOL
      "   the inconsistency." EOL)))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPAGATIONWORLD)
    SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES? TRUE-WRAPPER
    FALSE-WRAPPER)))

;;; (DEFUN PROPAGATE-CONSTRAINTS ...)

(CL:DEFUN %PROPAGATE-CONSTRAINTS (NAME)
  "Trigger constraint propagation over all propositions of module `name'.
If no `name' is supplied, the current module will be used.  This also
enables incremental constraint propagation for future monotonic updates to
the module.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of a function value, all cached inferences will be discarded
and constraint propagation will be turned off until this function is
called again."
  (PROCESS-CHECK-TYPES-AGENDA)
  (CL:LET* ((OPTIONALNAME NAME) (MODULE NULL))
   (CL:WHEN (CL:NOT (CL:EQ (%%VALUE OPTIONALNAME) NULL))
    (CL:SETQ MODULE (COERCE-TO-MODULE (%%VALUE OPTIONALNAME) CL:T)))
   (CL:IF (CL:NOT (CL:EQ MODULE NULL)) (CALL-PROPAGATE-CONSTRAINTS MODULE)
    (CALL-PROPAGATE-CONSTRAINTS *CONTEXT*))))

(CL:DEFUN PROPAGATE-CONSTRAINTS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%PROPAGATE-CONSTRAINTS ARGUMENTS))

(CL:DEFMACRO PROPAGATE-CONSTRAINTS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Trigger constraint propagation over all propositions of module `name'.
If no `name' is supplied, the current module will be used.  This also
enables incremental constraint propagation for future monotonic updates to
the module.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of a function value, all cached inferences will be discarded
and constraint propagation will be turned off until this function is
called again."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/PROPAGATE-CONSTRAINTS|)) (CL:MACRO-FUNCTION (CL:QUOTE PROPAGATE-CONSTRAINTS)))

;;; (DEFUN REPROPAGATE-CONSTRAINTS ...)

(CL:DEFUN %REPROPAGATE-CONSTRAINTS (NAME)
  "Force non-incremental constraint propagation over all propositions of
module `name'.  If no `name' is supplied, the current module will be used.
This also enables incremental constraint propagation for future monotonic
updates to the module similar to `propagate-constraints'."
  (PROCESS-CHECK-TYPES-AGENDA)
  (CL:LET*
   ((OPTIONALNAME NAME)
    (CONTEXT (COERCE-TO-MODULE (%%VALUE OPTIONALNAME) CL:T)))
   (CL:WHEN (CL:EQ CONTEXT NULL) (CL:SETQ CONTEXT *CONTEXT*))
   (DESTROY-INFERENCE-CACHES CONTEXT) (CALL-PROPAGATE-CONSTRAINTS CONTEXT)))

(CL:DEFUN REPROPAGATE-CONSTRAINTS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%REPROPAGATE-CONSTRAINTS ARGUMENTS))

(CL:DEFMACRO REPROPAGATE-CONSTRAINTS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Force non-incremental constraint propagation over all propositions of
module `name'.  If no `name' is supplied, the current module will be used.
This also enables incremental constraint propagation for future monotonic
updates to the module similar to `propagate-constraints'."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/REPROPAGATE-CONSTRAINTS|)) (CL:MACRO-FUNCTION (CL:QUOTE REPROPAGATE-CONSTRAINTS)))

;;; (DEFUN CALL-RUN-FORWARD-RULES ...)

(CL:DEFUN CALL-RUN-FORWARD-RULES (MODULE FORCE?)
  "Run forward inference rules in module 'module'. If 'module'
is NULL, the current module will be used.  If forward inferencing is already
up-to-date in the designated module, no additional inferencing will occur,
unless 'force?' is set to TRUE, in which case all forward rules are run or rerun."
  (FINALIZE-OBJECTS)
  (PROCESS-CHECK-TYPES-AGENDA)
  (CL:WHEN FORCE? (DESTROY-INFERENCE-CACHES MODULE))
  (CL:LET*
   ((WORLDSTATE (GET-WORLD-STATE MODULE))
    (PROPAGATIONWORLD
     (GET-INFERENCE-CACHE WORLDSTATE KWD-INFERENCE-CACHES-META)))
   (CL:WHEN
    (%WRAPPER-VALUE
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPAGATIONWORLD)
      SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES? FALSE-WRAPPER))
    (CL:RETURN-FROM CALL-RUN-FORWARD-RULES))
   (CL:LET* ((P NULL) (ITER-000 (ALL-PROPOSITIONS WORLDSTATE CL:T)))
    (CL:LOOP WHILE (NEXT? ITER-000) DO (CL:SETQ P (%VALUE ITER-000))
     (REACT-TO-KB-UPDATE PROPAGATIONWORLD P)))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROPAGATIONWORLD)
    SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES? TRUE-WRAPPER
    FALSE-WRAPPER)))

;;; (DEFUN RUN-FORWARD-RULES ...)

(CL:DEFUN %RUN-FORWARD-RULES (MODULEREF FORCE)
  "Run forward inference rules in module 'moduleRef'. If 'moduleRef' is NULL, the
current module will be used.  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless the
optional keyword `:force' is included, in which case all
forward rules are run or rerun.

Calling `run-forward-rules' temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is
called again."
  (CL:LET*
   ((MODULE (COERCE-TO-MODULE MODULEREF CL:T)) (OPTIONALARGUMENTS FORCE)
    (FORCE? (CL:EQ (%%VALUE OPTIONALARGUMENTS) KWD-INFERENCE-CACHES-FORCE)))
   (CL:WHEN (CL:EQ MODULE NULL) (CL:SETQ MODULE *MODULE*))
   (CL:HANDLER-CASE (CALL-RUN-FORWARD-RULES MODULE FORCE?)
    (CLASH (E)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) (EXCEPTION-MESSAGE E))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
      "   One or more facts need to be retracted to eliminate the inconsistency."
      EOL)))))

(CL:DEFUN RUN-FORWARD-RULES-EVALUATOR-WRAPPER (ARGUMENTS)
  (%RUN-FORWARD-RULES (%%VALUE ARGUMENTS) (%%REST ARGUMENTS)))

(CL:DEFMACRO RUN-FORWARD-RULES (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Run forward inference rules in module 'moduleRef'. If 'moduleRef' is NULL, the
current module will be used.  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless the
optional keyword `:force' is included, in which case all
forward rules are run or rerun.

Calling `run-forward-rules' temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is
called again."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/STELLA/RUN-FORWARD-RULES|)) (CL:MACRO-FUNCTION (CL:QUOTE RUN-FORWARD-RULES)))

(CL:DEFUN HELP-STARTUP-INFERENCE-CACHES1 ()
  (CL:PROGN
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-INFERENCE-CACHE-OF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE-CACHE-OF" NULL 0))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-MONOTONIC?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MONOTONIC?" NULL 0))
   (CL:SETQ SGT-INFERENCE-CACHES-STELLA-WORLD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WORLD" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ KWD-INFERENCE-CACHES-JUST-IN-TIME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUST-IN-TIME" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-JUST-IN-TIME-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUST-IN-TIME-INFERENCE-CACHE" NULL 0))
   (CL:SETQ KWD-INFERENCE-CACHES-META
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-META-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "META-INFERENCE-CACHE" NULL 0))
   (CL:SETQ KWD-INFERENCE-CACHES-TMS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TMS" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED-INFERENCE-CACHE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-MAINTAINED-INFERENCE-CACHE" NULL
     0))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-UP-TO-DATE-INFERENCES?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UP-TO-DATE-INFERENCES?" NULL 0))
   (CL:SETQ KWD-INFERENCE-CACHES-PREORDER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PREORDER" NULL 2))
   (CL:SETQ SGT-INFERENCE-CACHES-LOGIC-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DESCRIPTION" NULL 1))
   (CL:SETQ SGT-INFERENCE-CACHES-STELLA-LITERAL-WRAPPER
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LITERAL-WRAPPER"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ SGT-INFERENCE-CACHES-PL-KERNEL-KB-HIDDEN-RELATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HIDDEN-RELATION"
     (GET-STELLA-MODULE "/PL-KERNEL-KB" CL:T) 1))
   (CL:SETQ KWD-INFERENCE-CACHES-RETRACT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RETRACT" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-TRUTH-MAINTAINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRUTH-MAINTAINED?" NULL 0))
   (CL:SETQ KWD-INFERENCE-CACHES-PERFORMANCE-CLUES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PERFORMANCE-CLUES" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-PROPAGATE-CONSTRAINTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPAGATE-CONSTRAINTS" NULL 0))
   (CL:SETQ KWD-INFERENCE-CACHES-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-INFERENCE-CACHES-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-REPROPAGATE-CONSTRAINTS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REPROPAGATE-CONSTRAINTS" NULL 0))
   (CL:SETQ KWD-INFERENCE-CACHES-FORCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORCE" NULL 2))
   (CL:SETQ SYM-INFERENCE-CACHES-STELLA-RUN-FORWARD-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "RUN-FORWARD-RULES"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-INFERENCE-CACHES-LOGIC-STARTUP-INFERENCE-CACHES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-INFERENCE-CACHES" NULL 0))
   (CL:SETQ SYM-INFERENCE-CACHES-STELLA-METHOD-STARTUP-CLASSNAME
    (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))))

(CL:DEFUN STARTUP-INFERENCE-CACHES ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-INFERENCE-CACHES1))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "WORLD-STATE?"
     "(DEFUN (WORLD-STATE? BOOLEAN) ((SELF CONTEXT)) :PUBLIC? TRUE)"
     (CL:FUNCTION WORLD-STATE?) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-WORLD-STATE"
     "(DEFUN (GET-WORLD-STATE CONTEXT) ((SELF CONTEXT)) :PUBLIC? TRUE)"
     (CL:FUNCTION GET-WORLD-STATE) NULL)
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CONTEXT META-INFERENCE-CACHE :TYPE WORLD :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CONTEXT TRUTH-MAINTAINED-INFERENCE-CACHE :TYPE WORLD :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT CONTEXT JUST-IN-TIME-INFERENCE-CACHE :TYPE WORLD :ALLOCATION :DYNAMIC)")
    (DEFINE-EXTERNAL-SLOT-FROM-STRINGIFIED-SOURCE
     "(DEFSLOT WORLD INFERENCE-CACHE-OF :TYPE CONTEXT :PUBLIC? TRUE :ALLOCATION :DYNAMIC)")
    (DEFINE-FUNCTION-OBJECT "LOOKUP-INFERENCE-CACHE"
     "(DEFUN (LOOKUP-INFERENCE-CACHE WORLD) ((CONTEXT CONTEXT) (KIND KEYWORD)) :PUBLIC? TRUE)"
     (CL:FUNCTION LOOKUP-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "INITIALIZE-INFERENCE-WORLD"
     "(DEFUN INITIALIZE-INFERENCE-WORLD ((WORLD WORLD)))"
     (CL:FUNCTION INITIALIZE-INFERENCE-WORLD) NULL)
    (DEFINE-FUNCTION-OBJECT "CREATE-INFERENCE-CACHE"
     "(DEFUN (CREATE-INFERENCE-CACHE WORLD) ((CONTEXT CONTEXT) (KIND KEYWORD)) :PUBLIC? TRUE)"
     (CL:FUNCTION CREATE-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-INFERENCE-CACHE"
     "(DEFUN (GET-INFERENCE-CACHE WORLD) ((CONTEXT CONTEXT) (KIND KEYWORD)) :PUBLIC? TRUE)"
     (CL:FUNCTION GET-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTROY-INFERENCE-CACHE"
     "(DEFUN DESTROY-INFERENCE-CACHE ((CONTEXT CONTEXT) (KIND KEYWORD)) :PUBLIC? TRUE)"
     (CL:FUNCTION DESTROY-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTROY-ALL-INFERENCE-CACHES"
     "(DEFUN DESTROY-ALL-INFERENCE-CACHES ((CONTEXT CONTEXT) (KIND KEYWORD)) :PUBLIC? TRUE)"
     (CL:FUNCTION DESTROY-ALL-INFERENCE-CACHES) NULL)
    (DEFINE-FUNCTION-OBJECT "UNLINK-INFERENCE-CACHE"
     "(DEFUN UNLINK-INFERENCE-CACHE ((SELF WORLD)))"
     (CL:FUNCTION UNLINK-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "DESTROY-INFERENCE-CACHES"
     "(DEFUN DESTROY-INFERENCE-CACHES ((CONTEXT CONTEXT)) :PUBLIC? TRUE)"
     (CL:FUNCTION DESTROY-INFERENCE-CACHES) NULL)
    (DEFINE-FUNCTION-OBJECT "META-PROPOSITION?"
     "(DEFUN (META-PROPOSITION? BOOLEAN) ((PROPOSITION PROPOSITION)) :PUBLIC? TRUE)"
     (CL:FUNCTION META-PROPOSITION?) NULL)
    (DEFINE-FUNCTION-OBJECT "HANDLE-OUT-OF-DATE-INFERENCE-CACHE"
     "(DEFUN HANDLE-OUT-OF-DATE-INFERENCE-CACHE ((ASSERTORRETRACT KEYWORD) (PROPOSITION PROPOSITION)))"
     (CL:FUNCTION HANDLE-OUT-OF-DATE-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "BEST-INFERENCE-CACHE"
     "(DEFUN (BEST-INFERENCE-CACHE WORLD) ((CONTEXT CONTEXT)))"
     (CL:FUNCTION BEST-INFERENCE-CACHE) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-QUERY-CONTEXT"
     "(DEFUN (GET-QUERY-CONTEXT CONTEXT) () :PUBLIC? TRUE)"
     (CL:FUNCTION GET-QUERY-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-PROPERTY-TEST-CONTEXT"
     "(DEFUN (GET-PROPERTY-TEST-CONTEXT CONTEXT) ())"
     (CL:FUNCTION GET-PROPERTY-TEST-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-INFERABLE-TEST-CONTEXT"
     "(DEFUN (GET-INFERABLE-TEST-CONTEXT CONTEXT) ())"
     (CL:FUNCTION GET-INFERABLE-TEST-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "GET-TOP-LEVEL-UPDATE-CONTEXT"
     "(DEFUN (GET-TOP-LEVEL-UPDATE-CONTEXT CONTEXT) ())"
     (CL:FUNCTION GET-TOP-LEVEL-UPDATE-CONTEXT) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-CONSTRAINT-PROPAGATION-WORLD"
     "(DEFUN (LOOKUP-CONSTRAINT-PROPAGATION-WORLD WORLD) ((SELF CONTEXT)))"
     (CL:FUNCTION LOOKUP-CONSTRAINT-PROPAGATION-WORLD) NULL)
    (DEFINE-FUNCTION-OBJECT "INHERIT-CACHED-INFERENCES"
     "(DEFUN INHERIT-CACHED-INFERENCES ((FROMWORLD WORLD) (TOWORLD WORLD)))"
     (CL:FUNCTION INHERIT-CACHED-INFERENCES) NULL)
    (DEFINE-FUNCTION-OBJECT "INHERIT-TRUTH-VALUE-UPDATE"
     "(DEFUN INHERIT-TRUTH-VALUE-UPDATE ((PROPOSITION PROPOSITION) (TOWORLD WORLD)))"
     (CL:FUNCTION INHERIT-TRUTH-VALUE-UPDATE) NULL)
    (DEFINE-FUNCTION-OBJECT "INHERIT-VARIABLE-VALUE-UPDATE"
     "(DEFUN INHERIT-VARIABLE-VALUE-UPDATE ((SKOLEM SKOLEM) (TOWORLD WORLD)))"
     (CL:FUNCTION INHERIT-VARIABLE-VALUE-UPDATE) NULL)
    (DEFINE-FUNCTION-OBJECT "CALL-PROPAGATE-CONSTRAINTS"
     "(DEFUN CALL-PROPAGATE-CONSTRAINTS ((CONTEXT CONTEXT)) :DOCUMENTATION \"Trigger constraint propagation over all propositions
in the module or world `context'.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CALL-PROPAGATE-CONSTRAINTS) NULL)
    (DEFINE-FUNCTION-OBJECT "PROPAGATE-CONSTRAINTS"
     "(DEFUN PROPAGATE-CONSTRAINTS (|&REST| (NAME NAME)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Trigger constraint propagation over all propositions of module `name'.
If no `name' is supplied, the current module will be used.  This also
enables incremental constraint propagation for future monotonic updates to
the module.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of a function value, all cached inferences will be discarded
and constraint propagation will be turned off until this function is
called again.\")" (CL:FUNCTION %PROPAGATE-CONSTRAINTS)
     (CL:FUNCTION PROPAGATE-CONSTRAINTS-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "REPROPAGATE-CONSTRAINTS"
     "(DEFUN REPROPAGATE-CONSTRAINTS (|&REST| (NAME NAME)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Force non-incremental constraint propagation over all propositions of
module `name'.  If no `name' is supplied, the current module will be used.
This also enables incremental constraint propagation for future monotonic
updates to the module similar to `propagate-constraints'.\")"
     (CL:FUNCTION %REPROPAGATE-CONSTRAINTS)
     (CL:FUNCTION REPROPAGATE-CONSTRAINTS-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "CALL-RUN-FORWARD-RULES"
     "(DEFUN CALL-RUN-FORWARD-RULES ((MODULE MODULE) (FORCE? BOOLEAN)) :DOCUMENTATION \"Run forward inference rules in module 'module'. If 'module'
is NULL, the current module will be used.  If forward inferencing is already
up-to-date in the designated module, no additional inferencing will occur,
unless 'force?' is set to TRUE, in which case all forward rules are run or rerun.\" :PUBLIC? TRUE)"
     (CL:FUNCTION CALL-RUN-FORWARD-RULES) NULL)
    (DEFINE-FUNCTION-OBJECT "RUN-FORWARD-RULES"
     "(DEFUN RUN-FORWARD-RULES ((MODULEREF NAME) |&REST| (FORCE KEYWORD)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Run forward inference rules in module 'moduleRef'. If 'moduleRef' is NULL, the
current module will be used.  If forward inferencing is already up-to-date
in the designated module, no additional inferencing will occur, unless the
optional keyword `:force' is included, in which case all
forward rules are run or rerun.

Calling `run-forward-rules' temporarily puts the module into a mode where
future assertional (monotonic) updates will trigger additional forward
inference.  Once a non-monotonic update is performed, i.e., a retraction
or clipping of relation value, all cached forward inferences will be discarded
and forward inferencing will be disabled until this function is
called again.\")" (CL:FUNCTION %RUN-FORWARD-RULES)
     (CL:FUNCTION RUN-FORWARD-RULES-EVALUATOR-WRAPPER))
    (DEFINE-FUNCTION-OBJECT "STARTUP-INFERENCE-CACHES"
     "(DEFUN STARTUP-INFERENCE-CACHES () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-INFERENCE-CACHES) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION SYM-INFERENCE-CACHES-LOGIC-STARTUP-INFERENCE-CACHES)))
     (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
      SYM-INFERENCE-CACHES-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupInferenceCaches") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *INVISIBLEASSERTION?* BOOLEAN FALSE :DOCUMENTATION \"Used to signal an assertion that doesn't
blow away inference caches.\")")
    (REGISTER-NATIVE-NAME SYM-INFERENCE-CACHES-LOGIC-PROPAGATE-CONSTRAINTS
     KWD-INFERENCE-CACHES-COMMON-LISP KWD-INFERENCE-CACHES-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-INFERENCE-CACHES-LOGIC-REPROPAGATE-CONSTRAINTS
     KWD-INFERENCE-CACHES-COMMON-LISP KWD-INFERENCE-CACHES-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-INFERENCE-CACHES-STELLA-RUN-FORWARD-RULES
     KWD-INFERENCE-CACHES-COMMON-LISP KWD-INFERENCE-CACHES-FUNCTION))))
