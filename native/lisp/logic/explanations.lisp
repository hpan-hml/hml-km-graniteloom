;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; explanations.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2014      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-EXPLANATIONS-ASCII NULL)
(CL:DEFVAR KWD-EXPLANATIONS-BRIEF NULL)
(CL:DEFVAR KWD-EXPLANATIONS-TECHNICAL NULL)
(CL:DEFVAR KWD-EXPLANATIONS-ASSERTION NULL)
(CL:DEFVAR KWD-EXPLANATIONS-FAILURE NULL)
(CL:DEFVAR KWD-EXPLANATIONS-CUTOFF NULL)
(CL:DEFVAR KWD-EXPLANATIONS-INFERENCE NULL)
(CL:DEFVAR KWD-EXPLANATIONS-HTML NULL)
(CL:DEFVAR KWD-EXPLANATIONS-IMPLIES NULL)
(CL:DEFVAR SYM-EXPLANATIONS-LOGIC-EXPLANATION-VOCABULARY NULL)
(CL:DEFVAR KWD-EXPLANATIONS-UNKNOWN-RULE NULL)
(CL:DEFVAR KWD-EXPLANATIONS-FOLLOWS NULL)
(CL:DEFVAR KWD-EXPLANATIONS-LAY NULL)
(CL:DEFVAR KWD-EXPLANATIONS-PARTIAL NULL)
(CL:DEFVAR KWD-EXPLANATIONS-HOLDS NULL)
(CL:DEFVAR KWD-EXPLANATIONS-DEFINITION NULL)
(CL:DEFVAR KWD-EXPLANATIONS-FAILED NULL)
(CL:DEFVAR KWD-EXPLANATIONS-INCONSISTENT NULL)
(CL:DEFVAR KWD-EXPLANATIONS-CLASH NULL)
(CL:DEFVAR KWD-EXPLANATIONS-NOT-ASSERTED NULL)
(CL:DEFVAR KWD-EXPLANATIONS-NO-RULES NULL)
(CL:DEFVAR SGT-EXPLANATIONS-LOGIC-EXPLANATION-INFO NULL)
(CL:DEFVAR SYM-EXPLANATIONS-STELLA-LABEL NULL)
(CL:DEFVAR SYM-EXPLANATIONS-STELLA-DEPTH NULL)
(CL:DEFVAR SYM-EXPLANATIONS-LOGIC-EXPLAINED? NULL)
(CL:DEFVAR SYM-EXPLANATIONS-LOGIC-EXPLANATION-MAPPING NULL)
(CL:DEFVAR KWD-EXPLANATIONS-XML NULL)
(CL:DEFVAR KWD-EXPLANATIONS-CYC-NL NULL)
(CL:DEFVAR KWD-EXPLANATIONS-KIF-ONTOSAURUS NULL)
(CL:DEFVAR KWD-EXPLANATIONS-JAVA-GUI-HTML NULL)
(CL:DEFVAR KWD-EXPLANATIONS-REALISTIC NULL)
(CL:DEFVAR SYM-EXPLANATIONS-STELLA-NOT NULL)
(CL:DEFVAR KWD-EXPLANATIONS-AMPLIFICATION NULL)
(CL:DEFVAR KWD-EXPLANATIONS-REVERSE NULL)
(CL:DEFVAR SGT-EXPLANATIONS-LOGIC-CLASH-JUSTIFICATION NULL)
(CL:DEFVAR KWD-EXPLANATIONS-PRIMITIVE-STRATEGY NULL)
(CL:DEFVAR KWD-EXPLANATIONS-SCAN-PROPOSITIONS NULL)
(CL:DEFVAR SYM-EXPLANATIONS-LOGIC-MASTER-PROPOSITION NULL)
(CL:DEFVAR KWD-EXPLANATIONS-FORWARD NULL)
(CL:DEFVAR KWD-EXPLANATIONS-SCAN-COLLECTION NULL)
(CL:DEFVAR KWD-EXPLANATIONS-LOOKUP-ASSERTIONS NULL)
(CL:DEFVAR KWD-EXPLANATIONS-EQUIVALENCE NULL)
(CL:DEFVAR SYM-EXPLANATIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)
(CL:DEFVAR SGT-EXPLANATIONS-LOGIC-NAMED-DESCRIPTION NULL)
(CL:DEFVAR SGT-EXPLANATIONS-LOGIC-FORWARD-JUSTIFICATION NULL)
(CL:DEFVAR SGT-EXPLANATIONS-LOGIC-ALTERNATIVE-BINDINGS-SET NULL)
(CL:DEFVAR KWD-EXPLANATIONS-MODUS-PONENS NULL)
(CL:DEFVAR KWD-EXPLANATIONS-MODUS-TOLLENS NULL)
(CL:DEFVAR KWD-EXPLANATIONS-DISPROOF NULL)
(CL:DEFVAR KWD-EXPLANATIONS-GOAL-COMPLEMENT NULL)
(CL:DEFVAR KWD-EXPLANATIONS-PATTERN NULL)
(CL:DEFVAR KWD-EXPLANATIONS-AND-INTRODUCTION NULL)
(CL:DEFVAR SYM-EXPLANATIONS-LOGIC-WHY NULL)
(CL:DEFVAR KWD-EXPLANATIONS-COMMON-LISP NULL)
(CL:DEFVAR KWD-EXPLANATIONS-FUNCTION NULL)
(CL:DEFVAR SYM-EXPLANATIONS-LOGIC-JUSTIFICATION NULL)
(CL:DEFVAR SGT-EXPLANATIONS-STELLA-GENERALIZED-SYMBOL NULL)
(CL:DEFVAR KWD-EXPLANATIONS-DIGIT NULL)
(CL:DEFVAR KWD-EXPLANATIONS-VERBOSE NULL)
(CL:DEFVAR KWD-EXPLANATIONS-DEPTH NULL)
(CL:DEFVAR SYM-EXPLANATIONS-LOGIC-STARTUP-EXPLANATIONS NULL)
(CL:DEFVAR SYM-EXPLANATIONS-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* *MODULE* ONE-WRAPPER
  *CHARACTER-TYPE-TABLE* *MOST-RECENT-QUERY* STANDARD-OUTPUT
  *CYC-KLUDGES-ENABLED?* *LOGIC-DIALECT* UNKNOWN-TRUTH-VALUE EOL
  *MOST-RECENT-EXPLANATION-MAPPING* TRUE-WRAPPER FALSE-WRAPPER
  NULL-INTEGER NIL))

;;; (DEFCLASS EXPLAIN-EXCEPTION ...)

(CL:DEFINE-CONDITION EXPLAIN-EXCEPTION (LOGIC-EXCEPTION)
  ())

(CL:DEFUN NEW-EXPLAIN-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE EXPLAIN-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   SELF))

;;; (DEFCLASS EXPLAIN-NO-QUERY-EXCEPTION ...)

(CL:DEFINE-CONDITION EXPLAIN-NO-QUERY-EXCEPTION (EXPLAIN-EXCEPTION)
  ())

(CL:DEFUN NEW-EXPLAIN-NO-QUERY-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE EXPLAIN-NO-QUERY-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   SELF))

;;; (DEFCLASS EXPLAIN-NO-SOLUTION-EXCEPTION ...)

(CL:DEFINE-CONDITION EXPLAIN-NO-SOLUTION-EXCEPTION (EXPLAIN-EXCEPTION)
  ())

(CL:DEFUN NEW-EXPLAIN-NO-SOLUTION-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE EXPLAIN-NO-SOLUTION-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   SELF))

;;; (DEFCLASS EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION ...)

(CL:DEFINE-CONDITION EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION (EXPLAIN-EXCEPTION)
  ())

(CL:DEFUN NEW-EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   SELF))

;;; (DEFCLASS EXPLAIN-NOT-ENABLED-EXCEPTION ...)

(CL:DEFINE-CONDITION EXPLAIN-NOT-ENABLED-EXCEPTION (EXPLAIN-EXCEPTION)
  ())

(CL:DEFUN NEW-EXPLAIN-NOT-ENABLED-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE EXPLAIN-NOT-ENABLED-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   SELF))

;;; (DEFCLASS EXPLAIN-NO-SUCH-LABEL-EXCEPTION ...)

(CL:DEFINE-CONDITION EXPLAIN-NO-SUCH-LABEL-EXCEPTION (EXPLAIN-EXCEPTION)
  ())

(CL:DEFUN NEW-EXPLAIN-NO-SUCH-LABEL-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE EXPLAIN-NO-SUCH-LABEL-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   SELF))

;;; (DEFCLASS EXPLAIN-QUERY-TRUE-EXCEPTION ...)

(CL:DEFINE-CONDITION EXPLAIN-QUERY-TRUE-EXCEPTION (EXPLAIN-EXCEPTION)
  ())

(CL:DEFUN NEW-EXPLAIN-QUERY-TRUE-EXCEPTION (MESSAGE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING MESSAGE))
  #+MCL
  (CL:CHECK-TYPE MESSAGE CL:SIMPLE-STRING)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF
    (CL:MAKE-CONDITION (CL:QUOTE EXPLAIN-QUERY-TRUE-EXCEPTION)
     *CONDITION-MESSAGE-KEYWORD*
     (REPLACE-SUBSTRINGS MESSAGE "~~" "~")))
   SELF))

;;; (DEFSPECIAL *EXPLANATION-FORMAT* ...)

(CL:DEFVAR *EXPLANATION-FORMAT* NULL
  "Keyword to control the explanation format.
Valid values are :ASCII, :HTML and :XML")

;;; (DEFSPECIAL *EXPLANATION-STYLE* ...)

(CL:DEFVAR *EXPLANATION-STYLE* NULL
  "Keywords that controls how detailed explanations will be.
Valid values are :VERBOSE and :BRIEF.")

;;; (DEFSPECIAL *EXPLANATION-AUDIENCE* ...)

(CL:DEFVAR *EXPLANATION-AUDIENCE* NULL
  "Keywords that controls the language for justifications.
Valid values are :TECHNICAL and :LAY")

;;; (DEFGLOBAL *DEFAULT-EXPLANATION-DEPTH* ...)

(CL:DEFVAR *DEFAULT-EXPLANATION-DEPTH* 3
  "Maximal explanation depth used if not otherwise specified.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *DEFAULT-EXPLANATION-DEPTH*))

;;; (DEFGLOBAL *EXPLANATION-TAB-STRING* ...)

(CL:DEFVAR *EXPLANATION-TAB-STRING* "    ")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *EXPLANATION-TAB-STRING*))

;;; (DEFGLOBAL *MAX-INLINE-LABEL-LENGTH* ...)

(CL:DEFVAR *MAX-INLINE-LABEL-LENGTH* 10
  "Maximum length of a label string for which the following
proposition will be printed on the same line.")
(CL:DECLAIM (CL:TYPE CL:FIXNUM *MAX-INLINE-LABEL-LENGTH*))

;;; (DEFGLOBAL *EXPLANATION-ASSERTION-MARKER* ...)

(CL:DEFVAR *EXPLANATION-ASSERTION-MARKER* "!")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *EXPLANATION-ASSERTION-MARKER*))

;;; (DEFGLOBAL *EXPLANATION-FAILURE-MARKER* ...)

(CL:DEFVAR *EXPLANATION-FAILURE-MARKER* "?")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *EXPLANATION-FAILURE-MARKER*))

;;; (DEFGLOBAL *EXPLANATION-CUTOFF-MARKER* ...)

(CL:DEFVAR *EXPLANATION-CUTOFF-MARKER* "x")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *EXPLANATION-CUTOFF-MARKER*))

;;; (DEFGLOBAL *EXPLANATION-INFERENCE-MARKER* ...)

(CL:DEFVAR *EXPLANATION-INFERENCE-MARKER* " ")
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *EXPLANATION-INFERENCE-MARKER*))

;;; (DEFUN (EXPLANATION-TRUTH-MARKER STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  EXPLANATION-TRUTH-MARKER))
(CL:DEFUN EXPLANATION-TRUTH-MARKER (JUSTIFICATION)
  (CL:LET* ((HOLDSBY NULL))
   (CL:COND
    ((MARK-AS-EXPLICIT-ASSERTION? JUSTIFICATION)
     (CL:SETQ HOLDSBY KWD-EXPLANATIONS-ASSERTION))
    ((MARK-AS-FAILED-GOAL? JUSTIFICATION)
     (CL:SETQ HOLDSBY KWD-EXPLANATIONS-FAILURE))
    ((MARK-AS-CUTOFF-GOAL? JUSTIFICATION)
     (CL:SETQ HOLDSBY KWD-EXPLANATIONS-CUTOFF))
    (CL:T (CL:SETQ HOLDSBY KWD-EXPLANATIONS-INFERENCE)))
   (CL:COND
    ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
     (CL:LET*
      ((LABEL "Fact:") (GREEN "#00ff00") (YELLOW "#ffd70")
       (RED "#ff0000") (COLOR STELLA::NULL-STRING))
      (CL:DECLARE
       (CL:TYPE CL:SIMPLE-STRING LABEL GREEN YELLOW RED COLOR))
      (CL:COND
       ((CL:EQ HOLDSBY KWD-EXPLANATIONS-ASSERTION)
        (CL:WHEN
         (CL:EQ (%KIND (%PROPOSITION JUSTIFICATION))
          KWD-EXPLANATIONS-IMPLIES)
         (CL:SETQ LABEL "Rule:"))
        (CL:SETQ COLOR GREEN))
       ((CL:EQ HOLDSBY KWD-EXPLANATIONS-FAILURE) (CL:SETQ COLOR RED)
        (CL:SETQ LABEL "Unknown:"))
       ((CL:EQ HOLDSBY KWD-EXPLANATIONS-CUTOFF) (CL:SETQ COLOR RED)
        (CL:SETQ LABEL "Cutoff:"))
       ((CL:EQ HOLDSBY KWD-EXPLANATIONS-INFERENCE)
        (CL:SETQ LABEL "Inferred:")
        (CL:IF (PARTIALLY-FOLLOWS? JUSTIFICATION)
         (CL:SETQ COLOR YELLOW) (CL:SETQ COLOR GREEN)))
       (CL:T
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" HOLDSBY
          "' is not a valid case option")
         (CL:ERROR
          (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
      (CL:WHEN (CL:NOT (CL:EQ COLOR STELLA::NULL-STRING))
       (CL:SETQ LABEL
        (CONCATENATE "<font color=\"" COLOR "\">" "<strong>" LABEL
         "</strong>" "</font>")))
      LABEL))
    (CL:T
     (CL:COND
      ((CL:EQ HOLDSBY KWD-EXPLANATIONS-ASSERTION)
       *EXPLANATION-ASSERTION-MARKER*)
      ((CL:EQ HOLDSBY KWD-EXPLANATIONS-FAILURE)
       *EXPLANATION-FAILURE-MARKER*)
      ((CL:EQ HOLDSBY KWD-EXPLANATIONS-CUTOFF)
       *EXPLANATION-CUTOFF-MARKER*)
      ((CL:EQ HOLDSBY KWD-EXPLANATIONS-INFERENCE)
       *EXPLANATION-INFERENCE-MARKER*)
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`" HOLDSBY
         "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))))

;;; (DEFSPECIAL *EXPLANATION-VOCABULARY* ...)

(CL:DEFVAR *EXPLANATION-VOCABULARY* NULL
  "The currently active vocabulary lookup table")

;;; (DEFGLOBAL *EXPLANATION-VOCABULARIES* ...)

(CL:DEFVAR *EXPLANATION-VOCABULARIES* NULL
  "List of vocabularies with keyword keys")

;;; (DEFUN DEFINE-EXPLANATION-PHRASE ...)

(CL:DEFUN DEFINE-EXPLANATION-PHRASE (PHRASEKEY AUDIENCE PHRASE CL:&REST MODIFIERS)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING PHRASE))
  #+MCL
  (CL:CHECK-TYPE PHRASE CL:SIMPLE-STRING)
  (CL:LET* ((VOCABULARY (LOOKUP *EXPLANATION-VOCABULARIES* AUDIENCE)))
   (CL:LET* ((ARGLIST-000 NIL))
    (CL:LET* ((ARG-000 NULL) (ITER-000 MODIFIERS) (COLLECT-000 NULL))
     (CL:LOOP WHILE ITER-000 DO (CL:SETQ ARG-000 (CL:POP ITER-000))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN (CL:SETQ COLLECT-000 (CONS ARG-000 NIL))
        (CL:IF (CL:EQ ARGLIST-000 NIL)
         (CL:SETQ ARGLIST-000 COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST ARGLIST-000 COLLECT-000)))
       (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ARG-000 NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))))
    (CL:LET* ((MODS ARGLIST-000) (ENTRY NIL))
     (CL:WHEN (CL:EQ VOCABULARY NULL)
      (CL:SETQ VOCABULARY (NEW-HASH-TABLE))
      (INSERT-AT *EXPLANATION-VOCABULARIES* AUDIENCE VOCABULARY))
     (CL:SETQ ENTRY (LOOKUP VOCABULARY PHRASEKEY))
     (CL:WHEN (CL:EQ ENTRY NULL) (CL:SETQ ENTRY NIL))
     (INSERT-AT VOCABULARY PHRASEKEY
      (CONS (CONS (WRAP-STRING PHRASE) MODS) ENTRY))))))

;;; (DEFUN (LOOKUP-EXPLANATION-PHRASE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:T) CL:SIMPLE-STRING)
  LOOKUP-EXPLANATION-PHRASE))
(CL:DEFUN LOOKUP-EXPLANATION-PHRASE (PHRASEKEY MODIFIERS AUDIENCE)
  (CL:LET*
   ((VOCABULARY
     (LOOKUP *EXPLANATION-VOCABULARIES*
      (CL:IF (CL:NOT (CL:EQ AUDIENCE NULL)) AUDIENCE
       *EXPLANATION-AUDIENCE*)))
    (ENTRY NIL) (BESTPHRASE STELLA::NULL-STRING) (BESTSCORE -1))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING BESTPHRASE)
    (CL:TYPE CL:FIXNUM BESTSCORE))
   (CL:WHEN (CL:EQ VOCABULARY NULL)
    (CL:SETQ VOCABULARY
     (LOOKUP *EXPLANATION-VOCABULARIES* KWD-EXPLANATIONS-TECHNICAL)))
   (CL:WHEN (CL:EQ PHRASEKEY NULL)
    (CL:SETQ PHRASEKEY KWD-EXPLANATIONS-UNKNOWN-RULE))
   (CL:SETQ ENTRY (LOOKUP VOCABULARY PHRASEKEY))
   (CL:WHEN (CL:EQ ENTRY NULL)
    (CL:SETQ VOCABULARY
     (LOOKUP *EXPLANATION-VOCABULARIES* KWD-EXPLANATIONS-TECHNICAL))
    (CL:SETQ ENTRY (LOOKUP VOCABULARY PHRASEKEY)))
   (CL:WHEN (CL:EQ ENTRY NULL)
    (CL:RETURN-FROM LOOKUP-EXPLANATION-PHRASE
     (LOOKUP-EXPLANATION-PHRASE KWD-EXPLANATIONS-UNKNOWN-RULE NIL
      AUDIENCE)))
   (CL:LET* ((PHRASE NULL) (ITER-000 ENTRY))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ PHRASE (%%VALUE ITER-000))
     (CL:LET* ((TEST-VALUE-000 CL:NIL))
      (CL:LET* ((ALWAYS?-000 CL:T))
       (CL:LET* ((MOD NULL) (ITER-001 (%%REST PHRASE)))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
         (CL:SETQ MOD (%%VALUE ITER-001))
         (CL:WHEN (CL:NOT (MEMB? MODIFIERS MOD))
          (CL:SETQ ALWAYS?-000 CL:NIL) (CL:RETURN))
         (CL:SETQ ITER-001 (%%REST ITER-001))))
       (CL:SETQ TEST-VALUE-000 ALWAYS?-000))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ TEST-VALUE-000 (> (LENGTH (%%REST PHRASE)) BESTSCORE)))
      (CL:WHEN TEST-VALUE-000
       (CL:SETQ BESTSCORE (LENGTH (%%REST PHRASE)))
       (CL:SETQ BESTPHRASE (%WRAPPER-VALUE (%%VALUE PHRASE)))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   BESTPHRASE))

;;; (DEFCLASS EXPLANATION-INFO ...)

(CL:DEFCLASS EXPLANATION-INFO (STANDARD-OBJECT)
  ((LABEL :TYPE CL:SIMPLE-STRING :INITFORM STELLA::NULL-STRING
    :ALLOCATION :INSTANCE :ACCESSOR %LABEL)
   (DEPTH :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %DEPTH)
   (EXPLAINED? :ALLOCATION :INSTANCE :ACCESSOR %EXPLAINED?)))

(CL:DEFUN NEW-EXPLANATION-INFO ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE EXPLANATION-INFO)))
   (CL:SETF (%EXPLAINED? SELF) CL:NIL)
   (CL:SETF (%DEPTH SELF) NULL-INTEGER)
   (CL:SETF (%LABEL SELF) STELLA::NULL-STRING) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF EXPLANATION-INFO))
  SGT-EXPLANATIONS-LOGIC-EXPLANATION-INFO)

(CL:DEFUN ACCESS-EXPLANATION-INFO-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-EXPLANATIONS-STELLA-LABEL)
    (CL:IF SETVALUE? (CL:SETF (%LABEL SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-STRING (%LABEL SELF)))))
   ((CL:EQ SLOTNAME SYM-EXPLANATIONS-STELLA-DEPTH)
    (CL:IF SETVALUE? (CL:SETF (%DEPTH SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%DEPTH SELF)))))
   ((CL:EQ SLOTNAME SYM-EXPLANATIONS-LOGIC-EXPLAINED?)
    (CL:IF SETVALUE?
     (CL:SETF (%EXPLAINED? SELF)
      (COERCE-WRAPPED-BOOLEAN-TO-BOOLEAN VALUE))
     (CL:SETQ VALUE
      (CL:IF (%EXPLAINED? SELF) TRUE-WRAPPER FALSE-WRAPPER))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFUN (REGISTER-JUSTIFICATION EXPLANATION-INFO) ...)

(CL:DEFUN REGISTER-JUSTIFICATION (SELF MAPPING)
  (GET-EXPLANATION-INFO SELF MAPPING CL:T))

;;; (DEFUN (GET-EXPLANATION-INFO EXPLANATION-INFO) ...)

(CL:DEFUN GET-EXPLANATION-INFO (SELF MAPPING CREATE?)
  (CL:LET* ((INFO (LOOKUP MAPPING SELF)))
   (CL:WHEN (CL:EQ INFO NULL)
    (CL:LET*
     ((JUST NULL) (INFO NULL) (ITER-000 (%THE-KV-LIST MAPPING)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
      (CL:SETQ JUST (%KEY ITER-000)) (CL:SETQ INFO (%VALUE ITER-000))
      (CL:WHEN (JUSTIFICATION-EQL? JUST SELF)
       (INSERT-AT MAPPING SELF INFO)
       (CL:RETURN-FROM GET-EXPLANATION-INFO INFO))
      (CL:SETQ ITER-000 (%REST ITER-000))))
    (CL:WHEN CREATE? (CL:SETQ INFO (NEW-EXPLANATION-INFO))
     (INSERT-AT MAPPING SELF INFO)))
   INFO))

;;; (DEFUN (EXPLANATION-INFO EXPLANATION-INFO) ...)

(CL:DEFUN EXPLANATION-INFO (SELF MAPPING)
  (GET-EXPLANATION-INFO SELF MAPPING CL:NIL))

;;; (DEFUN (LOOKUP-JUSTIFICATION JUSTIFICATION) ...)

(CL:DEFUN LOOKUP-JUSTIFICATION (MAPPING LABEL)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL))
  #+MCL
  (CL:CHECK-TYPE LABEL CL:SIMPLE-STRING)
  (CL:LET*
   ((JUSTIFICATION NULL) (INFO NULL) (ITER-000 (%THE-KV-LIST MAPPING)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
    (CL:SETQ JUSTIFICATION (%KEY ITER-000))
    (CL:SETQ INFO (%VALUE ITER-000))
    (CL:WHEN (STRING-EQL? (%LABEL INFO) LABEL)
     (CL:RETURN-FROM LOOKUP-JUSTIFICATION JUSTIFICATION))
    (CL:SETQ ITER-000 (%REST ITER-000))))
  NULL)

;;; (DEFUN RESET-MAPPING-FOR-SUBEXPLANATION ...)

(CL:DEFUN RESET-MAPPING-FOR-SUBEXPLANATION (MAPPING)
  (CL:LET*
   ((JUSTIFICATION NULL) (INFO NULL) (ITER-000 (%THE-KV-LIST MAPPING)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NULL)) DO
    (CL:SETQ JUSTIFICATION (%KEY ITER-000))
    (CL:SETQ INFO (%VALUE ITER-000))
    (CL:SETQ JUSTIFICATION JUSTIFICATION)
    (CL:SETF (%EXPLAINED? INFO) CL:NIL)
    (CL:SETQ ITER-000 (%REST ITER-000)))))

;;; (DEFUN (PRINT-EXPLANATION EXPLANATION-MAPPING) ...)

(CL:DEFUN PRINT-EXPLANATION (SELF STREAM MAPPING MAXDEPTH AUDIENCE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM MAXDEPTH))
  #+MCL
  (CL:CHECK-TYPE MAXDEPTH CL:FIXNUM)
  (CL:LET* ((UNEXPLAINED (NEW-LIST)) (INFO NULL))
   (CL:SETQ SELF (VISIBLE-JUSTIFICATION SELF))
   (CL:COND
    ((CL:EQ MAPPING NULL) (CL:SETQ MAPPING (NEW-KEY-VALUE-LIST))
     (CL:SETQ INFO (REGISTER-JUSTIFICATION SELF MAPPING))
     (CL:SETF (%LABEL INFO) "1") (CL:SETF (%DEPTH INFO) 1))
    (CL:T (CL:SETQ INFO (EXPLANATION-INFO SELF MAPPING))
     (CL:WHEN (CL:EQ INFO NULL)
      (CL:ERROR
       (NEW-STELLA-EXCEPTION
        "Justification not found in supplied explanation mapping.")))
     (RESET-MAPPING-FOR-SUBEXPLANATION MAPPING)
     (CL:SETQ MAXDEPTH (CL:1- (CL:+ (%DEPTH INFO) MAXDEPTH)))))
   (PUSH UNEXPLAINED SELF)
   (CL:LET* ((*EXPLANATION-AUDIENCE* AUDIENCE))
    (CL:DECLARE (CL:SPECIAL *EXPLANATION-AUDIENCE*))
    (CL:LOOP WHILE (NON-EMPTY? UNEXPLAINED) DO
     (CL:SETQ SELF (POP UNEXPLAINED))
     (PRINT-ONE-EXPLANATION SELF STREAM MAPPING MAXDEPTH UNEXPLAINED)))
   (CL:SETQ *MOST-RECENT-EXPLANATION-MAPPING* MAPPING) MAPPING))

;;; (DEFUN PRINT-EXPLANATION-SUPPORT ...)

(CL:DEFUN PRINT-EXPLANATION-SUPPORT (SELF STREAM MAPPING MAXDEPTH UNEXPLAINED)
  (CL:DECLARE (CL:TYPE CL:FIXNUM MAXDEPTH))
  #+MCL
  (CL:CHECK-TYPE MAXDEPTH CL:FIXNUM)
  (PRINT-EXPLANATION-TEXT SELF STREAM MAPPING)
  (PRINT-EXPLANATION-SUBSTITUTION SELF STREAM MAPPING)
  (PRINT-EXPLANATION-ANTECEDENTS SELF STREAM MAPPING MAXDEPTH
   UNEXPLAINED))

;;; (DEFUN PRINT-ONE-EXPLANATION ...)

(CL:DEFUN PRINT-ONE-EXPLANATION (SELF STREAM MAPPING MAXDEPTH UNEXPLAINED)
  (CL:DECLARE (CL:TYPE CL:FIXNUM MAXDEPTH))
  #+MCL
  (CL:CHECK-TYPE MAXDEPTH CL:FIXNUM)
  (CL:COND
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)
    (PRINT-EXPLANATION-HEADER SELF STREAM MAPPING)
    (PRINT-EXPLANATION-SUPPORT SELF STREAM MAPPING MAXDEPTH
     UNEXPLAINED)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL))
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-XML)
    (CL:PROGN (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<inference>")
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL)
     (PRINT-EXPLANATION-HEADER SELF STREAM MAPPING)
     (CL:PROGN (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<support>")
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL)
      (PRINT-EXPLANATION-SUPPORT SELF STREAM MAPPING MAXDEPTH
       UNEXPLAINED)
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</support>" EOL))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</inference>" EOL)))
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
    (CL:PROGN (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<TABLE>")
     (CL:PROGN (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<TR>")
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL)
      (PRINT-EXPLANATION-HEADER SELF STREAM MAPPING)
      (PRINT-EXPLANATION-SUPPORT SELF STREAM MAPPING MAXDEPTH
       UNEXPLAINED)
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</TD>")
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</TR>" EOL))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</TABLE>" EOL)))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
      *EXPLANATION-FORMAT* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFSPECIAL *CURRENTJUSTIFICATION* ...)

(CL:DEFVAR *CURRENTJUSTIFICATION* NULL)

;;; (DEFUN (PRINTING-JUSTIFICATION? BOOLEAN) ...)

(CL:DEFUN PRINTING-JUSTIFICATION? ()
  (CL:NOT (CL:EQ *CURRENTJUSTIFICATION* NULL)))

;;; (DEFUN PRINT-JUSTIFICATION-PROPOSITION-FOR-FORMAT ...)

(CL:DEFUN PRINT-JUSTIFICATION-PROPOSITION-FOR-FORMAT (SELF STREAM INDENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  #+MCL
  (CL:CHECK-TYPE INDENT CL:FIXNUM)
  (CL:COND
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)
    (PRINT-JUSTIFICATION-PROPOSITION SELF STREAM INDENT))
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
    (CL:LET*
     ((STRING-STREAM (NEW-OUTPUT-STRING-STREAM)) (QUOTEHTML? CL:T))
     (PRINT-JUSTIFICATION-PROPOSITION SELF STRING-STREAM INDENT)
     (CL:WHEN *CYC-KLUDGES-ENABLED?*
      (CL:WHEN (CL:EQ *LOGIC-DIALECT* KWD-EXPLANATIONS-CYC-NL)
       (CL:SETQ QUOTEHTML? CL:NIL)))
     (CL:WHEN
      (CL:OR (CL:EQ *LOGIC-DIALECT* KWD-EXPLANATIONS-KIF-ONTOSAURUS)
       (CL:EQ *LOGIC-DIALECT* KWD-EXPLANATIONS-JAVA-GUI-HTML))
      (CL:SETQ QUOTEHTML? CL:NIL))
     (CL:IF QUOTEHTML?
      (WRITE-HTML-QUOTING-SPECIAL-CHARACTERS (%NATIVE-STREAM STREAM)
       (THE-STRING-READER STRING-STREAM))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
       (THE-STRING-READER STRING-STREAM)))))
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-XML)
    (CL:LET*
     ((PROPOSITION (%PROPOSITION SELF))
      (STRING-STREAM (NEW-OUTPUT-STRING-STREAM)))
     (PRINT-JUSTIFICATION-PROPOSITION SELF STRING-STREAM 0)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<proposition type=\"")
     (CL:IF (CL:EQ (%KIND PROPOSITION) KWD-EXPLANATIONS-IMPLIES)
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "RULE")
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "FACT"))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "\" truthvalue=\""
      (CL:IF (CL:EQ (%TRUTH-VALUE SELF) NULL) UNKNOWN-TRUTH-VALUE
       (%TRUTH-VALUE SELF)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "\">" EOL)
     (WRITE-HTML-QUOTING-SPECIAL-CHARACTERS (%NATIVE-STREAM STREAM)
      (THE-STRING-READER STRING-STREAM))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL "</proposition>")))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
      *EXPLANATION-FORMAT* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN PRINT-JUSTIFICATION-PROPOSITION ...)

(CL:DEFUN PRINT-JUSTIFICATION-PROPOSITION (SELF STREAM INDENT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM INDENT))
  #+MCL
  (CL:CHECK-TYPE INDENT CL:FIXNUM)
  (CL:LET*
   ((*INDENTCOUNTER* INDENT) (*PRINTMODE* KWD-EXPLANATIONS-REALISTIC))
   (CL:DECLARE (CL:SPECIAL *INDENTCOUNTER* *PRINTMODE*))
   (CL:DECLARE (CL:TYPE CL:FIXNUM *INDENTCOUNTER*))
   (CL:LET* ((PROPOSITION (%PROPOSITION SELF)))
    (CL:WHEN (%REVERSE-POLARITY? SELF)
     (CL:SETQ PROPOSITION
      (CREATE-PROPOSITION SYM-EXPLANATIONS-STELLA-NOT 1))
     (CL:LET
      ((SELF (%THE-ARRAY (%ARGUMENTS PROPOSITION)))
       (VALUE (%PROPOSITION SELF)) (POSITION 0))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE)))
    (CL:LET* ((*CURRENTJUSTIFICATION* SELF))
     (CL:DECLARE (CL:SPECIAL *CURRENTJUSTIFICATION*))
     (PRETTY-PRINT-LOGICAL-FORM PROPOSITION STREAM)))))

;;; (DEFUN PRINT-EXPLANATION-LABEL ...)

(CL:DEFUN PRINT-EXPLANATION-LABEL (STREAM LABEL HEAD?)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL))
  #+MCL
  (CL:CHECK-TYPE LABEL CL:SIMPLE-STRING)
  (CL:SETQ HEAD? HEAD?)
  (CL:COND
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)
    (%%PRINT-STREAM (%NATIVE-STREAM STREAM) LABEL))
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-XML)
    (CL:PROGN (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<label>")
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) LABEL)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</label>" EOL)))
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
    (CL:PROGN (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<STRONG>")
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) LABEL "&nbsp;")
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</STRONG>")))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
      *EXPLANATION-FORMAT* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN PRINT-EXPLANATION-HEADER ...)

(CL:DEFUN PRINT-EXPLANATION-HEADER (SELF STREAM MAPPING)
  (CL:LET*
   ((INFO (EXPLANATION-INFO SELF MAPPING)) (LABEL (%LABEL INFO))
    (INDENT (CL:1+ (CL:THE CL:FIXNUM (CL:LENGTH LABEL)))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL)
    (CL:TYPE CL:FIXNUM INDENT))
   (CL:COND
    ((CL:OR (CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-XML)
      (CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII))
     (PRINT-EXPLANATION-LABEL STREAM LABEL CL:T))
    ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
     (CL:PROGN
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
       "<TD align=left valign=top>")
      (PRINT-EXPLANATION-LABEL STREAM LABEL CL:T)
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</TD>" EOL)))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
       *EXPLANATION-FORMAT* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
   (CL:COND
    ((CL:> (CL:THE CL:FIXNUM (CL:LENGTH LABEL))
      *MAX-INLINE-LABEL-LENGTH*)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL
      *EXPLANATION-TAB-STRING*)
     (CL:SETQ INDENT
      (CL:THE CL:FIXNUM (CL:LENGTH *EXPLANATION-TAB-STRING*))))
    (CL:T (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " ")))
   (CL:COND
    ((CL:OR (CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-XML)
      (CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)))
    ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
      "<TD align=left valign=top>"))
    (CL:T
     (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
       *EXPLANATION-FORMAT* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))
   (PRINT-JUSTIFICATION-PROPOSITION-FOR-FORMAT SELF STREAM INDENT)
   (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL)
   (CL:SETF (%EXPLAINED? INFO) CL:T)))

;;; (DEFUN PRINT-EXPLANATION-TEXT ...)

(CL:DEFUN PRINT-EXPLANATION-TEXT (SELF STREAM MAPPING)
  (CL:LET*
   ((INTRODUCTION "") (INFERENCE STELLA::NULL-STRING)
    (AMPLIFICATION "") (MODIFIERS NIL)
    (MODIFIERS+ (CONS KWD-EXPLANATIONS-AMPLIFICATION NIL)))
   (CL:DECLARE
    (CL:TYPE CL:SIMPLE-STRING INTRODUCTION INFERENCE AMPLIFICATION))
   (CL:WHEN (%REVERSE-POLARITY? SELF)
    (CL:SETQ MODIFIERS (CONS KWD-EXPLANATIONS-REVERSE MODIFIERS))
    (CL:SETQ MODIFIERS+ (CONS KWD-EXPLANATIONS-REVERSE MODIFIERS+)))
   (CL:WHEN (PARTIALLY-FOLLOWS? SELF)
    (CL:SETQ MODIFIERS (CONS KWD-EXPLANATIONS-PARTIAL MODIFIERS))
    (CL:SETQ MODIFIERS+ (CONS KWD-EXPLANATIONS-PARTIAL MODIFIERS+)))
   (CL:COND
    ((FAILED-GOAL-JUSTIFICATION? SELF)
     (CL:SETQ INTRODUCTION
      (LOOKUP-EXPLANATION-PHRASE KWD-EXPLANATIONS-FAILED MODIFIERS
       NULL)))
    ((ISA? SELF SGT-EXPLANATIONS-LOGIC-CLASH-JUSTIFICATION)
     (CL:SETQ INTRODUCTION
      (LOOKUP-EXPLANATION-PHRASE KWD-EXPLANATIONS-INCONSISTENT
       MODIFIERS NULL)))
    (CL:T
     (CL:SETQ INTRODUCTION
      (LOOKUP-EXPLANATION-PHRASE KWD-EXPLANATIONS-FOLLOWS MODIFIERS
       NULL))))
   (CL:COND
    ((CL:EQ (%INFERENCE-RULE SELF) KWD-EXPLANATIONS-PRIMITIVE-STRATEGY)
     (CL:COND
      ((CL:EQ (INFERENCE-STRATEGY SELF)
        KWD-EXPLANATIONS-SCAN-PROPOSITIONS)
       (CL:WHEN
        (CL:NOT
         (CL:EQ
          (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%PROPOSITION SELF))
           SYM-EXPLANATIONS-LOGIC-MASTER-PROPOSITION NULL)
          NULL))
        (CL:SETQ INTRODUCTION
         (LOOKUP-EXPLANATION-PHRASE KWD-EXPLANATIONS-HOLDS NIL NULL))
        (CL:SETQ INFERENCE
         (MAKE-RULE-ORIGIN-EXPLANATION-PHRASE SELF))))
      (CL:T))
     (CL:WHEN (CL:EQ INFERENCE STELLA::NULL-STRING)
      (CL:SETQ INFERENCE
       (LOOKUP-EXPLANATION-PHRASE (INFERENCE-STRATEGY SELF) MODIFIERS
        NULL))))
    (CL:T
     (CL:SETQ INFERENCE
      (LOOKUP-EXPLANATION-PHRASE (%INFERENCE-RULE SELF) MODIFIERS
       NULL))
     (CL:SETQ AMPLIFICATION
      (LOOKUP-EXPLANATION-PHRASE (%INFERENCE-RULE SELF) MODIFIERS+
       NULL))))
   (CL:COND
    ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) *EXPLANATION-TAB-STRING*)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) INTRODUCTION " "
      INFERENCE)
     (CL:WHEN
      (CL:AND (CL:> (CL:THE CL:FIXNUM (CL:LENGTH AMPLIFICATION)) 0)
       (CL:NOT (STRING-EQL? AMPLIFICATION INFERENCE)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " " AMPLIFICATION))
     (CL:WHEN
      (CL:EQ (INFERENCE-DIRECTION SELF) KWD-EXPLANATIONS-FORWARD)
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " [Forward]"))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL))
    ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<BR>" EOL)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) INTRODUCTION " "
      INFERENCE)
     (CL:WHEN
      (CL:AND (CL:> (CL:THE CL:FIXNUM (CL:LENGTH AMPLIFICATION)) 0)
       (CL:NOT (STRING-EQL? AMPLIFICATION INFERENCE)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " " AMPLIFICATION))
     (CL:WHEN
      (CL:EQ (INFERENCE-DIRECTION SELF) KWD-EXPLANATIONS-FORWARD)
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " [Forward]"))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL))
    ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-XML)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<method")
     (CL:WHEN
      (CL:EQ (INFERENCE-DIRECTION SELF) KWD-EXPLANATIONS-FORWARD)
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " direction='forward'"))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) ">" INFERENCE "</method>"
      EOL))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
       *EXPLANATION-FORMAT* "' is not a valid case option")
      (CL:ERROR
       (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (MARK-AS-EXPLICIT-ASSERTION? BOOLEAN) ...)

(CL:DEFUN MARK-AS-EXPLICIT-ASSERTION? (SELF)
  (CL:WHEN (CL:EQ *EXPLANATION-STYLE* KWD-EXPLANATIONS-BRIEF)
   (CL:COND
    ((CL:EQ (%INFERENCE-RULE SELF) KWD-EXPLANATIONS-PRIMITIVE-STRATEGY)
     (CL:LET* ((TEST-VALUE-000 (%STRATEGY SELF)))
      (CL:COND
       ((CL:OR (CL:EQ TEST-VALUE-000 KWD-EXPLANATIONS-SCAN-COLLECTION)
         (CL:EQ TEST-VALUE-000 KWD-EXPLANATIONS-SCAN-PROPOSITIONS)
         (CL:EQ TEST-VALUE-000 KWD-EXPLANATIONS-LOOKUP-ASSERTIONS)
         (CL:EQ TEST-VALUE-000 KWD-EXPLANATIONS-EQUIVALENCE))
        (CL:RETURN-FROM MARK-AS-EXPLICIT-ASSERTION? CL:T))
       (CL:T))))
    (CL:T)))
  CL:NIL)

;;; (DEFUN (MARK-AS-FAILED-GOAL? BOOLEAN) ...)

(CL:DEFUN MARK-AS-FAILED-GOAL? (SELF)
  (CL:AND (CL:EQ *EXPLANATION-STYLE* KWD-EXPLANATIONS-BRIEF)
   (CL:EQ (%INFERENCE-RULE SELF) KWD-EXPLANATIONS-PRIMITIVE-STRATEGY)
   (FAILED-GOAL-JUSTIFICATION? SELF)))

;;; (DEFUN (MARK-AS-CUTOFF-GOAL? BOOLEAN) ...)

(CL:DEFUN MARK-AS-CUTOFF-GOAL? (SELF)
  (CUTOFF-GOAL-JUSTIFICATION? SELF))

;;; (DEFUN (PARTIALLY-FOLLOWS? BOOLEAN) ...)

(CL:DEFUN PARTIALLY-FOLLOWS? (SELF)
  (CL:OR (CL:EQ (%TRUTH-VALUE SELF) UNKNOWN-TRUTH-VALUE)
   (CL:EQ (%TRUTH-VALUE SELF) NULL)))

;;; (DEFUN (MAKE-RULE-ORIGIN-EXPLANATION-PHRASE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING)
  MAKE-RULE-ORIGIN-EXPLANATION-PHRASE))
(CL:DEFUN MAKE-RULE-ORIGIN-EXPLANATION-PHRASE (SELF)
  (CL:LET*
   ((SATELLITE (%PROPOSITION SELF))
    (MASTER
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS SATELLITE)
      SYM-EXPLANATIONS-LOGIC-MASTER-PROPOSITION NULL))
    (HEAD
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SATELLITE))) 1))
    (TAIL
     (CL:AREF
      (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS SATELLITE))) 0))
    (NAMEDSOURCE NULL) (SOURCE NULL))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 4))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO
     (CL:SETQ I ITER-000)
     (CL:ECASE I (1 (CL:SETQ SOURCE HEAD))
      (2
       (CL:SETQ SOURCE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS HEAD)
         SYM-EXPLANATIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL)))
      (3 (CL:SETQ SOURCE TAIL))
      (4
       (CL:SETQ SOURCE
        (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS TAIL)
         SYM-EXPLANATIONS-LOGIC-COMPLEMENT-DESCRIPTION NULL))))
     (CL:WHEN
      (CL:AND (CL:NOT (CL:EQ SOURCE NULL))
       (ISA? SOURCE SGT-EXPLANATIONS-LOGIC-NAMED-DESCRIPTION))
      (CL:WHEN (MEMBER? (ORIGINATED-PROPOSITIONS SOURCE) MASTER)
       (CL:SETQ NAMEDSOURCE SOURCE) (CL:RETURN)))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:IF (CL:NOT (CL:EQ NAMEDSOURCE NULL))
    (CONCATENATE
     (LOOKUP-EXPLANATION-PHRASE KWD-EXPLANATIONS-DEFINITION NIL NULL)
     " " (NAME-OBJECT-METACLASS NAMEDSOURCE) " "
     (%SYMBOL-NAME (DESCRIPTION-NAME NAMEDSOURCE)))
    (LOOKUP-EXPLANATION-PHRASE KWD-EXPLANATIONS-LOOKUP-ASSERTIONS NIL
     NULL))))

;;; (DEFUN (GET-EXPLANATION-SUBSTITUTION ENTITY-MAPPING) ...)

(CL:DEFUN GET-EXPLANATION-SUBSTITUTION (SELF)
  (CL:LET*
   ((RULE-JUSTIFICATION (%%VALUE (%ANTECEDENTS SELF)))
    (RULE (%PROPOSITION RULE-JUSTIFICATION))
    (ANTECEDENT-JUSTIFICATION (%%VALUE (%%REST (%ANTECEDENTS SELF))))
    (ANTECEDENT-SUBSTITUTION (%SUBSTITUTION ANTECEDENT-JUSTIFICATION)))
   (CL:WHEN (ISA? SELF SGT-EXPLANATIONS-LOGIC-FORWARD-JUSTIFICATION)
    (CL:SETQ ANTECEDENT-SUBSTITUTION (%SUBSTITUTION SELF)))
   ANTECEDENT-SUBSTITUTION))

;;; (DEFUN PRINT-ONE-VARIABLE-SUBSTITUTION ...)

(CL:DEFUN PRINT-ONE-VARIABLE-SUBSTITUTION (STREAM VAR VALUE)
  (CL:COND
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)
    (PRETTY-PRINT-LOGICAL-FORM VAR STREAM)
    (CL:WHEN (EQL? (VALUE-OF VAR) VAR)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "/")
     (CL:COND
      ((CL:AND (CL:NOT (CL:EQ VALUE NULL))
        (ISA? VALUE SGT-EXPLANATIONS-LOGIC-ALTERNATIVE-BINDINGS-SET))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "{")
       (CL:LET*
        ((BINDING NULL)
         (ITER-000 (ALLOCATE-ITERATOR (%BINDINGS VALUE))))
        (CL:LOOP WHILE (NEXT? ITER-000) DO
         (CL:SETQ BINDING (%VALUE ITER-000))
         (PRETTY-PRINT-LOGICAL-FORM BINDING STREAM)
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM) ", ")))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "...}"))
      (CL:T (PRETTY-PRINT-LOGICAL-FORM VALUE STREAM)))))
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
    (CL:LET*
     ((STRING-STREAM (NEW-OUTPUT-STRING-STREAM)) (QUOTEHTML? CL:T))
     (CL:WHEN *CYC-KLUDGES-ENABLED?*
      (CL:WHEN (CL:EQ *LOGIC-DIALECT* KWD-EXPLANATIONS-CYC-NL)
       (CL:SETQ QUOTEHTML? CL:NIL)))
     (CL:WHEN
      (CL:OR (CL:EQ *LOGIC-DIALECT* KWD-EXPLANATIONS-KIF-ONTOSAURUS)
       (CL:EQ *LOGIC-DIALECT* KWD-EXPLANATIONS-JAVA-GUI-HTML))
      (CL:SETQ QUOTEHTML? CL:NIL))
     (PRETTY-PRINT-LOGICAL-FORM VAR STRING-STREAM)
     (CL:WHEN (EQL? (VALUE-OF VAR) VAR)
      (%%PRINT-STREAM (%NATIVE-STREAM STRING-STREAM) "/")
      (CL:COND
       ((CL:AND (CL:NOT (CL:EQ VALUE NULL))
         (ISA? VALUE SGT-EXPLANATIONS-LOGIC-ALTERNATIVE-BINDINGS-SET))
        (%%PRINT-STREAM (%NATIVE-STREAM STRING-STREAM) "{one of ")
        (CL:LET*
         ((BINDING NULL)
          (ITER-001 (ALLOCATE-ITERATOR (%BINDINGS VALUE))))
         (CL:LOOP WHILE (NEXT? ITER-001) DO
          (CL:SETQ BINDING (%VALUE ITER-001))
          (PRETTY-PRINT-LOGICAL-FORM BINDING STRING-STREAM)
          (%%PRINT-STREAM (%NATIVE-STREAM STRING-STREAM) ", ")))
        (%%PRINT-STREAM (%NATIVE-STREAM STRING-STREAM) "etc.}"))
       (CL:T (PRETTY-PRINT-LOGICAL-FORM VALUE STRING-STREAM))))
     (CL:IF QUOTEHTML?
      (WRITE-HTML-QUOTING-SPECIAL-CHARACTERS (%NATIVE-STREAM STREAM)
       (THE-STRING-READER STRING-STREAM))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
       (THE-STRING-READER STRING-STREAM)))))
   ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-XML)
    (CL:LET* ((STRING-STREAM (NEW-OUTPUT-STRING-STREAM)))
     (CL:PROGN (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<binding>")
      (PRETTY-PRINT-LOGICAL-FORM VAR STRING-STREAM)
      (CL:PROGN (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<variable>")
       (WRITE-HTML-QUOTING-SPECIAL-CHARACTERS (%NATIVE-STREAM STREAM)
        (THE-STRING-READER STRING-STREAM))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</variable>" EOL))
      (CL:WHEN (EQL? (VALUE-OF VAR) VAR)
       (CL:SETQ STRING-STREAM (NEW-OUTPUT-STRING-STREAM))
       (PRETTY-PRINT-LOGICAL-FORM VALUE STRING-STREAM)
       (CL:PROGN (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<value>")
        (WRITE-HTML-QUOTING-SPECIAL-CHARACTERS (%NATIVE-STREAM STREAM)
         (THE-STRING-READER STRING-STREAM))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</value>")))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</binding>" EOL))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
      *EXPLANATION-FORMAT* "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))))

;;; (DEFUN PRINT-EXPLANATION-SUBSTITUTION ...)

(CL:DEFUN PRINT-EXPLANATION-SUBSTITUTION (SELF STREAM MAPPING)
  (CL:SETQ MAPPING MAPPING)
  (CL:WHEN
   (CL:OR (CL:EQ (%INFERENCE-RULE SELF) KWD-EXPLANATIONS-MODUS-PONENS)
    (CL:EQ (%INFERENCE-RULE SELF) KWD-EXPLANATIONS-MODUS-TOLLENS))
   (CL:LET*
    ((SUBSTITUTION (GET-EXPLANATION-SUBSTITUTION SELF))
     (NOFVARS NULL-INTEGER))
    (CL:DECLARE (CL:TYPE CL:FIXNUM NOFVARS))
    (CL:WHEN (CL:NOT (CL:EQ SUBSTITUTION NULL))
     (CL:SETQ NOFVARS (LENGTH SUBSTITUTION))
     (CL:COND
      ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) *EXPLANATION-TAB-STRING*
        "with substitution {"))
      ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<BR><TABLE><TR>" EOL)
       (CL:PROGN
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
         "<TD align=left valign=top>")
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
         "with&nbsp;substitution" EOL)
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</TD>" EOL))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<TD>{"))
      ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-XML)
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<variables>"))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
         *EXPLANATION-FORMAT* "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
     (CL:LET*
      ((VAR NULL) (VALUE NULL)
       (ITER-000 (ALLOCATE-ITERATOR SUBSTITUTION)) (I NULL-INTEGER)
       (ITER-001 1) (UPPER-BOUND-000 NOFVARS)
       (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-000))
      (CL:LOOP WHILE
       (CL:AND (NEXT? ITER-000)
        (CL:OR UNBOUNDED?-000 (CL:<= ITER-001 UPPER-BOUND-000)))
       DO (CL:SETQ VAR (%KEY ITER-000))
       (CL:SETQ VALUE (%VALUE ITER-000)) (CL:SETQ I ITER-001)
       (PRINT-ONE-VARIABLE-SUBSTITUTION STREAM VAR VALUE)
       (CL:WHEN
        (CL:AND (CL:< I NOFVARS)
         (CL:OR (CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)
          (CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM) ", ")
        (CL:WHEN *CYC-KLUDGES-ENABLED?*
         (CL:WHEN
          (CL:OR (CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)
           (CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL
           *EXPLANATION-TAB-STRING* "                   "))))
       (CL:SETQ ITER-001 (CL:1+ ITER-001))))
     (CL:COND
      ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "}" EOL))
      ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "}</TD></TR></TABLE>"
        EOL))
      ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-XML)
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</variables>" EOL))
      (CL:T
       (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
         *EXPLANATION-FORMAT* "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))))

;;; (DEFUN PRINT-EXPLANATION-ANTECEDENTS ...)

(CL:DEFUN PRINT-EXPLANATION-ANTECEDENTS (SELF STREAM MAPPING MAXDEPTH UNEXPLAINED)
  (CL:DECLARE (CL:TYPE CL:FIXNUM MAXDEPTH))
  #+MCL
  (CL:CHECK-TYPE MAXDEPTH CL:FIXNUM)
  (CL:LET*
   ((INFO (EXPLANATION-INFO SELF MAPPING)) (LABEL (%LABEL INFO))
    (DEPTH (%DEPTH INFO)) (ANTECEDENTS (VISIBLE-ANTECEDENTS SELF))
    (NEWANTECEDENTS NIL) (NEWANTECEDENTSINDEX 0) (MAXLABELLENGTH 0)
    (HAVEMARKEDANTECEDENT? CL:NIL)
    (LABELSTARTPOSITION
     (CL:+ (CL:THE CL:FIXNUM (CL:LENGTH *EXPLANATION-TAB-STRING*)) 6))
    (PROPOSITIONSTARTPOSITION 0) (INDENT 0))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL)
    (CL:TYPE CL:FIXNUM DEPTH NEWANTECEDENTSINDEX MAXLABELLENGTH
     LABELSTARTPOSITION PROPOSITIONSTARTPOSITION INDENT))
   (CL:LET* ((ANTECEDENT NULL) (ITER-000 (%THE-CONS-LIST ANTECEDENTS)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
     (CL:SETQ INFO (EXPLANATION-INFO ANTECEDENT MAPPING))
     (CL:WHEN (CL:EQ INFO NULL)
      (CL:SETQ INFO (REGISTER-JUSTIFICATION ANTECEDENT MAPPING))
      (CL:SETF (%LABEL INFO)
       (CONCATENATE LABEL "."
        (INTEGER-TO-STRING
         (CL:TRUNCATE
          (CL:SETQ NEWANTECEDENTSINDEX (CL:1+ NEWANTECEDENTSINDEX))))))
      (CL:SETF (%DEPTH INFO) (CL:1+ DEPTH)))
     (CL:SETQ MAXLABELLENGTH
      (MAX MAXLABELLENGTH
       (CL:THE CL:FIXNUM
        (CL:LENGTH (CL:THE CL:SIMPLE-STRING (%LABEL INFO))))))
     (CL:WHEN (CL:NOT HAVEMARKEDANTECEDENT?)
      (CL:SETQ HAVEMARKEDANTECEDENT?
       (CL:OR (MARK-AS-EXPLICIT-ASSERTION? ANTECEDENT)
        (MARK-AS-FAILED-GOAL? ANTECEDENT))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:IF (CL:> MAXLABELLENGTH *MAX-INLINE-LABEL-LENGTH*)
    (CL:SETQ PROPOSITIONSTARTPOSITION LABELSTARTPOSITION)
    (CL:SETQ PROPOSITIONSTARTPOSITION
     (CL:+ LABELSTARTPOSITION MAXLABELLENGTH 1)))
   (CL:COND
    ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<TABLE>" EOL))
    (CL:T))
   (CL:LET*
    ((ANTECEDENT NULL) (ITER-001 (%THE-CONS-LIST ANTECEDENTS))
     (I NULL-INTEGER) (ITER-002 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ ANTECEDENT (%%VALUE ITER-001)) (CL:SETQ I ITER-002)
     (CL:SETQ INFO (EXPLANATION-INFO ANTECEDENT MAPPING))
     (CL:SETQ LABEL (%LABEL INFO))
     (CL:WHEN
      (CL:NOT
       (CL:OR (%EXPLAINED? INFO)
        (MARK-AS-EXPLICIT-ASSERTION? ANTECEDENT)
        (MARK-AS-FAILED-GOAL? ANTECEDENT)
        (CL:AND (CL:NOT (CL:= MAXDEPTH NULL-INTEGER))
         (CL:> (%DEPTH INFO) MAXDEPTH))))
      (CL:SETQ NEWANTECEDENTS (CONS ANTECEDENT NEWANTECEDENTS)))
     (CL:COND
      ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) *EXPLANATION-TAB-STRING*
        (CL:IF (CL:= I 1) "since " "and   "))
       (PRINT-EXPLANATION-LABEL STREAM LABEL CL:NIL)
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " ")
       (CL:COND
        ((CL:> MAXLABELLENGTH *MAX-INLINE-LABEL-LENGTH*)
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL)
         (CL:SETQ INDENT PROPOSITIONSTARTPOSITION))
        (CL:T
         (CL:SETQ INDENT
          (CL:- PROPOSITIONSTARTPOSITION
           (CL:+ LABELSTARTPOSITION
            (CL:THE CL:FIXNUM (CL:LENGTH LABEL)))
           1))))
       (CL:LET*
        ((I NULL-INTEGER) (ITER-003 1) (UPPER-BOUND-000 INDENT)
         (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003 UPPER-BOUND-000))
        (CL:LOOP WHILE
         (CL:OR UNBOUNDED?-000 (CL:<= ITER-003 UPPER-BOUND-000)) DO
         (CL:SETQ I ITER-003) (CL:SETQ I I)
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " ")
         (CL:SETQ ITER-003 (CL:1+ ITER-003))))
       (CL:WHEN HAVEMARKEDANTECEDENT?
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
         (EXPLANATION-TRUTH-MARKER ANTECEDENT) " ")))
      ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<TR>" EOL)
       (CL:PROGN
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
         "<TD align=right valign=top>")
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
         (CL:IF (CL:= I 1) "since&nbsp;" "and&nbsp;"))
        (PRINT-EXPLANATION-LABEL STREAM LABEL CL:NIL)
        (CL:PROGN
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
          "<TD align=left valign=top>")
         (CL:WHEN HAVEMARKEDANTECEDENT?
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM)
           (EXPLANATION-TRUTH-MARKER ANTECEDENT)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</TD>"))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</TD>" EOL)))
      ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-XML)
       (PRINT-EXPLANATION-LABEL STREAM LABEL CL:NIL))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
         *EXPLANATION-FORMAT* "' is not a valid case option")
        (CL:ERROR
         (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
     (CL:COND
      ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "<TD>" EOL))
      (CL:T))
     (PRINT-JUSTIFICATION-PROPOSITION-FOR-FORMAT ANTECEDENT STREAM
      (CL:IF HAVEMARKEDANTECEDENT?
       (CL:+ PROPOSITIONSTARTPOSITION
        (CL:1+
         (CL:THE CL:FIXNUM
          (CL:LENGTH
           (CL:THE CL:SIMPLE-STRING
            (EXPLANATION-TRUTH-MARKER ANTECEDENT))))))
       PROPOSITIONSTARTPOSITION))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL)
     (CL:COND
      ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</TD></TR>" EOL))
      (CL:T))
     (CL:SETQ ITER-001 (%%REST ITER-001))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))))
   (CL:COND
    ((CL:EQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-HTML)
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "</TABLE>" EOL))
    (CL:T))
   (CL:LET* ((ANTECEDENT NULL) (ITER-004 NEWANTECEDENTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
     (CL:SETQ ANTECEDENT (%%VALUE ITER-004))
     (PUSH UNEXPLAINED ANTECEDENT)
     (CL:SETQ ITER-004 (%%REST ITER-004))))))

;;; (DEFUN (VISIBLE-JUSTIFICATION JUSTIFICATION) ...)

(CL:DEFUN VISIBLE-JUSTIFICATION (SELF)
  (CL:COND
   ((CL:OR
     (CL:AND (CL:EQ (%INFERENCE-RULE SELF) KWD-EXPLANATIONS-DISPROOF)
      (CL:NOT (%REVERSE-POLARITY? SELF)))
     (CL:AND
      (CL:EQ (%INFERENCE-RULE SELF)
       KWD-EXPLANATIONS-PRIMITIVE-STRATEGY)
      (CL:EQ (INFERENCE-STRATEGY SELF)
       KWD-EXPLANATIONS-GOAL-COMPLEMENT)))
    (VISIBLE-JUSTIFICATION (%%VALUE (%ANTECEDENTS SELF))))
   ((CL:EQ (%INFERENCE-RULE SELF) KWD-EXPLANATIONS-PATTERN)
    (VISIBLE-JUSTIFICATION (%%VALUE (%ANTECEDENTS SELF))))
   (CL:T SELF)))

;;; (DEFUN (VISIBLE-ANTECEDENTS (LIST OF JUSTIFICATION)) ...)

(CL:DEFUN VISIBLE-ANTECEDENTS (SELF)
  (CL:LET* ((VISIBLEANTECEDENTS (NEW-LIST)))
   (COLLECT-VISIBLE-ANTECEDENTS SELF VISIBLEANTECEDENTS)
   (REVERSE VISIBLEANTECEDENTS)))

;;; (DEFUN COLLECT-VISIBLE-ANTECEDENTS ...)

(CL:DEFUN COLLECT-VISIBLE-ANTECEDENTS (SELF VISIBLEANTECEDENTS)
  (CL:LET* ((ANTECEDENTS (%ANTECEDENTS SELF)))
   (CL:LET* ((ANTECEDENT NULL) (ITER-000 ANTECEDENTS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ANTECEDENT (%%VALUE ITER-000))
     (CL:SETQ ANTECEDENT (VISIBLE-JUSTIFICATION ANTECEDENT))
     (CL:LET* ((TEST-VALUE-000 (%INFERENCE-RULE ANTECEDENT)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 KWD-EXPLANATIONS-AND-INTRODUCTION)
        (CL:IF (CL:EQ *EXPLANATION-STYLE* KWD-EXPLANATIONS-BRIEF)
         (CL:LET*
          ((SUBANTECEDENT NULL)
           (ITER-001
            (%THE-CONS-LIST (VISIBLE-ANTECEDENTS ANTECEDENT))))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
           (CL:SETQ SUBANTECEDENT (%%VALUE ITER-001))
           (PUSH VISIBLEANTECEDENTS SUBANTECEDENT)
           (CL:SETQ ITER-001 (%%REST ITER-001))))
         (PUSH VISIBLEANTECEDENTS ANTECEDENT)))
       ((CL:EQ TEST-VALUE-000 KWD-EXPLANATIONS-PRIMITIVE-STRATEGY)
        (CL:COND
         ((CL:EQ (%STRATEGY ANTECEDENT) KWD-EXPLANATIONS-EQUIVALENCE)
          (CL:WHEN
           (CL:NOT
            (AUXILIARY-EQUIVALENCE-PROPOSITION?
             (%PROPOSITION ANTECEDENT)))
           (PUSH VISIBLEANTECEDENTS ANTECEDENT)))
         (CL:T (PUSH VISIBLEANTECEDENTS ANTECEDENT))))
       (CL:T (PUSH VISIBLEANTECEDENTS ANTECEDENT))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFSPECIAL *MOST-RECENT-EXPLANATION-MAPPING* ...)

(CL:DEFVAR *MOST-RECENT-EXPLANATION-MAPPING* NULL)

;;; (DEFUN WHY ...)

(CL:DEFUN %WHY (ARGS)
  "Print an explanation for the result of the most recent query.
Without any arguments, `why' prints an explanation of the top level
query proposition down to a maximum depth of 3.  `(why all)' prints
an explanation to unlimited depth.  Alternatively, a particular depth
can be specified, for example, `(why 5)' explains down to a depth of 5.
A proof step that was not explained explicitly (e.g., due to a depth
cutoff) can be explained by supplying the label of the step as the
first argument to `why', for example, `(why 1.2.3 5)' prints an explanation
starting at 1.2.3 down to a depth of 5 (which is counted relative to the
depth of the starting point).  The keywords `brief' and `verbose' can be
used to select a particular explanation style.  In brief mode, explicitly
asserted propositions are not further explained and indicated with a
`!' assertion marker.  Additionally, relatively uninteresting proof steps
such as AND-introductions are skipped.  This explanation style option is
sticky and will affect future calls to `why' until it gets changed again.
The various options can be combined in any way, for example,
`(why 1.2.3 brief 3)' explains starting from step 1.2.3 down to a depth
of 3 in brief explanation mode."
  (CL:LET*
   ((LABEL STELLA::NULL-STRING) (STYLE NULL) (MAXDEPTH NULL-INTEGER)
    (SUMMARY? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL)
    (CL:TYPE CL:FIXNUM MAXDEPTH))
   (CL:MULTIPLE-VALUE-SETQ (LABEL STYLE MAXDEPTH SUMMARY?)
    (PARSE-WHY-ARGUMENTS ARGS))
   (CL:SETQ SUMMARY? SUMMARY?)
   (EXPLAIN-WHY LABEL STYLE MAXDEPTH STANDARD-OUTPUT)))

(CL:DEFUN WHY-EVALUATOR-WRAPPER (ARGUMENTS)
  (%WHY ARGUMENTS))

(CL:DEFMACRO WHY (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Print an explanation for the result of the most recent query.
Without any arguments, `why' prints an explanation of the top level
query proposition down to a maximum depth of 3.  `(why all)' prints
an explanation to unlimited depth.  Alternatively, a particular depth
can be specified, for example, `(why 5)' explains down to a depth of 5.
A proof step that was not explained explicitly (e.g., due to a depth
cutoff) can be explained by supplying the label of the step as the
first argument to `why', for example, `(why 1.2.3 5)' prints an explanation
starting at 1.2.3 down to a depth of 5 (which is counted relative to the
depth of the starting point).  The keywords `brief' and `verbose' can be
used to select a particular explanation style.  In brief mode, explicitly
asserted propositions are not further explained and indicated with a
`!' assertion marker.  Additionally, relatively uninteresting proof steps
such as AND-introductions are skipped.  This explanation style option is
sticky and will affect future calls to `why' until it gets changed again.
The various options can be combined in any way, for example,
`(why 1.2.3 brief 3)' explains starting from step 1.2.3 down to a depth
of 3 in brief explanation mode."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/WHY|)) (CL:MACRO-FUNCTION (CL:QUOTE WHY)))

;;; (DEFUN EXPLAIN-WHY ...)

(CL:DEFUN EXPLAIN-WHY (LABEL STYLE MAXDEPTH STREAM)
  "Programmer's interface to WHY function."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL)
   (CL:TYPE CL:FIXNUM MAXDEPTH))
  #+MCL
  (CL:CHECK-TYPE LABEL CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE MAXDEPTH CL:FIXNUM)
  (CL:HANDLER-CASE
   (CL:LET* ((JUSTIFICATION (GET-WHY-JUSTIFICATION LABEL)))
    (CL:LET*
     ((*EXPLANATION-STYLE*
       (CL:IF (CL:NOT (CL:EQ STYLE NULL)) STYLE
        KWD-EXPLANATIONS-BRIEF)))
     (CL:DECLARE (CL:SPECIAL *EXPLANATION-STYLE*))
     (PRINT-EXPLANATION JUSTIFICATION STREAM
      *MOST-RECENT-EXPLANATION-MAPPING* MAXDEPTH
      *EXPLANATION-AUDIENCE*)))
   (EXPLAIN-EXCEPTION (EE)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     (EXCEPTION-MESSAGE EE)))))

;;; (DEFUN EXPLAIN-PROPOSITION ...)

(CL:DEFUN EXPLAIN-PROPOSITION (PROP STYLE MAXDEPTH STREAM)
  "Print an explanation for `prop' if there is one.  This will only happen
for forward-chained propositions."
  (CL:DECLARE (CL:TYPE CL:FIXNUM MAXDEPTH))
  #+MCL
  (CL:CHECK-TYPE MAXDEPTH CL:FIXNUM)
  (CL:HANDLER-CASE
   (CL:LET* ((JUSTIFICATIONS (FORWARD-JUSTIFICATIONS PROP)))
    (CL:WHEN (CL:NOT (CL:EQ JUSTIFICATIONS NULL))
     (CL:LET*
      ((*EXPLANATION-STYLE*
        (CL:IF (CL:NOT (CL:EQ STYLE NULL)) STYLE
         KWD-EXPLANATIONS-BRIEF))
       (*MOST-RECENT-EXPLANATION-MAPPING* NULL))
      (CL:DECLARE
       (CL:SPECIAL *EXPLANATION-STYLE*
        *MOST-RECENT-EXPLANATION-MAPPING*))
      (CL:LET*
       ((JUSTIFICATION NULL)
        (ITER-000 (%THE-CONS-LIST JUSTIFICATIONS)))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
        (CL:SETQ JUSTIFICATION (%%VALUE ITER-000))
        (CL:SETQ *MOST-RECENT-EXPLANATION-MAPPING* NULL)
        (PRINT-EXPLANATION JUSTIFICATION STREAM
         *MOST-RECENT-EXPLANATION-MAPPING* MAXDEPTH
         *EXPLANATION-AUDIENCE*)
        (CL:SETQ ITER-000 (%%REST ITER-000)))))))
   (EXPLAIN-EXCEPTION (EE)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     (EXCEPTION-MESSAGE EE)))))

;;; (DEFUN (GET-WHY-JUSTIFICATION JUSTIFICATION) ...)

(CL:DEFUN GET-WHY-JUSTIFICATION (LABEL)
  "Returns the current WHY justification.  May also throw one of the
following subtypes of EXPLAIN-EXCEPTION:
   EXPLAIN-NO-QUERY-EXCEPTION
   EXPLAIN-NO-SOLUTION-EXCEPTION
   EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION
   EXPLAIN-NOT-ENABLED-EXCEPTION
   EXPLAIN-NO-SUCH-LABEL-EXCEPTION
   EXPLAIN-QUERY-TRUE-EXCEPTION"
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL))
  #+MCL
  (CL:CHECK-TYPE LABEL CL:SIMPLE-STRING)
  (CL:LET*
   ((QUERY *MOST-RECENT-QUERY*) (PARTIALQUERY? CL:NIL)
    (JUSTIFICATION NULL))
   (CL:WHEN (CL:EQ QUERY NULL)
    (CL:ERROR
     (NEW-EXPLAIN-NO-QUERY-EXCEPTION "There is nothing to explain.")))
   (CL:SETQ PARTIALQUERY?
    (CL:NOT
     (CL:EQ (%PARTIAL-MATCH-STRATEGY *MOST-RECENT-QUERY*) NULL)))
   (CL:SETQ JUSTIFICATION
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%BASE-CONTROL-FRAME QUERY))
     SYM-EXPLANATIONS-LOGIC-JUSTIFICATION NULL))
   (CL:COND
    ((CL:EQ JUSTIFICATION NULL)
     (CL:COND
      ((NON-EMPTY? (%SOLUTIONS QUERY))
       (CL:IF (%EXHAUSTED? QUERY)
        (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000)
          "There were either no more solutions, or you used the `all' keyword."
          EOL
          "   The query must generate only a single answer for explanation"
          EOL
          "   to be possible, thus don't use the `all' keyword to `retrieve'.")
         (CL:ERROR
          (NEW-EXPLAIN-NO-SOLUTION-EXCEPTION
           (THE-STRING-READER STREAM-000))))
        (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001)
          "No justifications available.  You have to enable justifications"
          EOL
          "   with `(set-feature justifications)' and rerun the query in"
          EOL "   order to enable the explanation of results.")
         (CL:ERROR
          (NEW-EXPLAIN-NOT-ENABLED-EXCEPTION
           (THE-STRING-READER STREAM-001))))))
      ((%EXHAUSTED? QUERY)
       (CL:ERROR
        (NEW-EXPLAIN-NO-SOLUTION-EXCEPTION "There was no solution.")))
      (CL:T
       (CL:ERROR
        (NEW-EXPLAIN-NO-SOLUTION-EXCEPTION
         "There is no solution yet.")))))
    ((CL:AND (%EXHAUSTED? QUERY) (CL:NOT PARTIALQUERY?))
     (CL:ERROR
      (NEW-EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION
       "There were no more solutions.")))
    (CL:T
     (CL:COND
      ((CL:NOT (CL:EQ LABEL STELLA::NULL-STRING))
       (CL:WHEN (CL:NOT (CL:EQ *MOST-RECENT-EXPLANATION-MAPPING* NULL))
        (CL:SETQ JUSTIFICATION
         (LOOKUP-JUSTIFICATION *MOST-RECENT-EXPLANATION-MAPPING*
          LABEL)))
       (CL:WHEN (CL:EQ JUSTIFICATION NULL)
        (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "Label `" LABEL
          "' does not exists in the current explanation.")
         (CL:ERROR
          (NEW-EXPLAIN-NO-SUCH-LABEL-EXCEPTION
           (THE-STRING-READER STREAM-002))))))
      (CL:T (CL:SETQ *MOST-RECENT-EXPLANATION-MAPPING* NULL)))
     JUSTIFICATION))))

;;; (DEFUN (COMMAND-OPTION-EQL? BOOLEAN) ...)

(CL:DEFUN COMMAND-OPTION-EQL? (ARG OPTION)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING OPTION))
  #+MCL
  (CL:CHECK-TYPE OPTION CL:SIMPLE-STRING)
  (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ARG)))
   (CL:COND
    ((SUBTYPE-OF? TEST-VALUE-000
      SGT-EXPLANATIONS-STELLA-GENERALIZED-SYMBOL)
     (CL:PROGN
      (STRING-EQL? (STRING-UPCASE (%SYMBOL-NAME ARG)) OPTION)))
    ((SUBTYPE-OF-STRING? TEST-VALUE-000)
     (CL:PROGN
      (STRING-EQL? (STRING-UPCASE (%WRAPPER-VALUE ARG)) OPTION)))
    (CL:T CL:NIL))))

;;; (DEFUN (PARSE-WHY-ARGUMENTS STRING KEYWORD INTEGER BOOLEAN) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:T) (CL:VALUES CL:SIMPLE-STRING CL:T CL:FIXNUM CL:T))
  PARSE-WHY-ARGUMENTS))
(CL:DEFUN PARSE-WHY-ARGUMENTS (ARGS)
  (CL:LET*
   ((LABEL STELLA::NULL-STRING) (DEPTH *DEFAULT-EXPLANATION-DEPTH*)
    (STYLE NULL) (SUMMARY? CL:NIL) (FIRSTARG (%%VALUE ARGS)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LABEL)
    (CL:TYPE CL:FIXNUM DEPTH))
   (CL:WHEN (CL:NOT (CL:EQ FIRSTARG NULL))
    (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE FIRSTARG)))
     (CL:COND
      ((SUBTYPE-OF-STRING? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ LABEL (%WRAPPER-VALUE FIRSTARG))
        (CL:SETQ ARGS (%%REST ARGS))))
      ((SUBTYPE-OF-INTEGER? TEST-VALUE-000)
       (CL:PROGN
        (CL:WHEN (EQL? FIRSTARG ONE-WRAPPER) (CL:SETQ LABEL "1")
         (CL:SETQ ARGS (%%REST ARGS)))))
      ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
       (CL:PROGN (CL:SETQ LABEL (STRINGIFY FIRSTARG))
        (CL:SETQ ARGS (%%REST ARGS))))
      ((SUBTYPE-OF-SYMBOL? TEST-VALUE-000)
       (CL:PROGN
        (CL:WHEN
         (CL:EQ
          (CL:AREF *CHARACTER-TYPE-TABLE*
           (CL:THE CL:FIXNUM
            (CL:CHAR-CODE
             (CL:LET ((SELF (%SYMBOL-NAME FIRSTARG)) (POSITION 0))
              (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING SELF)
               (CL:TYPE CL:FIXNUM POSITION))
              (CL:SCHAR (CL:THE CL:SIMPLE-STRING SELF)
               (CL:THE CL:FIXNUM POSITION))))))
          KWD-EXPLANATIONS-DIGIT)
         (CL:SETQ LABEL (%SYMBOL-NAME FIRSTARG))
         (CL:SETQ ARGS (%%REST ARGS)))))
      (CL:T)))
    (CL:LET* ((ARG NULL) (ITER-000 ARGS) (I NULL-INTEGER) (ITER-001 0))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ ARG (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
      (CL:WHEN (COMMAND-OPTION-EQL? ARG "BRIEF")
       (CL:SETQ STYLE KWD-EXPLANATIONS-BRIEF))
      (CL:WHEN (COMMAND-OPTION-EQL? ARG "VERBOSE")
       (CL:SETQ STYLE KWD-EXPLANATIONS-VERBOSE))
      (CL:WHEN (COMMAND-OPTION-EQL? ARG "SUMMARY")
       (CL:SETQ SUMMARY? CL:T))
      (CL:WHEN (INTEGER? ARG) (CL:SETQ DEPTH (%WRAPPER-VALUE ARG)))
      (CL:WHEN (CL:EQ ARG KWD-EXPLANATIONS-DEPTH)
       (CL:WHEN (CL:EQ (NTH ARGS (CL:1+ I)) NULL)
        (CL:SETQ DEPTH NULL-INTEGER)))
      (CL:WHEN (COMMAND-OPTION-EQL? ARG "ALL")
       (CL:SETQ DEPTH NULL-INTEGER))
      (CL:SETQ ITER-000 (%%REST ITER-000))
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
   (CL:VALUES LABEL STYLE DEPTH SUMMARY?)))

(CL:DEFUN HELP-STARTUP-EXPLANATIONS1 ()
  (CL:PROGN
   (CL:SETQ KWD-EXPLANATIONS-ASCII
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASCII" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-BRIEF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BRIEF" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-TECHNICAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TECHNICAL" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-ASSERTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ASSERTION" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-FAILURE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILURE" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CUTOFF" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-INFERENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INFERENCE" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-HTML
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HTML" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-IMPLIES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IMPLIES" NULL 2))
   (CL:SETQ SYM-EXPLANATIONS-LOGIC-EXPLANATION-VOCABULARY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXPLANATION-VOCABULARY" NULL 0))
   (CL:SETQ KWD-EXPLANATIONS-UNKNOWN-RULE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "UNKNOWN-RULE" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-FOLLOWS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FOLLOWS" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-LAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LAY" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-PARTIAL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PARTIAL" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-HOLDS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HOLDS" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-DEFINITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFINITION" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-FAILED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FAILED" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-INCONSISTENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INCONSISTENT" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-CLASH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASH" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-NOT-ASSERTED
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT-ASSERTED" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-NO-RULES
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NO-RULES" NULL 2))
   (CL:SETQ SGT-EXPLANATIONS-LOGIC-EXPLANATION-INFO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXPLANATION-INFO" NULL 1))
   (CL:SETQ SYM-EXPLANATIONS-STELLA-LABEL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LABEL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-EXPLANATIONS-STELLA-DEPTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPTH"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SYM-EXPLANATIONS-LOGIC-EXPLAINED?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXPLAINED?" NULL 0))
   (CL:SETQ SYM-EXPLANATIONS-LOGIC-EXPLANATION-MAPPING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EXPLANATION-MAPPING" NULL 0))
   (CL:SETQ KWD-EXPLANATIONS-XML
    (INTERN-RIGID-SYMBOL-WRT-MODULE "XML" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-CYC-NL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CYC-NL" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-KIF-ONTOSAURUS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "KIF-ONTOSAURUS" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-JAVA-GUI-HTML
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JAVA-GUI-HTML" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-REALISTIC
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REALISTIC" NULL 2))
   (CL:SETQ SYM-EXPLANATIONS-STELLA-NOT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOT"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ KWD-EXPLANATIONS-AMPLIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AMPLIFICATION" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-REVERSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "REVERSE" NULL 2))
   (CL:SETQ SGT-EXPLANATIONS-LOGIC-CLASH-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CLASH-JUSTIFICATION" NULL 1))
   (CL:SETQ KWD-EXPLANATIONS-PRIMITIVE-STRATEGY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PRIMITIVE-STRATEGY" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-SCAN-PROPOSITIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-PROPOSITIONS" NULL 2))
   (CL:SETQ SYM-EXPLANATIONS-LOGIC-MASTER-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MASTER-PROPOSITION" NULL 0))
   (CL:SETQ KWD-EXPLANATIONS-FORWARD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-SCAN-COLLECTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SCAN-COLLECTION" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-LOOKUP-ASSERTIONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOOKUP-ASSERTIONS" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-EQUIVALENCE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "EQUIVALENCE" NULL 2))
   (CL:SETQ SYM-EXPLANATIONS-LOGIC-COMPLEMENT-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMPLEMENT-DESCRIPTION" NULL 0))
   (CL:SETQ SGT-EXPLANATIONS-LOGIC-NAMED-DESCRIPTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NAMED-DESCRIPTION" NULL 1))
   (CL:SETQ SGT-EXPLANATIONS-LOGIC-FORWARD-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FORWARD-JUSTIFICATION" NULL 1))
   (CL:SETQ SGT-EXPLANATIONS-LOGIC-ALTERNATIVE-BINDINGS-SET
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ALTERNATIVE-BINDINGS-SET" NULL 1))
   (CL:SETQ KWD-EXPLANATIONS-MODUS-PONENS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODUS-PONENS" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-MODUS-TOLLENS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MODUS-TOLLENS" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-DISPROOF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DISPROOF" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-GOAL-COMPLEMENT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GOAL-COMPLEMENT" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-PATTERN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PATTERN" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-AND-INTRODUCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND-INTRODUCTION" NULL 2))
   (CL:SETQ SYM-EXPLANATIONS-LOGIC-WHY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WHY" NULL 0))
   (CL:SETQ KWD-EXPLANATIONS-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-EXPLANATIONS-LOGIC-JUSTIFICATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "JUSTIFICATION" NULL 0))
   (CL:SETQ SGT-EXPLANATIONS-STELLA-GENERALIZED-SYMBOL
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GENERALIZED-SYMBOL"
     (GET-STELLA-MODULE "/STELLA" CL:T) 1))
   (CL:SETQ KWD-EXPLANATIONS-DIGIT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DIGIT" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-VERBOSE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "VERBOSE" NULL 2))
   (CL:SETQ KWD-EXPLANATIONS-DEPTH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEPTH" NULL 2))))

(CL:DEFUN HELP-STARTUP-EXPLANATIONS2 ()
  (CL:PROGN
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "EXPLAIN-EXCEPTION"
       "(DEFCLASS EXPLAIN-EXCEPTION (LOGIC-EXCEPTION))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EXPLAIN-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "EXPLAIN-NO-QUERY-EXCEPTION"
       "(DEFCLASS EXPLAIN-NO-QUERY-EXCEPTION (EXPLAIN-EXCEPTION))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EXPLAIN-NO-QUERY-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "EXPLAIN-NO-SOLUTION-EXCEPTION"
       "(DEFCLASS EXPLAIN-NO-SOLUTION-EXCEPTION (EXPLAIN-EXCEPTION))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EXPLAIN-NO-SOLUTION-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION"
       "(DEFCLASS EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION (EXPLAIN-EXCEPTION))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "EXPLAIN-NOT-ENABLED-EXCEPTION"
       "(DEFCLASS EXPLAIN-NOT-ENABLED-EXCEPTION (EXPLAIN-EXCEPTION))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EXPLAIN-NOT-ENABLED-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "EXPLAIN-NO-SUCH-LABEL-EXCEPTION"
       "(DEFCLASS EXPLAIN-NO-SUCH-LABEL-EXCEPTION (EXPLAIN-EXCEPTION))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EXPLAIN-NO-SUCH-LABEL-EXCEPTION)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE
       "EXPLAIN-QUERY-TRUE-EXCEPTION"
       "(DEFCLASS EXPLAIN-QUERY-TRUE-EXCEPTION (EXPLAIN-EXCEPTION))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EXPLAIN-QUERY-TRUE-EXCEPTION)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE EXPLANATION-VOCABULARY (HASH-TABLE OF KEYWORD (CONS OF CONS)))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "EXPLANATION-INFO"
       "(DEFCLASS EXPLANATION-INFO (STANDARD-OBJECT) :SLOTS ((LABEL :TYPE STRING) (DEPTH :TYPE INTEGER) (EXPLAINED? :TYPE BOOLEAN)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-EXPLANATION-INFO))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-EXPLANATION-INFO-SLOT-VALUE)))
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE EXPLANATION-MAPPING (KEY-VALUE-LIST OF JUSTIFICATION EXPLANATION-INFO))")))

(CL:DEFUN HELP-STARTUP-EXPLANATIONS3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "EXPLANATION-TRUTH-MARKER"
    "(DEFUN (EXPLANATION-TRUTH-MARKER STRING) ((JUSTIFICATION JUSTIFICATION)))"
    (CL:FUNCTION EXPLANATION-TRUTH-MARKER) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFINE-EXPLANATION-PHRASE"
    "(DEFUN DEFINE-EXPLANATION-PHRASE ((PHRASEKEY KEYWORD) (AUDIENCE KEYWORD) (PHRASE STRING) |&REST| (MODIFIERS KEYWORD)))"
    (CL:FUNCTION DEFINE-EXPLANATION-PHRASE) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-EXPLANATION-PHRASE"
    "(DEFUN (LOOKUP-EXPLANATION-PHRASE STRING) ((PHRASEKEY KEYWORD) (MODIFIERS (CONS OF KEYWORD)) (AUDIENCE KEYWORD)))"
    (CL:FUNCTION LOOKUP-EXPLANATION-PHRASE) NULL)
   (DEFINE-FUNCTION-OBJECT "REGISTER-JUSTIFICATION"
    "(DEFUN (REGISTER-JUSTIFICATION EXPLANATION-INFO) ((SELF JUSTIFICATION) (MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION REGISTER-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-EXPLANATION-INFO"
    "(DEFUN (GET-EXPLANATION-INFO EXPLANATION-INFO) ((SELF JUSTIFICATION) (MAPPING EXPLANATION-MAPPING) (CREATE? BOOLEAN)))"
    (CL:FUNCTION GET-EXPLANATION-INFO) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPLANATION-INFO"
    "(DEFUN (EXPLANATION-INFO EXPLANATION-INFO) ((SELF JUSTIFICATION) (MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION EXPLANATION-INFO) NULL)
   (DEFINE-FUNCTION-OBJECT "LOOKUP-JUSTIFICATION"
    "(DEFUN (LOOKUP-JUSTIFICATION JUSTIFICATION) ((MAPPING EXPLANATION-MAPPING) (LABEL STRING)))"
    (CL:FUNCTION LOOKUP-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "RESET-MAPPING-FOR-SUBEXPLANATION"
    "(DEFUN RESET-MAPPING-FOR-SUBEXPLANATION ((MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION RESET-MAPPING-FOR-SUBEXPLANATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION"
    "(DEFUN (PRINT-EXPLANATION EXPLANATION-MAPPING) ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING) (MAXDEPTH INTEGER) (AUDIENCE KEYWORD)))"
    (CL:FUNCTION PRINT-EXPLANATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION-SUPPORT"
    "(DEFUN PRINT-EXPLANATION-SUPPORT ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING) (MAXDEPTH INTEGER) (UNEXPLAINED (LIST OF JUSTIFICATION))))"
    (CL:FUNCTION PRINT-EXPLANATION-SUPPORT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-ONE-EXPLANATION"
    "(DEFUN PRINT-ONE-EXPLANATION ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING) (MAXDEPTH INTEGER) (UNEXPLAINED (LIST OF JUSTIFICATION))))"
    (CL:FUNCTION PRINT-ONE-EXPLANATION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINTING-JUSTIFICATION?"
    "(DEFUN (PRINTING-JUSTIFICATION? BOOLEAN) () :GLOBALLY-INLINE? TRUE (RETURN (DEFINED? *CURRENTJUSTIFICATION*)))"
    (CL:FUNCTION PRINTING-JUSTIFICATION?) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-JUSTIFICATION-PROPOSITION-FOR-FORMAT"
    "(DEFUN PRINT-JUSTIFICATION-PROPOSITION-FOR-FORMAT ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (INDENT INTEGER)))"
    (CL:FUNCTION PRINT-JUSTIFICATION-PROPOSITION-FOR-FORMAT) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-JUSTIFICATION-PROPOSITION"
    "(DEFUN PRINT-JUSTIFICATION-PROPOSITION ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (INDENT INTEGER)))"
    (CL:FUNCTION PRINT-JUSTIFICATION-PROPOSITION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION-LABEL"
    "(DEFUN PRINT-EXPLANATION-LABEL ((STREAM OUTPUT-STREAM) (LABEL STRING) (HEAD? BOOLEAN)))"
    (CL:FUNCTION PRINT-EXPLANATION-LABEL) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION-HEADER"
    "(DEFUN PRINT-EXPLANATION-HEADER ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION PRINT-EXPLANATION-HEADER) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION-TEXT"
    "(DEFUN PRINT-EXPLANATION-TEXT ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION PRINT-EXPLANATION-TEXT) NULL)
   (DEFINE-FUNCTION-OBJECT "MARK-AS-EXPLICIT-ASSERTION?"
    "(DEFUN (MARK-AS-EXPLICIT-ASSERTION? BOOLEAN) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION MARK-AS-EXPLICIT-ASSERTION?) NULL)
   (DEFINE-FUNCTION-OBJECT "MARK-AS-FAILED-GOAL?"
    "(DEFUN (MARK-AS-FAILED-GOAL? BOOLEAN) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION MARK-AS-FAILED-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "MARK-AS-CUTOFF-GOAL?"
    "(DEFUN (MARK-AS-CUTOFF-GOAL? BOOLEAN) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION MARK-AS-CUTOFF-GOAL?) NULL)
   (DEFINE-FUNCTION-OBJECT "PARTIALLY-FOLLOWS?"
    "(DEFUN (PARTIALLY-FOLLOWS? BOOLEAN) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION PARTIALLY-FOLLOWS?) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-RULE-ORIGIN-EXPLANATION-PHRASE"
    "(DEFUN (MAKE-RULE-ORIGIN-EXPLANATION-PHRASE STRING) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION MAKE-RULE-ORIGIN-EXPLANATION-PHRASE) NULL)
   (DEFINE-FUNCTION-OBJECT "GET-EXPLANATION-SUBSTITUTION"
    "(DEFUN (GET-EXPLANATION-SUBSTITUTION ENTITY-MAPPING) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION GET-EXPLANATION-SUBSTITUTION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-ONE-VARIABLE-SUBSTITUTION"
    "(DEFUN PRINT-ONE-VARIABLE-SUBSTITUTION ((STREAM OUTPUT-STREAM) (VAR OBJECT) (VALUE OBJECT)))"
    (CL:FUNCTION PRINT-ONE-VARIABLE-SUBSTITUTION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION-SUBSTITUTION"
    "(DEFUN PRINT-EXPLANATION-SUBSTITUTION ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING)))"
    (CL:FUNCTION PRINT-EXPLANATION-SUBSTITUTION) NULL)
   (DEFINE-FUNCTION-OBJECT "PRINT-EXPLANATION-ANTECEDENTS"
    "(DEFUN PRINT-EXPLANATION-ANTECEDENTS ((SELF JUSTIFICATION) (STREAM OUTPUT-STREAM) (MAPPING EXPLANATION-MAPPING) (MAXDEPTH INTEGER) (UNEXPLAINED (LIST OF JUSTIFICATION))))"
    (CL:FUNCTION PRINT-EXPLANATION-ANTECEDENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "VISIBLE-JUSTIFICATION"
    "(DEFUN (VISIBLE-JUSTIFICATION JUSTIFICATION) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION VISIBLE-JUSTIFICATION) NULL)
   (DEFINE-FUNCTION-OBJECT "VISIBLE-ANTECEDENTS"
    "(DEFUN (VISIBLE-ANTECEDENTS (LIST OF JUSTIFICATION)) ((SELF JUSTIFICATION)))"
    (CL:FUNCTION VISIBLE-ANTECEDENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "COLLECT-VISIBLE-ANTECEDENTS"
    "(DEFUN COLLECT-VISIBLE-ANTECEDENTS ((SELF JUSTIFICATION) (VISIBLEANTECEDENTS (LIST OF JUSTIFICATION))))"
    (CL:FUNCTION COLLECT-VISIBLE-ANTECEDENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "WHY"
    "(DEFUN WHY (|&REST| (ARGS OBJECT)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :DOCUMENTATION \"Print an explanation for the result of the most recent query.
Without any arguments, `why' prints an explanation of the top level
query proposition down to a maximum depth of 3.  `(why all)' prints
an explanation to unlimited depth.  Alternatively, a particular depth
can be specified, for example, `(why 5)' explains down to a depth of 5.
A proof step that was not explained explicitly (e.g., due to a depth
cutoff) can be explained by supplying the label of the step as the
first argument to `why', for example, `(why 1.2.3 5)' prints an explanation
starting at 1.2.3 down to a depth of 5 (which is counted relative to the
depth of the starting point).  The keywords `brief' and `verbose' can be
used to select a particular explanation style.  In brief mode, explicitly
asserted propositions are not further explained and indicated with a
`!' assertion marker.  Additionally, relatively uninteresting proof steps
such as AND-introductions are skipped.  This explanation style option is
sticky and will affect future calls to `why' until it gets changed again.
The various options can be combined in any way, for example,
`(why 1.2.3 brief 3)' explains starting from step 1.2.3 down to a depth
of 3 in brief explanation mode.\")" (CL:FUNCTION %WHY)
    (CL:FUNCTION WHY-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "EXPLAIN-WHY"
    "(DEFUN EXPLAIN-WHY ((LABEL STRING) (STYLE KEYWORD) (MAXDEPTH INTEGER) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Programmer's interface to WHY function.\")"
    (CL:FUNCTION EXPLAIN-WHY) NULL)
   (DEFINE-FUNCTION-OBJECT "EXPLAIN-PROPOSITION"
    "(DEFUN EXPLAIN-PROPOSITION ((PROP PROPOSITION) (STYLE KEYWORD) (MAXDEPTH INTEGER) (STREAM OUTPUT-STREAM)) :PUBLIC? TRUE :DOCUMENTATION \"Print an explanation for `prop' if there is one.  This will only happen
for forward-chained propositions.\")" (CL:FUNCTION EXPLAIN-PROPOSITION)
    NULL)
   (DEFINE-FUNCTION-OBJECT "GET-WHY-JUSTIFICATION"
    "(DEFUN (GET-WHY-JUSTIFICATION JUSTIFICATION) ((LABEL STRING)) :PUBLIC? TRUE :DOCUMENTATION \"Returns the current WHY justification.  May also throw one of the
following subtypes of EXPLAIN-EXCEPTION:
   EXPLAIN-NO-QUERY-EXCEPTION
   EXPLAIN-NO-SOLUTION-EXCEPTION
   EXPLAIN-NO-MORE-SOLUTIONS-EXCEPTION
   EXPLAIN-NOT-ENABLED-EXCEPTION
   EXPLAIN-NO-SUCH-LABEL-EXCEPTION
   EXPLAIN-QUERY-TRUE-EXCEPTION\")" (CL:FUNCTION GET-WHY-JUSTIFICATION)
    NULL)
   (DEFINE-FUNCTION-OBJECT "COMMAND-OPTION-EQL?"
    "(DEFUN (COMMAND-OPTION-EQL? BOOLEAN) ((ARG OBJECT) (OPTION STRING)))"
    (CL:FUNCTION COMMAND-OPTION-EQL?) NULL)
   (DEFINE-FUNCTION-OBJECT "PARSE-WHY-ARGUMENTS"
    "(DEFUN (PARSE-WHY-ARGUMENTS STRING KEYWORD INTEGER BOOLEAN) ((ARGS (CONS OF OBJECT))))"
    (CL:FUNCTION PARSE-WHY-ARGUMENTS) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-EXPLANATIONS"
    "(DEFUN STARTUP-EXPLANATIONS () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-EXPLANATIONS) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-EXPLANATIONS-LOGIC-STARTUP-EXPLANATIONS)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
     SYM-EXPLANATIONS-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupExplanations") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-EXPLANATIONS ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (HELP-STARTUP-EXPLANATIONS1)
    (CL:SETQ SYM-EXPLANATIONS-LOGIC-STARTUP-EXPLANATIONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-EXPLANATIONS" NULL 0))
    (CL:SETQ SYM-EXPLANATIONS-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *EXPLANATION-FORMAT* KWD-EXPLANATIONS-ASCII)
    (CL:SETQ *EXPLANATION-STYLE* KWD-EXPLANATIONS-BRIEF)
    (CL:SETQ *EXPLANATION-AUDIENCE* KWD-EXPLANATIONS-TECHNICAL)
    (CL:SETQ *EXPLANATION-VOCABULARIES* (NEW-KEY-VALUE-LIST)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5)
    (HELP-STARTUP-EXPLANATIONS2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (HELP-STARTUP-EXPLANATIONS3))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EXPLANATION-FORMAT* KEYWORD :ASCII :DOCUMENTATION \"Keyword to control the explanation format.
Valid values are :ASCII, :HTML and :XML\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EXPLANATION-STYLE* KEYWORD :BRIEF :DOCUMENTATION \"Keywords that controls how detailed explanations will be.
Valid values are :VERBOSE and :BRIEF.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EXPLANATION-AUDIENCE* KEYWORD :TECHNICAL :DOCUMENTATION \"Keywords that controls the language for justifications.
Valid values are :TECHNICAL and :LAY\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *DEFAULT-EXPLANATION-DEPTH* INTEGER 3 :DOCUMENTATION \"Maximal explanation depth used if not otherwise specified.\" :PUBLIC? TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXPLANATION-TAB-STRING* STRING \"    \")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAX-INLINE-LABEL-LENGTH* INTEGER 10 :DOCUMENTATION \"Maximum length of a label string for which the following
proposition will be printed on the same line.\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXPLANATION-ASSERTION-MARKER* STRING \"!\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXPLANATION-FAILURE-MARKER* STRING \"?\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXPLANATION-CUTOFF-MARKER* STRING \"x\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXPLANATION-INFERENCE-MARKER* STRING \" \")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *EXPLANATION-VOCABULARY* EXPLANATION-VOCABULARY NULL :DOCUMENTATION \"The currently active vocabulary lookup table\")")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *EXPLANATION-VOCABULARIES* (KEY-VALUE-LIST OF KEYWORD EXPLANATION-VOCABULARY) (NEW KEY-VALUE-LIST) :DOCUMENTATION \"List of vocabularies with keyword keys\")")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-UNKNOWN-RULE
     KWD-EXPLANATIONS-TECHNICAL
     "because of an inference PowerLoom can't explain yet")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-FOLLOWS
     KWD-EXPLANATIONS-TECHNICAL "follows")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-FOLLOWS
     KWD-EXPLANATIONS-LAY "is true")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-FOLLOWS
     KWD-EXPLANATIONS-TECHNICAL "is partially true"
     KWD-EXPLANATIONS-PARTIAL)
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-FOLLOWS
     KWD-EXPLANATIONS-LAY "is true to some part"
     KWD-EXPLANATIONS-PARTIAL)
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-HOLDS
     KWD-EXPLANATIONS-TECHNICAL "holds")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-HOLDS
     KWD-EXPLANATIONS-LAY "is true")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-DEFINITION
     KWD-EXPLANATIONS-TECHNICAL "by the definition of")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-DEFINITION
     KWD-EXPLANATIONS-LAY "by the definition of")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-FAILED
     KWD-EXPLANATIONS-TECHNICAL "failed")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-FAILED
     KWD-EXPLANATIONS-LAY "could not be proven")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-INCONSISTENT
     KWD-EXPLANATIONS-TECHNICAL "is inconsistent")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-INCONSISTENT
     KWD-EXPLANATIONS-LAY "has a contradiction")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-CLASH
     KWD-EXPLANATIONS-TECHNICAL
     "because it and its negation were inferred")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-CLASH
     KWD-EXPLANATIONS-LAY "because opposite conclusions were reached")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-NOT-ASSERTED
     KWD-EXPLANATIONS-TECHNICAL "is not asserted")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-NOT-ASSERTED
     KWD-EXPLANATIONS-LAY "is not asserted to be true")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-NO-RULES
     KWD-EXPLANATIONS-TECHNICAL
     "no potential inference leading to the proposition could be found")
    (DEFINE-EXPLANATION-PHRASE KWD-EXPLANATIONS-NO-RULES
     KWD-EXPLANATIONS-LAY
     "no rules for proving the proposition could be found")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *CURRENTJUSTIFICATION* JUSTIFICATION NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFSPECIAL *MOST-RECENT-EXPLANATION-MAPPING* EXPLANATION-MAPPING NULL)")
    (REGISTER-NATIVE-NAME SYM-EXPLANATIONS-LOGIC-WHY
     KWD-EXPLANATIONS-COMMON-LISP KWD-EXPLANATIONS-FUNCTION))))
