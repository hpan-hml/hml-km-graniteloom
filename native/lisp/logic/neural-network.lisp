;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; neural-network.lisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2010      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR KWD-NEURAL-NETWORK-BACKPROP NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-WEIGHT-VECTOR NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-2_D_WEIGHT-ARRAY NULL)
(CL:DEFVAR SGT-NEURAL-NETWORK-LOGIC-PROPOSITION-NEURAL-NETWORK NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-INPUT NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-HIDDEN NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-OUTPUT NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-INPUT-ERROR NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-HIDDEN-ERROR NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-IH NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-IH-DELTA NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-HO NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-HO-DELTA NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-IH-SLOPE NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-IH-PREV-SLOPE NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-HO-SLOPE NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-HO-PREV-SLOPE NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SET-TRACE-NEURAL-NETWORK-TRAINING NULL)
(CL:DEFVAR KWD-NEURAL-NETWORK-COMMON-LISP NULL)
(CL:DEFVAR KWD-NEURAL-NETWORK-FUNCTION NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SET-SAVE-NETWORK-CYCLE NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SET-ERROR-CUTOFF NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SET-TRAIN-CACHED-NEURAL-NETWORKS NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SET-LEARNING-RATE NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SET-MOMENTUM-TERM NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SET-WEIGHT-RANGE NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SET-NEURAL-NETWORK-TRAINING-METHOD NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SET-ERROR-PRINT-CYCLE NULL)
(CL:DEFVAR KWD-NEURAL-NETWORK-AND NULL)
(CL:DEFVAR KWD-NEURAL-NETWORK-OR NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-GNP NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-DEFNETWORK NULL)
(CL:DEFVAR KWD-NEURAL-NETWORK-QUICKPROP NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-TRAIN-NEURAL-NETWORK NULL)
(CL:DEFVAR KWD-NEURAL-NETWORK-BACKPROPAGATION NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-NEURAL-NETWORK NULL)
(CL:DEFVAR KWD-NEURAL-NETWORK-MAX NULL)
(CL:DEFVAR KWD-NEURAL-NETWORK-NOISY-OR NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-TRAIN-AND-TEST-NEURAL-NETWORK NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-MULTIPLE-NETWORK-TRAINING-RUNS NULL)
(CL:DEFVAR SGT-NEURAL-NETWORK-STELLA-CONS NULL)
(CL:DEFVAR SGT-NEURAL-NETWORK-LOGIC-PROPOSITION NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-STRUCTURED-NEURAL-NETWORK-REGRESSION NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SWAP-IN-NEW-NETWORKS NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SWAP-IN-NETWORK-FILE NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-LOAD-NEURAL-NETWORK-FILE NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SAVE-ALL-NEURAL-NETWORKS NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-SAVE-NEURAL-NETWORK NULL)
(CL:DEFVAR KWD-NEURAL-NETWORK-MATCH-MODE NULL)
(CL:DEFVAR KWD-NEURAL-NETWORK-NN NULL)
(CL:DEFVAR KWD-NEURAL-NETWORK-MAXIMIZE-SCORE? NULL)
(CL:DEFVAR SGT-NEURAL-NETWORK-LOGIC-MULTI-DIMENSIONAL-ARRAY NULL)
(CL:DEFVAR SGT-NEURAL-NETWORK-LOGIC-2_D_ARRAY NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-NOF-ROWS NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-NOF-COLUMNS NULL)
(CL:DEFVAR SGT-NEURAL-NETWORK-LOGIC-FLOAT-VECTOR NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-STELLA-ARRAY-SIZE NULL)
(CL:DEFVAR SGT-NEURAL-NETWORK-LOGIC-2_D_FLOAT-ARRAY NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-LOGIC-STARTUP-NEURAL-NETWORK NULL)
(CL:DEFVAR SYM-NEURAL-NETWORK-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* TRUE-WRAPPER ZERO-WRAPPER
  *PRINT-CASE-DISTANCES* *MODULE* *TESTING-EXAMPLES* *RULE-COMBINATION*
  *TRAINING-EXAMPLES* STANDARD-ERROR *PARTIAL-SUPPORT-CACHE*
  NULL-FLOAT-WRAPPER NIL STANDARD-OUTPUT EOL NULL-INTEGER NULL-FLOAT))

;;; (DEFGLOBAL *NEURAL-NETWORK-TRAINING-METHOD* ...)

(CL:DEFVAR *NEURAL-NETWORK-TRAINING-METHOD* NULL)

;;; (DEFGLOBAL *LEARNING-RATE* ...)

(CL:DEFVAR *LEARNING-RATE* 0.1d0)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *LEARNING-RATE*))

;;; (DEFGLOBAL *MOMENTUM-TERM* ...)

(CL:DEFVAR *MOMENTUM-TERM* 0.9d0)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *MOMENTUM-TERM*))

;;; (DEFGLOBAL *WEIGHT-RANGE* ...)

(CL:DEFVAR *WEIGHT-RANGE* 0.05d0)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *WEIGHT-RANGE*))

;;; (DEFGLOBAL *ERROR-CUTOFF* ...)

(CL:DEFVAR *ERROR-CUTOFF* 0.0d0)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *ERROR-CUTOFF*))

;;; (DEFGLOBAL *ERROR-PRINT-CYCLE* ...)

(CL:DEFVAR *ERROR-PRINT-CYCLE* 25)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *ERROR-PRINT-CYCLE*))

;;; (DEFGLOBAL *SAVE-NETWORK-CYCLE* ...)

(CL:DEFVAR *SAVE-NETWORK-CYCLE* 10000)
(CL:DECLAIM (CL:TYPE CL:FIXNUM *SAVE-NETWORK-CYCLE*))

;;; (DEFGLOBAL *SAVE-NETWORK-FILE* ...)

(CL:DEFVAR *SAVE-NETWORK-FILE* STELLA::NULL-STRING)
(CL:DECLAIM (CL:TYPE CL:SIMPLE-STRING *SAVE-NETWORK-FILE*))

;;; (DEFGLOBAL *TRACE-NEURAL-NETWORK-TRAINING* ...)

(CL:DEFVAR *TRACE-NEURAL-NETWORK-TRAINING* CL:NIL)

;;; (DEFGLOBAL *TRAIN-CACHED-NETWORKS?* ...)

(CL:DEFVAR *TRAIN-CACHED-NETWORKS?* CL:T)

;;; (DEFGLOBAL *MAX-MOVEMENT* ...)

(CL:DEFVAR *MAX-MOVEMENT* 1.75d0)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *MAX-MOVEMENT*))

;;; (DEFGLOBAL *MODE-SWITCH* ...)

(CL:DEFVAR *MODE-SWITCH* 0.0d0)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *MODE-SWITCH*))

;;; (DEFGLOBAL *SHRINK-FACTOR* ...)

(CL:DEFVAR *SHRINK-FACTOR* NULL-FLOAT)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *SHRINK-FACTOR*))

;;; (DEFGLOBAL *WEIGHT-DECAY* ...)

(CL:DEFVAR *WEIGHT-DECAY* -1.0d-4)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *WEIGHT-DECAY*))

;;; (DEFGLOBAL *SIGMOID-PRIME-OFFSET* ...)

(CL:DEFVAR *SIGMOID-PRIME-OFFSET* 0.1d0)
(CL:DECLAIM (CL:TYPE CL:DOUBLE-FLOAT *SIGMOID-PRIME-OFFSET*))

;;; (DEFCLASS PROPOSITION-NEURAL-NETWORK ...)

(CL:DEFCLASS PROPOSITION-NEURAL-NETWORK (STANDARD-OBJECT)
  ((PROPOSITION :ALLOCATION :INSTANCE :ACCESSOR %PROPOSITION)
   (INPUT :ALLOCATION :INSTANCE :ACCESSOR %INPUT)
   (HIDDEN :ALLOCATION :INSTANCE :ACCESSOR %HIDDEN)
   (OUTPUT :TYPE CL:DOUBLE-FLOAT :INITFORM NULL-FLOAT :ALLOCATION :INSTANCE
    :ACCESSOR %OUTPUT)
   (INPUT-ERROR :ALLOCATION :INSTANCE :ACCESSOR %INPUT-ERROR)
   (HIDDEN-ERROR :ALLOCATION :INSTANCE :ACCESSOR %HIDDEN-ERROR)
   (IH :ALLOCATION :INSTANCE :ACCESSOR %IH)
   (IH-DELTA :ALLOCATION :INSTANCE :ACCESSOR %IH-DELTA)
   (HO :ALLOCATION :INSTANCE :ACCESSOR %HO)
   (HO-DELTA :ALLOCATION :INSTANCE :ACCESSOR %HO-DELTA)
   (IH-SLOPE :ALLOCATION :INSTANCE :ACCESSOR %IH-SLOPE)
   (IH-PREV-SLOPE :ALLOCATION :INSTANCE :ACCESSOR %IH-PREV-SLOPE)
   (HO-SLOPE :ALLOCATION :INSTANCE :ACCESSOR %HO-SLOPE)
   (HO-PREV-SLOPE :ALLOCATION :INSTANCE :ACCESSOR %HO-PREV-SLOPE)))

(CL:DEFUN NEW-PROPOSITION-NEURAL-NETWORK ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE PROPOSITION-NEURAL-NETWORK)))
   (CL:SETF (%HO-PREV-SLOPE SELF) NULL) (CL:SETF (%HO-SLOPE SELF) NULL)
   (CL:SETF (%IH-PREV-SLOPE SELF) NULL) (CL:SETF (%IH-SLOPE SELF) NULL)
   (CL:SETF (%HO-DELTA SELF) NULL) (CL:SETF (%HO SELF) NULL)
   (CL:SETF (%IH-DELTA SELF) NULL) (CL:SETF (%IH SELF) NULL)
   (CL:SETF (%HIDDEN-ERROR SELF) NULL) (CL:SETF (%INPUT-ERROR SELF) NULL)
   (CL:SETF (%OUTPUT SELF) NULL-FLOAT) (CL:SETF (%HIDDEN SELF) NULL)
   (CL:SETF (%INPUT SELF) NULL) (CL:SETF (%PROPOSITION SELF) NULL) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF PROPOSITION-NEURAL-NETWORK))
  SGT-NEURAL-NETWORK-LOGIC-PROPOSITION-NEURAL-NETWORK)

(CL:DEFUN ACCESS-PROPOSITION-NEURAL-NETWORK-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-PROPOSITION)
    (CL:IF SETVALUE? (CL:SETF (%PROPOSITION SELF) VALUE)
     (CL:SETQ VALUE (%PROPOSITION SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-INPUT)
    (CL:IF SETVALUE? (CL:SETF (%INPUT SELF) VALUE)
     (CL:SETQ VALUE (%INPUT SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-HIDDEN)
    (CL:IF SETVALUE? (CL:SETF (%HIDDEN SELF) VALUE)
     (CL:SETQ VALUE (%HIDDEN SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-OUTPUT)
    (CL:IF SETVALUE? (CL:SETF (%OUTPUT SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-FLOAT (%OUTPUT SELF)))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-INPUT-ERROR)
    (CL:IF SETVALUE? (CL:SETF (%INPUT-ERROR SELF) VALUE)
     (CL:SETQ VALUE (%INPUT-ERROR SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-HIDDEN-ERROR)
    (CL:IF SETVALUE? (CL:SETF (%HIDDEN-ERROR SELF) VALUE)
     (CL:SETQ VALUE (%HIDDEN-ERROR SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-IH)
    (CL:IF SETVALUE? (CL:SETF (%IH SELF) VALUE) (CL:SETQ VALUE (%IH SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-IH-DELTA)
    (CL:IF SETVALUE? (CL:SETF (%IH-DELTA SELF) VALUE)
     (CL:SETQ VALUE (%IH-DELTA SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-HO)
    (CL:IF SETVALUE? (CL:SETF (%HO SELF) VALUE) (CL:SETQ VALUE (%HO SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-HO-DELTA)
    (CL:IF SETVALUE? (CL:SETF (%HO-DELTA SELF) VALUE)
     (CL:SETQ VALUE (%HO-DELTA SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-IH-SLOPE)
    (CL:IF SETVALUE? (CL:SETF (%IH-SLOPE SELF) VALUE)
     (CL:SETQ VALUE (%IH-SLOPE SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-IH-PREV-SLOPE)
    (CL:IF SETVALUE? (CL:SETF (%IH-PREV-SLOPE SELF) VALUE)
     (CL:SETQ VALUE (%IH-PREV-SLOPE SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-HO-SLOPE)
    (CL:IF SETVALUE? (CL:SETF (%HO-SLOPE SELF) VALUE)
     (CL:SETQ VALUE (%HO-SLOPE SELF))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-HO-PREV-SLOPE)
    (CL:IF SETVALUE? (CL:SETF (%HO-PREV-SLOPE SELF) VALUE)
     (CL:SETQ VALUE (%HO-PREV-SLOPE SELF))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

;;; (DEFGLOBAL *MASTER-NEURAL-NETWORK-LIST* ...)

(CL:DEFVAR *MASTER-NEURAL-NETWORK-LIST* NULL)

;;; (DEFGLOBAL *ACTIVATED-NETWORKS* ...)

(CL:DEFVAR *ACTIVATED-NETWORKS* NULL)

;;; (DEFGLOBAL *SAVED-NET* ...)

(CL:DEFVAR *SAVED-NET* NULL)

;;; (DEFUN SET-TRACE-NEURAL-NETWORK-TRAINING ...)

(CL:DEFUN %SET-TRACE-NEURAL-NETWORK-TRAINING (B)
  (CL:SETQ *TRACE-NEURAL-NETWORK-TRAINING* B))

(CL:DEFUN SET-TRACE-NEURAL-NETWORK-TRAINING-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-TRACE-NEURAL-NETWORK-TRAINING (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-TRACE-NEURAL-NETWORK-TRAINING (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-TRACE-NEURAL-NETWORK-TRAINING|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-TRACE-NEURAL-NETWORK-TRAINING)))

;;; (DEFUN SET-SAVE-NETWORK-CYCLE ...)

(CL:DEFUN %SET-SAVE-NETWORK-CYCLE (I)
  "Set number of cycles between which networks are saved to the
file established by the last call to `save-all-neural-networks'.  A number <= 0
or a NULL number turns off periodic saving."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:WHEN (CL:= I NULL-INTEGER) (CL:SETQ I 0))
  (CL:SETQ *SAVE-NETWORK-CYCLE* I))

(CL:DEFUN SET-SAVE-NETWORK-CYCLE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-SAVE-NETWORK-CYCLE (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-SAVE-NETWORK-CYCLE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set number of cycles between which networks are saved to the
file established by the last call to `save-all-neural-networks'.  A number <= 0
or a NULL number turns off periodic saving."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-SAVE-NETWORK-CYCLE|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-SAVE-NETWORK-CYCLE)))

;;; (DEFUN SET-ERROR-CUTOFF ...)

(CL:DEFUN %SET-ERROR-CUTOFF (F)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT F))
  #+MCL
  (CL:CHECK-TYPE F CL:DOUBLE-FLOAT)
  (CL:SETQ *ERROR-CUTOFF* F))

(CL:DEFUN SET-ERROR-CUTOFF-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-ERROR-CUTOFF (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-ERROR-CUTOFF (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-ERROR-CUTOFF|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-ERROR-CUTOFF)))

;;; (DEFUN SET-TRAIN-CACHED-NEURAL-NETWORKS ...)

(CL:DEFUN %SET-TRAIN-CACHED-NEURAL-NETWORKS (B)
  (CL:SETQ *TRAIN-CACHED-NETWORKS?* B))

(CL:DEFUN SET-TRAIN-CACHED-NEURAL-NETWORKS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-TRAIN-CACHED-NEURAL-NETWORKS (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-TRAIN-CACHED-NEURAL-NETWORKS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-TRAIN-CACHED-NEURAL-NETWORKS|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-TRAIN-CACHED-NEURAL-NETWORKS)))

;;; (DEFUN SET-LEARNING-RATE ...)

(CL:DEFUN %SET-LEARNING-RATE (RATE)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RATE))
  #+MCL
  (CL:CHECK-TYPE RATE CL:DOUBLE-FLOAT)
  (CL:SETQ *LEARNING-RATE* RATE))

(CL:DEFUN SET-LEARNING-RATE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-LEARNING-RATE (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-LEARNING-RATE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-LEARNING-RATE|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-LEARNING-RATE)))

;;; (DEFUN SET-MOMENTUM-TERM ...)

(CL:DEFUN %SET-MOMENTUM-TERM (M)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT M))
  #+MCL
  (CL:CHECK-TYPE M CL:DOUBLE-FLOAT)
  (CL:SETQ *MOMENTUM-TERM* M))

(CL:DEFUN SET-MOMENTUM-TERM-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-MOMENTUM-TERM (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-MOMENTUM-TERM (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-MOMENTUM-TERM|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-MOMENTUM-TERM)))

;;; (DEFUN SET-WEIGHT-RANGE ...)

(CL:DEFUN %SET-WEIGHT-RANGE (W)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT W))
  #+MCL
  (CL:CHECK-TYPE W CL:DOUBLE-FLOAT)
  (CL:SETQ *WEIGHT-RANGE* W))

(CL:DEFUN SET-WEIGHT-RANGE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-WEIGHT-RANGE (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-WEIGHT-RANGE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-WEIGHT-RANGE|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-WEIGHT-RANGE)))

;;; (DEFUN SET-NEURAL-NETWORK-TRAINING-METHOD ...)

(CL:DEFUN %SET-NEURAL-NETWORK-TRAINING-METHOD (M)
  (CL:SETQ *NEURAL-NETWORK-TRAINING-METHOD* M))

(CL:DEFMACRO SET-NEURAL-NETWORK-TRAINING-METHOD (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-NEURAL-NETWORK-TRAINING-METHOD|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-NEURAL-NETWORK-TRAINING-METHOD)))

;;; (DEFUN SET-ERROR-PRINT-CYCLE ...)

(CL:DEFUN %SET-ERROR-PRINT-CYCLE (I)
  "Set number of cycles between which error rates are saved to
the file established by the last call to `save-all-neural-networks' appended
with extension `.err'.  A number <= 0 (or NULL) turns off periodic saving."
  (CL:DECLARE (CL:TYPE CL:FIXNUM I))
  #+MCL
  (CL:CHECK-TYPE I CL:FIXNUM)
  (CL:WHEN (CL:= I NULL-INTEGER) (CL:SETQ I 0))
  (CL:SETQ *ERROR-PRINT-CYCLE* I))

(CL:DEFUN SET-ERROR-PRINT-CYCLE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SET-ERROR-PRINT-CYCLE (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SET-ERROR-PRINT-CYCLE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Set number of cycles between which error rates are saved to
the file established by the last call to `save-all-neural-networks' appended
with extension `.err'.  A number <= 0 (or NULL) turns off periodic saving."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SET-ERROR-PRINT-CYCLE|)) (CL:MACRO-FUNCTION (CL:QUOTE SET-ERROR-PRINT-CYCLE)))

;;; (DEFUN DELETE-ALL-NEURAL-NETWORKS ...)

(CL:DEFUN DELETE-ALL-NEURAL-NETWORKS ()
  (CL:SETQ *MASTER-NEURAL-NETWORK-LIST* (NEW-LIST)))

;;; (DEFUN CHECK-MASTER-NETWORK-LIST ...)

(CL:DEFUN CHECK-MASTER-NETWORK-LIST ()
  (CL:LET*
   ((NET NULL) (ITER-000 (%THE-CONS-LIST *MASTER-NEURAL-NETWORK-LIST*))
    (I NULL-INTEGER) (ITER-001 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ NET (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Net " I ": "
     (LENGTH (%INPUT NET)) " inputs, " (LENGTH (%HIDDEN NET)) " outputs." EOL)
    (CL:SETQ ITER-000 (%%REST ITER-000)) (CL:SETQ ITER-001 (CL:1+ ITER-001)))))

;;; (DEFUN CLEAR-ALL-NEURAL-NETWORKS ...)

(CL:DEFUN CLEAR-ALL-NEURAL-NETWORKS ()
  (CL:LET*
   ((NET NULL) (ITER-000 (%THE-CONS-LIST *MASTER-NEURAL-NETWORK-LIST*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ NET (%%VALUE ITER-000)) (RANDOMIZE-NEURAL-NETWORK NET)
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN CLEAR-ALL-SLOPES ...)

(CL:DEFUN CLEAR-ALL-SLOPES ()
  (CL:LET*
   ((NET NULL) (ITER-000 (%THE-CONS-LIST *MASTER-NEURAL-NETWORK-LIST*)))
   (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
    (CL:SETQ NET (%%VALUE ITER-000)) (CLEAR-SLOPES NET)
    (CL:SETQ ITER-000 (%%REST ITER-000)))))

;;; (DEFUN CLEAR-SLOPES ...)

(CL:DEFUN CLEAR-SLOPES (NET)
  (CL:LET*
   ((H NULL-INTEGER) (ITER-000 0)
    (UPPER-BOUND-000 (CL:1- (LENGTH (%HIDDEN NET)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ H ITER-000)
    (CL:LET*
     ((I NULL-INTEGER) (ITER-001 0)
      (UPPER-BOUND-001 (CL:1- (LENGTH (%INPUT NET)))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
     (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ I ITER-001)
      (CL:LET
       ((SELF (%THE-ARRAY (%IH-PREV-SLOPE NET)))
        (VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH-SLOPE NET)))
          (CL:THE CL:FIXNUM
           (CL:+ (CL:* I (%NOF-COLUMNS (%IH-SLOPE NET))) H))))
        (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH-PREV-SLOPE NET))) H)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET
       ((SELF (%THE-ARRAY (%IH-SLOPE NET)))
        (VALUE
         (WRAP-FLOAT
          (CL:*
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH NET)))
             (CL:THE CL:FIXNUM (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H))))
           *WEIGHT-DECAY*)))
        (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH-SLOPE NET))) H)))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (CL:LET
     ((SELF (%THE-ARRAY (%HO-PREV-SLOPE NET)))
      (VALUE
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO-SLOPE NET))) H))
      (POSITION H))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET
     ((SELF (%THE-ARRAY (%HO-SLOPE NET)))
      (VALUE
       (WRAP-FLOAT
        (CL:*
         (%WRAPPER-VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO NET))) H))
         *WEIGHT-DECAY*)))
      (POSITION H))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:SETQ ITER-000 (CL:1+ ITER-000)))))

;;; (DEFUN RANDOMIZE-NEURAL-NETWORK ...)

(CL:DEFUN RANDOMIZE-NEURAL-NETWORK (NET)
  (CL:LET*
   ((NUM-IN (LENGTH (%INPUT NET))) (NUM-HIDDEN (LENGTH (%HIDDEN NET))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-IN NUM-HIDDEN))
   (CL:LET*
    ((H NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NUM-HIDDEN)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ H ITER-000)
     (CL:LET
      ((SELF (%THE-ARRAY (%HO-DELTA NET))) (VALUE (WRAP-FLOAT 0.0d0))
       (POSITION H))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET* ((I NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- NUM-IN)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
      (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ I ITER-001)
       (CL:LET
        ((SELF (%THE-ARRAY (%IH-DELTA NET))) (VALUE (WRAP-FLOAT 0.0d0))
         (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH-DELTA NET))) H)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-001 (CL:1+ ITER-001))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-002 (CL:1- NUM-HIDDEN)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-002))
    (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-002) DO (CL:SETQ I ITER-002)
     (CL:LET* ((J NULL-INTEGER) (ITER-003 0) (UPPER-BOUND-003 (CL:1- NUM-IN)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-003 UPPER-BOUND-003))
      (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-003) DO (CL:SETQ J ITER-003)
       (CL:LET
        ((SELF (%THE-ARRAY (%IH NET)))
         (VALUE (WRAP-FLOAT (RANDOM-WEIGHT *WEIGHT-RANGE*)))
         (POSITION (CL:+ (CL:* J (%NOF-COLUMNS (%IH NET))) I)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-003 (CL:1+ ITER-003))))
     (CL:LET
      ((SELF (%THE-ARRAY (%HO NET)))
       (VALUE (WRAP-FLOAT (RANDOM-WEIGHT *WEIGHT-RANGE*))) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))))))

;;; (DEFUN (CREATE-NEURAL-NETWORK PROPOSITION-NEURAL-NETWORK) ...)

(CL:DEFUN CREATE-NEURAL-NETWORK (PROP)
  (CL:LET*
   ((NET NULL) (NUM-IN (CL:1+ (LENGTH (%ARGUMENTS PROP))))
    (NUM-HIDDEN (MIN (CL:+ NUM-IN 0) 20)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-IN NUM-HIDDEN))
   (CL:WHEN (CL:> NUM-IN 100)
    (CL:SETQ NUM-HIDDEN (CL:+ (FLOOR (CL:/ NUM-IN 10.0d0)) 10)))
   (CL:SETQ NET (ALLOCATE-NEURAL-NETWORK NUM-IN NUM-HIDDEN))
   (PUSH *MASTER-NEURAL-NETWORK-LIST* NET) (CL:SETF (%PROPOSITION NET) PROP)
   (CL:LET* ((TEST-VALUE-000 (%KIND PROP)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-NEURAL-NETWORK-AND)
       (CL:EQ TEST-VALUE-000 KWD-NEURAL-NETWORK-OR))
      (RANDOMIZE-NEURAL-NETWORK NET))
     (CL:T (RANDOMIZE-NEURAL-NETWORK NET))))
   NET))

;;; (DEFUN (GNP PROPOSITION) ...)

(CL:DEFUN %GNP (NAME)
  (%SURROGATE-VALUE (LOOKUP-SURROGATE (%SYMBOL-NAME NAME))))

(CL:DEFMACRO GNP (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/GNP|)) (CL:MACRO-FUNCTION (CL:QUOTE GNP)))

;;; (DEFUN (DEFNETWORK PROPOSITION-NEURAL-NETWORK) ...)

(CL:DEFUN %DEFNETWORK (ARGS)
  (DEFINE-NEURAL-NETWORK-FROM-PARSE-TREE ARGS))

(CL:DEFUN DEFNETWORK-EVALUATOR-WRAPPER (ARGUMENTS)
  (%DEFNETWORK ARGUMENTS))

(CL:DEFMACRO DEFNETWORK (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/DEFNETWORK|)) (CL:MACRO-FUNCTION (CL:QUOTE DEFNETWORK)))

;;; (DEFUN (DEFINE-NEURAL-NETWORK-FROM-PARSE-TREE PROPOSITION-NEURAL-NETWORK) ...)

(CL:DEFUN DEFINE-NEURAL-NETWORK-FROM-PARSE-TREE (TREE)
  (CL:LET*
   ((PROP (BUILD-PROPOSITION (%%VALUE TREE)))
    (NET (CREATE-NEURAL-NETWORK PROP)) (IH (%%VALUE (%%REST TREE)))
    (HO (%%VALUE (%%REST (%%REST TREE)))) (K 0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM K))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH (%INPUT NET)))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET*
      ((H NULL-INTEGER) (ITER-001 0)
       (UPPER-BOUND-001 (CL:1- (LENGTH (%HIDDEN NET)))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-001 UPPER-BOUND-001))
      (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ H ITER-001)
       (CL:LET
        ((SELF (%THE-ARRAY (%IH NET))) (VALUE (NTH IH K))
         (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ K (CL:1+ K)) (CL:SETQ ITER-001 (CL:1+ ITER-001))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((H NULL-INTEGER) (ITER-002 0)
     (UPPER-BOUND-002 (CL:1- (LENGTH (%HIDDEN NET)))) (NUM NULL)
     (ITER-003 HO))
    (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-002 UPPER-BOUND-002))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-002 UPPER-BOUND-002) (CL:NOT (CL:EQ ITER-003 NIL)))
     DO (CL:SETQ H ITER-002) (CL:SETQ NUM (%%VALUE ITER-003))
     (CL:LET ((SELF (%THE-ARRAY (%HO NET))) (VALUE NUM) (POSITION H))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))
     (CL:SETQ ITER-003 (%%REST ITER-003))))
   NET))

;;; (DEFUN (ALLOCATE-NEURAL-NETWORK PROPOSITION-NEURAL-NETWORK) ...)

(CL:DEFUN ALLOCATE-NEURAL-NETWORK (NUM-IN NUM-HIDDEN)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-IN NUM-HIDDEN))
  #+MCL
  (CL:CHECK-TYPE NUM-IN CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NUM-HIDDEN CL:FIXNUM)
  (CL:LET* ((NET (NEW-PROPOSITION-NEURAL-NETWORK)))
   (CL:SETF (%INPUT NET) (NEW-VECTOR NUM-IN))
   (CL:SETF (%HIDDEN NET) (NEW-VECTOR NUM-HIDDEN))
   (CL:SETF (%IH NET) (NEW-2_D_ARRAY NUM-IN NUM-HIDDEN))
   (CL:SETF (%IH-DELTA NET) (NEW-2_D_ARRAY NUM-IN NUM-HIDDEN))
   (CL:SETF (%INPUT-ERROR NET) (NEW-VECTOR NUM-IN))
   (CL:SETF (%HIDDEN-ERROR NET) (NEW-VECTOR NUM-HIDDEN))
   (CL:SETF (%HO NET) (NEW-VECTOR NUM-HIDDEN))
   (CL:SETF (%HO-DELTA NET) (NEW-VECTOR NUM-HIDDEN))
   (CL:WHEN
    (CL:EQ *NEURAL-NETWORK-TRAINING-METHOD* KWD-NEURAL-NETWORK-QUICKPROP)
    (CL:SETF (%IH-SLOPE NET) (NEW-2_D_ARRAY NUM-IN NUM-HIDDEN))
    (CL:SETF (%IH-PREV-SLOPE NET) (NEW-2_D_ARRAY NUM-IN NUM-HIDDEN))
    (CL:SETF (%HO-SLOPE NET) (NEW-VECTOR NUM-HIDDEN))
    (CL:SETF (%HO-PREV-SLOPE NET) (NEW-VECTOR NUM-HIDDEN)))
   NET))

;;; (DEFUN (ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT)
  ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK))
(CL:DEFUN ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK (NET)
  (CL:LET*
   ((NUM-IN (LENGTH (%INPUT NET))) (NUM-HIDDEN (LENGTH (%HIDDEN NET)))
    (ARGUMENTS (%ARGUMENTS (%PROPOSITION NET))) (STOP (CL:1- NUM-IN))
    (INPUT (%INPUT NET)) (HIDDEN (%HIDDEN NET)) (IH (%IH NET)) (HO (%HO NET))
    (SCORE 0.0d0) (SUM 0.0d0))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-IN NUM-HIDDEN STOP)
    (CL:TYPE CL:DOUBLE-FLOAT SCORE SUM))
   (PUSH *ACTIVATED-NETWORKS* NET)
   (CL:LET
    ((SELF (%THE-ARRAY (%INPUT NET))) (VALUE (WRAP-FLOAT 1.0d0)) (POSITION 0))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
    (CL:SETF (CL:AREF SELF POSITION) VALUE))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 STOP)
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:IF
      (CL:NOT
       (CL:=
        (%WRAPPER-VALUE
         (DYNAMIC-SLOT-VALUE
          (%DYNAMIC-SLOTS
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS))
            (CL:THE CL:FIXNUM (CL:1- I))))
          SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER))
        NULL-FLOAT))
      (CL:LET
       ((SELF (%THE-ARRAY INPUT))
        (VALUE
         (WRAP-FLOAT
          (%WRAPPER-VALUE
           (DYNAMIC-SLOT-VALUE
            (%DYNAMIC-SLOTS
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARGUMENTS))
              (CL:THE CL:FIXNUM (CL:1- I))))
            SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER))))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET
       ((SELF (%THE-ARRAY INPUT)) (VALUE (WRAP-FLOAT 0.0d0)) (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- NUM-HIDDEN)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ I ITER-001)
     (CL:LET*
      ((J NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-002 STOP)
       (UNBOUNDED?-001 (CL:= UPPER-BOUND-002 NULL-INTEGER)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-002 UPPER-BOUND-002))
      (CL:LOOP WHILE (CL:OR UNBOUNDED?-001 (CL:<= ITER-002 UPPER-BOUND-002))
       DO (CL:SETQ J ITER-002)
       (CL:SETQ SUM
        (CL:+ SUM
         (CL:*
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INPUT)) J))
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY IH))
            (CL:THE CL:FIXNUM (CL:+ (CL:* J (%NOF-COLUMNS IH)) I)))))))
       (CL:SETQ ITER-002 (CL:1+ ITER-002))))
     (CL:LET
      ((SELF (%THE-ARRAY HIDDEN))
       (VALUE
        (WRAP-FLOAT
         (CL:/ 1.0d0
          (CL:+ 1.0d0
           (CL:THE CL:DOUBLE-FLOAT
            (CL:EXP (CL:THE CL:DOUBLE-FLOAT (CL:- 0 SUM))))))))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ SCORE
      (CL:+ SCORE
       (CL:*
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN)) I))
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HO)) I)))))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:WHEN
    (CL:=
     (CL:+ 1.0d0
      (CL:THE CL:DOUBLE-FLOAT
       (CL:EXP (CL:THE CL:DOUBLE-FLOAT (CL:- 0 SCORE)))))
     0.0d0)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Sum is " SCORE EOL))
   (CL:SETF (%OUTPUT NET)
    (CL:/ 1.0d0
     (CL:+ 1.0d0
      (CL:THE CL:DOUBLE-FLOAT
       (CL:EXP (CL:THE CL:DOUBLE-FLOAT (CL:- 0 SCORE)))))))
   (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%PROPOSITION NET))
    SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE (WRAP-FLOAT (%OUTPUT NET))
    NULL-FLOAT-WRAPPER)
   (%OUTPUT NET)))

;;; (DEFUN (MAKE-NET-INPUT-STRING STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:SIMPLE-STRING) MAKE-NET-INPUT-STRING))
(CL:DEFUN MAKE-NET-INPUT-STRING (INPUT)
  (STRINGIFY INPUT))

;;; (DEFUN TRAIN-NEURAL-NETWORK ...)

(CL:DEFUN %TRAIN-NEURAL-NETWORK (CYCLES NUM-TRAINING)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CYCLES NUM-TRAINING))
  #+MCL
  (CL:CHECK-TYPE CYCLES CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NUM-TRAINING CL:FIXNUM)
  (CL:IF *TRAIN-CACHED-NETWORKS?*
   (TRAIN-CACHED-NEURAL-NETWORKS CYCLES NUM-TRAINING)
   (TRAIN-UNCACHED-NEURAL-NETWORKS CYCLES NUM-TRAINING)))

(CL:DEFUN TRAIN-NEURAL-NETWORK-EVALUATOR-WRAPPER (ARGUMENTS)
  (%TRAIN-NEURAL-NETWORK (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
   (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO TRAIN-NEURAL-NETWORK (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/TRAIN-NEURAL-NETWORK|)) (CL:MACRO-FUNCTION (CL:QUOTE TRAIN-NEURAL-NETWORK)))

;;; (DEFUN TRAIN-UNCACHED-NEURAL-NETWORKS ...)

(CL:DEFUN TRAIN-UNCACHED-NEURAL-NETWORKS (CYCLES NUM-TRAINING)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CYCLES NUM-TRAINING))
  #+MCL
  (CL:CHECK-TYPE CYCLES CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NUM-TRAINING CL:FIXNUM)
  (CL:LET*
   ((MSE 0.0d0) (NUM-EX (LENGTH *TRAINING-EXAMPLES*)) (LOOK-PTR NULL)
    (EXAMPLES (NEW-VECTOR NUM-TRAINING)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MSE) (CL:TYPE CL:FIXNUM NUM-EX))
   (CL:WHEN (CL:> NUM-TRAINING NUM-EX)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-ERROR) "Error: There are only "
     NUM-EX " training examples")
    (CL:RETURN-FROM TRAIN-UNCACHED-NEURAL-NETWORKS))
   (SHUFFLE-LIST *TRAINING-EXAMPLES*)
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NUM-TRAINING)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%THE-ARRAY EXAMPLES)) (VALUE (NTH *TRAINING-EXAMPLES* I))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((CYCLE NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- CYCLES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM CYCLE ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
     (CL:SETQ CYCLE ITER-001) (CL:SETQ MSE 0.0d0)
     (CL:COND
      ((CL:OR
        (CL:EQ *NEURAL-NETWORK-TRAINING-METHOD* KWD-NEURAL-NETWORK-BACKPROP)
        (CL:EQ *NEURAL-NETWORK-TRAINING-METHOD*
         KWD-NEURAL-NETWORK-BACKPROPAGATION))
       (SHUFFLE-VECTOR EXAMPLES))
      ((CL:EQ *NEURAL-NETWORK-TRAINING-METHOD* KWD-NEURAL-NETWORK-QUICKPROP)
       (CLEAR-ALL-SLOPES))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
         *NEURAL-NETWORK-TRAINING-METHOD* "' is not a valid case option")
        (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
     (CL:LET*
      ((EXAMPLE NULL) (VECTOR-000 EXAMPLES) (INDEX-000 0)
       (LENGTH-000 (LENGTH VECTOR-000)) (K NULL-INTEGER) (ITER-002 0))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 K ITER-002))
      (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
       (CL:SETQ EXAMPLE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
       (CL:SETQ K ITER-002)
       (CL:WHEN *TRACE-NEURAL-NETWORK-TRAINING*
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Example " K ": "
         (%QUERY EXAMPLE) "  " (%SCORE EXAMPLE) EOL))
       (CL:WHEN (CL:NOT (CL:EQ (%MODULE EXAMPLE) NULL))
        (CHANGE-MODULE (%MODULE EXAMPLE)))
       (CL:LET*
        ((FORM (COPY-CONS-TREE (%QUERY EXAMPLE))) (TARGET (%SCORE EXAMPLE))
         (QUERY (MAKE-QUERY NIL (COERCE-TO-TREE FORM) NIL NIL))
         (PROP (%PROPOSITION (%BASE-CONTROL-FRAME QUERY)))
         (OUTPUT (RETURN-PARTIAL-TRUTH QUERY CL:T))
         (ERROR (COMPUTE-ERROR TARGET OUTPUT)))
        (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT TARGET OUTPUT ERROR))
        (CL:WHEN *TRACE-NEURAL-NETWORK-TRAINING*
         (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   Output: " OUTPUT
          EOL))
        (CL:SETQ MSE (CL:+ MSE (CL:* ERROR ERROR)))
        (CL:SETQ *PARTIAL-SUPPORT-CACHE* (NEW-LIST))
        (CL:COND
         ((CL:OR
           (CL:EQ *NEURAL-NETWORK-TRAINING-METHOD*
            KWD-NEURAL-NETWORK-BACKPROPAGATION)
           (CL:EQ *NEURAL-NETWORK-TRAINING-METHOD*
            KWD-NEURAL-NETWORK-BACKPROP))
          (BACKPROPAGATE-ERROR PROP ERROR))
         ((CL:EQ *NEURAL-NETWORK-TRAINING-METHOD*
           KWD-NEURAL-NETWORK-QUICKPROP)
          (QUICKPROPAGATE-ERROR PROP ERROR))
         (CL:T
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
            *NEURAL-NETWORK-TRAINING-METHOD* "' is not a valid case option")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))
       (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
       (CL:SETQ ITER-002 (CL:1+ ITER-002))))
     (CL:WHEN
      (CL:EQ *NEURAL-NETWORK-TRAINING-METHOD* KWD-NEURAL-NETWORK-QUICKPROP)
      (MODIFY-WEIGHTS))
     (CL:WHEN
      (CL:AND (CL:> *SAVE-NETWORK-CYCLE* 0)
       (CL:= (CL:THE CL:FIXNUM (CL:REM CYCLE *SAVE-NETWORK-CYCLE*)) 0))
      (%SAVE-ALL-NEURAL-NETWORKS *SAVE-NETWORK-FILE*))
     (CL:WHEN
      (CL:AND (CL:> *ERROR-PRINT-CYCLE* 0)
       (CL:= (CL:THE CL:FIXNUM (CL:REM CYCLE *ERROR-PRINT-CYCLE*)) 0))
      (CL:WHEN (CL:NOT (CL:EQ *SAVE-NETWORK-FILE* STELLA::NULL-STRING))
       (CL:WHEN (CL:EQ LOOK-PTR NULL)
        (CL:SETQ LOOK-PTR
         (NEW-OUTPUT-FILE-STREAM (CONCATENATE *SAVE-NETWORK-FILE* ".err"))))
       (%%PRINT-STREAM (%NATIVE-STREAM LOOK-PTR) "Cycle " CYCLE " Error: "
        (CL:/ MSE NUM-TRAINING) EOL))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Cycle " CYCLE
       " Error: " (CL:/ MSE NUM-TRAINING) EOL))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:WHEN (CL:NOT (CL:EQ LOOK-PTR NULL)) (FREE LOOK-PTR))))

;;; (DEFGLOBAL *PARTIAL-SUPPORT-CACHE* ...)

(CL:DEFVAR *PARTIAL-SUPPORT-CACHE* NULL)

;;; (DEFUN BACKPROPAGATE-ERROR ...)

(CL:DEFUN BACKPROPAGATE-ERROR (PROP ERROR)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ERROR))
  #+MCL
  (CL:CHECK-TYPE ERROR CL:DOUBLE-FLOAT)
  (CL:LET*
   ((NET
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
      SYM-NEURAL-NETWORK-LOGIC-NEURAL-NETWORK NULL))
    (OUTPUT
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
       SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER)))
    (NUM-HIDDEN 0) (DELTA 0.0d0) (SAVED-INPUT NULL) (SAVED-HIDDEN NULL)
    (HIDDEN-ERROR NULL) (INPUT-ERROR NULL) (NUM-IN 0)
    (RECURSIVE-CONFLICT CL:NIL) (FULL-ERROR ERROR))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT OUTPUT DELTA FULL-ERROR)
    (CL:TYPE CL:FIXNUM NUM-HIDDEN NUM-IN))
   (CL:WHEN (CL:NOT (CL:EQ NET NULL)) (CL:SETQ NUM-IN (LENGTH (%INPUT NET)))
    (CL:SETQ NUM-HIDDEN (LENGTH (%HIDDEN NET)))
    (CL:SETQ SAVED-INPUT (%INPUT NET)) (CL:SETQ SAVED-HIDDEN (%HIDDEN NET))
    (CL:LET
     ((SELF (%THE-ARRAY (%INPUT NET))) (VALUE (WRAP-FLOAT 1.0d0))
      (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET* ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 (CL:1- NUM-IN)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
      (CL:LET*
       ((VALUE
         (%WRAPPER-VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT NET))) I))))
       (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE))
       (CL:WHEN
        (CL:NOT
         (CL:= VALUE
          (%WRAPPER-VALUE
           (DYNAMIC-SLOT-VALUE
            (%DYNAMIC-SLOTS
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP)))
              (CL:THE CL:FIXNUM (CL:1- I))))
            SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER))))
        (CL:SETQ RECURSIVE-CONFLICT CL:T) (CL:RETURN)))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    (CL:WHEN RECURSIVE-CONFLICT
     (CL:LET* ((I NULL-INTEGER) (ITER-001 1) (UPPER-BOUND-001 (CL:1- NUM-IN)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
      (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ I ITER-001)
       (CL:LET
        ((SELF (%THE-ARRAY (%INPUT NET)))
         (VALUE
          (WRAP-FLOAT
           (%WRAPPER-VALUE
            (DYNAMIC-SLOT-VALUE
             (%DYNAMIC-SLOTS
              (CL:AREF
               (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP)))
               (CL:THE CL:FIXNUM (CL:1- I))))
             SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER))))
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-001 (CL:1+ ITER-001))))
     (ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK NET))
    (CL:SETQ ERROR (CL:* ERROR OUTPUT (CL:- 1.0d0 OUTPUT)))
    (CL:WHEN RECURSIVE-CONFLICT (CL:SETQ SAVED-INPUT (NEW-VECTOR NUM-IN))
     (CL:SETQ SAVED-HIDDEN (NEW-VECTOR NUM-HIDDEN))
     (CL:LET* ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-002 (CL:1- NUM-IN)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-002))
      (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-002) DO (CL:SETQ I ITER-002)
       (CL:LET
        ((SELF (%THE-ARRAY SAVED-INPUT))
         (VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT NET))) I))
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-002 (CL:1+ ITER-002))))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-003 0) (UPPER-BOUND-003 (CL:1- NUM-HIDDEN)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003 UPPER-BOUND-003))
      (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-003) DO (CL:SETQ I ITER-003)
       (CL:LET
        ((SELF (%THE-ARRAY SAVED-HIDDEN))
         (VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HIDDEN NET))) I))
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-003 (CL:1+ ITER-003)))))
    (CL:SETQ HIDDEN-ERROR (NEW-VECTOR NUM-HIDDEN))
    (CL:SETQ INPUT-ERROR (NEW-VECTOR NUM-IN))
    (CL:LET*
     ((H NULL-INTEGER) (ITER-004 0) (UPPER-BOUND-004 (CL:1- NUM-HIDDEN)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-004 UPPER-BOUND-004))
     (CL:LOOP WHILE (CL:<= ITER-004 UPPER-BOUND-004) DO (CL:SETQ H ITER-004)
      (CL:LET
       ((SELF (%THE-ARRAY HIDDEN-ERROR))
        (VALUE
         (WRAP-FLOAT
          (CL:* ERROR
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO NET))) H)))))
        (POSITION H))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET
       ((SELF (%THE-ARRAY HIDDEN-ERROR))
        (VALUE
         (WRAP-FLOAT
          (CL:*
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN-ERROR)) H))
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HIDDEN NET))) H))
           (CL:- 1.0d0
            (%WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HIDDEN NET)))
              H))))))
        (POSITION H))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ITER-004 (CL:1+ ITER-004))))
    (CL:LET* ((I NULL-INTEGER) (ITER-005 0) (UPPER-BOUND-005 (CL:1- NUM-IN)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-005 UPPER-BOUND-005))
     (CL:LOOP WHILE (CL:<= ITER-005 UPPER-BOUND-005) DO (CL:SETQ I ITER-005)
      (CL:LET
       ((SELF (%THE-ARRAY INPUT-ERROR)) (VALUE (WRAP-FLOAT 0.0d0))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET*
       ((H NULL-INTEGER) (ITER-006 0) (UPPER-BOUND-006 (CL:1- NUM-HIDDEN)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-006 UPPER-BOUND-006))
       (CL:LOOP WHILE (CL:<= ITER-006 UPPER-BOUND-006) DO (CL:SETQ H ITER-006)
        (CL:LET
         ((SELF (%THE-ARRAY INPUT-ERROR))
          (VALUE
           (WRAP-FLOAT
            (CL:+
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INPUT-ERROR)) I))
             (CL:*
              (%WRAPPER-VALUE
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN-ERROR))
                H))
              (%WRAPPER-VALUE
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH NET)))
                (CL:THE CL:FIXNUM
                 (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H))))))))
          (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (CL:SETQ ITER-006 (CL:1+ ITER-006))))
      (CL:SETQ ITER-005 (CL:1+ ITER-005)))))
   (CL:LET* ((TEST-VALUE-000 (%KIND PROP)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-NEURAL-NETWORK-AND)
       (CL:EQ TEST-VALUE-000 KWD-NEURAL-NETWORK-OR))
      (CL:LET*
       ((CHILD NULL) (VECTOR-000 (%ARGUMENTS PROP)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-007 1)
        (UPPER-BOUND-007 (CL:1- NUM-IN)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-007 UPPER-BOUND-007))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:<= ITER-007 UPPER-BOUND-007))
        DO
        (CL:SETQ CHILD
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ I ITER-007)
        (BACKPROPAGATE-ERROR CHILD
         (%WRAPPER-VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INPUT-ERROR)) I)))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ ITER-007 (CL:1+ ITER-007))))
      (CL:LET*
       ((H NULL-INTEGER) (ITER-008 0) (UPPER-BOUND-008 (CL:1- NUM-HIDDEN)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-008 UPPER-BOUND-008))
       (CL:LOOP WHILE (CL:<= ITER-008 UPPER-BOUND-008) DO (CL:SETQ H ITER-008)
        (CL:SETQ DELTA
         (CL:+
          (CL:* *MOMENTUM-TERM*
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO-DELTA NET)))
             H)))
          (CL:* *LEARNING-RATE* ERROR
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SAVED-HIDDEN))
             H)))))
        (CL:LET
         ((SELF (%THE-ARRAY (%HO NET)))
          (VALUE
           (WRAP-FLOAT
            (CL:+
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO NET))) H))
             DELTA)))
          (POSITION H))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (CL:LET
         ((SELF (%THE-ARRAY (%HO-DELTA NET))) (VALUE (WRAP-FLOAT DELTA))
          (POSITION H))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (CL:SETQ ITER-008 (CL:1+ ITER-008))))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-009 0) (UPPER-BOUND-009 (CL:1- NUM-IN)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-009 UPPER-BOUND-009))
       (CL:LOOP WHILE (CL:<= ITER-009 UPPER-BOUND-009) DO (CL:SETQ I ITER-009)
        (CL:LET*
         ((H NULL-INTEGER) (ITER-010 0) (UPPER-BOUND-010 (CL:1- NUM-HIDDEN)))
         (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-010 UPPER-BOUND-010))
         (CL:LOOP WHILE (CL:<= ITER-010 UPPER-BOUND-010) DO
          (CL:SETQ H ITER-010)
          (CL:SETQ DELTA
           (CL:+
            (CL:* *MOMENTUM-TERM*
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH-DELTA NET)))
               (CL:THE CL:FIXNUM
                (CL:+ (CL:* I (%NOF-COLUMNS (%IH-DELTA NET))) H)))))
            (CL:* *LEARNING-RATE*
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN-ERROR)) H))
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SAVED-INPUT))
               I)))))
          (CL:LET
           ((SELF (%THE-ARRAY (%IH NET)))
            (VALUE
             (WRAP-FLOAT
              (CL:+
               (%WRAPPER-VALUE
                (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH NET)))
                 (CL:THE CL:FIXNUM
                  (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H))))
               DELTA)))
            (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H)))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SETF (CL:AREF SELF POSITION) VALUE))
          (CL:LET
           ((SELF (%THE-ARRAY (%IH-DELTA NET))) (VALUE (WRAP-FLOAT DELTA))
            (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH-DELTA NET))) H)))
           (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
            (CL:TYPE CL:FIXNUM POSITION))
           (CL:SETF (CL:AREF SELF POSITION) VALUE))
          (CL:SETQ ITER-010 (CL:1+ ITER-010))))
        (CL:SETQ ITER-009 (CL:1+ ITER-009)))))
     (CL:T
      (CL:WHEN (CL:NOT (CL:EQ (SUPPORT PROP) NIL))
       (CL:LET* ((PROOFS (SUPPORT PROP)) (GUILTY NIL))
        (CL:COND
         ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-MAX)
          (CL:SETQ GUILTY (CONS-LIST (%%VALUE PROOFS)))
          (CL:LET* ((PROOF NULL) (ITER-011 (%%REST PROOFS)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-011 NIL)) DO
            (CL:SETQ PROOF (%%VALUE ITER-011))
            (CL:WHEN (CL:= (%SCORE PROOF) OUTPUT)
             (CL:SETQ GUILTY (CONS-LIST PROOF)))
            (CL:SETQ ITER-011 (%%REST ITER-011)))))
         ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-NOISY-OR)
          (CL:SETQ GUILTY PROOFS))
         (CL:T
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" *RULE-COMBINATION*
            "' is not a valid case option")
           (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
        (CL:LET* ((PROOF NULL) (ITER-012 GUILTY))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-012 NIL)) DO
          (CL:SETQ PROOF (%%VALUE ITER-012))
          (CL:WHEN
           (CL:NOT
            (MEMBER? *PARTIAL-SUPPORT-CACHE* (WRAP-INTEGER (%ID PROOF))))
           (CL:LET* ((FACT (%FACT PROOF)))
            (CL:IF (CL:= (LENGTH (%ARGUMENT-SCORES PROOF)) 1)
             (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FACT)
              SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE
              (WRAP-FLOAT (%WRAPPER-VALUE (%%VALUE (%ARGUMENT-SCORES PROOF))))
              NULL-FLOAT-WRAPPER)
             (CL:LET*
              ((SCORE NULL) (ITER-013 (%ARGUMENT-SCORES PROOF)) (ARG NULL)
               (VECTOR-001 (%ARGUMENTS FACT)) (INDEX-001 0)
               (LENGTH-001 (LENGTH VECTOR-001)))
              (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
              (CL:LOOP WHILE
               (CL:AND (CL:NOT (CL:EQ ITER-013 NIL))
                (CL:< INDEX-001 LENGTH-001))
               DO (CL:SETQ SCORE (%%VALUE ITER-013))
               (CL:SETQ ARG
                (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
                 INDEX-001))
               (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARG)
                SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE
                (WRAP-FLOAT (%WRAPPER-VALUE SCORE)) NULL-FLOAT-WRAPPER)
               (CL:SETQ ITER-013 (%%REST ITER-013))
               (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
            (PUSH *PARTIAL-SUPPORT-CACHE* (WRAP-INTEGER (%ID PROOF)))
            (BACKPROPAGATE-ERROR (%FACT PROOF)
             (CL:* FULL-ERROR (%SCORE PROOF)))
            (POP *PARTIAL-SUPPORT-CACHE*)))
          (CL:SETQ ITER-012 (%%REST ITER-012)))))))))))

;;; (DEFUN QUICKPROPAGATE-ERROR ...)

(CL:DEFUN QUICKPROPAGATE-ERROR (PROP ERROR)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ERROR))
  #+MCL
  (CL:CHECK-TYPE ERROR CL:DOUBLE-FLOAT)
  (CL:LET*
   ((NET
     (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
      SYM-NEURAL-NETWORK-LOGIC-NEURAL-NETWORK NULL))
    (OUTPUT
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
       SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER)))
    (FULL-ERROR ERROR) (TEMP 0.0d0) (NUM-IN 0) (NUM-HIDDEN 0)
    (INPUT-ERROR NULL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT OUTPUT FULL-ERROR TEMP)
    (CL:TYPE CL:FIXNUM NUM-IN NUM-HIDDEN))
   (CL:WHEN (CL:NOT (CL:EQ NET NULL)) (CL:SETQ NUM-IN (LENGTH (%INPUT NET)))
    (CL:SETQ NUM-HIDDEN (LENGTH (%HIDDEN NET)))
    (CL:LET
     ((SELF (%THE-ARRAY (%INPUT NET))) (VALUE (WRAP-FLOAT 1.0d0))
      (POSITION 0))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:LET* ((I NULL-INTEGER) (ITER-000 1) (UPPER-BOUND-000 (CL:1- NUM-IN)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
      (CL:LET
       ((SELF (%THE-ARRAY (%INPUT NET)))
        (VALUE
         (WRAP-FLOAT
          (%WRAPPER-VALUE
           (DYNAMIC-SLOT-VALUE
            (%DYNAMIC-SLOTS
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%ARGUMENTS PROP)))
              (CL:THE CL:FIXNUM (CL:1- I))))
            SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER))))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    (ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK NET)
    (CL:SETQ ERROR
     (CL:* ERROR
      (CL:+ *SIGMOID-PRIME-OFFSET* (CL:* OUTPUT (CL:- 1.0d0 OUTPUT)))))
    (CL:SETQ INPUT-ERROR (NEW-VECTOR NUM-IN)) (ZERO-VECTOR INPUT-ERROR)
    (CL:LET*
     ((H NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- NUM-HIDDEN)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-001 UPPER-BOUND-001))
     (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ H ITER-001)
      (CL:LET
       ((SELF (%THE-ARRAY (%HO-SLOPE NET)))
        (VALUE
         (WRAP-FLOAT
          (CL:+
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO-SLOPE NET)))
             H))
           (CL:* ERROR
            (%WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HIDDEN NET)))
              H))))))
        (POSITION H))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ TEMP
       (CL:* ERROR
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO NET))) H))
        (CL:+ *SIGMOID-PRIME-OFFSET*
         (CL:*
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HIDDEN NET))) H))
          (CL:- 1.0d0
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HIDDEN NET)))
             H)))))))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-002 (CL:1- NUM-IN)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-002))
       (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-002) DO (CL:SETQ I ITER-002)
        (CL:LET
         ((SELF (%THE-ARRAY (%IH-SLOPE NET)))
          (VALUE
           (WRAP-FLOAT
            (CL:+
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH-SLOPE NET)))
               (CL:THE CL:FIXNUM
                (CL:+ (CL:* I (%NOF-COLUMNS (%IH-SLOPE NET))) H))))
             (CL:* TEMP
              (%WRAPPER-VALUE
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT NET)))
                I))))))
          (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH-SLOPE NET))) H)))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (CL:LET
         ((SELF (%THE-ARRAY INPUT-ERROR))
          (VALUE
           (WRAP-FLOAT
            (CL:+
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INPUT-ERROR)) I))
             (CL:* TEMP
              (%WRAPPER-VALUE
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH NET)))
                (CL:THE CL:FIXNUM
                 (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H))))))))
          (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (CL:SETQ ITER-002 (CL:1+ ITER-002))))
      (CL:SETQ ITER-001 (CL:1+ ITER-001)))))
   (CL:LET* ((TEST-VALUE-000 (%KIND PROP)))
    (CL:COND
     ((CL:OR (CL:EQ TEST-VALUE-000 KWD-NEURAL-NETWORK-AND)
       (CL:EQ TEST-VALUE-000 KWD-NEURAL-NETWORK-OR))
      (CL:LET*
       ((CHILD NULL) (VECTOR-000 (%ARGUMENTS PROP)) (INDEX-000 0)
        (LENGTH-000 (LENGTH VECTOR-000)) (I NULL-INTEGER) (ITER-003 1)
        (UPPER-BOUND-003 (CL:1- NUM-IN)))
       (CL:DECLARE
        (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-003 UPPER-BOUND-003))
       (CL:LOOP WHILE
        (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:<= ITER-003 UPPER-BOUND-003))
        DO
        (CL:SETQ CHILD
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
          INDEX-000))
        (CL:SETQ I ITER-003)
        (QUICKPROPAGATE-ERROR CHILD
         (%WRAPPER-VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INPUT-ERROR)) I)))
        (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
        (CL:SETQ ITER-003 (CL:1+ ITER-003)))))
     (CL:T
      (CL:WHEN (CL:NOT (CL:EQ (SUPPORT PROP) NIL))
       (CL:LET* ((PROOFS (SUPPORT PROP)) (GUILTY NIL))
        (CL:COND
         ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-MAX)
          (CL:SETQ GUILTY (CONS-LIST (%%VALUE PROOFS)))
          (CL:LET* ((PROOF NULL) (ITER-004 (%%REST PROOFS)))
           (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
            (CL:SETQ PROOF (%%VALUE ITER-004))
            (CL:WHEN (CL:= (%SCORE PROOF) OUTPUT)
             (CL:SETQ GUILTY (CONS-LIST PROOF)))
            (CL:SETQ ITER-004 (%%REST ITER-004)))))
         ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-NOISY-OR)
          (CL:SETQ GUILTY PROOFS))
         (CL:T
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" *RULE-COMBINATION*
            "' is not a valid case option")
           (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
        (CL:LET* ((PROOF NULL) (ITER-005 GUILTY))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
          (CL:SETQ PROOF (%%VALUE ITER-005))
          (CL:WHEN
           (CL:NOT
            (MEMBER? *PARTIAL-SUPPORT-CACHE* (WRAP-INTEGER (%ID PROOF))))
           (CL:LET* ((FACT (%FACT PROOF)))
            (CL:IF (CL:= (LENGTH (%ARGUMENT-SCORES PROOF)) 1)
             (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FACT)
              SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE
              (WRAP-FLOAT (%WRAPPER-VALUE (%%VALUE (%ARGUMENT-SCORES PROOF))))
              NULL-FLOAT-WRAPPER)
             (CL:LET*
              ((SCORE NULL) (ITER-006 (%ARGUMENT-SCORES PROOF)) (ARG NULL)
               (VECTOR-001 (%ARGUMENTS FACT)) (INDEX-001 0)
               (LENGTH-001 (LENGTH VECTOR-001)))
              (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001))
              (CL:LOOP WHILE
               (CL:AND (CL:NOT (CL:EQ ITER-006 NIL))
                (CL:< INDEX-001 LENGTH-001))
               DO (CL:SETQ SCORE (%%VALUE ITER-006))
               (CL:SETQ ARG
                (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001))
                 INDEX-001))
               (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARG)
                SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE
                (WRAP-FLOAT (%WRAPPER-VALUE SCORE)) NULL-FLOAT-WRAPPER)
               (CL:SETQ ITER-006 (%%REST ITER-006))
               (CL:SETQ INDEX-001 (CL:1+ INDEX-001)))))
            (PUSH *PARTIAL-SUPPORT-CACHE* (WRAP-INTEGER (%ID PROOF)))
            (QUICKPROPAGATE-ERROR (%FACT PROOF)
             (CL:* FULL-ERROR (%SCORE PROOF)))
            (POP *PARTIAL-SUPPORT-CACHE*)))
          (CL:SETQ ITER-005 (%%REST ITER-005)))))))))))

;;; (DEFUN (COMPUTE-ERROR FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:DOUBLE-FLOAT CL:DOUBLE-FLOAT) CL:DOUBLE-FLOAT)
  COMPUTE-ERROR))
(CL:DEFUN COMPUTE-ERROR (TRAINING OUTPUT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT TRAINING OUTPUT))
  #+MCL
  (CL:CHECK-TYPE TRAINING CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE OUTPUT CL:DOUBLE-FLOAT)
  (CL:COND
   ((CL:= TRAINING 1.0d0)
    (CL:WHEN (CL:> OUTPUT 0.9d0) (CL:RETURN-FROM COMPUTE-ERROR 0.0d0)))
   ((CL:= TRAINING 0.0d0)
    (CL:WHEN (CL:< OUTPUT 0.1d0) (CL:RETURN-FROM COMPUTE-ERROR 0.0d0)))
   (CL:T))
  (CL:- TRAINING OUTPUT))

;;; (DEFUN (COMPUTE-DELTA FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:DOUBLE-FLOAT CL:DOUBLE-FLOAT CL:DOUBLE-FLOAT)
   CL:DOUBLE-FLOAT)
  COMPUTE-DELTA))
(CL:DEFUN COMPUTE-DELTA (SLOPE PREV-SLOPE PREV-DELTA)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SLOPE PREV-SLOPE PREV-DELTA))
  #+MCL
  (CL:CHECK-TYPE SLOPE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE PREV-SLOPE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE PREV-DELTA CL:DOUBLE-FLOAT)
  (CL:SETQ PREV-SLOPE PREV-SLOPE)
  (CL:+ (CL:* *LEARNING-RATE* SLOPE) (CL:* *MOMENTUM-TERM* PREV-DELTA)))

;;; (DEFUN (COMPUTE-QP-DELTA FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:DOUBLE-FLOAT CL:DOUBLE-FLOAT CL:DOUBLE-FLOAT)
   CL:DOUBLE-FLOAT)
  COMPUTE-QP-DELTA))
(CL:DEFUN COMPUTE-QP-DELTA (SLOPE PREV-SLOPE PREV-DELTA)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SLOPE PREV-SLOPE PREV-DELTA))
  #+MCL
  (CL:CHECK-TYPE SLOPE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE PREV-SLOPE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE PREV-DELTA CL:DOUBLE-FLOAT)
  (CL:LET* ((DELTA 0.0d0)) (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT DELTA))
   (CL:COND
    ((CL:> PREV-DELTA *MODE-SWITCH*)
     (CL:WHEN (CL:> SLOPE 0.0d0) (CL:SETQ DELTA (CL:* *LEARNING-RATE* SLOPE)))
     (CL:IF (CL:> SLOPE (CL:* *SHRINK-FACTOR* PREV-SLOPE))
      (CL:SETQ DELTA (CL:+ DELTA (CL:* *MAX-MOVEMENT* PREV-DELTA)))
      (CL:SETQ DELTA
       (CL:+ DELTA (CL:* (CL:/ SLOPE (CL:- PREV-SLOPE SLOPE)) PREV-DELTA)))))
    ((CL:< PREV-DELTA (CL:- 0.0d0 *MODE-SWITCH*))
     (CL:WHEN (CL:< SLOPE 0.0d0) (CL:SETQ DELTA (CL:* *LEARNING-RATE* SLOPE)))
     (CL:IF (CL:< SLOPE (CL:* *SHRINK-FACTOR* PREV-SLOPE))
      (CL:SETQ DELTA (CL:+ DELTA (CL:* *MAX-MOVEMENT* PREV-DELTA)))
      (CL:SETQ DELTA
       (CL:+ DELTA (CL:* (CL:/ SLOPE (CL:- PREV-SLOPE SLOPE)) PREV-DELTA)))))
    (CL:T
     (CL:SETQ DELTA
      (CL:+ (CL:* *LEARNING-RATE* SLOPE) (CL:* *MOMENTUM-TERM* PREV-DELTA)))))
   DELTA))

;;; (DEFUN MODIFY-WEIGHTS ...)

(CL:DEFUN MODIFY-WEIGHTS ()
  (CL:LET* ((DELTA 0.0d0) (NUM-IN 0) (NUM-HIDDEN 0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT DELTA)
    (CL:TYPE CL:FIXNUM NUM-IN NUM-HIDDEN))
   (CL:LET*
    ((NET NULL) (ITER-000 (%THE-CONS-LIST *MASTER-NEURAL-NETWORK-LIST*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ NET (%%VALUE ITER-000)) (CL:SETQ NUM-IN (LENGTH (%INPUT NET)))
     (CL:SETQ NUM-HIDDEN (LENGTH (%HIDDEN NET)))
     (CL:LET*
      ((H NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-000 (CL:1- NUM-HIDDEN)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-001 UPPER-BOUND-000))
      (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-000) DO (CL:SETQ H ITER-001)
       (CL:SETQ DELTA
        (COMPUTE-QP-DELTA
         (%WRAPPER-VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO-SLOPE NET))) H))
         (%WRAPPER-VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO-PREV-SLOPE NET)))
           H))
         (%WRAPPER-VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO-DELTA NET)))
           H))))
       (CL:LET
        ((SELF (%THE-ARRAY (%HO NET)))
         (VALUE
          (WRAP-FLOAT
           (CL:+
            (%WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO NET))) H))
            DELTA)))
         (POSITION H))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:LET
        ((SELF (%THE-ARRAY (%HO-DELTA NET))) (VALUE (WRAP-FLOAT DELTA))
         (POSITION H))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-001 (CL:1+ ITER-001))))
     (CL:LET* ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-001 (CL:1- NUM-IN)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-001))
      (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-001) DO (CL:SETQ I ITER-002)
       (CL:LET*
        ((H NULL-INTEGER) (ITER-003 0) (UPPER-BOUND-002 (CL:1- NUM-HIDDEN)))
        (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-003 UPPER-BOUND-002))
        (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-002) DO
         (CL:SETQ H ITER-003)
         (CL:SETQ DELTA
          (COMPUTE-QP-DELTA
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH-SLOPE NET)))
             (CL:THE CL:FIXNUM
              (CL:+ (CL:* I (%NOF-COLUMNS (%IH-SLOPE NET))) H))))
           (%WRAPPER-VALUE
            (CL:AREF
             (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH-PREV-SLOPE NET)))
             (CL:THE CL:FIXNUM
              (CL:+ (CL:* I (%NOF-COLUMNS (%IH-PREV-SLOPE NET))) H))))
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH-DELTA NET)))
             (CL:THE CL:FIXNUM
              (CL:+ (CL:* I (%NOF-COLUMNS (%IH-DELTA NET))) H))))))
         (CL:LET
          ((SELF (%THE-ARRAY (%IH NET)))
           (VALUE
            (WRAP-FLOAT
             (CL:+
              (%WRAPPER-VALUE
               (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH NET)))
                (CL:THE CL:FIXNUM
                 (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H))))
              DELTA)))
           (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H)))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:LET
          ((SELF (%THE-ARRAY (%IH-DELTA NET))) (VALUE (WRAP-FLOAT DELTA))
           (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH-DELTA NET))) H)))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:SETQ ITER-003 (CL:1+ ITER-003))))
       (CL:SETQ ITER-002 (CL:1+ ITER-002))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))))

;;; (DEFUN (TEST-OVER-TRAINING-EXAMPLES FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION () CL:DOUBLE-FLOAT) TEST-OVER-TRAINING-EXAMPLES))
(CL:DEFUN TEST-OVER-TRAINING-EXAMPLES ()
  (CL:LET* ((MSE 0.0d0) (ERROR 0.0d0) (OUTPUT 0.0d0) (FORM NIL) (QUERY NULL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MSE ERROR OUTPUT))
   (CL:LET*
    ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST *TRAINING-EXAMPLES*))
     (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000)) (CL:SETQ I ITER-001)
     (CL:WHEN (CL:NOT (CL:EQ (%MODULE EXAMPLE) NULL))
      (CHANGE-MODULE (%MODULE EXAMPLE)))
     (CL:SETQ FORM (COPY-CONS-TREE (%QUERY EXAMPLE)))
     (CL:SETQ QUERY (MAKE-QUERY NIL (COERCE-TO-TREE FORM) NIL NIL))
     (CL:SETQ OUTPUT (RETURN-PARTIAL-TRUTH QUERY CL:T))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Example " I ": "
      (%%VALUE (%%REST (%QUERY EXAMPLE))) ", " OUTPUT "  Target: "
      (%SCORE EXAMPLE) EOL)
     (CL:SETQ ERROR (CL:- (%SCORE EXAMPLE) OUTPUT))
     (CL:SETQ MSE (CL:+ MSE (CL:* ERROR ERROR)))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   MSE))

(CL:DEFUN TEST-OVER-TRAINING-EXAMPLES-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:SETQ ARGUMENTS ARGUMENTS)
  (CL:LET* ((RESULT (TEST-OVER-TRAINING-EXAMPLES)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:IF (CL:NOT (CL:= RESULT NULL-FLOAT)) (WRAP-FLOAT RESULT) NULL)))

;;; (DEFUN (TRAIN-AND-TEST-NEURAL-NETWORK FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:FIXNUM CL:FIXNUM CL:FIXNUM) CL:DOUBLE-FLOAT)
  %TRAIN-AND-TEST-NEURAL-NETWORK))
(CL:DEFUN %TRAIN-AND-TEST-NEURAL-NETWORK (CYCLES NUM-TRAINING NUM-TESTING)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CYCLES NUM-TRAINING NUM-TESTING))
  #+MCL
  (CL:CHECK-TYPE CYCLES CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NUM-TRAINING CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NUM-TESTING CL:FIXNUM)
  (%TRAIN-NEURAL-NETWORK CYCLES NUM-TRAINING)
  (CL:LET* ((MSE 0.0d0) (TESTING-EXAMPLES (NEW-VECTOR NUM-TESTING)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MSE))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 NUM-TRAINING)
     (UPPER-BOUND-000 (CL:+ NUM-TRAINING (CL:1- NUM-TESTING))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%THE-ARRAY TESTING-EXAMPLES))
       (VALUE (NTH *TRAINING-EXAMPLES* I)) (POSITION (CL:- I NUM-TRAINING)))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET*
    ((EXAMPLE NULL) (VECTOR-000 TESTING-EXAMPLES) (INDEX-000 0)
     (LENGTH-000 (LENGTH VECTOR-000)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
    (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
     (CL:SETQ EXAMPLE
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
     (CL:WHEN (CL:NOT (CL:EQ (%MODULE EXAMPLE) NULL))
      (CHANGE-MODULE (%MODULE EXAMPLE)))
     (CL:LET*
      ((FORM (COPY-CONS-TREE (%QUERY EXAMPLE)))
       (QUERY (MAKE-QUERY NIL (COERCE-TO-TREE FORM) NIL NIL))
       (OUTPUT (RETURN-PARTIAL-TRUTH QUERY CL:T))
       (ERROR (CL:- (%SCORE EXAMPLE) OUTPUT)))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT OUTPUT ERROR))
      (CL:SETQ MSE (CL:+ MSE (CL:* ERROR ERROR))))
     (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
   (CL:SETQ MSE (CL:/ MSE NUM-TESTING)) MSE))

(CL:DEFUN TRAIN-AND-TEST-NEURAL-NETWORK-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (%TRAIN-AND-TEST-NEURAL-NETWORK (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
      (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))
      (%WRAPPER-VALUE (%%VALUE (%%REST (%%REST ARGUMENTS)))))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:IF (CL:NOT (CL:= RESULT NULL-FLOAT)) (WRAP-FLOAT RESULT) NULL)))

(CL:DEFMACRO TRAIN-AND-TEST-NEURAL-NETWORK (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/TRAIN-AND-TEST-NEURAL-NETWORK|)) (CL:MACRO-FUNCTION (CL:QUOTE TRAIN-AND-TEST-NEURAL-NETWORK)))

;;; (DEFUN (TEST-NEURAL-NETWORK FLOAT) ...)

(CL:DECLAIM (CL:FTYPE (CL:FUNCTION () CL:DOUBLE-FLOAT) TEST-NEURAL-NETWORK))
(CL:DEFUN TEST-NEURAL-NETWORK ()
  (CL:LET* ((ERROR-SUM 0.0d0) (NUM-TESTING (LENGTH *TESTING-EXAMPLES*)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ERROR-SUM)
    (CL:TYPE CL:FIXNUM NUM-TESTING))
   (CL:LET* ((EXAMPLE NULL) (ITER-000 (%THE-CONS-LIST *TESTING-EXAMPLES*)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ EXAMPLE (%%VALUE ITER-000))
     (CL:WHEN (CL:NOT (CL:EQ (%MODULE EXAMPLE) NULL))
      (CHANGE-MODULE (%MODULE EXAMPLE)))
     (CL:LET*
      ((FORM (COPY-CONS-TREE (%QUERY EXAMPLE)))
       (QUERY (MAKE-QUERY NIL (COERCE-TO-TREE FORM) NIL NIL))
       (OUTPUT (RETURN-PARTIAL-TRUTH QUERY CL:T))
       (ERROR (CL:- (%SCORE EXAMPLE) OUTPUT)))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT OUTPUT ERROR))
      (CL:SETQ ERROR-SUM
       (CL:+ ERROR-SUM (CL:IF (CL:< ERROR 0.0d0) (CL:- 0.0d0 ERROR) ERROR))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ ERROR-SUM (CL:/ ERROR-SUM NUM-TESTING)) ERROR-SUM))

(CL:DEFUN TEST-NEURAL-NETWORK-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:SETQ ARGUMENTS ARGUMENTS)
  (CL:LET* ((RESULT (TEST-NEURAL-NETWORK)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:IF (CL:NOT (CL:= RESULT NULL-FLOAT)) (WRAP-FLOAT RESULT) NULL)))

;;; (DEFUN (MULTIPLE-NETWORK-TRAINING-RUNS FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:FIXNUM CL:FIXNUM CL:FIXNUM) CL:DOUBLE-FLOAT)
  %MULTIPLE-NETWORK-TRAINING-RUNS))
(CL:DEFUN %MULTIPLE-NETWORK-TRAINING-RUNS (RUNS CYCLES NUM-TRAINING)
  (CL:DECLARE (CL:TYPE CL:FIXNUM RUNS CYCLES NUM-TRAINING))
  #+MCL
  (CL:CHECK-TYPE RUNS CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE CYCLES CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NUM-TRAINING CL:FIXNUM)
  (CL:LET* ((ERRORS (NEW-VECTOR RUNS)) (SUM 0.0d0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SUM))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- RUNS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CLEAR-ALL-NEURAL-NETWORKS) (%TRAIN-NEURAL-NETWORK CYCLES NUM-TRAINING)
     (CL:LET
      ((SELF (%THE-ARRAY ERRORS)) (VALUE (WRAP-FLOAT (TEST-NEURAL-NETWORK)))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ SUM
      (CL:+ SUM
       (%WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ERRORS)) I))))
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "** Run " I ": "
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ERRORS)) I) EOL)
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) EOL "*** Report" EOL)
   (CL:LET* ((I NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- RUNS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ I ITER-001)
     (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "** Run " I ": "
      (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ERRORS)) I) EOL)
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:/ SUM RUNS)))

(CL:DEFUN MULTIPLE-NETWORK-TRAINING-RUNS-EVALUATOR-WRAPPER (ARGUMENTS)
  (CL:LET*
   ((RESULT
     (%MULTIPLE-NETWORK-TRAINING-RUNS (%WRAPPER-VALUE (%%VALUE ARGUMENTS))
      (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))
      (%WRAPPER-VALUE (%%VALUE (%%REST (%%REST ARGUMENTS)))))))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT RESULT))
   (CL:IF (CL:NOT (CL:= RESULT NULL-FLOAT)) (WRAP-FLOAT RESULT) NULL)))

(CL:DEFMACRO MULTIPLE-NETWORK-TRAINING-RUNS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/MULTIPLE-NETWORK-TRAINING-RUNS|)) (CL:MACRO-FUNCTION (CL:QUOTE MULTIPLE-NETWORK-TRAINING-RUNS)))

;;; (DEFUN TRAIN-CACHED-NEURAL-NETWORKS ...)

(CL:DEFUN TRAIN-CACHED-NEURAL-NETWORKS (CYCLES NUM-TRAINING)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CYCLES NUM-TRAINING))
  #+MCL
  (CL:CHECK-TYPE CYCLES CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NUM-TRAINING CL:FIXNUM)
  (CL:LET*
   ((MSE 0.0d0) (ABS-ERROR 0.0d0) (ERROR 0.0d0) (TARGET 0.0d0) (OUTPUT 0.0d0)
    (NUM-EX (LENGTH *TRAINING-EXAMPLES*)) (INDEX (NEW-VECTOR NUM-TRAINING))
    (LOOK-PTR NULL) (EXAMPLES (NEW-VECTOR NUM-TRAINING))
    (NET-RECORDS (NEW-VECTOR NUM-TRAINING)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MSE ABS-ERROR ERROR TARGET OUTPUT)
    (CL:TYPE CL:FIXNUM NUM-EX))
   (CL:WHEN (CL:> NUM-TRAINING NUM-EX)
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Error: There are only "
     NUM-EX " training examples")
    (CL:RETURN-FROM TRAIN-CACHED-NEURAL-NETWORKS))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NUM-TRAINING))
     (EXAMPLE NULL) (ITER-001 (%THE-CONS-LIST *TRAINING-EXAMPLES*)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-000 UPPER-BOUND-000) (CL:NOT (CL:EQ ITER-001 NIL)))
     DO (CL:SETQ I ITER-000) (CL:SETQ EXAMPLE (%%VALUE ITER-001))
     (CL:LET ((SELF (%THE-ARRAY EXAMPLES)) (VALUE EXAMPLE) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET ((SELF (%THE-ARRAY INDEX)) (VALUE (WRAP-INTEGER I)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-001 (CL:1- NUM-TRAINING)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-001) DO (CL:SETQ I ITER-002)
     (CL:LET*
      ((EXAMPLE (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY EXAMPLES)) I))
       (TIMESTAMP (GET-NOW-TIMESTAMP)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM TIMESTAMP))
      (CL:IF
       (CL:AND (CL:NOT (CL:EQ (%CACHED-SOLUTION EXAMPLE) NULL))
        (CL:= TIMESTAMP (%TIMESTAMP EXAMPLE)))
       (CL:LET
        ((SELF (%THE-ARRAY NET-RECORDS)) (VALUE (%CACHED-SOLUTION EXAMPLE))
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:LET* ((CURRENT-MODULE *MODULE*))
        (CL:WHEN (CL:NOT (CL:EQ (%MODULE EXAMPLE) NULL))
         (CHANGE-MODULE (%MODULE EXAMPLE)))
        (CL:LET
         ((SELF (%THE-ARRAY NET-RECORDS))
          (VALUE (CREATE-CACHED-NETWORK (%QUERY EXAMPLE))) (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (CL:SETF (%CACHED-SOLUTION EXAMPLE)
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY NET-RECORDS)) I))
        (CL:SETF (%TIMESTAMP EXAMPLE) TIMESTAMP)
        (CHANGE-MODULE CURRENT-MODULE))))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Training Networks" EOL)
   (CL:LET*
    ((CYCLE NULL-INTEGER) (ITER-003 0) (UPPER-BOUND-002 (CL:1- CYCLES)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM CYCLE ITER-003 UPPER-BOUND-002))
    (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-002) DO
     (CL:SETQ CYCLE ITER-003) (CL:SETQ MSE 0.0d0) (CL:SETQ ABS-ERROR 0.0d0)
     (CL:COND
      ((CL:OR
        (CL:EQ *NEURAL-NETWORK-TRAINING-METHOD* KWD-NEURAL-NETWORK-BACKPROP)
        (CL:EQ *NEURAL-NETWORK-TRAINING-METHOD*
         KWD-NEURAL-NETWORK-BACKPROPAGATION))
       (SHUFFLE-VECTOR INDEX))
      ((CL:EQ *NEURAL-NETWORK-TRAINING-METHOD* KWD-NEURAL-NETWORK-QUICKPROP)
       (CLEAR-ALL-SLOPES))
      (CL:T
       (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
        (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`"
         *NEURAL-NETWORK-TRAINING-METHOD* "' is not a valid case option")
        (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
     (CL:LET*
      ((K NULL-INTEGER) (ITER-004 0) (UPPER-BOUND-003 (CL:1- NUM-TRAINING)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM K ITER-004 UPPER-BOUND-003))
      (CL:LOOP WHILE (CL:<= ITER-004 UPPER-BOUND-003) DO (CL:SETQ K ITER-004)
       (CL:WHEN *TRACE-NEURAL-NETWORK-TRAINING*
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Example " K ": "
         (%QUERY
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY EXAMPLES))
           (CL:THE CL:FIXNUM
            (%WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INDEX)) K)))))
         "  "
         (%SCORE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY EXAMPLES))
           (CL:THE CL:FIXNUM
            (%WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INDEX)) K)))))
         EOL))
       (CL:SETQ TARGET
        (%SCORE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY EXAMPLES))
          (CL:THE CL:FIXNUM
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INDEX)) K))))))
       (CL:SETQ OUTPUT
        (ACTIVATE-CACHED-NETWORK
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY NET-RECORDS))
          (CL:THE CL:FIXNUM
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INDEX)) K))))))
       (CL:SETQ ERROR (COMPUTE-ERROR TARGET OUTPUT))
       (CL:WHEN *TRACE-NEURAL-NETWORK-TRAINING*
        (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "   Output: " OUTPUT
         EOL))
       (CL:SETQ ABS-ERROR
        (CL:+ ABS-ERROR (CL:IF (CL:< ERROR 0.0d0) (CL:- 0.0d0 ERROR) ERROR)))
       (CL:SETQ MSE (CL:+ MSE (CL:* ERROR ERROR)))
       (CL:COND
        ((CL:OR
          (CL:EQ *NEURAL-NETWORK-TRAINING-METHOD*
           KWD-NEURAL-NETWORK-BACKPROPAGATION)
          (CL:EQ *NEURAL-NETWORK-TRAINING-METHOD*
           KWD-NEURAL-NETWORK-BACKPROP))
         (CACHED-BACKPROPAGATE-ERROR
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY NET-RECORDS))
           (CL:THE CL:FIXNUM
            (%WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INDEX)) K))))
          ERROR))
        ((CL:EQ *NEURAL-NETWORK-TRAINING-METHOD* KWD-NEURAL-NETWORK-QUICKPROP)
         (CACHED-QUICKPROPAGATE-ERROR
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY NET-RECORDS))
           (CL:THE CL:FIXNUM
            (%WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INDEX)) K))))
          ERROR))
        (CL:T
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
           *NEURAL-NETWORK-TRAINING-METHOD* "' is not a valid case option")
          (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))
       (CL:SETQ ITER-004 (CL:1+ ITER-004))))
     (CL:WHEN
      (CL:EQ *NEURAL-NETWORK-TRAINING-METHOD* KWD-NEURAL-NETWORK-QUICKPROP)
      (MODIFY-WEIGHTS))
     (CL:WHEN
      (CL:AND (CL:> *SAVE-NETWORK-CYCLE* 0)
       (CL:= (CL:THE CL:FIXNUM (CL:REM CYCLE *SAVE-NETWORK-CYCLE*)) 0))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Saving networks" EOL)
      (%SAVE-ALL-NEURAL-NETWORKS *SAVE-NETWORK-FILE*))
     (CL:WHEN
      (CL:AND (CL:> *ERROR-PRINT-CYCLE* 0)
       (CL:= (CL:THE CL:FIXNUM (CL:REM CYCLE *ERROR-PRINT-CYCLE*)) 0))
      (CL:WHEN (CL:NOT (CL:EQ *SAVE-NETWORK-FILE* STELLA::NULL-STRING))
       (CL:WHEN (CL:EQ LOOK-PTR NULL)
        (CL:SETQ LOOK-PTR
         (NEW-OUTPUT-FILE-STREAM (CONCATENATE *SAVE-NETWORK-FILE* ".err"))))
       (%%PRINT-STREAM (%NATIVE-STREAM LOOK-PTR) "Cycle " CYCLE " Error: "
        (CL:/ ABS-ERROR NUM-TRAINING) EOL))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Cycle " CYCLE
       " Error: " (CL:/ ABS-ERROR NUM-TRAINING) EOL))
     (CL:WHEN (CL:< (CL:/ MSE NUM-TRAINING) *ERROR-CUTOFF*) (CL:RETURN))
     (CL:SETQ ITER-003 (CL:1+ ITER-003))))
   (CL:WHEN (CL:NOT (CL:EQ LOOK-PTR NULL)) (FREE LOOK-PTR))))

;;; (DEFGLOBAL *LEARNING-CURVE* ...)

(CL:DEFVAR *LEARNING-CURVE* NULL)

;;; (DEFUN CACHED-BACKPROPAGATE-ERROR ...)

(CL:DEFUN CACHED-BACKPROPAGATE-ERROR (TREE ERROR)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ERROR))
  #+MCL
  (CL:CHECK-TYPE ERROR CL:DOUBLE-FLOAT)
  (CL:LET*
   ((NET NULL) (TEMP 0.0d0) (DELTA 0.0d0) (INPUT NULL) (HIDDEN NULL)
    (HIDDEN-ERROR NULL) (INPUT-ERROR NULL) (RECURSIVE-CONFLICT? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT TEMP DELTA))
   (CL:WHEN (ISA? (%%VALUE TREE) SGT-NEURAL-NETWORK-STELLA-CONS)
    (CL:COND
     ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-MAX)
      (CL:LET* ((MAX 0.0d0) (GUILTY NIL))
       (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MAX))
       (CL:LET* ((NET-DEF NULL) (ITER-000 TREE))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ NET-DEF (%%VALUE ITER-000)) (CL:SETQ NET (%%VALUE NET-DEF))
         (CL:WHEN (CL:> (%OUTPUT NET) MAX) (CL:SETQ MAX (%OUTPUT NET))
          (CL:SETQ GUILTY NET-DEF))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CACHED-BACKPROPAGATE-ERROR GUILTY ERROR)))
     ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-NOISY-OR)
      (CL:LET* ((NET-DEF NULL) (ITER-001 TREE))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ NET-DEF (%%VALUE ITER-001))
        (CACHED-BACKPROPAGATE-ERROR NET-DEF
         (CL:* ERROR (%OUTPUT (%%VALUE NET-DEF))))
        (CL:SETQ ITER-001 (%%REST ITER-001)))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" *RULE-COMBINATION*
        "' is not a valid case option")
       (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
    (CL:RETURN-FROM CACHED-BACKPROPAGATE-ERROR))
   (CL:SETQ NET (%%VALUE TREE)) (CL:SETQ INPUT (%INPUT NET))
   (CL:SETQ HIDDEN (%HIDDEN NET)) (CL:SETQ INPUT-ERROR (%INPUT-ERROR NET))
   (CL:SETQ HIDDEN-ERROR (%HIDDEN-ERROR NET))
   (CL:SETQ ERROR (CL:* ERROR (%OUTPUT NET) (CL:- 1.0d0 (%OUTPUT NET))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 1)
     (UPPER-BOUND-000 (CL:1- (LENGTH (%INPUT NET)))) (ELE NULL)
     (ITER-003 (%%REST TREE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-002 UPPER-BOUND-000) (CL:NOT (CL:EQ ITER-003 NIL)))
     DO (CL:SETQ I ITER-002) (CL:SETQ ELE (%%VALUE ITER-003))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ELE)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 SGT-NEURAL-NETWORK-STELLA-CONS)
        (CL:PROGN
         (CL:IF (CL:= (LENGTH ELE) 1)
          (CL:SETQ TEMP (%OUTPUT (%%VALUE (%%VALUE ELE))))
          (CL:COND
           ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-MAX)
            (CL:SETQ TEMP 0.0d0)
            (CL:LET* ((NET-DEF NULL) (ITER-004 ELE))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
              (CL:SETQ NET-DEF (%%VALUE ITER-004))
              (CL:WHEN (CL:> (%OUTPUT (%%VALUE NET-DEF)) TEMP)
               (CL:SETQ TEMP (%OUTPUT NET)))
              (CL:SETQ ITER-004 (%%REST ITER-004)))))
           ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-NOISY-OR)
            (CL:LET* ((SCORES NIL))
             (CL:LET* ((NET-DEF NULL) (ITER-005 ELE) (COLLECT-000 NULL))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
               (CL:SETQ NET-DEF (%%VALUE ITER-005))
               (CL:IF (CL:EQ COLLECT-000 NULL)
                (CL:PROGN
                 (CL:SETQ COLLECT-000
                  (CONS (WRAP-FLOAT (%OUTPUT (%%VALUE NET-DEF))) NIL))
                 (CL:IF (CL:EQ SCORES NIL) (CL:SETQ SCORES COLLECT-000)
                  (ADD-CONS-TO-END-OF-CONS-LIST SCORES COLLECT-000)))
                (CL:PROGN
                 (CL:SETF (%%REST COLLECT-000)
                  (CONS (WRAP-FLOAT (%OUTPUT (%%VALUE NET-DEF))) NIL))
                 (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
               (CL:SETQ ITER-005 (%%REST ITER-005))))
             (CL:SETQ TEMP (PROBABILISTIC-SUM-N SCORES))))
           (CL:T
            (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
              *RULE-COMBINATION* "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))))
       ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
        (CL:PROGN (CL:SETQ TEMP (%WRAPPER-VALUE ELE))))
       (CL:T
        (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" TEST-VALUE-000
          "' is not a valid case option")
         (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))))
     (CL:LET*
      ((VALUE
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT NET))) I))))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE))
      (CL:WHEN (CL:NOT (CL:= VALUE TEMP)) (CL:SETQ RECURSIVE-CONFLICT? CL:T)
       (CL:RETURN)))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))
     (CL:SETQ ITER-003 (%%REST ITER-003))))
   (CL:WHEN RECURSIVE-CONFLICT? (ACTIVATE-CACHED-NETWORK (CONS-LIST TREE))
    (CL:SETQ HIDDEN (NEW-VECTOR (LENGTH (%HIDDEN NET))))
    (CL:SETQ HIDDEN-ERROR (NEW-VECTOR (LENGTH (%HIDDEN NET))))
    (CL:SETQ INPUT (NEW-VECTOR (LENGTH (%INPUT NET))))
    (CL:LET*
     ((I NULL-INTEGER) (ITER-006 0) (UPPER-BOUND-001 (CL:1- (LENGTH INPUT))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-006 UPPER-BOUND-001))
     (CL:LOOP WHILE (CL:<= ITER-006 UPPER-BOUND-001) DO (CL:SETQ I ITER-006)
      (CL:LET
       ((SELF (%THE-ARRAY INPUT))
        (VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT NET))) I))
        (POSITION I))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ITER-006 (CL:1+ ITER-006))))
    (CL:LET*
     ((H NULL-INTEGER) (ITER-007 0) (UPPER-BOUND-002 (CL:1- (LENGTH HIDDEN))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-007 UPPER-BOUND-002))
     (CL:LOOP WHILE (CL:<= ITER-007 UPPER-BOUND-002) DO (CL:SETQ H ITER-007)
      (CL:LET
       ((SELF (%THE-ARRAY HIDDEN))
        (VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HIDDEN NET))) H))
        (POSITION H))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ITER-007 (CL:1+ ITER-007)))))
   (CL:LET*
    ((H NULL-INTEGER) (ITER-008 0) (UPPER-BOUND-003 (CL:1- (LENGTH HIDDEN))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-008 UPPER-BOUND-003))
    (CL:LOOP WHILE (CL:<= ITER-008 UPPER-BOUND-003) DO (CL:SETQ H ITER-008)
     (CL:LET
      ((SELF (%THE-ARRAY HIDDEN-ERROR))
       (VALUE
        (WRAP-FLOAT
         (CL:* ERROR
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO NET))) H)))))
       (POSITION H))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF (%THE-ARRAY HIDDEN-ERROR))
       (VALUE
        (WRAP-FLOAT
         (CL:*
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN-ERROR)) H))
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN)) H))
          (CL:- 1.0d0
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN)) H))))))
       (POSITION H))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-008 (CL:1+ ITER-008))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-009 0) (UPPER-BOUND-004 (CL:1- (LENGTH INPUT))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-009 UPPER-BOUND-004))
    (CL:LOOP WHILE (CL:<= ITER-009 UPPER-BOUND-004) DO (CL:SETQ I ITER-009)
     (CL:LET
      ((SELF (%THE-ARRAY INPUT-ERROR)) (VALUE (WRAP-FLOAT 0.0d0))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET*
      ((H NULL-INTEGER) (ITER-010 0)
       (UPPER-BOUND-005 (CL:1- (LENGTH HIDDEN))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-010 UPPER-BOUND-005))
      (CL:LOOP WHILE (CL:<= ITER-010 UPPER-BOUND-005) DO (CL:SETQ H ITER-010)
       (CL:LET
        ((SELF (%THE-ARRAY INPUT-ERROR))
         (VALUE
          (WRAP-FLOAT
           (CL:+
            (%WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INPUT-ERROR)) I))
            (CL:*
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN-ERROR)) H))
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH NET)))
               (CL:THE CL:FIXNUM
                (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H))))))))
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-010 (CL:1+ ITER-010))))
     (CL:SETQ ITER-009 (CL:1+ ITER-009))))
   (CL:LET*
    ((INPUT NULL) (ITER-011 (%%REST TREE)) (I NULL-INTEGER) (ITER-012 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-012))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-011 NIL)) DO
     (CL:SETQ INPUT (%%VALUE ITER-011)) (CL:SETQ I ITER-012)
     (CL:WHEN (ISA? INPUT SGT-NEURAL-NETWORK-STELLA-CONS)
      (CACHED-BACKPROPAGATE-ERROR INPUT
       (%WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INPUT-ERROR)) I))))
     (CL:SETQ ITER-011 (%%REST ITER-011))
     (CL:SETQ ITER-012 (CL:1+ ITER-012))))
   (CL:LET*
    ((H NULL-INTEGER) (ITER-013 0) (UPPER-BOUND-006 (CL:1- (LENGTH HIDDEN))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-013 UPPER-BOUND-006))
    (CL:LOOP WHILE (CL:<= ITER-013 UPPER-BOUND-006) DO (CL:SETQ H ITER-013)
     (CL:SETQ DELTA
      (CL:+
       (CL:* *MOMENTUM-TERM*
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO-DELTA NET))) H)))
       (CL:* *LEARNING-RATE* ERROR
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN)) H)))))
     (CL:LET
      ((SELF (%THE-ARRAY (%HO NET)))
       (VALUE
        (WRAP-FLOAT
         (CL:+
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO NET))) H))
          DELTA)))
       (POSITION H))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET
      ((SELF (%THE-ARRAY (%HO-DELTA NET))) (VALUE (WRAP-FLOAT DELTA))
       (POSITION H))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-014 0) (UPPER-BOUND-007 (CL:1- (LENGTH INPUT))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-014 UPPER-BOUND-007))
      (CL:LOOP WHILE (CL:<= ITER-014 UPPER-BOUND-007) DO (CL:SETQ I ITER-014)
       (CL:SETQ DELTA
        (CL:+
         (CL:* *MOMENTUM-TERM*
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH-DELTA NET)))
            (CL:THE CL:FIXNUM
             (CL:+ (CL:* I (%NOF-COLUMNS (%IH-DELTA NET))) H)))))
         (CL:* *LEARNING-RATE*
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN-ERROR)) H))
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INPUT)) I)))))
       (CL:LET
        ((SELF (%THE-ARRAY (%IH NET)))
         (VALUE
          (WRAP-FLOAT
           (CL:+
            (%WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH NET)))
              (CL:THE CL:FIXNUM (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H))))
            DELTA)))
         (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:LET
        ((SELF (%THE-ARRAY (%IH-DELTA NET))) (VALUE (WRAP-FLOAT DELTA))
         (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH-DELTA NET))) H)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-014 (CL:1+ ITER-014))))
     (CL:SETQ ITER-013 (CL:1+ ITER-013))))))

;;; (DEFUN CACHED-QUICKPROPAGATE-ERROR ...)

(CL:DEFUN CACHED-QUICKPROPAGATE-ERROR (TREE ERROR)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ERROR))
  #+MCL
  (CL:CHECK-TYPE ERROR CL:DOUBLE-FLOAT)
  (CL:LET*
   ((NET NULL) (TEMP 0.0d0) (INPUT NULL) (HIDDEN NULL) (INPUT-ERROR NULL)
    (RECURSIVE-CONFLICT? CL:NIL))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT TEMP))
   (CL:WHEN (ISA? (%%VALUE TREE) SGT-NEURAL-NETWORK-STELLA-CONS)
    (CL:COND
     ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-MAX)
      (CL:LET* ((MAX 0.0d0) (GUILTY NIL))
       (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT MAX))
       (CL:LET* ((NET-DEF NULL) (ITER-000 TREE))
        (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
         (CL:SETQ NET-DEF (%%VALUE ITER-000)) (CL:SETQ NET (%%VALUE NET-DEF))
         (CL:WHEN (CL:> (%OUTPUT NET) MAX) (CL:SETQ MAX (%OUTPUT NET))
          (CL:SETQ GUILTY NET-DEF))
         (CL:SETQ ITER-000 (%%REST ITER-000))))
       (CACHED-QUICKPROPAGATE-ERROR GUILTY ERROR)))
     ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-NOISY-OR)
      (CL:LET* ((NET-DEF NULL) (ITER-001 TREE))
       (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
        (CL:SETQ NET-DEF (%%VALUE ITER-001))
        (CACHED-QUICKPROPAGATE-ERROR NET-DEF
         (CL:* ERROR (%OUTPUT (%%VALUE NET-DEF))))
        (CL:SETQ ITER-001 (%%REST ITER-001)))))
     (CL:T
      (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" *RULE-COMBINATION*
        "' is not a valid case option")
       (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
    (CL:RETURN-FROM CACHED-QUICKPROPAGATE-ERROR))
   (CL:SETQ NET (%%VALUE TREE)) (CL:SETQ INPUT (%INPUT NET))
   (CL:SETQ HIDDEN (%HIDDEN NET)) (CL:SETQ INPUT-ERROR (%INPUT-ERROR NET))
   (CL:SETQ ERROR
    (CL:* ERROR
     (CL:+ *SIGMOID-PRIME-OFFSET*
      (CL:* (%OUTPUT NET) (CL:- 1.0d0 (%OUTPUT NET))))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-002 1)
     (UPPER-BOUND-000 (CL:1- (LENGTH (%INPUT NET)))) (ELE NULL)
     (ITER-003 (%%REST TREE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-002 UPPER-BOUND-000) (CL:NOT (CL:EQ ITER-003 NIL)))
     DO (CL:SETQ I ITER-002) (CL:SETQ ELE (%%VALUE ITER-003))
     (CL:LET* ((TEST-VALUE-000 (SAFE-PRIMARY-TYPE ELE)))
      (CL:COND
       ((CL:EQ TEST-VALUE-000 SGT-NEURAL-NETWORK-STELLA-CONS)
        (CL:PROGN
         (CL:IF (CL:= (LENGTH ELE) 1)
          (CL:SETQ TEMP (%OUTPUT (%%VALUE (%%VALUE ELE))))
          (CL:COND
           ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-MAX)
            (CL:SETQ TEMP 0.0d0)
            (CL:LET* ((NET-DEF NULL) (ITER-004 ELE))
             (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-004 NIL)) DO
              (CL:SETQ NET-DEF (%%VALUE ITER-004))
              (CL:WHEN (CL:> (%OUTPUT (%%VALUE NET-DEF)) TEMP)
               (CL:SETQ TEMP (%OUTPUT NET)))
              (CL:SETQ ITER-004 (%%REST ITER-004)))))
           ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-NOISY-OR)
            (CL:LET* ((SCORES NIL))
             (CL:LET* ((NET-DEF NULL) (ITER-005 ELE) (COLLECT-000 NULL))
              (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-005 NIL)) DO
               (CL:SETQ NET-DEF (%%VALUE ITER-005))
               (CL:IF (CL:EQ COLLECT-000 NULL)
                (CL:PROGN
                 (CL:SETQ COLLECT-000
                  (CONS (WRAP-FLOAT (%OUTPUT (%%VALUE NET-DEF))) NIL))
                 (CL:IF (CL:EQ SCORES NIL) (CL:SETQ SCORES COLLECT-000)
                  (ADD-CONS-TO-END-OF-CONS-LIST SCORES COLLECT-000)))
                (CL:PROGN
                 (CL:SETF (%%REST COLLECT-000)
                  (CONS (WRAP-FLOAT (%OUTPUT (%%VALUE NET-DEF))) NIL))
                 (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
               (CL:SETQ ITER-005 (%%REST ITER-005))))
             (CL:SETQ TEMP (PROBABILISTIC-SUM-N SCORES))))
           (CL:T
            (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
             (%%PRINT-STREAM (%NATIVE-STREAM STREAM-001) "`"
              *RULE-COMBINATION* "' is not a valid case option")
             (CL:ERROR
              (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001)))))))))
       ((SUBTYPE-OF-FLOAT? TEST-VALUE-000)
        (CL:PROGN (CL:SETQ TEMP (%WRAPPER-VALUE ELE))))
       (CL:T
        (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
         (%%PRINT-STREAM (%NATIVE-STREAM STREAM-002) "`" TEST-VALUE-000
          "' is not a valid case option")
         (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-002)))))))
     (CL:LET*
      ((VALUE
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT NET))) I))))
      (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE))
      (CL:WHEN (CL:NOT (CL:= VALUE TEMP)) (CL:SETQ RECURSIVE-CONFLICT? CL:T)
       (CL:RETURN)))
     (CL:SETQ ITER-002 (CL:1+ ITER-002))
     (CL:SETQ ITER-003 (%%REST ITER-003))))
   (CL:WHEN RECURSIVE-CONFLICT? (ACTIVATE-CACHED-NETWORK (CONS-LIST TREE)))
   (ZERO-VECTOR INPUT-ERROR)
   (CL:LET*
    ((H NULL-INTEGER) (ITER-006 0) (UPPER-BOUND-001 (CL:1- (LENGTH HIDDEN))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-006 UPPER-BOUND-001))
    (CL:LOOP WHILE (CL:<= ITER-006 UPPER-BOUND-001) DO (CL:SETQ H ITER-006)
     (CL:LET
      ((SELF (%THE-ARRAY (%HO-SLOPE NET)))
       (VALUE
        (WRAP-FLOAT
         (CL:+
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO-SLOPE NET))) H))
          (CL:* ERROR
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN)) H))))))
       (POSITION H))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ TEMP
      (CL:* ERROR
       (%WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO NET))) H))
       (CL:+ *SIGMOID-PRIME-OFFSET*
        (CL:*
         (%WRAPPER-VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN)) H))
         (CL:- 1.0d0
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY HIDDEN)) H)))))))
     (CL:LET*
      ((I NULL-INTEGER) (ITER-007 0) (UPPER-BOUND-002 (CL:1- (LENGTH INPUT))))
      (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-007 UPPER-BOUND-002))
      (CL:LOOP WHILE (CL:<= ITER-007 UPPER-BOUND-002) DO (CL:SETQ I ITER-007)
       (CL:LET
        ((SELF (%THE-ARRAY (%IH-SLOPE NET)))
         (VALUE
          (WRAP-FLOAT
           (CL:+
            (%WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH-SLOPE NET)))
              (CL:THE CL:FIXNUM
               (CL:+ (CL:* I (%NOF-COLUMNS (%IH-SLOPE NET))) H))))
            (CL:* TEMP
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INPUT)) I))))))
         (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH-SLOPE NET))) H)))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:LET
        ((SELF (%THE-ARRAY INPUT-ERROR))
         (VALUE
          (WRAP-FLOAT
           (CL:+
            (%WRAPPER-VALUE
             (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INPUT-ERROR)) I))
            (CL:* TEMP
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH NET)))
               (CL:THE CL:FIXNUM
                (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H))))))))
         (POSITION I))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
         (CL:TYPE CL:FIXNUM POSITION))
        (CL:SETF (CL:AREF SELF POSITION) VALUE))
       (CL:SETQ ITER-007 (CL:1+ ITER-007))))
     (CL:SETQ ITER-006 (CL:1+ ITER-006))))
   (CL:LET*
    ((INPUT NULL) (ITER-008 (%%REST TREE)) (I NULL-INTEGER) (ITER-009 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-009))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-008 NIL)) DO
     (CL:SETQ INPUT (%%VALUE ITER-008)) (CL:SETQ I ITER-009)
     (CL:WHEN (ISA? INPUT SGT-NEURAL-NETWORK-STELLA-CONS)
      (CACHED-QUICKPROPAGATE-ERROR INPUT
       (%WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY INPUT-ERROR)) I))))
     (CL:SETQ ITER-008 (%%REST ITER-008))
     (CL:SETQ ITER-009 (CL:1+ ITER-009))))))

;;; (DEFUN (CREATE-CACHED-NETWORK CONS) ...)

(CL:DEFUN CREATE-CACHED-NETWORK (CONS-QUERY)
  (CL:LET*
   ((QUERY
     (MAKE-QUERY NIL (COERCE-TO-TREE (COPY-CONS-TREE CONS-QUERY)) NIL NIL))
    (SCORE (RETURN-PARTIAL-TRUTH QUERY CL:T))
    (TREE
     (BUILD-NETWORK-TREE (%PROPOSITION (%BASE-CONTROL-FRAME QUERY)) NIL)))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE)) (CL:SETQ SCORE SCORE)
   (CL:WHEN (ISA? TREE SGT-NEURAL-NETWORK-STELLA-CONS)
    (CL:RETURN-FROM CREATE-CACHED-NETWORK TREE))
   NIL))

;;; (DEFUN (BUILD-NETWORK-TREE PARSE-TREE) ...)

(CL:DEFUN BUILD-NETWORK-TREE (PROP PROP-LIST)
  (CL:WHEN (MEMBER? PROP-LIST PROP)
   (CL:RETURN-FROM BUILD-NETWORK-TREE
    (WRAP-FLOAT
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
       SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER)))))
  (CL:COND
   ((CL:NOT (CL:EQ (SUPPORT PROP) NIL))
    (CL:LET* ((PROOFS (SUPPORT PROP)) (TREE NIL))
     (CL:LET* ((PROOF NULL) (ITER-000 PROOFS))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
       (CL:SETQ PROOF (%%VALUE ITER-000))
       (CL:LET* ((FACT (%FACT PROOF)) (PROOF-TREE NIL))
        (CL:LET*
         ((ARG NULL) (VECTOR-000 (%ARGUMENTS FACT)) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)) (SCORE NULL)
          (ITER-001 (%ARGUMENT-SCORES PROOF)) (COLLECT-000 NULL))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE
          (CL:AND (CL:< INDEX-000 LENGTH-000) (CL:NOT (CL:EQ ITER-001 NIL)))
          DO
          (CL:SETQ ARG
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:SETQ SCORE (%%VALUE ITER-001))
          (CL:WHEN (ISA? ARG SGT-NEURAL-NETWORK-LOGIC-PROPOSITION)
           (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARG)
            SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE
            (WRAP-FLOAT (%WRAPPER-VALUE SCORE)) NULL-FLOAT-WRAPPER)
           (CL:IF (CL:EQ COLLECT-000 NULL)
            (CL:PROGN
             (CL:SETQ COLLECT-000
              (CONS (BUILD-NETWORK-TREE ARG (CONS PROP PROP-LIST)) NIL))
             (CL:IF (CL:EQ PROOF-TREE NIL) (CL:SETQ PROOF-TREE COLLECT-000)
              (ADD-CONS-TO-END-OF-CONS-LIST PROOF-TREE COLLECT-000)))
            (CL:PROGN
             (CL:SETF (%%REST COLLECT-000)
              (CONS (BUILD-NETWORK-TREE ARG (CONS PROP PROP-LIST)) NIL))
             (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:IF
         (CL:NOT
          (CL:EQ
           (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FACT)
            SYM-NEURAL-NETWORK-LOGIC-NEURAL-NETWORK NULL)
           NULL))
         (CL:SETQ TREE
          (CONS
           (CONS
            (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FACT)
             SYM-NEURAL-NETWORK-LOGIC-NEURAL-NETWORK NULL)
            PROOF-TREE)
           TREE))
         (CL:SETQ TREE
          (CONS
           (WRAP-FLOAT
            (%WRAPPER-VALUE
             (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
              SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER)))
           TREE))))
       (CL:SETQ ITER-000 (%%REST ITER-000))))
     (CL:IF (CL:AND (CL:EQ (%%REST TREE) NIL) (CL:NOT (CONS? (%%VALUE TREE))))
      (%%VALUE TREE) TREE)))
   ((CL:NOT
     (CL:EQ
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
       SYM-NEURAL-NETWORK-LOGIC-NEURAL-NETWORK NULL)
      NULL))
    (CL:LET* ((TREE NIL))
     (CL:LET*
      ((ARG NULL) (VECTOR-001 (%ARGUMENTS PROP)) (INDEX-001 0)
       (LENGTH-001 (LENGTH VECTOR-001)) (I NULL-INTEGER) (ITER-002 1)
       (COLLECT-001 NULL))
      (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-001 LENGTH-001 I ITER-002))
      (CL:LOOP WHILE (CL:< INDEX-001 LENGTH-001) DO
       (CL:SETQ ARG
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-001)) INDEX-001))
       (CL:SETQ I ITER-002)
       (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS ARG)
        SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE
        (WRAP-FLOAT
         (%WRAPPER-VALUE
          (CL:AREF
           (CL:THE CL:SIMPLE-VECTOR
            (%THE-ARRAY
             (%INPUT
              (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
               SYM-NEURAL-NETWORK-LOGIC-NEURAL-NETWORK NULL))))
           I)))
        NULL-FLOAT-WRAPPER)
       (CL:IF (CL:EQ COLLECT-001 NULL)
        (CL:PROGN
         (CL:SETQ COLLECT-001
          (CONS (BUILD-NETWORK-TREE ARG (CONS PROP PROP-LIST)) NIL))
         (CL:IF (CL:EQ TREE NIL) (CL:SETQ TREE COLLECT-001)
          (ADD-CONS-TO-END-OF-CONS-LIST TREE COLLECT-001)))
        (CL:PROGN
         (CL:SETF (%%REST COLLECT-001)
          (CONS (BUILD-NETWORK-TREE ARG (CONS PROP PROP-LIST)) NIL))
         (CL:SETQ COLLECT-001 (%%REST COLLECT-001))))
       (CL:SETQ INDEX-001 (CL:1+ INDEX-001))
       (CL:SETQ ITER-002 (CL:1+ ITER-002))))
     (CL:SETQ TREE
      (CONS
       (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
        SYM-NEURAL-NETWORK-LOGIC-NEURAL-NETWORK NULL)
       TREE))
     (CONS-LIST TREE)))
   (CL:T
    (WRAP-FLOAT
     (%WRAPPER-VALUE
      (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS PROP)
       SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE NULL-FLOAT-WRAPPER))))))

;;; (DEFUN (ACTIVATE-CACHED-NETWORK FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T) CL:DOUBLE-FLOAT) ACTIVATE-CACHED-NETWORK))
(CL:DEFUN ACTIVATE-CACHED-NETWORK (TREE)
  (CL:LET* ((SCORES (NEW-VECTOR (LENGTH TREE))) (SCORE 0.0d0) (SUM 0.0d0))
   (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT SCORE SUM))
   (CL:LET* ((CACHED-NET NULL) (ITER-000 TREE) (K NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM K ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ CACHED-NET (%%VALUE ITER-000)) (CL:SETQ K ITER-001)
     (CL:LET* ((NET (%%VALUE CACHED-NET))) (CL:SETQ SUM 0.0d0)
      (CL:SETQ SCORE 0.0d0)
      (CL:LET
       ((SELF (%THE-ARRAY (%INPUT NET))) (VALUE (WRAP-FLOAT 1.0d0))
        (POSITION 0))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-002 1)
        (UPPER-BOUND-000 (CL:1- (LENGTH (%INPUT NET)))) (INPUT NULL)
        (ITER-003 (%%REST CACHED-NET)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-002 UPPER-BOUND-000))
       (CL:LOOP WHILE
        (CL:AND (CL:<= ITER-002 UPPER-BOUND-000)
         (CL:NOT (CL:EQ ITER-003 NIL)))
        DO (CL:SETQ I ITER-002) (CL:SETQ INPUT (%%VALUE ITER-003))
        (CL:IF (ISA? INPUT SGT-NEURAL-NETWORK-STELLA-CONS)
         (CL:LET
          ((SELF (%THE-ARRAY (%INPUT NET)))
           (VALUE (WRAP-FLOAT (ACTIVATE-CACHED-NETWORK INPUT))) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE))
         (CL:LET ((SELF (%THE-ARRAY (%INPUT NET))) (VALUE INPUT) (POSITION I))
          (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
           (CL:TYPE CL:FIXNUM POSITION))
          (CL:SETF (CL:AREF SELF POSITION) VALUE)))
        (CL:SETQ ITER-002 (CL:1+ ITER-002))
        (CL:SETQ ITER-003 (%%REST ITER-003))))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-004 0)
        (UPPER-BOUND-001 (CL:1- (LENGTH (%HIDDEN NET)))))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-004 UPPER-BOUND-001))
       (CL:LOOP WHILE (CL:<= ITER-004 UPPER-BOUND-001) DO (CL:SETQ I ITER-004)
        (CL:LET*
         ((J NULL-INTEGER) (ITER-005 0)
          (UPPER-BOUND-002 (CL:1- (LENGTH (%INPUT NET)))))
         (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-005 UPPER-BOUND-002))
         (CL:LOOP WHILE (CL:<= ITER-005 UPPER-BOUND-002) DO
          (CL:SETQ J ITER-005)
          (CL:SETQ SUM
           (CL:+ SUM
            (CL:*
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%INPUT NET))) J))
             (%WRAPPER-VALUE
              (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH NET)))
               (CL:THE CL:FIXNUM
                (CL:+ (CL:* J (%NOF-COLUMNS (%IH NET))) I)))))))
          (CL:SETQ ITER-005 (CL:1+ ITER-005))))
        (CL:LET
         ((SELF (%THE-ARRAY (%HIDDEN NET)))
          (VALUE
           (WRAP-FLOAT
            (CL:/ 1.0d0
             (CL:+ 1.0d0
              (CL:THE CL:DOUBLE-FLOAT
               (CL:EXP (CL:THE CL:DOUBLE-FLOAT (CL:- 0 SUM))))))))
          (POSITION I))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (CL:SETQ SCORE
         (CL:+ SCORE
          (CL:*
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HIDDEN NET))) I))
           (%WRAPPER-VALUE
            (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HO NET))) I)))))
        (CL:SETQ ITER-004 (CL:1+ ITER-004))))
      (CL:SETF (%OUTPUT NET)
       (CL:/ 1.0d0
        (CL:+ 1.0d0
         (CL:THE CL:DOUBLE-FLOAT
          (CL:EXP (CL:THE CL:DOUBLE-FLOAT (CL:- 0 SCORE)))))))
      (CL:LET
       ((SELF (%THE-ARRAY SCORES)) (VALUE (WRAP-FLOAT (%OUTPUT NET)))
        (POSITION K))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE)))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:COND
    ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-MAX)
     (CL:LET*
      ((MAX (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SCORES)) 0)))
      (CL:LET*
       ((I NULL-INTEGER) (ITER-006 0)
        (UPPER-BOUND-003 (CL:1- (LENGTH SCORES))))
       (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-006 UPPER-BOUND-003))
       (CL:LOOP WHILE (CL:<= ITER-006 UPPER-BOUND-003) DO (CL:SETQ I ITER-006)
        (CL:WHEN
         (CL:>
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SCORES)) I))
          (%WRAPPER-VALUE MAX))
         (CL:SETQ MAX
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SCORES)) I)))
        (CL:SETQ ITER-006 (CL:1+ ITER-006))))
      (%WRAPPER-VALUE MAX)))
    ((CL:EQ *RULE-COMBINATION* KWD-NEURAL-NETWORK-NOISY-OR)
     (CL:CASE (LENGTH SCORES) (0 0.0d0)
      (1
       (%WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SCORES)) 0)))
      (2
       (PROBABILISTIC-SUM
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SCORES)) 0))
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SCORES)) 1))))
      (CL:OTHERWISE
       (CL:LET* ((CONS-SCORES NIL))
        (CL:LET*
         ((ELE NULL) (VECTOR-000 SCORES) (INDEX-000 0)
          (LENGTH-000 (LENGTH VECTOR-000)) (COLLECT-000 NULL))
         (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
         (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
          (CL:SETQ ELE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
            INDEX-000))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN (CL:SETQ COLLECT-000 (CONS ELE NIL))
            (CL:IF (CL:EQ CONS-SCORES NIL) (CL:SETQ CONS-SCORES COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST CONS-SCORES COLLECT-000)))
           (CL:PROGN (CL:SETF (%%REST COLLECT-000) (CONS ELE NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
          (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
        (PROBABILISTIC-SUM-N CONS-SCORES)))))
    (CL:T
     (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
      (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" *RULE-COMBINATION*
       "' is not a valid case option")
      (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))))

;;; (DEFUN (RANDOM-WEIGHT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:DOUBLE-FLOAT) CL:DOUBLE-FLOAT) RANDOM-WEIGHT))
(CL:DEFUN RANDOM-WEIGHT (N)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT N))
  #+MCL
  (CL:CHECK-TYPE N CL:DOUBLE-FLOAT)
  (CL:WHEN (CL:= (RANDOM 2) 1) (CL:RETURN-FROM RANDOM-WEIGHT (RANDOM-FLOAT N)))
  (CL:- 0.0d0 (RANDOM-FLOAT N)))

;;; (DEFUN (RANDOM-FLOAT FLOAT) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:DOUBLE-FLOAT) CL:DOUBLE-FLOAT) RANDOM-FLOAT))
(CL:DEFUN RANDOM-FLOAT (N)
  "Generate a random integer in the interval [0..n-1].
'n' must be <= 2^15."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT N))
  #+MCL
  (CL:CHECK-TYPE N CL:DOUBLE-FLOAT)
  (CL:WHEN (CL:> N 32768)
   (CL:ERROR
    (NEW-STELLA-EXCEPTION
     "random: Can only generate random numbers between 0 and (2^15)-1.")))
  (CL:* N (CL:/ (RANDOM 32768) 32767.0d0)))

;;; (DEFUN (CONS-TO-VECTOR VECTOR) ...)

(CL:DEFUN CONS-TO-VECTOR (FORM)
  (CL:LET* ((SIZE (LENGTH FORM)) (VECT (NEW-VECTOR SIZE)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM SIZE))
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- SIZE)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET ((SELF (%THE-ARRAY VECT)) (VALUE (NTH FORM I)) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   VECT))

;;; (DEFUN (CREATE-VECTOR VECTOR) ...)

(CL:DEFUN CREATE-VECTOR (CL:&REST VALUES)
  "Return a vector containing 'values', in order."
  (CL:LET* ((VECTOR (NEW-VECTOR (CL:LENGTH VALUES))))
   (CL:LET* ((V NULL) (ITER-000 VALUES) (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ V (CL:POP ITER-000))
     (CL:SETQ I ITER-001)
     (CL:LET ((SELF (%THE-ARRAY VECTOR)) (VALUE V) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   VECTOR))

;;; (DEFUN ZERO-VECTOR ...)

(CL:DEFUN ZERO-VECTOR (V)
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- (LENGTH V))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
    (CL:LET ((SELF (%THE-ARRAY V)) (VALUE (WRAP-FLOAT 0.0d0)) (POSITION I))
     (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
     (CL:SETF (CL:AREF SELF POSITION) VALUE))
    (CL:SETQ ITER-000 (CL:1+ ITER-000)))))

;;; (DEFUN STRUCTURED-NEURAL-NETWORK-REGRESSION ...)

(CL:DEFUN %STRUCTURED-NEURAL-NETWORK-REGRESSION (CLASS-NAME SLOT-NAME CYCLES)
  (CL:DECLARE (CL:TYPE CL:FIXNUM CYCLES))
  #+MCL
  (CL:CHECK-TYPE CYCLES CL:FIXNUM)
  (CL:SETQ SLOT-NAME (PERMANENTIFY SLOT-NAME))
  (CL:SETQ CLASS-NAME (PERMANENTIFY CLASS-NAME))
  (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
   "Generating training examples" EOL)
  (CL:LET*
   ((CLASS (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION CLASS-NAME)))
    (SLOT (%SURROGATE-VALUE-INVERSE (GET-DESCRIPTION SLOT-NAME)))
    (ILIST (LISTIFY (ALL-CLASS-INSTANCES CLASS)))
    (INSTANCES (NEW-VECTOR (LENGTH ILIST))))
   (CL:WHEN (CL:NOT (FLOAT-FUNCTION? SLOT))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "ERROR " SLOT-NAME
     " is not a function of type float or integer" EOL)
    (CL:RETURN-FROM %STRUCTURED-NEURAL-NETWORK-REGRESSION))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- (LENGTH ILIST)))
     (INSTANCE NULL) (ITER-001 (%THE-CONS-LIST ILIST)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:AND (CL:<= ITER-000 UPPER-BOUND-000) (CL:NOT (CL:EQ ITER-001 NIL)))
     DO (CL:SETQ I ITER-000) (CL:SETQ INSTANCE (%%VALUE ITER-001))
     (CL:LET ((SELF (%THE-ARRAY INSTANCES)) (VALUE INSTANCE) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CLEAR-CASES)
   (GENERATE-REGRESSION-RULE-WO-SLOT INSTANCES SLOT-NAME CLASS-NAME CL:T)
   (CL:LET* ((NUM (GENERATE-REGRESSION-TRAINING-EXAMPLES INSTANCES SLOT)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM NUM))
    (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
     "Training regression networks" EOL)
    (TRAIN-CACHED-NEURAL-NETWORKS CYCLES NUM))))

(CL:DEFUN STRUCTURED-NEURAL-NETWORK-REGRESSION-EVALUATOR-WRAPPER (ARGUMENTS)
  (%STRUCTURED-NEURAL-NETWORK-REGRESSION (%%VALUE ARGUMENTS)
   (%%VALUE (%%REST ARGUMENTS))
   (%WRAPPER-VALUE (%%VALUE (%%REST (%%REST ARGUMENTS))))))

(CL:DEFMACRO STRUCTURED-NEURAL-NETWORK-REGRESSION (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/STRUCTURED-NEURAL-NETWORK-REGRESSION|)) (CL:MACRO-FUNCTION (CL:QUOTE STRUCTURED-NEURAL-NETWORK-REGRESSION)))

;;; (DEFUN (GET-NN-NEAREST-NEIGHBORS (LIST OF TRAINING-EXAMPLE)) ...)

(CL:DEFUN GET-NN-NEAREST-NEIGHBORS (PROBE CASES K)
  (CL:DECLARE (CL:TYPE CL:FIXNUM K))
  #+MCL
  (CL:CHECK-TYPE K CL:FIXNUM)
  (CL:LET*
   ((RESULT (NEW-LIST)) (CURRENT-MODULE *MODULE*) (NEIGHBORS (NEW-VECTOR K))
    (FARTHEST 0) (DISTANCE 0.0d0) (DISTANCES (NEW-VECTOR K)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM FARTHEST)
    (CL:TYPE CL:DOUBLE-FLOAT DISTANCE))
   (SHUFFLE-LIST CASES)
   (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- K)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%THE-ARRAY DISTANCES)) (VALUE (WRAP-FLOAT 999999.0d0))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETF (%NN-HIDDEN PROBE) (CREATE-HIDDEN-SIGNATURE (%QUERY PROBE)))
   (CL:LET* ((CASE NULL) (ITER-001 (%THE-CONS-LIST CASES)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ CASE (%%VALUE ITER-001))
     (CL:WHEN (CL:EQ (%NN-HIDDEN CASE) NULL)
      (CL:WHEN (CL:NOT (CL:EQ (%MODULE CASE) NULL))
       (CHANGE-MODULE (%MODULE CASE)))
      (CL:WHEN (CL:EQ (%NN-HIDDEN CASE) NULL)
       (CL:SETF (%NN-HIDDEN CASE) (CREATE-HIDDEN-SIGNATURE (%QUERY CASE))))
      (CHANGE-MODULE CURRENT-MODULE))
     (CL:SETQ DISTANCE
      (CL:+ (EUCLIDEAN-DISTANCE (%NN-HIDDEN PROBE) (%NN-HIDDEN CASE)) 0.0d0))
     (CL:WHEN *PRINT-CASE-DISTANCES*
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "  Distance from "
       (LAST (%QUERY CASE)) ": " DISTANCE EOL))
     (CL:SETF (%TEMP CASE) DISTANCE)
     (CL:WHEN
      (CL:< DISTANCE
       (%WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY DISTANCES)) FARTHEST)))
      (CL:LET
       ((SELF (%THE-ARRAY DISTANCES)) (VALUE (WRAP-FLOAT DISTANCE))
        (POSITION FARTHEST))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:LET ((SELF (%THE-ARRAY NEIGHBORS)) (VALUE CASE) (POSITION FARTHEST))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ FARTHEST 0)
      (CL:LET* ((J NULL-INTEGER) (ITER-002 1) (UPPER-BOUND-001 (CL:1- K)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-002 UPPER-BOUND-001))
       (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-001) DO (CL:SETQ J ITER-002)
        (CL:WHEN
         (CL:>
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY DISTANCES)) J))
          (%WRAPPER-VALUE
           (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY DISTANCES))
            FARTHEST)))
         (CL:SETQ FARTHEST J))
        (CL:SETQ ITER-002 (CL:1+ ITER-002)))))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-003 0) (UPPER-BOUND-002 (CL:1- K))
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-003 UPPER-BOUND-002))
    (CL:LOOP WHILE (CL:<= ITER-003 UPPER-BOUND-002) DO (CL:SETQ I ITER-003)
     (CL:WHEN
      (CL:NOT
       (CL:EQ (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY NEIGHBORS)) I)
        NULL))
      (CL:IF (CL:EQ COLLECT-000 NULL)
       (CL:PROGN
        (CL:SETQ COLLECT-000
         (CONS (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY NEIGHBORS)) I)
          NIL))
        (CL:IF (CL:EQ (%THE-CONS-LIST RESULT) NIL)
         (CL:SETF (%THE-CONS-LIST RESULT) COLLECT-000)
         (ADD-CONS-TO-END-OF-CONS-LIST (%THE-CONS-LIST RESULT) COLLECT-000)))
       (CL:PROGN
        (CL:SETF (%%REST COLLECT-000)
         (CONS (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY NEIGHBORS)) I)
          NIL))
        (CL:SETQ COLLECT-000 (%%REST COLLECT-000)))))
     (CL:SETQ ITER-003 (CL:1+ ITER-003))))
   RESULT))

;;; (DEFUN SWAP-IN-NEW-NETWORKS ...)

(CL:DEFUN %SWAP-IN-NEW-NETWORKS (OLD-NETS NEW-NETS)
  (CL:LET*
   ((OLD-NET NULL) (ITER-000 (%THE-CONS-LIST OLD-NETS)) (NEW-NET NULL)
    (ITER-001 (%THE-CONS-LIST NEW-NETS)))
   (CL:LOOP WHILE
    (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-001 NIL))) DO
    (CL:SETQ OLD-NET (%%VALUE ITER-000)) (CL:SETQ NEW-NET (%%VALUE ITER-001))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%PROPOSITION OLD-NET))
     SYM-NEURAL-NETWORK-LOGIC-NEURAL-NETWORK NEW-NET NULL)
    (CL:SETF (%PROPOSITION NEW-NET) (%PROPOSITION OLD-NET))
    (CL:SETQ ITER-000 (%%REST ITER-000)) (CL:SETQ ITER-001 (%%REST ITER-001))))
  (CL:SETQ *MASTER-NEURAL-NETWORK-LIST* NEW-NETS))

(CL:DEFMACRO SWAP-IN-NEW-NETWORKS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SWAP-IN-NEW-NETWORKS|)) (CL:MACRO-FUNCTION (CL:QUOTE SWAP-IN-NEW-NETWORKS)))

;;; (DEFUN SWAP-IN-NETWORK-FILE ...)

(CL:DEFUN %SWAP-IN-NETWORK-FILE (FILE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  #+MCL
  (CL:CHECK-TYPE FILE CL:SIMPLE-STRING)
  (CL:LET* ((NEW-NETS (%LOAD-NEURAL-NETWORK-FILE FILE)))
   (CL:LET*
    ((OLD-NET NULL) (ITER-000 (%THE-CONS-LIST *MASTER-NEURAL-NETWORK-LIST*))
     (NEW-NET NULL) (ITER-001 (%THE-CONS-LIST NEW-NETS)))
    (CL:LOOP WHILE
     (CL:AND (CL:NOT (CL:EQ ITER-000 NIL)) (CL:NOT (CL:EQ ITER-001 NIL))) DO
     (CL:SETQ OLD-NET (%%VALUE ITER-000)) (CL:SETQ NEW-NET (%%VALUE ITER-001))
     (CL:WHEN
      (CL:OR
       (CL:NOT (CL:= (LENGTH (%INPUT OLD-NET)) (LENGTH (%INPUT NEW-NET))))
       (CL:NOT (CL:= (LENGTH (%HIDDEN OLD-NET)) (LENGTH (%HIDDEN NEW-NET)))))
      (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT)
       "Error: network file does not match master list" EOL)
      (CL:RETURN-FROM %SWAP-IN-NETWORK-FILE))
     (CL:SETQ ITER-000 (%%REST ITER-000))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (%SWAP-IN-NEW-NETWORKS *MASTER-NEURAL-NETWORK-LIST* NEW-NETS)))

(CL:DEFUN SWAP-IN-NETWORK-FILE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SWAP-IN-NETWORK-FILE (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SWAP-IN-NETWORK-FILE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SWAP-IN-NETWORK-FILE|)) (CL:MACRO-FUNCTION (CL:QUOTE SWAP-IN-NETWORK-FILE)))

;;; (DEFUN (LOAD-NEURAL-NETWORK-FILE (LIST OF PROPOSITION-NEURAL-NETWORK)) ...)

(CL:DEFUN %LOAD-NEURAL-NETWORK-FILE (FILE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  #+MCL
  (CL:CHECK-TYPE FILE CL:SIMPLE-STRING)
  (CL:LET*
   ((NETS (NEW-LIST)) (STREAM (NEW-INPUT-FILE-STREAM FILE)) (NUM-HIDDEN 0)
    (PROP NIL) (TEMP NULL) (NUM-IN 0) (NET NULL))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NUM-HIDDEN NUM-IN))
   (CL:LOOP
    (CL:WHEN
     (CL:NOT
      (CL:EQ (READ-S-EXPRESSION STREAM) SYM-NEURAL-NETWORK-LOGIC-DEFNETWORK))
     (CL:RETURN-FROM %LOAD-NEURAL-NETWORK-FILE (REVERSE NETS)))
    (CL:SETQ PROP (READ-S-EXPRESSION STREAM))
    (CL:SETQ NUM-IN (%WRAPPER-VALUE (READ-S-EXPRESSION STREAM)))
    (CL:SETQ NUM-HIDDEN (%WRAPPER-VALUE (READ-S-EXPRESSION STREAM)))
    (CL:SETQ NET (ALLOCATE-NEURAL-NETWORK NUM-IN NUM-HIDDEN))
    (CL:LET* ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NUM-IN)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
     (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
      (CL:LET*
       ((H NULL-INTEGER) (ITER-001 0) (UPPER-BOUND-001 (CL:1- NUM-HIDDEN)))
       (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-001 UPPER-BOUND-001))
       (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ H ITER-001)
        (CL:SETQ TEMP (READ-S-EXPRESSION STREAM))
        (CL:WHEN (EQL? TEMP ZERO-WRAPPER) (CL:SETQ TEMP (WRAP-FLOAT 0.0d0)))
        (CL:LET
         ((SELF (%THE-ARRAY (%IH NET))) (VALUE TEMP)
          (POSITION (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) H)))
         (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
          (CL:TYPE CL:FIXNUM POSITION))
         (CL:SETF (CL:AREF SELF POSITION) VALUE))
        (CL:SETQ ITER-001 (CL:1+ ITER-001))))
      (CL:SETQ ITER-000 (CL:1+ ITER-000))))
    (CL:LET*
     ((H NULL-INTEGER) (ITER-002 0) (UPPER-BOUND-002 (CL:1- NUM-HIDDEN)))
     (CL:DECLARE (CL:TYPE CL:FIXNUM H ITER-002 UPPER-BOUND-002))
     (CL:LOOP WHILE (CL:<= ITER-002 UPPER-BOUND-002) DO (CL:SETQ H ITER-002)
      (CL:LET
       ((SELF (%THE-ARRAY (%HO NET))) (VALUE (READ-S-EXPRESSION STREAM))
        (POSITION H))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
        (CL:TYPE CL:FIXNUM POSITION))
       (CL:SETF (CL:AREF SELF POSITION) VALUE))
      (CL:SETQ ITER-002 (CL:1+ ITER-002))))
    (PUSH NETS NET))))

(CL:DEFUN LOAD-NEURAL-NETWORK-FILE-EVALUATOR-WRAPPER (ARGUMENTS)
  (%LOAD-NEURAL-NETWORK-FILE (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO LOAD-NEURAL-NETWORK-FILE (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/LOAD-NEURAL-NETWORK-FILE|)) (CL:MACRO-FUNCTION (CL:QUOTE LOAD-NEURAL-NETWORK-FILE)))

;;; (DEFUN SAVE-ALL-NEURAL-NETWORKS ...)

(CL:DEFUN %SAVE-ALL-NEURAL-NETWORKS (FILE)
  "Save all neural networks to `file' (if `file' is non-NULL).
If networks are saved periodically (see `set-save-network-cycle') this file
name will be used to perform periodic saves."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  #+MCL
  (CL:CHECK-TYPE FILE CL:SIMPLE-STRING)
  (CL:SETQ *SAVE-NETWORK-FILE* FILE)
  (CL:WHEN (CL:NOT (CL:EQ FILE STELLA::NULL-STRING))
   (%%PRINT-STREAM (%NATIVE-STREAM STANDARD-OUTPUT) "Saving networks" EOL)
   (CL:LET* ((FPTR (NEW-OUTPUT-FILE-STREAM FILE)))
    (CL:LET*
     ((NET NULL) (ITER-000 (%THE-CONS-LIST *MASTER-NEURAL-NETWORK-LIST*)))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ NET (%%VALUE ITER-000)) (PRINT-NEURAL-NETWORK NET FPTR)
      (%%PRINT-STREAM (%NATIVE-STREAM FPTR) EOL)
      (CL:SETQ ITER-000 (%%REST ITER-000))))
    (FREE FPTR))))

(CL:DEFUN SAVE-ALL-NEURAL-NETWORKS-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SAVE-ALL-NEURAL-NETWORKS (%WRAPPER-VALUE (%%VALUE ARGUMENTS))))

(CL:DEFMACRO SAVE-ALL-NEURAL-NETWORKS (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  "Save all neural networks to `file' (if `file' is non-NULL).
If networks are saved periodically (see `set-save-network-cycle') this file
name will be used to perform periodic saves."
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SAVE-ALL-NEURAL-NETWORKS|)) (CL:MACRO-FUNCTION (CL:QUOTE SAVE-ALL-NEURAL-NETWORKS)))

;;; (DEFUN SAVE-NEURAL-NETWORK ...)

(CL:DEFUN %SAVE-NEURAL-NETWORK (NET FILE)
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING FILE))
  #+MCL
  (CL:CHECK-TYPE FILE CL:SIMPLE-STRING)
  (CL:LET* ((FPTR (NEW-OUTPUT-FILE-STREAM FILE)))
   (PRINT-NEURAL-NETWORK NET FPTR) (FREE FPTR)))

(CL:DEFUN SAVE-NEURAL-NETWORK-EVALUATOR-WRAPPER (ARGUMENTS)
  (%SAVE-NEURAL-NETWORK (%%VALUE ARGUMENTS)
   (%WRAPPER-VALUE (%%VALUE (%%REST ARGUMENTS)))))

(CL:DEFMACRO SAVE-NEURAL-NETWORK (CL:&WHOLE EXPRESSION CL:&REST IGNORE)
  (CL:DECLARE (CL:IGNORE IGNORE))
  (CL:LET ((*IGNORETRANSLATIONERRORS?* FALSE))
   (CL-INCREMENTALLY-TRANSLATE EXPRESSION)))

(CL:SETF (CL:MACRO-FUNCTION (CL:QUOTE |/LOGIC/SAVE-NEURAL-NETWORK|)) (CL:MACRO-FUNCTION (CL:QUOTE SAVE-NEURAL-NETWORK)))

;;; (DEFUN PRINT-NEURAL-NETWORK ...)

(CL:DEFUN PRINT-NEURAL-NETWORK (NET STREAM)
  (%%PRINT-STREAM (%NATIVE-STREAM STREAM) "defnetwork " EOL)
  (PRINT-PROPOSITION (%PROPOSITION NET) STREAM CL:NIL)
  (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL)
  (%%PRINT-STREAM (%NATIVE-STREAM STREAM) (LENGTH (%INPUT NET)) " "
   (LENGTH (%HIDDEN NET)) EOL)
  (CL:LET*
   ((I NULL-INTEGER) (ITER-000 0)
    (UPPER-BOUND-000 (CL:1- (LENGTH (%INPUT NET)))))
   (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
   (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
    (CL:LET*
     ((J NULL-INTEGER) (ITER-001 0)
      (UPPER-BOUND-001 (CL:1- (LENGTH (%HIDDEN NET)))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM J ITER-001 UPPER-BOUND-001))
     (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO (CL:SETQ J ITER-001)
      (CL:LET*
       ((VALUE
         (%WRAPPER-VALUE
          (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%IH NET)))
           (CL:THE CL:FIXNUM (CL:+ (CL:* I (%NOF-COLUMNS (%IH NET))) J))))))
       (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE))
       (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " " VALUE))
      (CL:SETQ ITER-001 (CL:1+ ITER-001))))
    (CL:SETQ ITER-000 (CL:1+ ITER-000))))
  (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL)
  (CL:LET*
   ((NUM NULL) (VECTOR-000 (%HO NET)) (INDEX-000 0)
    (LENGTH-000 (LENGTH VECTOR-000)))
   (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
   (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
    (CL:SETQ NUM
     (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000)) INDEX-000))
    (CL:LET* ((VALUE (%WRAPPER-VALUE NUM)))
     (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM) " " VALUE))
    (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
  (%%PRINT-STREAM (%NATIVE-STREAM STREAM) EOL))

;;; (DEFUN (CREATE-HIDDEN-SIGNATURE WEIGHT-VECTOR) ...)

(CL:DEFUN CREATE-HIDDEN-SIGNATURE (CONS-QUERY)
  (CL:LET*
   ((QUERY (MAKE-QUERY NIL (COPY-CONS-TREE CONS-QUERY) NIL NIL)) (PMF NULL)
    (NET NULL) (RESULT NULL))
   (INSERT-AT (%OPTIONS QUERY) KWD-NEURAL-NETWORK-MATCH-MODE
    KWD-NEURAL-NETWORK-NN)
   (INSERT-AT (%OPTIONS QUERY) KWD-NEURAL-NETWORK-MAXIMIZE-SCORE?
    TRUE-WRAPPER)
   (CALL-ASK-PARTIAL QUERY)
   (CL:SETQ PMF
    (%CHILD (%CHILD (%PARTIAL-MATCH-FRAME (%BASE-CONTROL-FRAME QUERY)))))
   (CL:SETQ NET
    (DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS (%PROPOSITION (%CONTROL-FRAME PMF)))
     SYM-NEURAL-NETWORK-LOGIC-NEURAL-NETWORK NULL))
   (CL:SETQ RESULT (NEW-VECTOR (LENGTH (%HIDDEN NET))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (LENGTH (%HIDDEN NET)))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%THE-ARRAY RESULT))
       (VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY (%HIDDEN NET))) I))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   RESULT))

;;; (DEFCLASS MULTI-DIMENSIONAL-ARRAY ...)

(CL:DEFCLASS MULTI-DIMENSIONAL-ARRAY (ABSTRACT-COLLECTION)
  ())

(CL:DEFUN NEW-MULTI-DIMENSIONAL-ARRAY ()
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE MULTI-DIMENSIONAL-ARRAY))) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF MULTI-DIMENSIONAL-ARRAY))
  SGT-NEURAL-NETWORK-LOGIC-MULTI-DIMENSIONAL-ARRAY)

;;; (DEFCLASS 2_D_ARRAY ...)

(CL:DEFCLASS 2_D_ARRAY (MULTI-DIMENSIONAL-ARRAY)
  ((NOF-ROWS :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %NOF-ROWS)
   (NOF-COLUMNS :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %NOF-COLUMNS)
   (THE-ARRAY :TYPE CL:SIMPLE-VECTOR :INITFORM STELLA::NULL-NATIVE-VECTOR
    :ALLOCATION :INSTANCE :ACCESSOR %THE-ARRAY))
  (:DOCUMENTATION "Two-dimensional arrays with elements of type OBJECT."))

(CL:DEFUN NEW-2_D_ARRAY (NOF-ROWS NOF-COLUMNS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NOF-ROWS NOF-COLUMNS))
  #+MCL
  (CL:CHECK-TYPE NOF-ROWS CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NOF-COLUMNS CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE 2_D_ARRAY)))
   (CL:SETF (%NOF-ROWS SELF) NOF-ROWS)
   (CL:SETF (%NOF-COLUMNS SELF) NOF-COLUMNS)
   (CL:SETF (%THE-ARRAY SELF) STELLA::NULL-NATIVE-VECTOR)
   (INITIALIZE-2_D_ARRAY SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF 2_D_ARRAY))
  SGT-NEURAL-NETWORK-LOGIC-2_D_ARRAY)

(CL:DEFUN ACCESS-2_D_ARRAY-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-NOF-ROWS)
    (CL:IF SETVALUE? (CL:SETF (%NOF-ROWS SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%NOF-ROWS SELF)))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-NOF-COLUMNS)
    (CL:IF SETVALUE? (CL:SETF (%NOF-COLUMNS SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%NOF-COLUMNS SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF 2_D_ARRAY) STREAM)
  (PRINT-ARRAY SELF STREAM))

;;; (DEFUN INITIALIZE-2_D_ARRAY ...)

(CL:DEFUN INITIALIZE-2_D_ARRAY (SELF)
  (CL:LET* ((VECTOR (NEW-VECTOR (CL:* (%NOF-ROWS SELF) (%NOF-COLUMNS SELF)))))
   (CL:SETF (%THE-ARRAY SELF) (%THE-ARRAY VECTOR))
   (CL:SETF (%THE-ARRAY VECTOR) STELLA::NULL-NATIVE-VECTOR)))

;;; (DEFMETHOD (2_D_ELEMENT (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD 2_D_ELEMENT ((ARRAY 2_D_ARRAY) ROW COLUMN)
  "Return the element of `array' at position [`row', `column']."
  (CL:DECLARE (CL:TYPE CL:FIXNUM ROW COLUMN))
  #+MCL
  (CL:CHECK-TYPE ROW CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE COLUMN CL:FIXNUM)
  (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARRAY))
   (CL:THE CL:FIXNUM (CL:+ (CL:* ROW (%NOF-COLUMNS ARRAY)) COLUMN))))

;;; (DEFMETHOD (2_D_ELEMENT-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD 2_D_ELEMENT-SETTER ((ARRAY 2_D_ARRAY) VALUE ROW COLUMN)
  "Set the element of `array' at position [`row', `column']
to `value' and return the result."
  (CL:DECLARE (CL:TYPE CL:FIXNUM ROW COLUMN))
  #+MCL
  (CL:CHECK-TYPE ROW CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE COLUMN CL:FIXNUM)
  (CL:LET
   ((SELF (%THE-ARRAY ARRAY)) (VALUE VALUE)
    (POSITION (CL:+ (CL:* ROW (%NOF-COLUMNS ARRAY)) COLUMN)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF) (CL:TYPE CL:FIXNUM POSITION))
   (CL:SETF (CL:AREF SELF POSITION) VALUE)))

;;; (DEFUN (CREATE-2_D_ARRAY 2_D_ARRAY) ...)

(CL:DEFUN CREATE-2_D_ARRAY (NOF-ROWS NOF-COLUMNS CL:&REST VALUES)
  "Create a two-dimensional array with `nof-rows' rows and
`nof-columns' columns, and initialize it in row-major-order from `values'.
Missing values will be padded with NULL, extraneous values will be ignored."
  (CL:DECLARE (CL:TYPE CL:FIXNUM NOF-ROWS NOF-COLUMNS))
  #+MCL
  (CL:CHECK-TYPE NOF-ROWS CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NOF-COLUMNS CL:FIXNUM)
  (CL:LET*
   ((ARRAY (NEW-2_D_ARRAY NOF-ROWS NOF-COLUMNS))
    (NATIVEARRAY (%THE-ARRAY ARRAY)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR NATIVEARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (CL:* NOF-ROWS NOF-COLUMNS))) (VALUE NULL)
     (ITER-001 VALUES))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:AND (CL:<= ITER-000 UPPER-BOUND-000) ITER-001) DO
     (CL:SETQ I ITER-000) (CL:SETQ VALUE (CL:POP ITER-001))
     (CL:LET ((SELF NATIVEARRAY) (VALUE VALUE) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   ARRAY))

;;; (DEFMETHOD FILL-ARRAY ...)

(CL:DEFMETHOD FILL-ARRAY ((SELF 2_D_ARRAY) CL:&REST VALUES)
  "Fill the two-dimensional array `self' in row-major-order
from `values'.  Missing values will retain their old values, extraneous values
will be ignored."
  (CL:LET* ((NATIVEARRAY (%THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR NATIVEARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (CL:* (%NOF-ROWS SELF) (%NOF-COLUMNS SELF))))
     (VALUE NULL) (ITER-001 VALUES))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:AND (CL:<= ITER-000 UPPER-BOUND-000) ITER-001) DO
     (CL:SETQ I ITER-000) (CL:SETQ VALUE (CL:POP ITER-001))
     (CL:LET ((SELF NATIVEARRAY) (VALUE VALUE) (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))))

;;; (DEFMETHOD PRINT-ARRAY ...)

(CL:DEFMETHOD PRINT-ARRAY ((SELF 2_D_ARRAY) STREAM)
  "Print the array `self' to `stream'."
  (CL:LET*
   ((NOF-ROWS (%NOF-ROWS SELF)) (NOF-COLUMNS (%NOF-COLUMNS SELF)) (LIMIT 9))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOF-ROWS NOF-COLUMNS LIMIT))
   (%%PRINT-STREAM STREAM "|i|[")
   (CL:LET*
    ((ROW NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NOF-ROWS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ROW ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ ROW ITER-000)
     (%%PRINT-STREAM STREAM "[")
     (CL:LET*
      ((COLUMN NULL-INTEGER) (ITER-001 0)
       (UPPER-BOUND-001 (CL:1- NOF-COLUMNS)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM COLUMN ITER-001 UPPER-BOUND-001))
      (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
       (CL:SETQ COLUMN ITER-001)
       (%%PRINT-STREAM STREAM
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF))
         (CL:THE CL:FIXNUM (CL:+ (CL:* ROW (%NOF-COLUMNS SELF)) COLUMN))))
       (CL:COND
        ((CL:> COLUMN LIMIT) (%%PRINT-STREAM STREAM " ...]") (CL:RETURN))
        ((CL:< COLUMN (CL:1- NOF-COLUMNS)) (%%PRINT-STREAM STREAM " "))
        (CL:T (%%PRINT-STREAM STREAM "]")))
       (CL:SETQ ITER-001 (CL:1+ ITER-001))))
     (CL:COND ((CL:> ROW LIMIT) (%%PRINT-STREAM STREAM " ...]") (CL:RETURN))
      ((CL:< ROW (CL:1- NOF-ROWS)) (%%PRINT-STREAM STREAM " "))
      (CL:T (%%PRINT-STREAM STREAM "]")))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))))

;;; (DEFCLASS FLOAT-VECTOR ...)

(CL:DEFCLASS FLOAT-VECTOR (ABSTRACT-COLLECTION)
  ((ARRAY-SIZE :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %ARRAY-SIZE)
   (THE-ARRAY :TYPE CL:SIMPLE-VECTOR :INITFORM STELLA::NULL-NATIVE-VECTOR
    :ALLOCATION :INSTANCE :ACCESSOR %THE-ARRAY)))

(CL:DEFUN NEW-FLOAT-VECTOR (ARRAY-SIZE)
  (CL:DECLARE (CL:TYPE CL:FIXNUM ARRAY-SIZE))
  #+MCL
  (CL:CHECK-TYPE ARRAY-SIZE CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE FLOAT-VECTOR)))
   (CL:SETF (%ARRAY-SIZE SELF) ARRAY-SIZE)
   (CL:SETF (%THE-ARRAY SELF) STELLA::NULL-NATIVE-VECTOR)
   (INITIALIZE-FLOAT-VECTOR SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF FLOAT-VECTOR))
  SGT-NEURAL-NETWORK-LOGIC-FLOAT-VECTOR)

(CL:DEFUN ACCESS-FLOAT-VECTOR-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-STELLA-ARRAY-SIZE)
    (CL:IF SETVALUE? (CL:SETF (%ARRAY-SIZE SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%ARRAY-SIZE SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF FLOAT-VECTOR) STREAM)
  (PRINT-VECTOR SELF STREAM))

;;; (DEFUN INITIALIZE-FLOAT-VECTOR ...)

(CL:DEFUN INITIALIZE-FLOAT-VECTOR (SELF)
  (CL:LET* ((VECTOR (NEW-VECTOR (%ARRAY-SIZE SELF))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- (LENGTH VECTOR))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%THE-ARRAY VECTOR)) (VALUE (NEW-FLOAT-WRAPPER NULL-FLOAT))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETF (%THE-ARRAY SELF) (%THE-ARRAY VECTOR))
   (CL:SETF (%THE-ARRAY VECTOR) STELLA::NULL-NATIVE-VECTOR)))

;;; (DEFUN (CREATE-FLOAT-VECTOR FLOAT-VECTOR) ...)

(CL:DEFUN CREATE-FLOAT-VECTOR (CL:&REST VALUES)
  "Return a vector containing 'values', in order."
  (CL:LET* ((VECTOR (NEW-FLOAT-VECTOR (CL:LENGTH VALUES))))
   (CL:LET* ((V NULL-FLOAT) (ITER-000 VALUES) (I NULL-INTEGER) (ITER-001 0))
    (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT V) (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE ITER-000 DO (CL:SETQ V (CL:POP ITER-000))
     (CL:SETQ I ITER-001)
     (CL:SETF
      (%WRAPPER-VALUE
       (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR)) I))
      V)
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   VECTOR))

;;; (DEFMETHOD PRINT-VECTOR ...)

(CL:DEFMETHOD PRINT-VECTOR ((SELF FLOAT-VECTOR) STREAM)
  (CL:IF (CL:= (%ARRAY-SIZE SELF) 0) (%%PRINT-STREAM STREAM "|i|[]")
   (CL:LET* ((I 0) (LIMIT 9)) (CL:DECLARE (CL:TYPE CL:FIXNUM I LIMIT))
    (%%PRINT-STREAM STREAM "|i|[")
    (CL:LET*
     ((ELEMENT NULL-FLOAT) (VECTOR-000 SELF) (INDEX-000 0)
      (LENGTH-000 (%ARRAY-SIZE VECTOR-000)))
     (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT ELEMENT)
      (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
     (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
      (CL:SETQ ELEMENT
       (%WRAPPER-VALUE
        (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY VECTOR-000))
         INDEX-000)))
      (%%PRINT-STREAM STREAM ELEMENT) (CL:SETQ I (CL:1+ I))
      (CL:WHEN (CL:> I LIMIT) (CL:RETURN))
      (CL:WHEN (CL:< I (%ARRAY-SIZE SELF)) (%%PRINT-STREAM STREAM " "))
      (CL:SETQ INDEX-000 (CL:1+ INDEX-000))))
    (CL:IF (CL:OR (CL:<= I LIMIT) (CL:= I (%ARRAY-SIZE SELF)))
     (%%PRINT-STREAM STREAM "]") (%%PRINT-STREAM STREAM " ...]")))))

;;; (DEFMETHOD (EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD EMPTY? ((SELF FLOAT-VECTOR))
  "Return TRUE if 'self' has length 0."
  (CL:= (%ARRAY-SIZE SELF) 0))

;;; (DEFMETHOD (NON-EMPTY? BOOLEAN) ...)

(CL:DEFMETHOD NON-EMPTY? ((SELF FLOAT-VECTOR))
  "Return TRUE if 'self' has length > 0."
  (> (%ARRAY-SIZE SELF) 0))

;;; (DEFMETHOD (NTH FLOAT) ...)

(CL:DEFMETHOD NTH ((SELF FLOAT-VECTOR) POSITION)
  (CL:DECLARE (CL:TYPE CL:FIXNUM POSITION))
  #+MCL
  (CL:CHECK-TYPE POSITION CL:FIXNUM)
  (%WRAPPER-VALUE
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) POSITION)))

;;; (DEFMETHOD (NTH-SETTER FLOAT) ...)

(CL:DEFMETHOD NTH-SETTER ((SELF FLOAT-VECTOR) VALUE POSITION)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE) (CL:TYPE CL:FIXNUM POSITION))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE POSITION CL:FIXNUM)
  (CL:SETF
   (%WRAPPER-VALUE
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF)) POSITION))
   VALUE))

;;; (DEFMETHOD (LENGTH INTEGER) ...)

(CL:DEFMETHOD LENGTH ((SELF FLOAT-VECTOR))
  (%ARRAY-SIZE SELF))

;;; (DEFMETHOD (MEMBER? BOOLEAN) ...)

(CL:DEFMETHOD MEMBER? ((SELF FLOAT-VECTOR) OBJECT)
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT OBJECT))
  #+MCL
  (CL:CHECK-TYPE OBJECT CL:DOUBLE-FLOAT)
  (CL:LET* ((ARRAY (%THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR ARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (%ARRAY-SIZE SELF))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:WHEN (CL:= (%WRAPPER-VALUE (CL:AREF ARRAY I)) OBJECT)
      (CL:RETURN-FROM MEMBER? CL:T))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   CL:NIL))

;;; (DEFCLASS 2_D_FLOAT-ARRAY ...)

(CL:DEFCLASS 2_D_FLOAT-ARRAY (MULTI-DIMENSIONAL-ARRAY)
  ((NOF-ROWS :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %NOF-ROWS)
   (NOF-COLUMNS :TYPE CL:FIXNUM :INITFORM NULL-INTEGER :ALLOCATION :INSTANCE
    :ACCESSOR %NOF-COLUMNS)
   (THE-ARRAY :TYPE CL:SIMPLE-VECTOR :INITFORM STELLA::NULL-NATIVE-VECTOR
    :ALLOCATION :INSTANCE :ACCESSOR %THE-ARRAY))
  (:DOCUMENTATION "Two-dimensional arrays with elements of type FLOAT."))

(CL:DEFUN NEW-2_D_FLOAT-ARRAY (NOF-ROWS NOF-COLUMNS)
  (CL:DECLARE (CL:TYPE CL:FIXNUM NOF-ROWS NOF-COLUMNS))
  #+MCL
  (CL:CHECK-TYPE NOF-ROWS CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NOF-COLUMNS CL:FIXNUM)
  (CL:LET* ((SELF NULL))
   (CL:SETQ SELF (CL:MAKE-INSTANCE (CL:QUOTE 2_D_FLOAT-ARRAY)))
   (CL:SETF (%NOF-ROWS SELF) NOF-ROWS)
   (CL:SETF (%NOF-COLUMNS SELF) NOF-COLUMNS)
   (CL:SETF (%THE-ARRAY SELF) STELLA::NULL-NATIVE-VECTOR)
   (INITIALIZE-2_D_FLOAT-ARRAY SELF) SELF))

(CL:DEFMETHOD PRIMARY-TYPE ((SELF 2_D_FLOAT-ARRAY))
  SGT-NEURAL-NETWORK-LOGIC-2_D_FLOAT-ARRAY)

(CL:DEFUN ACCESS-2_D_FLOAT-ARRAY-SLOT-VALUE (SELF SLOTNAME VALUE SETVALUE?)
  (CL:COND
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-NOF-ROWS)
    (CL:IF SETVALUE? (CL:SETF (%NOF-ROWS SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%NOF-ROWS SELF)))))
   ((CL:EQ SLOTNAME SYM-NEURAL-NETWORK-LOGIC-NOF-COLUMNS)
    (CL:IF SETVALUE? (CL:SETF (%NOF-COLUMNS SELF) (%WRAPPER-VALUE VALUE))
     (CL:SETQ VALUE (WRAP-INTEGER (%NOF-COLUMNS SELF)))))
   (CL:T
    (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
     (%%PRINT-STREAM (%NATIVE-STREAM STREAM-000) "`" SLOTNAME
      "' is not a valid case option")
     (CL:ERROR (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000))))))
  VALUE)

(CL:DEFMETHOD PRINT-OBJECT ((SELF 2_D_FLOAT-ARRAY) STREAM)
  (PRINT-ARRAY SELF STREAM))

;;; (DEFUN INITIALIZE-2_D_FLOAT-ARRAY ...)

(CL:DEFUN INITIALIZE-2_D_FLOAT-ARRAY (SELF)
  (CL:LET* ((VECTOR (NEW-VECTOR (CL:* (%NOF-ROWS SELF) (%NOF-COLUMNS SELF)))))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- (LENGTH VECTOR))))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ I ITER-000)
     (CL:LET
      ((SELF (%THE-ARRAY VECTOR)) (VALUE (NEW-FLOAT-WRAPPER NULL-FLOAT))
       (POSITION I))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR SELF)
       (CL:TYPE CL:FIXNUM POSITION))
      (CL:SETF (CL:AREF SELF POSITION) VALUE))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:SETF (%THE-ARRAY SELF) (%THE-ARRAY VECTOR))
   (CL:SETF (%THE-ARRAY VECTOR) STELLA::NULL-NATIVE-VECTOR)))

;;; (DEFMETHOD (2_D_ELEMENT FLOAT) ...)

(CL:DEFMETHOD 2_D_ELEMENT ((ARRAY 2_D_FLOAT-ARRAY) ROW COLUMN)
  "Return the element of `array' at position [`row', `column']."
  (CL:DECLARE (CL:TYPE CL:FIXNUM ROW COLUMN))
  #+MCL
  (CL:CHECK-TYPE ROW CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE COLUMN CL:FIXNUM)
  (%WRAPPER-VALUE
   (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARRAY))
    (CL:THE CL:FIXNUM (CL:+ (CL:* ROW (%NOF-COLUMNS ARRAY)) COLUMN)))))

;;; (DEFMETHOD (2_D_ELEMENT-SETTER (LIKE (ANY-VALUE SELF))) ...)

(CL:DEFMETHOD 2_D_ELEMENT-SETTER ((ARRAY 2_D_FLOAT-ARRAY) VALUE ROW COLUMN)
  "Set the element of `array' at position [`row', `column']
to `value' and return the result."
  (CL:DECLARE (CL:TYPE CL:DOUBLE-FLOAT VALUE) (CL:TYPE CL:FIXNUM ROW COLUMN))
  #+MCL
  (CL:CHECK-TYPE VALUE CL:DOUBLE-FLOAT)
  #+MCL
  (CL:CHECK-TYPE ROW CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE COLUMN CL:FIXNUM)
  (CL:SETF
   (%WRAPPER-VALUE
    (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY ARRAY))
     (CL:THE CL:FIXNUM (CL:+ (CL:* ROW (%NOF-COLUMNS ARRAY)) COLUMN))))
   VALUE))

;;; (DEFUN (CREATE-2_D_FLOAT-ARRAY 2_D_FLOAT-ARRAY) ...)

(CL:DEFUN CREATE-2_D_FLOAT-ARRAY (NOF-ROWS NOF-COLUMNS CL:&REST VALUES)
  "Create a two-dimensional array with `nof-rows' rows and
`nof-columns' columns, and initialize it in row-major-order from `values'.
Missing values will be padded with NULL, extraneous values will be ignored."
  (CL:DECLARE (CL:TYPE CL:FIXNUM NOF-ROWS NOF-COLUMNS))
  #+MCL
  (CL:CHECK-TYPE NOF-ROWS CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE NOF-COLUMNS CL:FIXNUM)
  (CL:LET*
   ((ARRAY (NEW-2_D_FLOAT-ARRAY NOF-ROWS NOF-COLUMNS))
    (NATIVEARRAY (%THE-ARRAY ARRAY)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR NATIVEARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (CL:* NOF-ROWS NOF-COLUMNS))) (VALUE NULL-FLOAT)
     (ITER-001 VALUES))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000)
     (CL:TYPE CL:DOUBLE-FLOAT VALUE))
    (CL:LOOP WHILE (CL:AND (CL:<= ITER-000 UPPER-BOUND-000) ITER-001) DO
     (CL:SETQ I ITER-000) (CL:SETQ VALUE (CL:POP ITER-001))
     (CL:SETF (%WRAPPER-VALUE (CL:AREF NATIVEARRAY I)) VALUE)
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   ARRAY))

;;; (DEFMETHOD FILL-ARRAY ...)

(CL:DEFMETHOD FILL-ARRAY ((SELF 2_D_FLOAT-ARRAY) CL:&REST VALUES)
  "Fill the two-dimensional array `self' in row-major-order
from `values'.  Missing values will retain their old values, extraneous values
will be ignored."
  (CL:LET* ((NATIVEARRAY (%THE-ARRAY SELF)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-VECTOR NATIVEARRAY))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (CL:1- (CL:* (%NOF-ROWS SELF) (%NOF-COLUMNS SELF))))
     (VALUE NULL-FLOAT) (ITER-001 VALUES))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000)
     (CL:TYPE CL:DOUBLE-FLOAT VALUE))
    (CL:LOOP WHILE (CL:AND (CL:<= ITER-000 UPPER-BOUND-000) ITER-001) DO
     (CL:SETQ I ITER-000) (CL:SETQ VALUE (CL:POP ITER-001))
     (CL:SETF (%WRAPPER-VALUE (CL:AREF NATIVEARRAY I)) VALUE)
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))))

;;; (DEFMETHOD PRINT-ARRAY ...)

(CL:DEFMETHOD PRINT-ARRAY ((SELF 2_D_FLOAT-ARRAY) STREAM)
  "Print the array `self' to `stream'."
  (CL:LET*
   ((NOF-ROWS (%NOF-ROWS SELF)) (NOF-COLUMNS (%NOF-COLUMNS SELF)) (LIMIT 9))
   (CL:DECLARE (CL:TYPE CL:FIXNUM NOF-ROWS NOF-COLUMNS LIMIT))
   (%%PRINT-STREAM STREAM "|i|[")
   (CL:LET*
    ((ROW NULL-INTEGER) (ITER-000 0) (UPPER-BOUND-000 (CL:1- NOF-ROWS)))
    (CL:DECLARE (CL:TYPE CL:FIXNUM ROW ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE (CL:<= ITER-000 UPPER-BOUND-000) DO (CL:SETQ ROW ITER-000)
     (%%PRINT-STREAM STREAM "[")
     (CL:LET*
      ((COLUMN NULL-INTEGER) (ITER-001 0)
       (UPPER-BOUND-001 (CL:1- NOF-COLUMNS)))
      (CL:DECLARE (CL:TYPE CL:FIXNUM COLUMN ITER-001 UPPER-BOUND-001))
      (CL:LOOP WHILE (CL:<= ITER-001 UPPER-BOUND-001) DO
       (CL:SETQ COLUMN ITER-001)
       (%%PRINT-STREAM STREAM
        (%WRAPPER-VALUE
         (CL:AREF (CL:THE CL:SIMPLE-VECTOR (%THE-ARRAY SELF))
          (CL:THE CL:FIXNUM (CL:+ (CL:* ROW (%NOF-COLUMNS SELF)) COLUMN)))))
       (CL:COND
        ((CL:> COLUMN LIMIT) (%%PRINT-STREAM STREAM " ...]") (CL:RETURN))
        ((CL:< COLUMN (CL:1- NOF-COLUMNS)) (%%PRINT-STREAM STREAM " "))
        (CL:T (%%PRINT-STREAM STREAM "]")))
       (CL:SETQ ITER-001 (CL:1+ ITER-001))))
     (CL:COND ((CL:> ROW LIMIT) (%%PRINT-STREAM STREAM " ...]") (CL:RETURN))
      ((CL:< ROW (CL:1- NOF-ROWS)) (%%PRINT-STREAM STREAM " "))
      (CL:T (%%PRINT-STREAM STREAM "]")))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))))

(CL:DEFUN HELP-STARTUP-NEURAL-NETWORK1 ()
  (CL:PROGN
   (CL:SETQ KWD-NEURAL-NETWORK-BACKPROP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKPROP" NULL 2))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-WEIGHT-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "WEIGHT-VECTOR" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-2_D_WEIGHT-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "2_D_WEIGHT-ARRAY" NULL 0))
   (CL:SETQ SGT-NEURAL-NETWORK-LOGIC-PROPOSITION-NEURAL-NETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION-NEURAL-NETWORK" NULL 1))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-INPUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-HIDDEN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HIDDEN" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-OUTPUT
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OUTPUT" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-INPUT-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "INPUT-ERROR" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-HIDDEN-ERROR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HIDDEN-ERROR" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-IH
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IH" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-IH-DELTA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IH-DELTA" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-HO
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HO" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-HO-DELTA
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HO-DELTA" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-IH-SLOPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IH-SLOPE" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-IH-PREV-SLOPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "IH-PREV-SLOPE" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-HO-SLOPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HO-SLOPE" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-HO-PREV-SLOPE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "HO-PREV-SLOPE" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SET-TRACE-NEURAL-NETWORK-TRAINING
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-TRACE-NEURAL-NETWORK-TRAINING" NULL
     0))
   (CL:SETQ KWD-NEURAL-NETWORK-COMMON-LISP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "COMMON-LISP" NULL 2))
   (CL:SETQ KWD-NEURAL-NETWORK-FUNCTION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FUNCTION" NULL 2))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SET-SAVE-NETWORK-CYCLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-SAVE-NETWORK-CYCLE" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SET-ERROR-CUTOFF
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-ERROR-CUTOFF" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SET-TRAIN-CACHED-NEURAL-NETWORKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-TRAIN-CACHED-NEURAL-NETWORKS" NULL
     0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SET-LEARNING-RATE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-LEARNING-RATE" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SET-MOMENTUM-TERM
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-MOMENTUM-TERM" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SET-WEIGHT-RANGE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-WEIGHT-RANGE" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SET-NEURAL-NETWORK-TRAINING-METHOD
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-NEURAL-NETWORK-TRAINING-METHOD" NULL
     0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SET-ERROR-PRINT-CYCLE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SET-ERROR-PRINT-CYCLE" NULL 0))
   (CL:SETQ KWD-NEURAL-NETWORK-AND
    (INTERN-RIGID-SYMBOL-WRT-MODULE "AND" NULL 2))
   (CL:SETQ KWD-NEURAL-NETWORK-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "OR" NULL 2))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-GNP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "GNP" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-DEFNETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "DEFNETWORK" NULL 0))
   (CL:SETQ KWD-NEURAL-NETWORK-QUICKPROP
    (INTERN-RIGID-SYMBOL-WRT-MODULE "QUICKPROP" NULL 2))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-MATCH-SCORE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-SCORE" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-TRAIN-NEURAL-NETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRAIN-NEURAL-NETWORK" NULL 0))
   (CL:SETQ KWD-NEURAL-NETWORK-BACKPROPAGATION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "BACKPROPAGATION" NULL 2))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-NEURAL-NETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NEURAL-NETWORK" NULL 0))
   (CL:SETQ KWD-NEURAL-NETWORK-MAX
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAX" NULL 2))
   (CL:SETQ KWD-NEURAL-NETWORK-NOISY-OR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOISY-OR" NULL 2))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-TRAIN-AND-TEST-NEURAL-NETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "TRAIN-AND-TEST-NEURAL-NETWORK" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-MULTIPLE-NETWORK-TRAINING-RUNS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MULTIPLE-NETWORK-TRAINING-RUNS" NULL 0))
   (CL:SETQ SGT-NEURAL-NETWORK-STELLA-CONS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS" (GET-STELLA-MODULE "/STELLA" CL:T)
     1))
   (CL:SETQ SGT-NEURAL-NETWORK-LOGIC-PROPOSITION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "PROPOSITION" NULL 1))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-STRUCTURED-NEURAL-NETWORK-REGRESSION
    (INTERN-RIGID-SYMBOL-WRT-MODULE "STRUCTURED-NEURAL-NETWORK-REGRESSION"
     NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SWAP-IN-NEW-NETWORKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SWAP-IN-NEW-NETWORKS" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SWAP-IN-NETWORK-FILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SWAP-IN-NETWORK-FILE" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-LOAD-NEURAL-NETWORK-FILE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "LOAD-NEURAL-NETWORK-FILE" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SAVE-ALL-NEURAL-NETWORKS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVE-ALL-NEURAL-NETWORKS" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-SAVE-NEURAL-NETWORK
    (INTERN-RIGID-SYMBOL-WRT-MODULE "SAVE-NEURAL-NETWORK" NULL 0))
   (CL:SETQ KWD-NEURAL-NETWORK-MATCH-MODE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MATCH-MODE" NULL 2))
   (CL:SETQ KWD-NEURAL-NETWORK-NN
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NN" NULL 2))
   (CL:SETQ KWD-NEURAL-NETWORK-MAXIMIZE-SCORE?
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MAXIMIZE-SCORE?" NULL 2))
   (CL:SETQ SGT-NEURAL-NETWORK-LOGIC-MULTI-DIMENSIONAL-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "MULTI-DIMENSIONAL-ARRAY" NULL 1))
   (CL:SETQ SGT-NEURAL-NETWORK-LOGIC-2_D_ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "2_D_ARRAY" NULL 1))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-NOF-ROWS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOF-ROWS" NULL 0))
   (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-NOF-COLUMNS
    (INTERN-RIGID-SYMBOL-WRT-MODULE "NOF-COLUMNS" NULL 0))
   (CL:SETQ SGT-NEURAL-NETWORK-LOGIC-FLOAT-VECTOR
    (INTERN-RIGID-SYMBOL-WRT-MODULE "FLOAT-VECTOR" NULL 1))
   (CL:SETQ SYM-NEURAL-NETWORK-STELLA-ARRAY-SIZE
    (INTERN-RIGID-SYMBOL-WRT-MODULE "ARRAY-SIZE"
     (GET-STELLA-MODULE "/STELLA" CL:T) 0))
   (CL:SETQ SGT-NEURAL-NETWORK-LOGIC-2_D_FLOAT-ARRAY
    (INTERN-RIGID-SYMBOL-WRT-MODULE "2_D_FLOAT-ARRAY" NULL 1))))

(CL:DEFUN HELP-STARTUP-NEURAL-NETWORK2 ()
  (CL:PROGN
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE WEIGHT-VECTOR (VECTOR OF FLOAT-WRAPPER))")
   (DEFINE-STELLA-TYPE-FROM-STRINGIFIED-SOURCE
    "(DEFTYPE 2_D_WEIGHT-ARRAY (2_D_ARRAY OF FLOAT-WRAPPER))")
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "PROPOSITION-NEURAL-NETWORK"
       "(DEFCLASS PROPOSITION-NEURAL-NETWORK (STANDARD-OBJECT) :SLOTS ((PROPOSITION :TYPE PROPOSITION) (INPUT :TYPE WEIGHT-VECTOR) (HIDDEN :TYPE WEIGHT-VECTOR) (OUTPUT :TYPE FLOAT) (INPUT-ERROR :TYPE WEIGHT-VECTOR) (HIDDEN-ERROR :TYPE WEIGHT-VECTOR) (IH :TYPE 2_D_WEIGHT-ARRAY) (IH-DELTA :TYPE 2_D_WEIGHT-ARRAY) (HO :TYPE WEIGHT-VECTOR) (HO-DELTA :TYPE WEIGHT-VECTOR) (IH-SLOPE :TYPE 2_D_WEIGHT-ARRAY) (IH-PREV-SLOPE :TYPE 2_D_WEIGHT-ARRAY) (HO-SLOPE :TYPE WEIGHT-VECTOR) (HO-PREV-SLOPE :TYPE WEIGHT-VECTOR)))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-PROPOSITION-NEURAL-NETWORK))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-PROPOSITION-NEURAL-NETWORK-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "MULTI-DIMENSIONAL-ARRAY"
       "(DEFCLASS MULTI-DIMENSIONAL-ARRAY (ABSTRACT-COLLECTION))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-MULTI-DIMENSIONAL-ARRAY)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "2_D_ARRAY"
       "(DEFCLASS 2_D_ARRAY (MULTI-DIMENSIONAL-ARRAY) :DOCUMENTATION \"Two-dimensional arrays with elements of type OBJECT.\" :PARAMETERS ((ANY-VALUE :TYPE OBJECT)) :SLOTS ((NOF-ROWS :TYPE INTEGER :REQUIRED? TRUE) (NOF-COLUMNS :TYPE INTEGER :REQUIRED? TRUE) (THE-ARRAY :TYPE (NATIVE-VECTOR OF (LIKE (ANY-VALUE SELF))))) :INITIALIZER INITIALIZE-2_D_ARRAY :PRINT-FORM (PRINT-ARRAY SELF STREAM))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-2_D_ARRAY))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-2_D_ARRAY-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "FLOAT-VECTOR"
       "(DEFCLASS FLOAT-VECTOR (ABSTRACT-COLLECTION SEQUENCE-MIXIN) :PARAMETERS ((ANY-VALUE :TYPE FLOAT)) :PUBLIC-SLOTS ((ARRAY-SIZE :TYPE INTEGER :REQUIRED? TRUE)) :SLOTS ((THE-ARRAY :TYPE (NATIVE-VECTOR OF FLOAT-WRAPPER))) :PRINT-FORM (PRINT-VECTOR SELF STREAM) :INITIALIZER INITIALIZE-FLOAT-VECTOR)")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS) (CL:FUNCTION NEW-FLOAT-VECTOR))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-FLOAT-VECTOR-SLOT-VALUE)))
   (CL:LET*
    ((CLASS
      (DEFINE-CLASS-FROM-STRINGIFIED-SOURCE "2_D_FLOAT-ARRAY"
       "(DEFCLASS 2_D_FLOAT-ARRAY (MULTI-DIMENSIONAL-ARRAY) :DOCUMENTATION \"Two-dimensional arrays with elements of type FLOAT.\" :PARAMETERS ((ANY-VALUE :TYPE FLOAT)) :SLOTS ((NOF-ROWS :TYPE INTEGER :REQUIRED? TRUE) (NOF-COLUMNS :TYPE INTEGER :REQUIRED? TRUE) (THE-ARRAY :TYPE (NATIVE-VECTOR OF FLOAT-WRAPPER))) :INITIALIZER INITIALIZE-2_D_FLOAT-ARRAY :PRINT-FORM (PRINT-ARRAY SELF STREAM))")))
    (CL:SETF (%CLASS-CONSTRUCTOR-CODE CLASS)
     (CL:FUNCTION NEW-2_D_FLOAT-ARRAY))
    (CL:SETF (%CLASS-SLOT-ACCESSOR-CODE CLASS)
     (CL:FUNCTION ACCESS-2_D_FLOAT-ARRAY-SLOT-VALUE)))))

(CL:DEFUN HELP-STARTUP-NEURAL-NETWORK3 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "SET-TRACE-NEURAL-NETWORK-TRAINING"
    "(DEFUN SET-TRACE-NEURAL-NETWORK-TRAINING ((B BOOLEAN)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-TRACE-NEURAL-NETWORK-TRAINING)
    (CL:FUNCTION SET-TRACE-NEURAL-NETWORK-TRAINING-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-SAVE-NETWORK-CYCLE"
    "(DEFUN SET-SAVE-NETWORK-CYCLE ((I INTEGER)) :DOCUMENTATION \"Set number of cycles between which networks are saved to the
file established by the last call to `save-all-neural-networks'.  A number <= 0
or a NULL number turns off periodic saving.\" :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-SAVE-NETWORK-CYCLE)
    (CL:FUNCTION SET-SAVE-NETWORK-CYCLE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-ERROR-CUTOFF"
    "(DEFUN SET-ERROR-CUTOFF ((F FLOAT)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-ERROR-CUTOFF)
    (CL:FUNCTION SET-ERROR-CUTOFF-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-TRAIN-CACHED-NEURAL-NETWORKS"
    "(DEFUN SET-TRAIN-CACHED-NEURAL-NETWORKS ((B BOOLEAN)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-TRAIN-CACHED-NEURAL-NETWORKS)
    (CL:FUNCTION SET-TRAIN-CACHED-NEURAL-NETWORKS-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-LEARNING-RATE"
    "(DEFUN SET-LEARNING-RATE ((RATE FLOAT)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-LEARNING-RATE)
    (CL:FUNCTION SET-LEARNING-RATE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-MOMENTUM-TERM"
    "(DEFUN SET-MOMENTUM-TERM ((M FLOAT)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-MOMENTUM-TERM)
    (CL:FUNCTION SET-MOMENTUM-TERM-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-WEIGHT-RANGE"
    "(DEFUN SET-WEIGHT-RANGE ((W FLOAT)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-WEIGHT-RANGE)
    (CL:FUNCTION SET-WEIGHT-RANGE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SET-NEURAL-NETWORK-TRAINING-METHOD"
    "(DEFUN SET-NEURAL-NETWORK-TRAINING-METHOD ((M KEYWORD)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-NEURAL-NETWORK-TRAINING-METHOD) NULL)
   (DEFINE-FUNCTION-OBJECT "SET-ERROR-PRINT-CYCLE"
    "(DEFUN SET-ERROR-PRINT-CYCLE ((I INTEGER)) :DOCUMENTATION \"Set number of cycles between which error rates are saved to
the file established by the last call to `save-all-neural-networks' appended
with extension `.err'.  A number <= 0 (or NULL) turns off periodic saving.\" :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SET-ERROR-PRINT-CYCLE)
    (CL:FUNCTION SET-ERROR-PRINT-CYCLE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DELETE-ALL-NEURAL-NETWORKS"
    "(DEFUN DELETE-ALL-NEURAL-NETWORKS () :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION DELETE-ALL-NEURAL-NETWORKS) NULL)
   (DEFINE-FUNCTION-OBJECT "CHECK-MASTER-NETWORK-LIST"
    "(DEFUN CHECK-MASTER-NETWORK-LIST () :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION CHECK-MASTER-NETWORK-LIST) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-ALL-NEURAL-NETWORKS"
    "(DEFUN CLEAR-ALL-NEURAL-NETWORKS () :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION CLEAR-ALL-NEURAL-NETWORKS) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-ALL-SLOPES" "(DEFUN CLEAR-ALL-SLOPES ())"
    (CL:FUNCTION CLEAR-ALL-SLOPES) NULL)
   (DEFINE-FUNCTION-OBJECT "CLEAR-SLOPES"
    "(DEFUN CLEAR-SLOPES ((NET PROPOSITION-NEURAL-NETWORK)))"
    (CL:FUNCTION CLEAR-SLOPES) NULL)
   (DEFINE-FUNCTION-OBJECT "RANDOMIZE-NEURAL-NETWORK"
    "(DEFUN RANDOMIZE-NEURAL-NETWORK ((NET PROPOSITION-NEURAL-NETWORK)))"
    (CL:FUNCTION RANDOMIZE-NEURAL-NETWORK) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-NEURAL-NETWORK"
    "(DEFUN (CREATE-NEURAL-NETWORK PROPOSITION-NEURAL-NETWORK) ((PROP PROPOSITION)))"
    (CL:FUNCTION CREATE-NEURAL-NETWORK) NULL)
   (DEFINE-FUNCTION-OBJECT "GNP"
    "(DEFUN (GNP PROPOSITION) ((NAME SYMBOL)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %GNP) NULL)
   (DEFINE-FUNCTION-OBJECT "DEFNETWORK"
    "(DEFUN (DEFNETWORK PROPOSITION-NEURAL-NETWORK) (|&REST| (ARGS PARSE-TREE)) :PUBLIC? TRUE :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE)"
    (CL:FUNCTION %DEFNETWORK) (CL:FUNCTION DEFNETWORK-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "DEFINE-NEURAL-NETWORK-FROM-PARSE-TREE"
    "(DEFUN (DEFINE-NEURAL-NETWORK-FROM-PARSE-TREE PROPOSITION-NEURAL-NETWORK) ((TREE CONS)))"
    (CL:FUNCTION DEFINE-NEURAL-NETWORK-FROM-PARSE-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ALLOCATE-NEURAL-NETWORK"
    "(DEFUN (ALLOCATE-NEURAL-NETWORK PROPOSITION-NEURAL-NETWORK) ((NUM-IN INTEGER) (NUM-HIDDEN INTEGER)))"
    (CL:FUNCTION ALLOCATE-NEURAL-NETWORK) NULL)
   (DEFINE-FUNCTION-OBJECT "ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK"
    "(DEFUN (ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK FLOAT) ((NET PROPOSITION-NEURAL-NETWORK)))"
    (CL:FUNCTION ACTIVATE-PROPOSITIONAL-NEURAL-NETWORK) NULL)
   (DEFINE-FUNCTION-OBJECT "MAKE-NET-INPUT-STRING"
    "(DEFUN (MAKE-NET-INPUT-STRING STRING) ((INPUT WEIGHT-VECTOR)))"
    (CL:FUNCTION MAKE-NET-INPUT-STRING) NULL)
   (DEFINE-FUNCTION-OBJECT "TRAIN-NEURAL-NETWORK"
    "(DEFUN TRAIN-NEURAL-NETWORK ((CYCLES INTEGER) (NUM-TRAINING INTEGER)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %TRAIN-NEURAL-NETWORK)
    (CL:FUNCTION TRAIN-NEURAL-NETWORK-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "TRAIN-UNCACHED-NEURAL-NETWORKS"
    "(DEFUN TRAIN-UNCACHED-NEURAL-NETWORKS ((CYCLES INTEGER) (NUM-TRAINING INTEGER)))"
    (CL:FUNCTION TRAIN-UNCACHED-NEURAL-NETWORKS) NULL)
   (DEFINE-FUNCTION-OBJECT "BACKPROPAGATE-ERROR"
    "(DEFUN BACKPROPAGATE-ERROR ((PROP PROPOSITION) (ERROR FLOAT)))"
    (CL:FUNCTION BACKPROPAGATE-ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "QUICKPROPAGATE-ERROR"
    "(DEFUN QUICKPROPAGATE-ERROR ((PROP PROPOSITION) (ERROR FLOAT)))"
    (CL:FUNCTION QUICKPROPAGATE-ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-ERROR"
    "(DEFUN (COMPUTE-ERROR FLOAT) ((TRAINING FLOAT) (OUTPUT FLOAT)))"
    (CL:FUNCTION COMPUTE-ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-DELTA"
    "(DEFUN (COMPUTE-DELTA FLOAT) ((SLOPE FLOAT) (PREV-SLOPE FLOAT) (PREV-DELTA FLOAT)))"
    (CL:FUNCTION COMPUTE-DELTA) NULL)
   (DEFINE-FUNCTION-OBJECT "COMPUTE-QP-DELTA"
    "(DEFUN (COMPUTE-QP-DELTA FLOAT) ((SLOPE FLOAT) (PREV-SLOPE FLOAT) (PREV-DELTA FLOAT)))"
    (CL:FUNCTION COMPUTE-QP-DELTA) NULL)
   (DEFINE-FUNCTION-OBJECT "MODIFY-WEIGHTS" "(DEFUN MODIFY-WEIGHTS ())"
    (CL:FUNCTION MODIFY-WEIGHTS) NULL)
   (DEFINE-FUNCTION-OBJECT "TEST-OVER-TRAINING-EXAMPLES"
    "(DEFUN (TEST-OVER-TRAINING-EXAMPLES FLOAT) () :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION TEST-OVER-TRAINING-EXAMPLES)
    (CL:FUNCTION TEST-OVER-TRAINING-EXAMPLES-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "TRAIN-AND-TEST-NEURAL-NETWORK"
    "(DEFUN (TRAIN-AND-TEST-NEURAL-NETWORK FLOAT) ((CYCLES INTEGER) (NUM-TRAINING INTEGER) (NUM-TESTING INTEGER)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %TRAIN-AND-TEST-NEURAL-NETWORK)
    (CL:FUNCTION TRAIN-AND-TEST-NEURAL-NETWORK-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "TEST-NEURAL-NETWORK"
    "(DEFUN (TEST-NEURAL-NETWORK FLOAT) () :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION TEST-NEURAL-NETWORK)
    (CL:FUNCTION TEST-NEURAL-NETWORK-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "MULTIPLE-NETWORK-TRAINING-RUNS"
    "(DEFUN (MULTIPLE-NETWORK-TRAINING-RUNS FLOAT) ((RUNS INTEGER) (CYCLES INTEGER) (NUM-TRAINING INTEGER)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %MULTIPLE-NETWORK-TRAINING-RUNS)
    (CL:FUNCTION MULTIPLE-NETWORK-TRAINING-RUNS-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "TRAIN-CACHED-NEURAL-NETWORKS"
    "(DEFUN TRAIN-CACHED-NEURAL-NETWORKS ((CYCLES INTEGER) (NUM-TRAINING INTEGER)))"
    (CL:FUNCTION TRAIN-CACHED-NEURAL-NETWORKS) NULL)
   (DEFINE-FUNCTION-OBJECT "CACHED-BACKPROPAGATE-ERROR"
    "(DEFUN CACHED-BACKPROPAGATE-ERROR ((TREE CONS) (ERROR FLOAT)))"
    (CL:FUNCTION CACHED-BACKPROPAGATE-ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "CACHED-QUICKPROPAGATE-ERROR"
    "(DEFUN CACHED-QUICKPROPAGATE-ERROR ((TREE CONS) (ERROR FLOAT)))"
    (CL:FUNCTION CACHED-QUICKPROPAGATE-ERROR) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-CACHED-NETWORK"
    "(DEFUN (CREATE-CACHED-NETWORK CONS) ((CONS-QUERY CONS)))"
    (CL:FUNCTION CREATE-CACHED-NETWORK) NULL)
   (DEFINE-FUNCTION-OBJECT "BUILD-NETWORK-TREE"
    "(DEFUN (BUILD-NETWORK-TREE PARSE-TREE) ((PROP PROPOSITION) (PROP-LIST (CONS OF PROPOSITION))))"
    (CL:FUNCTION BUILD-NETWORK-TREE) NULL)
   (DEFINE-FUNCTION-OBJECT "ACTIVATE-CACHED-NETWORK"
    "(DEFUN (ACTIVATE-CACHED-NETWORK FLOAT) ((TREE (CONS OF CONS))))"
    (CL:FUNCTION ACTIVATE-CACHED-NETWORK) NULL)
   (DEFINE-FUNCTION-OBJECT "RANDOM-WEIGHT"
    "(DEFUN (RANDOM-WEIGHT FLOAT) ((N FLOAT)))" (CL:FUNCTION RANDOM-WEIGHT)
    NULL)
   (DEFINE-FUNCTION-OBJECT "RANDOM-FLOAT"
    "(DEFUN (RANDOM-FLOAT FLOAT) ((N FLOAT)) :PUBLIC? TRUE :DOCUMENTATION \"Generate a random integer in the interval [0..n-1].
'n' must be <= 2^15.\")" (CL:FUNCTION RANDOM-FLOAT) NULL)
   (DEFINE-FUNCTION-OBJECT "CONS-TO-VECTOR"
    "(DEFUN (CONS-TO-VECTOR VECTOR) ((FORM CONS)))"
    (CL:FUNCTION CONS-TO-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-VECTOR"
    "(DEFUN (CREATE-VECTOR VECTOR) (|&REST| (VALUES OBJECT)) :DOCUMENTATION \"Return a vector containing 'values', in order.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "ZERO-VECTOR"
    "(DEFUN ZERO-VECTOR ((V WEIGHT-VECTOR)))" (CL:FUNCTION ZERO-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "STRUCTURED-NEURAL-NETWORK-REGRESSION"
    "(DEFUN STRUCTURED-NEURAL-NETWORK-REGRESSION ((CLASS-NAME SYMBOL) (SLOT-NAME SYMBOL) (CYCLES INTEGER)) :COMMAND? TRUE :EVALUATE-ARGUMENTS? FALSE :PUBLIC? TRUE)"
    (CL:FUNCTION %STRUCTURED-NEURAL-NETWORK-REGRESSION)
    (CL:FUNCTION STRUCTURED-NEURAL-NETWORK-REGRESSION-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "GET-NN-NEAREST-NEIGHBORS"
    "(DEFUN (GET-NN-NEAREST-NEIGHBORS (LIST OF TRAINING-EXAMPLE)) ((PROBE TRAINING-EXAMPLE) (CASES (LIST OF TRAINING-EXAMPLE)) (K INTEGER)))"
    (CL:FUNCTION GET-NN-NEAREST-NEIGHBORS) NULL)
   (DEFINE-FUNCTION-OBJECT "SWAP-IN-NEW-NETWORKS"
    "(DEFUN SWAP-IN-NEW-NETWORKS ((OLD-NETS (LIST OF PROPOSITION-NEURAL-NETWORK)) (NEW-NETS (LIST OF PROPOSITION-NEURAL-NETWORK))) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SWAP-IN-NEW-NETWORKS) NULL)
   (DEFINE-FUNCTION-OBJECT "SWAP-IN-NETWORK-FILE"
    "(DEFUN SWAP-IN-NETWORK-FILE ((FILE STRING)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SWAP-IN-NETWORK-FILE)
    (CL:FUNCTION SWAP-IN-NETWORK-FILE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "LOAD-NEURAL-NETWORK-FILE"
    "(DEFUN (LOAD-NEURAL-NETWORK-FILE (LIST OF PROPOSITION-NEURAL-NETWORK)) ((FILE STRING)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %LOAD-NEURAL-NETWORK-FILE)
    (CL:FUNCTION LOAD-NEURAL-NETWORK-FILE-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SAVE-ALL-NEURAL-NETWORKS"
    "(DEFUN SAVE-ALL-NEURAL-NETWORKS ((FILE STRING)) :DOCUMENTATION \"Save all neural networks to `file' (if `file' is non-NULL).
If networks are saved periodically (see `set-save-network-cycle') this file
name will be used to perform periodic saves.\" :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SAVE-ALL-NEURAL-NETWORKS)
    (CL:FUNCTION SAVE-ALL-NEURAL-NETWORKS-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "SAVE-NEURAL-NETWORK"
    "(DEFUN SAVE-NEURAL-NETWORK ((NET PROPOSITION-NEURAL-NETWORK) (FILE STRING)) :COMMAND? TRUE :PUBLIC? TRUE)"
    (CL:FUNCTION %SAVE-NEURAL-NETWORK)
    (CL:FUNCTION SAVE-NEURAL-NETWORK-EVALUATOR-WRAPPER))
   (DEFINE-FUNCTION-OBJECT "PRINT-NEURAL-NETWORK"
    "(DEFUN PRINT-NEURAL-NETWORK ((NET PROPOSITION-NEURAL-NETWORK) (STREAM OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-NEURAL-NETWORK) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-HIDDEN-SIGNATURE"
    "(DEFUN (CREATE-HIDDEN-SIGNATURE WEIGHT-VECTOR) ((CONS-QUERY CONS)))"
    (CL:FUNCTION CREATE-HIDDEN-SIGNATURE) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-2_D_ARRAY"
    "(DEFUN INITIALIZE-2_D_ARRAY ((SELF 2_D_ARRAY)))"
    (CL:FUNCTION INITIALIZE-2_D_ARRAY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (2_D_ELEMENT (LIKE (ANY-VALUE SELF))) ((ARRAY 2_D_ARRAY) (ROW INTEGER) (COLUMN INTEGER)) :DOCUMENTATION \"Return the element of `array' at position [`row', `column'].\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (NTH (THE-ARRAY ARRAY) (+ (* ROW (NOF-COLUMNS ARRAY)) COLUMN))))"
    (CL:FUNCTION 2_D_ELEMENT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (2_D_ELEMENT-SETTER (LIKE (ANY-VALUE SELF))) ((ARRAY 2_D_ARRAY) (VALUE OBJECT) (ROW INTEGER) (COLUMN INTEGER)) :DOCUMENTATION \"Set the element of `array' at position [`row', `column']
to `value' and return the result.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (SETF (NTH (THE-ARRAY ARRAY) (+ (* ROW (NOF-COLUMNS ARRAY)) COLUMN)) VALUE)))"
    (CL:FUNCTION 2_D_ELEMENT-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-2_D_ARRAY"
    "(DEFUN (CREATE-2_D_ARRAY 2_D_ARRAY) ((NOF-ROWS INTEGER) (NOF-COLUMNS INTEGER) |&REST| (VALUES OBJECT)) :DOCUMENTATION \"Create a two-dimensional array with `nof-rows' rows and
`nof-columns' columns, and initialize it in row-major-order from `values'.
Missing values will be padded with NULL, extraneous values will be ignored.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-2_D_ARRAY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD FILL-ARRAY ((SELF 2_D_ARRAY) |&REST| (VALUES OBJECT)) :DOCUMENTATION \"Fill the two-dimensional array `self' in row-major-order
from `values'.  Missing values will retain their old values, extraneous values
will be ignored.\" :PUBLIC? TRUE)" (CL:FUNCTION FILL-ARRAY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRINT-ARRAY ((SELF 2_D_ARRAY) (STREAM NATIVE-OUTPUT-STREAM)) :DOCUMENTATION \"Print the array `self' to `stream'.\")"
    (CL:FUNCTION PRINT-ARRAY) NULL)))

(CL:DEFUN HELP-STARTUP-NEURAL-NETWORK4 ()
  (CL:PROGN
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-FLOAT-VECTOR"
    "(DEFUN INITIALIZE-FLOAT-VECTOR ((SELF FLOAT-VECTOR)))"
    (CL:FUNCTION INITIALIZE-FLOAT-VECTOR) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-FLOAT-VECTOR"
    "(DEFUN (CREATE-FLOAT-VECTOR FLOAT-VECTOR) (|&REST| (VALUES FLOAT)) :DOCUMENTATION \"Return a vector containing 'values', in order.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-FLOAT-VECTOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRINT-VECTOR ((SELF FLOAT-VECTOR) (STREAM NATIVE-OUTPUT-STREAM)))"
    (CL:FUNCTION PRINT-VECTOR) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (EMPTY? BOOLEAN) ((SELF FLOAT-VECTOR)) :DOCUMENTATION \"Return TRUE if 'self' has length 0.\" :GLOBALLY-INLINE? TRUE (RETURN (EQL? (ARRAY-SIZE SELF) 0)))"
    (CL:FUNCTION EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NON-EMPTY? BOOLEAN) ((SELF FLOAT-VECTOR)) :DOCUMENTATION \"Return TRUE if 'self' has length > 0.\" :GLOBALLY-INLINE? TRUE (RETURN (> (ARRAY-SIZE SELF) 0)))"
    (CL:FUNCTION NON-EMPTY?) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH FLOAT) ((SELF FLOAT-VECTOR) (POSITION INTEGER)) :GLOBALLY-INLINE? TRUE (RETURN (SAFE-CAST (NTH (THE-ARRAY SELF) POSITION) FLOAT-WRAPPER)))"
    (CL:FUNCTION NTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (NTH-SETTER FLOAT) ((SELF FLOAT-VECTOR) (VALUE FLOAT) (POSITION INTEGER)) :GLOBALLY-INLINE? TRUE (RETURN (SETF (WRAPPER-VALUE (SAFE-CAST (NTH (THE-ARRAY SELF) POSITION) FLOAT-WRAPPER)) VALUE)))"
    (CL:FUNCTION NTH-SETTER) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (LENGTH INTEGER) ((SELF FLOAT-VECTOR)) :GLOBALLY-INLINE? TRUE (RETURN (ARRAY-SIZE SELF)))"
    (CL:FUNCTION LENGTH) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (MEMBER? BOOLEAN) ((SELF FLOAT-VECTOR) (OBJECT FLOAT)))"
    (CL:FUNCTION MEMBER?) NULL)
   (DEFINE-FUNCTION-OBJECT "INITIALIZE-2_D_FLOAT-ARRAY"
    "(DEFUN INITIALIZE-2_D_FLOAT-ARRAY ((SELF 2_D_FLOAT-ARRAY)))"
    (CL:FUNCTION INITIALIZE-2_D_FLOAT-ARRAY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (2_D_ELEMENT FLOAT) ((ARRAY 2_D_FLOAT-ARRAY) (ROW INTEGER) (COLUMN INTEGER)) :DOCUMENTATION \"Return the element of `array' at position [`row', `column'].\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (SAFE-CAST (NTH (THE-ARRAY ARRAY) (+ (* ROW (NOF-COLUMNS ARRAY)) COLUMN)) FLOAT-WRAPPER)))"
    (CL:FUNCTION 2_D_ELEMENT) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD (2_D_ELEMENT-SETTER (LIKE (ANY-VALUE SELF))) ((ARRAY 2_D_FLOAT-ARRAY) (VALUE FLOAT) (ROW INTEGER) (COLUMN INTEGER)) :DOCUMENTATION \"Set the element of `array' at position [`row', `column']
to `value' and return the result.\" :GLOBALLY-INLINE? TRUE :PUBLIC? TRUE (RETURN (SETF (WRAPPER-VALUE (SAFE-CAST (NTH (THE-ARRAY ARRAY) (+ (* ROW (NOF-COLUMNS ARRAY)) COLUMN)) FLOAT-WRAPPER)) VALUE)))"
    (CL:FUNCTION 2_D_ELEMENT-SETTER) NULL)
   (DEFINE-FUNCTION-OBJECT "CREATE-2_D_FLOAT-ARRAY"
    "(DEFUN (CREATE-2_D_FLOAT-ARRAY 2_D_FLOAT-ARRAY) ((NOF-ROWS INTEGER) (NOF-COLUMNS INTEGER) |&REST| (VALUES FLOAT)) :DOCUMENTATION \"Create a two-dimensional array with `nof-rows' rows and
`nof-columns' columns, and initialize it in row-major-order from `values'.
Missing values will be padded with NULL, extraneous values will be ignored.\" :PUBLIC? TRUE)"
    (CL:FUNCTION CREATE-2_D_FLOAT-ARRAY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD FILL-ARRAY ((SELF 2_D_FLOAT-ARRAY) |&REST| (VALUES FLOAT)) :DOCUMENTATION \"Fill the two-dimensional array `self' in row-major-order
from `values'.  Missing values will retain their old values, extraneous values
will be ignored.\" :PUBLIC? TRUE)" (CL:FUNCTION FILL-ARRAY) NULL)
   (DEFINE-METHOD-OBJECT
    "(DEFMETHOD PRINT-ARRAY ((SELF 2_D_FLOAT-ARRAY) (STREAM NATIVE-OUTPUT-STREAM)) :DOCUMENTATION \"Print the array `self' to `stream'.\")"
    (CL:FUNCTION PRINT-ARRAY) NULL)
   (DEFINE-FUNCTION-OBJECT "STARTUP-NEURAL-NETWORK"
    "(DEFUN STARTUP-NEURAL-NETWORK () :PUBLIC? TRUE)"
    (CL:FUNCTION STARTUP-NEURAL-NETWORK) NULL)
   (CL:LET*
    ((FUNCTION
      (LOOKUP-FUNCTION SYM-NEURAL-NETWORK-LOGIC-STARTUP-NEURAL-NETWORK)))
    (SET-DYNAMIC-SLOT-VALUE (%DYNAMIC-SLOTS FUNCTION)
     SYM-NEURAL-NETWORK-STELLA-METHOD-STARTUP-CLASSNAME
     (WRAP-STRING "_StartupNeuralNetwork") NULL-STRING-WRAPPER))))

(CL:DEFUN STARTUP-NEURAL-NETWORK ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/LOGIC" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2) (HELP-STARTUP-NEURAL-NETWORK1)
    (CL:SETQ SYM-NEURAL-NETWORK-LOGIC-STARTUP-NEURAL-NETWORK
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-NEURAL-NETWORK" NULL 0))
    (CL:SETQ SYM-NEURAL-NETWORK-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 4)
    (CL:SETQ *NEURAL-NETWORK-TRAINING-METHOD* KWD-NEURAL-NETWORK-BACKPROP)
    (CL:SETQ *SAVE-NETWORK-FILE* STELLA::NULL-STRING)
    (CL:SETQ *SHRINK-FACTOR*
     (CL:/ *MAX-MOVEMENT* (CL:+ 1.0d0 *MAX-MOVEMENT*)))
    (CL:SETQ *MASTER-NEURAL-NETWORK-LIST* (NEW-LIST))
    (CL:SETQ *ACTIVATED-NETWORKS* (NEW-LIST))
    (CL:SETQ *PARTIAL-SUPPORT-CACHE* (NEW-LIST)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 5) (HELP-STARTUP-NEURAL-NETWORK2))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7) (HELP-STARTUP-NEURAL-NETWORK3)
    (HELP-STARTUP-NEURAL-NETWORK4))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "LOGIC")))
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *NEURAL-NETWORK-TRAINING-METHOD* KEYWORD :BACKPROP)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LEARNING-RATE* FLOAT 0.1)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MOMENTUM-TERM* FLOAT 0.9)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *WEIGHT-RANGE* FLOAT 0.05)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ERROR-CUTOFF* FLOAT 0.0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ERROR-PRINT-CYCLE* INTEGER 25)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SAVE-NETWORK-CYCLE* INTEGER 10000)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SAVE-NETWORK-FILE* STRING NULL)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TRACE-NEURAL-NETWORK-TRAINING* BOOLEAN FALSE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *TRAIN-CACHED-NETWORKS?* BOOLEAN TRUE)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MAX-MOVEMENT* FLOAT 1.75)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MODE-SWITCH* FLOAT 0.0)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SHRINK-FACTOR* FLOAT (/ *MAX-MOVEMENT* (+ 1.0 *MAX-MOVEMENT*)))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *WEIGHT-DECAY* FLOAT -1.0e-4)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SIGMOID-PRIME-OFFSET* FLOAT 0.1)")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *MASTER-NEURAL-NETWORK-LIST* (LIST OF PROPOSITION-NEURAL-NETWORK) (NEW LIST))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *ACTIVATED-NETWORKS* (LIST OF PROPOSITION-NEURAL-NETWORK) (NEW LIST))")
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *SAVED-NET* PROPOSITION-NEURAL-NETWORK NULL)")
    (REGISTER-NATIVE-NAME
     SYM-NEURAL-NETWORK-LOGIC-SET-TRACE-NEURAL-NETWORK-TRAINING
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-SET-SAVE-NETWORK-CYCLE
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-SET-ERROR-CUTOFF
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-NEURAL-NETWORK-LOGIC-SET-TRAIN-CACHED-NEURAL-NETWORKS
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-SET-LEARNING-RATE
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-SET-MOMENTUM-TERM
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-SET-WEIGHT-RANGE
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-NEURAL-NETWORK-LOGIC-SET-NEURAL-NETWORK-TRAINING-METHOD
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-SET-ERROR-PRINT-CYCLE
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-GNP
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-DEFNETWORK
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-TRAIN-NEURAL-NETWORK
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *PARTIAL-SUPPORT-CACHE* (LIST OF INTEGER-WRAPPER) (NEW LIST))")
    (REGISTER-NATIVE-NAME
     SYM-NEURAL-NETWORK-LOGIC-TRAIN-AND-TEST-NEURAL-NETWORK
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME
     SYM-NEURAL-NETWORK-LOGIC-MULTIPLE-NETWORK-TRAINING-RUNS
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (DEFINE-STELLA-GLOBAL-VARIABLE-FROM-STRINGIFIED-SOURCE
     "(DEFGLOBAL *LEARNING-CURVE* (VECTOR OF FLOAT-WRAPPER) NULL)")
    (REGISTER-NATIVE-NAME
     SYM-NEURAL-NETWORK-LOGIC-STRUCTURED-NEURAL-NETWORK-REGRESSION
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-SWAP-IN-NEW-NETWORKS
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-SWAP-IN-NETWORK-FILE
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-LOAD-NEURAL-NETWORK-FILE
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-SAVE-ALL-NEURAL-NETWORKS
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION)
    (REGISTER-NATIVE-NAME SYM-NEURAL-NETWORK-LOGIC-SAVE-NEURAL-NETWORK
     KWD-NEURAL-NETWORK-COMMON-LISP KWD-NEURAL-NETWORK-FUNCTION))))
