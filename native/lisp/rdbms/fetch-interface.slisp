;;; -*- Mode: Lisp; Package: STELLA; Syntax: COMMON-LISP; Base: 10 -*-

;;; fetch-interface.slisp

#|
 +---------------------------- BEGIN LICENSE BLOCK ---------------------------+
 |                                                                            |
 | Version: MPL 1.1/GPL 2.0/LGPL 2.1                                          |
 |                                                                            |
 | The contents of this file are subject to the Mozilla Public License        |
 | Version 1.1 (the "License"); you may not use this file except in           |
 | compliance with the License. You may obtain a copy of the License at       |
 | http://www.mozilla.org/MPL/                                                |
 |                                                                            |
 | Software distributed under the License is distributed on an "AS IS" basis, |
 | WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License   |
 | for the specific language governing rights and limitations under the       |
 | License.                                                                   |
 |                                                                            |
 | The Original Code is the PowerLoom KR&R System.                            |
 |                                                                            |
 | The Initial Developer of the Original Code is                              |
 | UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          |
 | 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               |
 |                                                                            |
 | Portions created by the Initial Developer are Copyright (C) 1997-2014      |
 | the Initial Developer. All Rights Reserved.                                |
 |                                                                            |
 | Contributor(s):                                                            |
 |                                                                            |
 | Alternatively, the contents of this file may be used under the terms of    |
 | either the GNU General Public License Version 2 or later (the "GPL"), or   |
 | the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),   |
 | in which case the provisions of the GPL or the LGPL are applicable instead |
 | of those above. If you wish to allow use of your version of this file only |
 | under the terms of either the GPL or the LGPL, and not to allow others to  |
 | use your version of this file under the terms of the MPL, indicate your    |
 | decision by deleting the provisions above and replace them with the notice |
 | and other provisions required by the GPL or the LGPL. If you do not delete |
 | the provisions above, a recipient may use your version of this file under  |
 | the terms of any one of the MPL, the GPL or the LGPL.                      |
 |                                                                            |
 +----------------------------- END LICENSE BLOCK ----------------------------+
|#

(CL:IN-PACKAGE "STELLA")

;;; Auxiliary variables:

(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-RUN-FETCH-QUERY NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-STELLA-CONS NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT NULL)
(CL:DEFVAR KWD-FETCH-INTERFACE-ERROR NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-HOST NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-PORT NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-TASK-ID NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-SUBTASK-ID NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-DB-NAME NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-RDBMS-F-FETCH-EDB-QUERY-MEMO-TABLE-000 NULL)
(CL:DEFVAR SGT-FETCH-INTERFACE-LOGIC-QUERY-ITERATOR NULL)
(CL:DEFVAR SYM-FETCH-INTERFACE-LOGIC-?X NULL)
(CL:DEFVAR SYM-FETCH-INTERFACE-RDBMS-STARTUP-FETCH-INTERFACE NULL)
(CL:DEFVAR SYM-FETCH-INTERFACE-STELLA-METHOD-STARTUP-CLASSNAME NULL)

;;; Forward declarations:

(CL:DECLAIM
 (CL:SPECIAL *STARTUP-TIME-PHASE* NULL-STRING-WRAPPER *MODULE*
  *POWERLOOM-LOCK* *CONTEXT* *REVERSEPOLARITY?* *MEMOIZATION-ENABLED?*
  TRUE-WRAPPER FALSE-WRAPPER MEMOIZED-NULL-VALUE NULL-INTEGER EOL NIL))

;;; (DEFUN (RUN-FETCH-QUERY OBJECT) ...)

(CL:DEFUN RUN-FETCH-QUERY (HOST PORT QUERY-ID TASK-ID SUBTASK-ID DATABASE PARAMETERS)
  "Runs a Fetch query specifying the parameters given.
Returns an object representing the returned XML-encoded answer from
the server."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING HOST QUERY-ID TASK-ID SUBTASK-ID DATABASE
    PARAMETERS)
   (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE QUERY-ID CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE TASK-ID CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SUBTASK-ID CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DATABASE CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PARAMETERS CL:SIMPLE-STRING)
  (CL:LET* ((*PRINTREADABLY?* CL:NIL))
   (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
   (CL:LET* ((URL (NEW-OUTPUT-STRING-STREAM)) (REPLY NULL))
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL)
     "/agent/runner?plan=")
    (WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS
     (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) QUERY-ID)
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL)
     "&TaskID=")
    (WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS
     (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) TASK-ID)
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) "-")
    (WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS
     (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) SUBTASK-ID)
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL)
     "&Database=")
    (WRITE-HTML-ESCAPING-URL-SPECIAL-CHARACTERS
     (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) DATABASE)
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL) "&")
    (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM URL)
     PARAMETERS)
    (CL:SETQ REPLY
     (CL:FUNCALL
      (AUTOLOAD "HTTP/HTTP-GET-DATA" "webtools"
       SGT-FETCH-INTERFACE-RDBMS-RUN-FETCH-QUERY CL:T)
      HOST PORT (THE-STRING-READER URL) NULL))
    (CL:LET* ((EXP NULL) (ITER-000 (XML-EXPRESSIONS REPLY NULL)))
     (CL:LOOP WHILE (NEXT? ITER-000) DO
      (CL:SETQ EXP (%XML-EXPRESSION-ITERATOR.VALUE ITER-000))
      (CL:WHEN
       (CL:AND (ISA? EXP SGT-FETCH-INTERFACE-STELLA-CONS)
        (ISA? (%%VALUE EXP) SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT))
       (CL:LET* ((ITEM-000 (%%VALUE EXP)))
        (CL:COND
         ((CL:AND
           (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "PlanExecution")
           (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000)
            STELLA::NULL-STRING))
          (CL:RETURN-FROM RUN-FETCH-QUERY EXP))
         ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "Error")
           (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000)
            STELLA::NULL-STRING))
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
            (%STRING-WRAPPER.WRAPPER-VALUE
             (%%VALUE (%%REST (%%REST EXP))))
            "'")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
         (CL:T))))))
    (CL:ERROR
     (NEW-STELLA-EXCEPTION
      "Fetch Query Error: No answer element found.")))))

;;; (DEFUN (NORMALIZE-FETCH-QUERY-ARGUMENTS STRING (CONS OF STRING-WRAPPER) PROPERTY-LIST) ...)

(CL:DECLAIM
 (CL:FTYPE
  (CL:FUNCTION (CL:T CL:T) (CL:VALUES CL:SIMPLE-STRING CL:T CL:T))
  NORMALIZE-FETCH-QUERY-ARGUMENTS))
(CL:DEFUN NORMALIZE-FETCH-QUERY-ARGUMENTS (PROPOSITION ARGUMENTS)
  (CL:WHEN (CL:NOT (STRING? ARGUMENTS))
   (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
    (CL:LET* ((*PRINTREADABLY?* CL:T))
     (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000)
      "PARSING ERROR: Fetch-EDB-query: illegal pattern arguments: `"
      ARGUMENTS "'." EOL)
     (HELP-SIGNAL-PROPOSITION-ERROR STREAM-000
      KWD-FETCH-INTERFACE-ERROR))
    (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-000)))))
  (CL:LET*
   ((ARGS
     (READ-S-EXPRESSION-FROM-STRING
      (%STRING-WRAPPER.WRAPPER-VALUE ARGUMENTS)))
    (CURSOR NULL) (QUERYID STELLA::NULL-STRING) (OUTPUTARGS NIL)
    (PARAMETERS NIL) (PARAMETERVALUE NULL))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUERYID))
   (CL:COND
    ((CL:EQ (SAFE-PRIMARY-TYPE ARGS) SGT-FETCH-INTERFACE-STELLA-CONS)
     (CL:PROGN
      (CL:LET* ((TEST-VALUE-000 CL:NIL))
       (CL:SETQ TEST-VALUE-000
        (CL:OR
         (CL:AND (CONS? (%%VALUE ARGS))
          (CL:LET ((X (LENGTH ARGS)))
           (CL:DECLARE (CL:TYPE CL:FIXNUM X))
           (CL:NOT (CL:LOGBITP 0 X))))
         (CL:AND (CL:NOT (CONS? (%%VALUE ARGS)))
          (CL:LOGBITP 0 (CL:THE CL:FIXNUM (LENGTH ARGS))))))
       (CL:WHEN TEST-VALUE-000
        (CL:LET* ((ALWAYS?-000 CL:T))
         (CL:LET* ((ARG NULL) (ITER-000 (%%REST ARGS)))
          (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
           (CL:SETQ ARG (%%VALUE ITER-000))
           (CL:WHEN (CONS? ARG) (CL:SETQ ALWAYS?-000 CL:NIL)
            (CL:RETURN))
           (CL:SETQ ITER-000 (%%REST ITER-000))))
         (CL:SETQ TEST-VALUE-000 ALWAYS?-000)))
       (CL:WHEN (CL:NOT TEST-VALUE-000)
        (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
         (CL:LET* ((*PRINTREADABLY?* CL:T))
          (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001)
           "PARSING ERROR: Fetch-EDB-query: illegal pattern arguments: `"
           ARGUMENTS "'." EOL)
          (HELP-SIGNAL-PROPOSITION-ERROR STREAM-001
           KWD-FETCH-INTERFACE-ERROR))
         (CL:ERROR
          (NEW-PARSING-ERROR (THE-STRING-READER STREAM-001))))))
      (CL:SETQ CURSOR ARGS)
      (CL:COND
       ((CONS? (%%VALUE CURSOR))
        (CL:LET*
         ((OUTARG NULL) (ITER-001 (%%VALUE CURSOR)) (COLLECT-000 NULL))
         (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
          (CL:SETQ OUTARG (%%VALUE ITER-001))
          (CL:IF (CL:EQ COLLECT-000 NULL)
           (CL:PROGN
            (CL:SETQ COLLECT-000
             (CONS (WRAP-STRING (COERCE-TO-STRING OUTARG)) NIL))
            (CL:IF (CL:EQ OUTPUTARGS NIL)
             (CL:SETQ OUTPUTARGS COLLECT-000)
             (ADD-CONS-TO-END-OF-CONS-LIST OUTPUTARGS COLLECT-000)))
           (CL:PROGN
            (CL:SETF (%%REST COLLECT-000)
             (CONS (WRAP-STRING (COERCE-TO-STRING OUTARG)) NIL))
            (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
          (CL:SETQ ITER-001 (%%REST ITER-001))))
        (CL:SETQ CURSOR (%%REST CURSOR)))
       (CL:T
        (CL:SETQ OUTPUTARGS
         (GET-TABLE-COLUMN-NAMES
          (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION))))
        (CL:WHEN (CL:EQ OUTPUTARGS NULL)
         (CL:LET* ((STREAM-002 (NEW-OUTPUT-STRING-STREAM)))
          (CL:LET* ((*PRINTREADABLY?* CL:T))
           (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-002)
            "PARSING ERROR: Fetch-EDB-query: missing output arg/column specifications for: `"
            (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION)) "'."
            EOL)
           (HELP-SIGNAL-PROPOSITION-ERROR STREAM-002
            KWD-FETCH-INTERFACE-ERROR))
          (CL:ERROR
           (NEW-PARSING-ERROR (THE-STRING-READER STREAM-002)))))))
      (CL:SETQ QUERYID (COERCE-TO-STRING (%%VALUE CURSOR)))
      (CL:SETQ CURSOR (%%REST CURSOR)) (CL:SETQ PARAMETERS CURSOR)
      (CL:LOOP WHILE (CL:NOT (CL:EQ CURSOR NIL)) DO
       (FIRST-SETTER CURSOR
        (WRAP-STRING (COERCE-TO-STRING (%%VALUE CURSOR))))
       (CL:SETQ PARAMETERVALUE (%%VALUE (%%REST CURSOR)))
       (CL:COND
        ((QUESTION-MARK-SYMBOL? PARAMETERVALUE)
         (CL:LET* ((VALUE-000 NULL))
          (CL:LET*
           ((ARG NULL)
            (VECTOR-000 (%PROPOSITION.ARGUMENTS PROPOSITION))
            (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000)) (VAR NULL)
            (ITER-002
             (%LIST.THE-CONS-LIST
              (%NAMED-DESCRIPTION.IO-VARIABLE-NAMES
               (GET-DESCRIPTION
                (%PROPOSITION.OPERATOR PROPOSITION))))))
           (CL:DECLARE (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000))
           (CL:LOOP WHILE
            (CL:AND (CL:< INDEX-000 LENGTH-000)
             (CL:NOT (CL:EQ ITER-002 NIL)))
            DO
            (CL:SETQ ARG
             (CL:AREF
              (CL:THE CL:SIMPLE-VECTOR (%VECTOR.THE-ARRAY VECTOR-000))
              INDEX-000))
            (CL:SETQ VAR (%%VALUE ITER-002))
            (CL:WHEN (CL:EQ VAR PARAMETERVALUE) (CL:SETQ VALUE-000 ARG)
             (CL:RETURN))
            (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
            (CL:SETQ ITER-002 (%%REST ITER-002))))
          (CL:SETQ PARAMETERVALUE VALUE-000))
         (CL:WHEN (CL:EQ PARAMETERVALUE NULL)
          (CL:LET* ((STREAM-003 (NEW-OUTPUT-STRING-STREAM)))
           (CL:LET* ((*PRINTREADABLY?* CL:T))
            (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
            (%%PRINT-STREAM
             (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-003)
             "PARSING ERROR: Fetch-EDB-query: non-existent input variable: `"
             (%%VALUE (%%REST CURSOR)) "'." EOL)
            (HELP-SIGNAL-PROPOSITION-ERROR STREAM-003
             KWD-FETCH-INTERFACE-ERROR))
           (CL:ERROR
            (NEW-PARSING-ERROR (THE-STRING-READER STREAM-003)))))
         (FIRST-SETTER (%%REST CURSOR) PARAMETERVALUE))
        (CL:T
         (FIRST-SETTER (%%REST CURSOR)
          (WRAP-STRING (COERCE-TO-STRING PARAMETERVALUE)))))
       (CL:SETQ CURSOR (%%REST (%%REST CURSOR))))))
    (CL:T
     (CL:LET* ((STREAM-004 (NEW-OUTPUT-STRING-STREAM)))
      (CL:LET* ((*PRINTREADABLY?* CL:T))
       (CL:DECLARE (CL:SPECIAL *PRINTREADABLY?*))
       (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-004)
        "PARSING ERROR: Fetch-EDB-query: illegal pattern arguments: `"
        ARGUMENTS "'." EOL)
       (HELP-SIGNAL-PROPOSITION-ERROR STREAM-004
        KWD-FETCH-INTERFACE-ERROR))
      (CL:ERROR (NEW-PARSING-ERROR (THE-STRING-READER STREAM-004))))))
   (CL:LET* ((SELF-010 (NEW-PROPERTY-LIST)))
    (CL:SETF (%PROPERTY-LIST.THE-PLIST SELF-010) PARAMETERS)
    (CL:LET* ((VALUE-001 SELF-010))
     (CL:VALUES QUERYID OUTPUTARGS VALUE-001)))))

;;; (DEFUN (HELP-MEMOIZE-FETCH-EDB-QUERY (ITERATOR OF CONS)) ...)

(CL:DEFUN HELP-MEMOIZE-FETCH-EDB-QUERY (PROPOSITION DATABASE ARGUMENTS)
  (CL:LET*
   ((QUERYID STELLA::NULL-STRING) (OUTPUTARGS NIL) (PARAMETERS NULL)
    (RELATION (GET-DESCRIPTION (%PROPOSITION.OPERATOR PROPOSITION)))
    (PARAMS (NEW-OUTPUT-STRING-STREAM)))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING QUERYID))
   (CL:MULTIPLE-VALUE-SETQ (QUERYID OUTPUTARGS PARAMETERS)
    (NORMALIZE-FETCH-QUERY-ARGUMENTS PROPOSITION ARGUMENTS))
   (CL:LET*
    ((KEY NULL) (VALUE NULL)
     (ITER-000 (%PROPERTY-LIST.THE-PLIST PARAMETERS)) (I NULL-INTEGER)
     (ITER-001 1))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-001))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ KEY (%%VALUE ITER-000))
     (CL:SETQ VALUE (%%VALUE (%%REST ITER-000))) (CL:SETQ I ITER-001)
     (CL:WHEN (CL:OR (CL:EQ KEY NULL) (CL:EQ VALUE NULL))
      (CL:RETURN-FROM HELP-MEMOIZE-FETCH-EDB-QUERY NULL))
     (CL:WHEN (CL:> I 1)
      (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM PARAMS)
       "&"))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM PARAMS)
      (UNWRAP-STRING KEY))
     (CL:SETQ VALUE (ARGUMENT-BOUND-TO VALUE))
     (CL:WHEN (CL:EQ VALUE NULL)
      (CL:RETURN-FROM HELP-MEMOIZE-FETCH-EDB-QUERY NULL))
     (%%PRINT-STREAM (%OUTPUT-STRING-STREAM.NATIVE-STREAM PARAMS) "="
      (COERCE-POWERLOOM-OBJECT-TO-STRING VALUE NULL))
     (CL:SETQ ITER-000 (%%REST (%%REST ITER-000)))
     (CL:SETQ ITER-001 (CL:1+ ITER-001))))
   (CL:LET*
    ((TEMP-000
      (UNWRAP-STRING
       (ACCESS-BINARY-VALUE DATABASE SGT-FETCH-INTERFACE-RDBMS-HOST))))
    (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-000))
    (CL:LET*
     ((TEMP-001
       (UNWRAP-INTEGER
        (ACCESS-BINARY-VALUE DATABASE
         SGT-FETCH-INTERFACE-RDBMS-PORT))))
     (CL:DECLARE (CL:TYPE CL:FIXNUM TEMP-001))
     (CL:LET*
      ((TEMP-002
        (UNWRAP-STRING
         (ACCESS-BINARY-VALUE DATABASE
          SGT-FETCH-INTERFACE-RDBMS-TASK-ID))))
      (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-002))
      (CL:LET*
       ((TEMP-003
         (UNWRAP-STRING
          (ACCESS-BINARY-VALUE DATABASE
           SGT-FETCH-INTERFACE-RDBMS-SUBTASK-ID))))
       (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-003))
       (CL:LET*
        ((TEMP-004
          (UNWRAP-STRING
           (ACCESS-BINARY-VALUE DATABASE
            SGT-FETCH-INTERFACE-RDBMS-DB-NAME))))
        (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TEMP-004))
        (CL:LET*
         ((VALUE-000
           (ALLOCATE-ITERATOR
            (PARSE-FETCH-XML-ANSWER
             (RUN-FETCH-QUERY
              (CL:IF (CL:NOT (CL:EQ TEMP-000 STELLA::NULL-STRING))
               TEMP-000 "pegasus2.isi.edu")
              (CL:IF (CL:NOT (CL:= TEMP-001 NULL-INTEGER)) TEMP-001
               8080)
              QUERYID
              (CL:IF (CL:NOT (CL:EQ TEMP-002 STELLA::NULL-STRING))
               TEMP-002 "TASK")
              (CL:IF (CL:NOT (CL:EQ TEMP-003 STELLA::NULL-STRING))
               TEMP-003 "SUBTASK")
              (CL:IF (CL:NOT (CL:EQ TEMP-004 STELLA::NULL-STRING))
               TEMP-004 "EELD-DATABASE")
              (THE-STRING-READER PARAMS))
             RELATION OUTPUTARGS))))
         VALUE-000))))))))

;;; (DEFUN (FETCH-EDB-QUERY (ITERATOR OF CONS)) ...)

(CL:DEFUN FETCH-EDB-QUERY (PROPOSITION DATABASE ARGUMENTS)
  (CHECK-FOR-EXTERNAL-DB-UPDATES PROPOSITION DATABASE)
  (CL:LET*
   ((MEMO-TABLE-000 NULL) (MEMOIZED-ENTRY-000 NULL)
    (MEMOIZED-VALUE-000 NULL))
   (CL:WHEN *MEMOIZATION-ENABLED?*
    (CL:SETQ MEMO-TABLE-000
     (%SURROGATE.SURROGATE-VALUE
      SGT-FETCH-INTERFACE-RDBMS-F-FETCH-EDB-QUERY-MEMO-TABLE-000))
    (CL:WHEN (CL:EQ MEMO-TABLE-000 NULL)
     (INITIALIZE-MEMOIZATION-TABLE
      SGT-FETCH-INTERFACE-RDBMS-F-FETCH-EDB-QUERY-MEMO-TABLE-000
      "(:MAX-VALUES 10000 :TIMESTAMPS (:META-KB-UPDATE :EXTERNAL-DB-UPDATE))")
     (CL:SETQ MEMO-TABLE-000
      (%SURROGATE.SURROGATE-VALUE
       SGT-FETCH-INTERFACE-RDBMS-F-FETCH-EDB-QUERY-MEMO-TABLE-000)))
    (CL:SETQ MEMOIZED-ENTRY-000
     (LOOKUP-MRU-MEMOIZED-VALUE MEMO-TABLE-000
      (GET-QUERY-PATTERN-MEMOIZATION-KEY PROPOSITION) *CONTEXT*
      (CL:IF *REVERSEPOLARITY?* TRUE-WRAPPER FALSE-WRAPPER)
      MEMOIZED-NULL-VALUE 6))
    (CL:SETQ MEMOIZED-VALUE-000 (%%VALUE MEMOIZED-ENTRY-000)))
   (CL:COND
    ((CL:NOT (CL:EQ MEMOIZED-VALUE-000 NULL))
     (CL:WHEN (CL:EQ MEMOIZED-VALUE-000 MEMOIZED-NULL-VALUE)
      (CL:SETQ MEMOIZED-VALUE-000 NULL)))
    (CL:T
     (CL:SETQ MEMOIZED-VALUE-000
      (NEW-MEMOIZABLE-ITERATOR
       (HELP-MEMOIZE-FETCH-EDB-QUERY PROPOSITION DATABASE ARGUMENTS)))
     (CL:WHEN *MEMOIZATION-ENABLED?*
      (CL:SETF (%%VALUE MEMOIZED-ENTRY-000)
       (CL:IF (CL:EQ MEMOIZED-VALUE-000 NULL) MEMOIZED-NULL-VALUE
        MEMOIZED-VALUE-000)))))
   (CL:LET* ((VALUE-000 (CLONE-MEMOIZED-ITERATOR MEMOIZED-VALUE-000)))
    VALUE-000)))

;;; (DEFUN (PARSE-FETCH-XML-ANSWER (CONS OF CONS)) ...)

(CL:DEFUN PARSE-FETCH-XML-ANSWER (XMLANSWER RELATION OUTPUTCOLUMNS)
  (CL:LET* ((TUPLES NIL))
   (CL:WHEN
    (CL:NOT
     (CL:AND
      (ISA? (%%VALUE XMLANSWER) SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT)
      (CL:AND
       (STRING-EQL? (%XML-ELEMENT.NAME (%%VALUE XMLANSWER))
        "PlanExecution")
       (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI (%%VALUE XMLANSWER))
        STELLA::NULL-STRING))))
    (CL:WARN
     "Fetch-EDB-query Error: Didn't find a Fetch Answer in `~A'"
     XMLANSWER)
    (CL:RETURN-FROM PARSE-FETCH-XML-ANSWER NIL))
   (CL:LET* ((ANSWER NULL) (ITER-000 (%%REST (%%REST XMLANSWER))))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ ANSWER (%%VALUE ITER-000))
     (CL:WHEN
      (CL:AND (ISA? ANSWER SGT-FETCH-INTERFACE-STELLA-CONS)
       (ISA? (%%VALUE ANSWER) SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT))
      (CL:LET* ((ITEM-000 (%%VALUE ANSWER)))
       (CL:COND
        ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "OBJECT")
          (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000)
           STELLA::NULL-STRING))
         (CL:SETQ TUPLES
          (CONS
           (PARSE-ONE-FETCH-XML-OBJECT (%%REST (%%REST ANSWER))
            RELATION OUTPUTCOLUMNS)
           TUPLES)))
        ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "Error")
          (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000)
           STELLA::NULL-STRING))
         (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
           (UNWRAP-STRING (%%VALUE (%%REST (%%REST ANSWER)))) "'")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
        ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "ERROR")
          (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000)
           STELLA::NULL-STRING))
         (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
          (%%PRINT-STREAM
           (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
           (UNWRAP-STRING (%%VALUE (%%REST (%%REST ANSWER)))) "'")
          (CL:ERROR
           (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (REVERSE TUPLES)))

;;; (DEFUN (PARSE-ONE-FETCH-XML-OBJECT CONS) ...)

(CL:DEFUN PARSE-ONE-FETCH-XML-OBJECT (OBJECT RELATION OUTPUTCOLUMNS)
  (CL:LET* ((TUPLE NIL))
   (CL:LET* ((COLUMN NULL) (ITER-000 OUTPUTCOLUMNS))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
     (CL:SETQ COLUMN (%%VALUE ITER-000))
     (CL:LET* ((ITEM NULL) (ITER-001 OBJECT))
      (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
       (CL:SETQ ITEM (%%VALUE ITER-001))
       (CL:WHEN
        (EQL-TO-STRING? COLUMN (%XML-ELEMENT.NAME (%%VALUE ITEM)))
        (CL:SETQ TUPLE (CONS (%%VALUE (%%REST (%%REST ITEM))) TUPLE))
        (CL:WHEN (CL:NOT (CL:EQ (%%REST (%%REST (%%REST ITEM))) NIL))
         (CL:WARN "Extra elements found in `~A'" ITEM)))
       (CL:SETQ ITER-001 (%%REST ITER-001))))
     (CL:SETQ ITER-000 (%%REST ITER-000))))
   (CL:SETQ TUPLE (REVERSE TUPLE))
   (COERCE-VALUES TUPLE (GET-RELATION-TABLE-INFO RELATION))))

;;; (DEFUN START-FETCH-EDB-GATEWAY ...)

(CL:DEFUN START-FETCH-EDB-GATEWAY (PORT)
  (CL:DECLARE (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  (CL:LET*
   ((LISPFORMS "#+:aserve
    (CL:progn
      (CL:defun handle-fetch-query (request entity)
        (net.aserve:with-http-response (request entity)
          (net.aserve:with-http-body (request entity)
            (CL:case (net.aserve:request-method request)
              (:get
               (CL:let ((query (net.aserve:request-query request
                                                         :uri CL:t
                                                         :post CL:nil))
                        (keys (stella::new-key-value-list)))
                 (CL:loop for (key . value) in query
                     do (stella::insert-at
                         keys
                         (stella::wrap-string (CL:string key))
                         (stella::wrap-string value)))
                 (evaluate-fetch-query
                  keys (net.aserve:request-reply-stream request))))
              (CL:t
               (CL:format (net.aserve:request-reply-stream request) 
                          \"Error occurred:<BR>~%Unhandled request method ~S\"
                          (net.aserve:request-method request)))))))
      (CL:defun start-fetch-EDB-servlet (port)
        (CL:compile 'handle-fetch-query)
        (net.aserve:publish :path \"/ploom/fetch-EDB-query\"
                            :content-type \"text/html\"
                            :function 'handle-fetch-query)
        (net.aserve:start :port port)))
    #-:aserve ()"))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING LISPFORMS)) #+:allegro
       (CL:progn
         (CL:require :aserve)
         (CL:pushnew :aserve CL:*features*)
         (CL:eval (CL:read-from-string lispForms))
         (start-fetch-EDB-servlet port))))

;;; (DEFUN EVALUATE-FETCH-QUERY ...)

(CL:DEFUN EVALUATE-FETCH-QUERY (KEYS OUT)
  (CL:HANDLER-CASE
   (CL:LET* ((TEMP-000 (GET-STELLA-MODULE "EELD-EDB" CL:NIL)))
    (CL:LET*
     ((MDL-000
       (CL:IF (CL:NOT (CL:EQ TEMP-000 NULL)) TEMP-000 *MODULE*))
      (CXT-000 MDL-000))
     (CL:WHEN (CL:EQ MDL-000 NULL) (CL:SETQ MDL-000 *MODULE*)
      (CL:SETQ CXT-000 *CONTEXT*))
     (CL:LET* ((*MODULE* MDL-000) (*CONTEXT* CXT-000))
      (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
      (WITH-PROCESS-LOCK *POWERLOOM-LOCK*
       (CL:LET*
        ((SECONDARYDBNAME (LOOKUP KEYS (WRAP-STRING "sdatabase")))
         (FETCHDB
          (%GET (COPY-CONS-TREE (WRAP-STRING "fetch-edb")) NIL))
         (TASKID (LOOKUP KEYS (WRAP-STRING "task")))
         (SUBTASKID (LOOKUP KEYS (WRAP-STRING "subtask")))
         (COMMAND (LOOKUP KEYS (WRAP-STRING "command"))) (RESULT NULL))
        (CL:LET* ((SELF-000 (NEW-OUTPUT-STREAM)))
         (CL:SETF (%OUTPUT-STREAM.NATIVE-STREAM SELF-000) OUT)
         (CL:LET* ((WRAPPEDOUT SELF-000))
          (CL:WHEN (CL:NOT (CL:EQ FETCHDB NULL))
           (CL:WHEN (CL:NOT (CL:EQ SECONDARYDBNAME NULL))
            (PLI::ASSERT-NARY-PROPOSITION
             (CONS (GET-RELATION SGT-FETCH-INTERFACE-RDBMS-DB-NAME)
              (CONS FETCHDB (CONS SECONDARYDBNAME NIL)))
             NULL NULL))
           (CL:WHEN (CL:NOT (CL:EQ TASKID NULL))
            (PLI::ASSERT-NARY-PROPOSITION
             (CONS (GET-RELATION SGT-FETCH-INTERFACE-RDBMS-TASK-ID)
              (CONS FETCHDB (CONS TASKID NIL)))
             NULL NULL))
           (CL:WHEN (CL:NOT (CL:EQ SUBTASKID NULL))
            (PLI::ASSERT-NARY-PROPOSITION
             (CONS (GET-RELATION SGT-FETCH-INTERFACE-RDBMS-SUBTASK-ID)
              (CONS FETCHDB (CONS SUBTASKID NIL)))
             NULL NULL)))
          (CL:SETQ RESULT
           (EVALUATE-LOGIC-COMMAND
            (READ-S-EXPRESSION-FROM-STRING
             (%STRING-WRAPPER.WRAPPER-VALUE COMMAND))
            CL:T))
          (CL:COND
           ((SUBTYPE-OF? (SAFE-PRIMARY-TYPE RESULT)
             SGT-FETCH-INTERFACE-LOGIC-QUERY-ITERATOR)
            (CL:PROGN
             (CL:LET*
              ((SOLUTION NULL)
               (ITER-000
                (ALLOCATE-ITERATOR
                 (%QUERY-ITERATOR.SOLUTIONS RESULT))))
              (CL:LOOP WHILE (NEXT? ITER-000) DO
               (CL:SETQ SOLUTION (%DICTIONARY-ITERATOR.VALUE ITER-000))
               (CL:LET*
                ((ELT NULL)
                 (VECTOR-000 (%QUERY-SOLUTION.BINDINGS SOLUTION))
                 (INDEX-000 0) (LENGTH-000 (LENGTH VECTOR-000))
                 (I NULL-INTEGER) (ITER-001 0))
                (CL:DECLARE
                 (CL:TYPE CL:FIXNUM INDEX-000 LENGTH-000 I ITER-001))
                (CL:LOOP WHILE (CL:< INDEX-000 LENGTH-000) DO
                 (CL:SETQ ELT
                  (CL:AREF
                   (CL:THE CL:SIMPLE-VECTOR
                    (%VECTOR.THE-ARRAY VECTOR-000))
                   INDEX-000))
                 (CL:SETQ I ITER-001)
                 (CL:WHEN (CL:> I 0) (%%PRINT-STREAM OUT " "))
                 (PRINT-LOGICAL-FORM ELT WRAPPEDOUT)
                 (CL:SETQ INDEX-000 (CL:1+ INDEX-000))
                 (CL:SETQ ITER-001 (CL:1+ ITER-001))))
               (%%PRINT-STREAM OUT "<br>")))))
           (CL:T
            (WRITE-HTML-QUOTING-SPECIAL-CHARACTERS OUT
             (STRINGIFY RESULT)))))))))))
   (CL:CONDITION (E)
    (%%PRINT-STREAM OUT "ERROR: " (EXCEPTION-MESSAGE E)))))

;;; (DEFUN (BUILD-ONE-TABLE-ASSERTION CONS) ...)

(CL:DEFUN BUILD-ONE-TABLE-ASSERTION (TABLE-RELATION TUPLE DB-MODULE)
  (CL:LET* ((ASSERTION NIL) (COLNO -1))
   (CL:DECLARE (CL:TYPE CL:FIXNUM COLNO))
   (CL:LET*
    ((I NULL-INTEGER) (ITER-000 0)
     (UPPER-BOUND-000 (ARITY TABLE-RELATION))
     (UNBOUNDED?-000 (CL:= UPPER-BOUND-000 NULL-INTEGER))
     (COLLECT-000 NULL))
    (CL:DECLARE (CL:TYPE CL:FIXNUM I ITER-000 UPPER-BOUND-000))
    (CL:LOOP WHILE
     (CL:OR UNBOUNDED?-000 (CL:<= ITER-000 UPPER-BOUND-000)) DO
     (CL:SETQ I ITER-000)
     (CL:IF (CL:EQ COLLECT-000 NULL)
      (CL:PROGN (CL:SETQ COLLECT-000 (CONS NULL-STRING-WRAPPER NIL))
       (CL:IF (CL:EQ ASSERTION NIL) (CL:SETQ ASSERTION COLLECT-000)
        (ADD-CONS-TO-END-OF-CONS-LIST ASSERTION COLLECT-000)))
      (CL:PROGN
       (CL:SETF (%%REST COLLECT-000) (CONS NULL-STRING-WRAPPER NIL))
       (CL:SETQ COLLECT-000 (%%REST COLLECT-000))))
     (CL:SETQ ITER-000 (CL:1+ ITER-000))))
   (CL:LET* ((ITEM NULL) (ITER-001 TUPLE))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-001 NIL)) DO
     (CL:SETQ ITEM (%%VALUE ITER-001))
     (CL:SETQ COLNO
      (GET-TABLE-COLUMN-INDEX TABLE-RELATION
       (%XML-ELEMENT.NAME (%%VALUE ITEM)) DB-MODULE))
     (CL:IF (CL:< COLNO 0)
      (CL:WARN "Couldn't find column number for `~A' on relation `~A'"
       ITEM TABLE-RELATION)
      (NTH-SETTER ASSERTION (%%VALUE (%%REST (%%REST ITEM))) COLNO))
     (CL:WHEN (CL:NOT (CL:EQ (%%REST (%%REST (%%REST ITEM))) NIL))
      (CL:WARN "Extra elements found in `~A'" ITEM))
     (CL:SETQ ITER-001 (%%REST ITER-001))))
   (CL:LET* ((ITEM NULL) (ITER-002 (%%REST ASSERTION)))
    (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-002 NIL)) DO
     (CL:SETQ ITEM (%%VALUE ITER-002))
     (CL:WHEN (CL:EQ (UNWRAP-STRING ITEM) STELLA::NULL-STRING)
      (CL:WARN "Some table relation values not set: `~A'" ASSERTION)
      (CL:RETURN))
     (CL:SETQ ITER-002 (%%REST ITER-002))))
   (CL:SETF (%%REST ASSERTION)
    (COERCE-VALUES (%%REST ASSERTION)
     (GET-RELATION-TABLE-INFO TABLE-RELATION)))
   (NTH-SETTER ASSERTION TABLE-RELATION 0) ASSERTION))

;;; (DEFUN (GENERATE-TABLE-ASSERTIONS (CONS OF CONS)) ...)

(CL:DEFUN GENERATE-TABLE-ASSERTIONS (TABLE-NAME XML-ANSWER MODULE DB-MODULE)
  "Takes a Stella-parsed, XML-encoded `xml-answer' from Fetch based on
the database table `table-name' and uses it to generate an assertion
for an appropriate relation for inclusion in `module'.  The database
meta information is found in `db-module'."
  (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING TABLE-NAME))
  #+MCL
  (CL:CHECK-TYPE TABLE-NAME CL:SIMPLE-STRING)
  (CL:LET*
   ((TABLE-RELATION (GET-TABLE-RELATION TABLE-NAME DB-MODULE))
    (ASSERTIONS NIL))
   (CL:WHEN
    (CL:NOT
     (CL:AND
      (ISA? (%%VALUE XML-ANSWER)
       SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT)
      (CL:AND
       (STRING-EQL? (%XML-ELEMENT.NAME (%%VALUE XML-ANSWER))
        "PlanExecution")
       (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI (%%VALUE XML-ANSWER))
        STELLA::NULL-STRING))))
    (CL:WARN "Didn't find a Fetch Answer in `~A'" XML-ANSWER)
    (CL:RETURN-FROM GENERATE-TABLE-ASSERTIONS NIL))
   (CL:LET* ((*MODULE* MODULE) (*CONTEXT* *MODULE*))
    (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
    (CL:LET* ((ANSWER NULL) (ITER-000 (%%REST (%%REST XML-ANSWER))))
     (CL:LOOP WHILE (CL:NOT (CL:EQ ITER-000 NIL)) DO
      (CL:SETQ ANSWER (%%VALUE ITER-000))
      (CL:WHEN
       (CL:AND (ISA? ANSWER SGT-FETCH-INTERFACE-STELLA-CONS)
        (ISA? (%%VALUE ANSWER) SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT))
       (CL:LET* ((ITEM-000 (%%VALUE ANSWER)))
        (CL:COND
         ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "OBJECT")
           (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000)
            STELLA::NULL-STRING))
          (CL:SETQ ASSERTIONS
           (CONS
            (BUILD-ONE-TABLE-ASSERTION TABLE-RELATION
             (%%REST (%%REST ANSWER)) DB-MODULE)
            ASSERTIONS)))
         ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "Error")
           (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000)
            STELLA::NULL-STRING))
          (CL:LET* ((STREAM-000 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-000) "`"
            (%STRING-WRAPPER.WRAPPER-VALUE
             (%%VALUE (%%REST (%%REST ANSWER))))
            "'")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-000)))))
         ((CL:AND (STRING-EQL? (%XML-ELEMENT.NAME ITEM-000) "ERROR")
           (STRING-EQL? (%XML-ELEMENT.NAMESPACE-URI ITEM-000)
            STELLA::NULL-STRING))
          (CL:LET* ((STREAM-001 (NEW-OUTPUT-STRING-STREAM)))
           (%%PRINT-STREAM
            (%OUTPUT-STRING-STREAM.NATIVE-STREAM STREAM-001) "`"
            (%STRING-WRAPPER.WRAPPER-VALUE
             (%%VALUE (%%REST (%%REST ANSWER))))
            "'")
           (CL:ERROR
            (NEW-STELLA-EXCEPTION (THE-STRING-READER STREAM-001))))))))
      (CL:SETQ ITER-000 (%%REST ITER-000)))))
   ASSERTIONS))

;;; (DEFUN (LOOKUP-STRING-VALUE STRING) ...)

(CL:DECLAIM
 (CL:FTYPE (CL:FUNCTION (CL:T CL:T CL:T) CL:SIMPLE-STRING)
  LOOKUP-STRING-VALUE))
(CL:DEFUN LOOKUP-STRING-VALUE (RELATION INSTANCE MOD)
  (CL:LET*
   ((ITER
     (PLI::RETRIEVE
      (LIST* (WRAP-INTEGER 1)
       (CONS (OBJECT-NAME RELATION)
        (CONS INSTANCE (CONS SYM-FETCH-INTERFACE-LOGIC-?X NIL)))
       NIL)
      MOD NULL)))
   (CL:IF (NEXT? ITER)
    (%STRING-WRAPPER.WRAPPER-VALUE (PLI::%PL-ITERATOR.VALUE ITER))
    STELLA::NULL-STRING)))

;;; (DEFUN (FETCH-QUERY-ASSERTIONS (CONS OF CONS)) ...)

(CL:DEFUN FETCH-QUERY-ASSERTIONS (HOST PORT FETCH-QUERY TASK-ID SUBTASK-ID DATABASE PARAMETER-VALUE TARGET-MODULE DB-MODULE)
  "Runs a `fetch-query' using `task-id'; `subtask-id',`database'
and specifying a single additional `parameter-value'.  The connection
is made to a remote http query server running on `host' port number `port'.
Returns a set of assertions for `target-module' using the information in `db-module'
to find the appropriate relations."
  (CL:DECLARE
   (CL:TYPE CL:SIMPLE-STRING HOST TASK-ID SUBTASK-ID DATABASE
    PARAMETER-VALUE)
   (CL:TYPE CL:FIXNUM PORT))
  #+MCL
  (CL:CHECK-TYPE HOST CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PORT CL:FIXNUM)
  #+MCL
  (CL:CHECK-TYPE TASK-ID CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE SUBTASK-ID CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE DATABASE CL:SIMPLE-STRING)
  #+MCL
  (CL:CHECK-TYPE PARAMETER-VALUE CL:SIMPLE-STRING)
  (CL:LET*
   ((DB-TABLE
     (LOOKUP-STRING-VALUE
      (PLI::GET-RELATION "QUERY-TABLE-NAME" DB-MODULE NULL) FETCH-QUERY
      DB-MODULE))
    (PARAMETER-NAME
     (LOOKUP-STRING-VALUE
      (PLI::GET-RELATION "QUERY-PARAMETER-NAME" DB-MODULE NULL)
      FETCH-QUERY DB-MODULE))
    (FETCH-ANSWER
     (RUN-FETCH-QUERY HOST PORT
      (%SYMBOL.SYMBOL-NAME (OBJECT-NAME FETCH-QUERY)) TASK-ID
      SUBTASK-ID DATABASE
      (CONCATENATE PARAMETER-NAME "=" PARAMETER-VALUE))))
   (CL:DECLARE (CL:TYPE CL:SIMPLE-STRING DB-TABLE PARAMETER-NAME))
   (GENERATE-TABLE-ASSERTIONS DB-TABLE FETCH-ANSWER TARGET-MODULE
    DB-MODULE)))

(CL:DEFUN STARTUP-FETCH-INTERFACE ()
  (CL:LET*
   ((*MODULE* (GET-STELLA-MODULE "/RDBMS" (> *STARTUP-TIME-PHASE* 1)))
    (*CONTEXT* *MODULE*))
   (CL:DECLARE (CL:SPECIAL *MODULE* *CONTEXT*))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 2)
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-RUN-FETCH-QUERY
     (INTERN-RIGID-SYMBOL-WRT-MODULE "RUN-FETCH-QUERY" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-STELLA-CONS
     (INTERN-RIGID-SYMBOL-WRT-MODULE "CONS"
      (GET-STELLA-MODULE "/STELLA" CL:T) 1))
    (CL:SETQ SGT-FETCH-INTERFACE-STELLA-XML-ELEMENT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "XML-ELEMENT"
      (GET-STELLA-MODULE "/STELLA" CL:T) 1))
    (CL:SETQ KWD-FETCH-INTERFACE-ERROR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "ERROR" NULL 2))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-HOST
     (INTERN-RIGID-SYMBOL-WRT-MODULE "HOST" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-PORT
     (INTERN-RIGID-SYMBOL-WRT-MODULE "PORT" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-TASK-ID
     (INTERN-RIGID-SYMBOL-WRT-MODULE "TASK-ID" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-SUBTASK-ID
     (INTERN-RIGID-SYMBOL-WRT-MODULE "SUBTASK-ID" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-DB-NAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "DB-NAME" NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-RDBMS-F-FETCH-EDB-QUERY-MEMO-TABLE-000
     (INTERN-RIGID-SYMBOL-WRT-MODULE "F-FETCH-EDB-QUERY-MEMO-TABLE-000"
      NULL 1))
    (CL:SETQ SGT-FETCH-INTERFACE-LOGIC-QUERY-ITERATOR
     (INTERN-RIGID-SYMBOL-WRT-MODULE "QUERY-ITERATOR"
      (GET-STELLA-MODULE "/LOGIC" CL:T) 1))
    (CL:SETQ SYM-FETCH-INTERFACE-LOGIC-?X
     (INTERN-RIGID-SYMBOL-WRT-MODULE "?X"
      (GET-STELLA-MODULE "/LOGIC" CL:T) 0))
    (CL:SETQ SYM-FETCH-INTERFACE-RDBMS-STARTUP-FETCH-INTERFACE
     (INTERN-RIGID-SYMBOL-WRT-MODULE "STARTUP-FETCH-INTERFACE" NULL 0))
    (CL:SETQ SYM-FETCH-INTERFACE-STELLA-METHOD-STARTUP-CLASSNAME
     (INTERN-RIGID-SYMBOL-WRT-MODULE "METHOD-STARTUP-CLASSNAME"
      (GET-STELLA-MODULE "/STELLA" CL:T) 0)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 6) (FINALIZE-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 7)
    (DEFINE-FUNCTION-OBJECT "RUN-FETCH-QUERY"
     "(DEFUN (RUN-FETCH-QUERY OBJECT) ((HOST STRING) (PORT INTEGER) (QUERY-ID STRING) (TASK-ID STRING) (SUBTASK-ID STRING) (DATABASE STRING) (PARAMETERS STRING)) :DOCUMENTATION \"Runs a Fetch query specifying the parameters given.
Returns an object representing the returned XML-encoded answer from
the server.\" :PUBLIC? TRUE)" (CL:FUNCTION RUN-FETCH-QUERY) NULL)
    (DEFINE-FUNCTION-OBJECT "NORMALIZE-FETCH-QUERY-ARGUMENTS"
     "(DEFUN (NORMALIZE-FETCH-QUERY-ARGUMENTS STRING (CONS OF STRING-WRAPPER) PROPERTY-LIST) ((PROPOSITION PROPOSITION) (ARGUMENTS OBJECT)))"
     (CL:FUNCTION NORMALIZE-FETCH-QUERY-ARGUMENTS) NULL)
    (DEFINE-FUNCTION-OBJECT "HELP-MEMOIZE-FETCH-EDB-QUERY"
     "(DEFUN (HELP-MEMOIZE-FETCH-EDB-QUERY (ITERATOR OF CONS)) ((PROPOSITION PROPOSITION) (DATABASE LOGIC-OBJECT) (ARGUMENTS OBJECT)))"
     (CL:FUNCTION HELP-MEMOIZE-FETCH-EDB-QUERY) NULL)
    (DEFINE-FUNCTION-OBJECT "FETCH-EDB-QUERY"
     "(DEFUN (FETCH-EDB-QUERY (ITERATOR OF CONS)) ((PROPOSITION PROPOSITION) (DATABASE LOGIC-OBJECT) (ARGUMENTS OBJECT)))"
     (CL:FUNCTION FETCH-EDB-QUERY) NULL)
    (DEFINE-FUNCTION-OBJECT "PARSE-FETCH-XML-ANSWER"
     "(DEFUN (PARSE-FETCH-XML-ANSWER (CONS OF CONS)) ((XMLANSWER CONS) (RELATION NAMED-DESCRIPTION) (OUTPUTCOLUMNS (CONS OF STRING-WRAPPER))))"
     (CL:FUNCTION PARSE-FETCH-XML-ANSWER) NULL)
    (DEFINE-FUNCTION-OBJECT "PARSE-ONE-FETCH-XML-OBJECT"
     "(DEFUN (PARSE-ONE-FETCH-XML-OBJECT CONS) ((OBJECT CONS) (RELATION NAMED-DESCRIPTION) (OUTPUTCOLUMNS (CONS OF STRING-WRAPPER))))"
     (CL:FUNCTION PARSE-ONE-FETCH-XML-OBJECT) NULL)
    (DEFINE-FUNCTION-OBJECT "START-FETCH-EDB-GATEWAY"
     "(DEFUN START-FETCH-EDB-GATEWAY ((PORT INTEGER)))"
     (CL:FUNCTION START-FETCH-EDB-GATEWAY) NULL)
    (DEFINE-FUNCTION-OBJECT "EVALUATE-FETCH-QUERY"
     "(DEFUN EVALUATE-FETCH-QUERY ((KEYS KEY-VALUE-LIST) (OUT NATIVE-OUTPUT-STREAM)))"
     (CL:FUNCTION EVALUATE-FETCH-QUERY) NULL)
    (DEFINE-FUNCTION-OBJECT "BUILD-ONE-TABLE-ASSERTION"
     "(DEFUN (BUILD-ONE-TABLE-ASSERTION CONS) ((TABLE-RELATION NAMED-DESCRIPTION) (TUPLE CONS) (DB-MODULE MODULE)))"
     (CL:FUNCTION BUILD-ONE-TABLE-ASSERTION) NULL)
    (DEFINE-FUNCTION-OBJECT "GENERATE-TABLE-ASSERTIONS"
     "(DEFUN (GENERATE-TABLE-ASSERTIONS (CONS OF CONS)) ((TABLE-NAME STRING) (XML-ANSWER CONS) (MODULE MODULE) (DB-MODULE MODULE)) :DOCUMENTATION \"Takes a Stella-parsed, XML-encoded `xml-answer' from Fetch based on
the database table `table-name' and uses it to generate an assertion
for an appropriate relation for inclusion in `module'.  The database
meta information is found in `db-module'.\")"
     (CL:FUNCTION GENERATE-TABLE-ASSERTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "LOOKUP-STRING-VALUE"
     "(DEFUN (LOOKUP-STRING-VALUE STRING) ((RELATION NAMED-DESCRIPTION) (INSTANCE LOGIC-OBJECT) (MOD MODULE)))"
     (CL:FUNCTION LOOKUP-STRING-VALUE) NULL)
    (DEFINE-FUNCTION-OBJECT "FETCH-QUERY-ASSERTIONS"
     "(DEFUN (FETCH-QUERY-ASSERTIONS (CONS OF CONS)) ((HOST STRING) (PORT INTEGER) (FETCH-QUERY LOGIC-OBJECT) (TASK-ID STRING) (SUBTASK-ID STRING) (DATABASE STRING) (PARAMETER-VALUE STRING) (TARGET-MODULE MODULE) (DB-MODULE MODULE)) :PUBLIC? TRUE :DOCUMENTATION \"Runs a `fetch-query' using `task-id'; `subtask-id',`database'
and specifying a single additional `parameter-value'.  The connection
is made to a remote http query server running on `host' port number `port'.
Returns a set of assertions for `target-module' using the information in `db-module'
to find the appropriate relations.\")"
     (CL:FUNCTION FETCH-QUERY-ASSERTIONS) NULL)
    (DEFINE-FUNCTION-OBJECT "STARTUP-FETCH-INTERFACE"
     "(DEFUN STARTUP-FETCH-INTERFACE () :PUBLIC? TRUE)"
     (CL:FUNCTION STARTUP-FETCH-INTERFACE) NULL)
    (CL:LET*
     ((FUNCTION
       (LOOKUP-FUNCTION
        SYM-FETCH-INTERFACE-RDBMS-STARTUP-FETCH-INTERFACE)))
     (SET-DYNAMIC-SLOT-VALUE (%METHOD-SLOT.DYNAMIC-SLOTS FUNCTION)
      SYM-FETCH-INTERFACE-STELLA-METHOD-STARTUP-CLASSNAME
      (WRAP-STRING "_StartupFetchInterface") NULL-STRING-WRAPPER)))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 8) (FINALIZE-SLOTS)
    (CLEANUP-UNFINALIZED-CLASSES))
   (CL:WHEN (CURRENT-STARTUP-TIME-PHASE? 9)
    (%IN-MODULE (COPY-CONS-TREE (WRAP-STRING "RDBMS"))))))
